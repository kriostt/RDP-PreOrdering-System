{"version":3,"file":"resolve.js","sources":["../../src/legacy/searchConfig/resolve.ts"],"sourcesContent":["import {isFinite, uniqBy} from 'lodash'\n\nexport const DEFAULT_MAX_FIELD_DEPTH = 5\n\nconst stringFieldsSymbols = {}\n\nconst getStringFieldSymbol = (maxDepth: number) => {\n  if (!stringFieldsSymbols[maxDepth]) {\n    stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)\n  }\n\n  return stringFieldsSymbols[maxDepth]\n}\n\nconst isReference = (type) => type.type && type.type.name === 'reference'\n\nconst portableTextFields = ['style', 'list']\nconst isPortableTextBlock = (type) =>\n  type.name === 'block' || (type.type && isPortableTextBlock(type.type))\nconst isPortableTextArray = (type) =>\n  type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock)\n\nfunction reduceType(type, reducer, acc, path = [], maxDepth) {\n  if (maxDepth < 0) {\n    return acc\n  }\n\n  const accumulator = reducer(acc, type, path)\n  if (type.jsonType === 'array' && Array.isArray(type.of)) {\n    return reduceArray(type, reducer, accumulator, path, maxDepth)\n  }\n\n  if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {\n    return reduceObject(type, reducer, accumulator, path, maxDepth)\n  }\n\n  return accumulator\n}\n\nfunction reduceArray(arrayType, reducer, accumulator, path, maxDepth) {\n  return arrayType.of.reduce(\n    (acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1),\n    accumulator,\n  )\n}\n\nfunction reduceObject(objectType, reducer, accumulator, path, maxDepth) {\n  const isPtBlock = isPortableTextBlock(objectType)\n  return objectType.fields.reduce((acc, field) => {\n    // Don't include styles and list types as searchable paths for portable text blocks\n    if (isPtBlock && portableTextFields.includes(field.name)) {\n      return acc\n    }\n\n    const segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : [])\n    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1)\n  }, accumulator)\n}\n\nconst BASE_WEIGHTS = [\n  {weight: 1, path: ['_id']},\n  {weight: 1, path: ['_type']},\n]\n\nconst PREVIEW_FIELD_WEIGHT_MAP = {\n  title: 10,\n  subtitle: 5,\n  description: 1.5,\n}\n\n/**\n * @internal\n */\nexport function deriveFromPreview(\n  type: {\n    preview: {select: Record<string, string>}\n  },\n  maxDepth: number,\n): {weight?: number; path: (string | number)[]}[] {\n  const select = type?.preview?.select\n\n  if (!select) {\n    return []\n  }\n\n  const fields: {weight: number; path: (string | number)[]}[] = []\n\n  for (const fieldName of Object.keys(select)) {\n    if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP)) {\n      continue\n    }\n\n    const path = select[fieldName].split('.')\n\n    if (maxDepth > -1 && path.length - 1 > maxDepth) {\n      continue\n    }\n\n    fields.push({\n      weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],\n      path,\n    })\n  }\n\n  return fields\n}\n\nfunction getCachedStringFieldPaths(type, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy(\n      [\n        ...BASE_WEIGHTS,\n        ...deriveFromPreview(type, maxDepth),\n        ...getStringFieldPaths(type, maxDepth).map((path) => ({weight: 1, path})),\n        ...getPortableTextFieldPaths(type, maxDepth).map((path) => ({\n          weight: 1,\n          path,\n          mapWith: 'pt::text',\n        })),\n      ],\n      (spec) => spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getCachedBaseFieldPaths(type, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy([...BASE_WEIGHTS, ...deriveFromPreview(type, maxDepth)], (spec) =>\n      spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getStringFieldPaths(type, maxDepth: number) {\n  const reducer = (accumulator, childType, path) =>\n    childType.jsonType === 'string' ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nfunction getPortableTextFieldPaths(type, maxDepth) {\n  const reducer = (accumulator, childType, path) =>\n    isPortableTextArray(childType) ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nexport function resolveSearchConfigForBaseFieldPaths(type, maxDepth?: number) {\n  return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * @internal\n */\nexport function resolveSearchConfig(type, maxDepth?: number) {\n  return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * Normalizes a one-indexed maxDepth to a zero-indexed maxDepth\n * 0 = all fields\n *\n * @internal\n */\nfunction normalizeMaxDepth(maxDepth?: number) {\n  if (!isFinite(maxDepth) || maxDepth < 1 || maxDepth > DEFAULT_MAX_FIELD_DEPTH) {\n    return DEFAULT_MAX_FIELD_DEPTH - 1\n  }\n\n  return maxDepth - 1\n}\n"],"names":["uniqBy","isFinite"],"mappings":"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"}