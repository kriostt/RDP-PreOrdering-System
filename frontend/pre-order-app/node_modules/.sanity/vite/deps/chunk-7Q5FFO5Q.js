import {
  require_hashlru,
  require_json_inspector
} from "./chunk-X3QM5JHE.js";
import {
  AddCircleIcon,
  AddCommentIcon,
  AddIcon,
  AddonDatasetProvider,
  AnimatePresence,
  ArrowLeftIcon,
  Avatar,
  AvatarStack,
  Badge,
  BetaBadge,
  BoundaryElementProvider,
  Box,
  Button,
  Button2,
  CalendarIcon,
  Card,
  ChangeConnectorRoot,
  ChangeFieldWrapper,
  ChangeList,
  Checkbox,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  CircleIcon,
  CloseIcon,
  Code,
  CommandList,
  CommentIcon,
  ConditionalWrapper,
  Container,
  ContextMenuButton,
  CopyIcon,
  DEFAULT_DATE_FORMAT,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  DIFF_DELETE,
  DIFF_EQUAL,
  DIFF_INSERT,
  DatePicker,
  Dialog,
  Dialog2,
  DialogProvider,
  DiffTooltip,
  DocumentChangeContext,
  DocumentIcon,
  DocumentPreviewPresence,
  DocumentStatus,
  DocumentStatusIndicator,
  DocumentsIcon,
  EMPTY_ARRAY$b,
  EMPTY_OBJECT,
  EarthAmericasIcon,
  EditIcon,
  ErrorBoundary,
  ErrorOutlineIcon,
  FieldActionsProvider,
  FieldActionsResolver,
  Flex,
  FolderIcon,
  FormBuilder,
  FormFieldHeaderText,
  GetHookCollectionState,
  Grid,
  Heading,
  Hotkeys,
  InfoOutlineIcon,
  Inline,
  InsufficientPermissionsMessage,
  IntentLink,
  JsonIcon,
  LaunchIcon,
  Layer,
  LayerProvider,
  LegacyLayerProvider,
  LinkIcon,
  LinkRemovedIcon,
  LoadingBlock,
  MasterDetailIcon,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  MenuItem2,
  NoChanges,
  PanelRightIcon,
  Popover,
  Popover2,
  PortableText,
  PortableTextEditable,
  PortableTextEditor,
  PortalProvider,
  PresenceOverlay,
  PreviewCard,
  PublishIcon,
  ReadOnlyIcon,
  ReferenceInputOptionsProvider,
  ResetIcon,
  ResourceCacheProvider,
  RestoreIcon,
  SanityDefaultPreview,
  Schema2,
  ScrollContainer,
  SearchIcon,
  SearchPopover,
  SearchProvider,
  SearchResultItemPreview,
  Skeleton,
  SortIcon,
  SourceProvider,
  Spinner,
  SpinnerIcon,
  SplitVerticalIcon,
  Stack,
  StackCompactIcon,
  StackIcon,
  StateLink,
  StatusButton,
  Switch,
  SyncIcon,
  Tab,
  TabList,
  TabPanel,
  TaskIcon,
  Text,
  TextInput,
  TextSkeleton,
  TextWithTone,
  ThemeColorProvider,
  Tooltip2 as Tooltip,
  TooltipDelayGroupProvider,
  TooltipOfDisabled,
  TransformPatches,
  Translate,
  TrashIcon,
  UndoIcon,
  UnknownIcon,
  UnpublishIcon,
  UpsellDescriptionSerializer,
  UpsellDialogDismissed,
  UpsellDialogLearnMoreCtaClicked,
  UpsellDialogUpgradeCtaClicked,
  UpsellDialogViewed,
  UserAvatar,
  UserIcon,
  VirtualizerScrollInstanceProvider,
  WarningOutlineIcon,
  WorkspaceLoaderBoundary,
  WorkspaceProvider,
  _raf2,
  apply,
  applyPatch,
  at,
  cleanupEfficiency,
  collate,
  createHookFromObservableFactory,
  createPatchChannel,
  createSearch,
  decodeJsonParams,
  defaultKeyGenerator,
  defineArrayMember,
  defineDocumentInspector,
  defineEvent,
  defineField,
  defineLocaleResourceBundle,
  definePlugin,
  defineType,
  diff,
  e,
  encodeJsonParams,
  es2015_default,
  exhaustMapWithTrailing,
  focusFirstDescendant,
  focusLastDescendant,
  format,
  fromMutationPatches,
  fromString,
  generateHelpUrl,
  get,
  getCalendarLabels,
  getConfigContextFromSource,
  getDraftId,
  getExpandOperations,
  getJsonStream,
  getPreviewStateObservable,
  getPreviewValueWithFallback,
  getPublishedId,
  getSchemaTypeTitle,
  getSearchableTypes,
  getTheme_v2,
  getValueAtPath,
  ht,
  hues,
  isActionEnabled,
  isArray,
  isArrayOfBlocksSchemaType,
  isArraySchemaType,
  isDeprecatedSchemaType,
  isDev,
  isImageSource,
  isIndexSegment,
  isKeySegment,
  isObjectSchemaType,
  isPortableTextSpan,
  isPortableTextTextBlock,
  isRecord$4,
  isReferenceSchemaType,
  isSanityDocument,
  isString,
  isThisISOWeek,
  isToday,
  isValidationError,
  isValidationErrorMarker,
  isValidationWarning,
  make,
  motion,
  parse,
  prepareConfig,
  rem,
  require_apply,
  require_baseGetTag,
  require_basePropertyOf,
  require_baseRest,
  require_baseValues,
  require_capitalize,
  require_copyObject,
  require_createAssigner,
  require_createCompounder,
  require_debounce,
  require_deburr,
  require_eq,
  require_find,
  require_findIndex,
  require_image_url_umd,
  require_isEqual,
  require_isIterateeCall,
  require_isObjectLike,
  require_isPlainObject,
  require_isString,
  require_keys,
  require_keysIn,
  require_lib,
  require_negate,
  require_omit,
  require_orderBy,
  require_react_fast_compare,
  require_react_is,
  require_shallow_equals,
  require_speakingurl,
  require_startCase,
  require_throttle,
  require_toString,
  require_uniq,
  require_uniqBy,
  require_uniqueId,
  resizeObserver,
  resolveConditionalProperty,
  resolveKeyedPath,
  rgba,
  route,
  set,
  setAtPath,
  toMutationPatches,
  toPlainText,
  toString,
  unset,
  useAddonDataset,
  useAsObservable,
  useBoundaryElement,
  useClickOutside,
  useClient,
  useConfigContextFromSource,
  useConnectionState,
  useCurrentUser,
  useDateTimeFormat,
  useDidUpdate,
  useDocumentOperation,
  useDocumentOperationEvent,
  useDocumentPairPermissions,
  useDocumentPresence,
  useDocumentPreview,
  useDocumentPreviewStore,
  useDocumentStore,
  useDocumentType,
  useDocumentValuePermissions,
  useEditState,
  useElementRect,
  useFeatureEnabled,
  useFieldActions,
  useFormState,
  useFormValue,
  useForwardedRef,
  useGetI18nText,
  useGlobalKeyDown,
  useI18nText,
  useInitialValue,
  useIntentLink,
  useKeyValueStore,
  useLayer,
  useListFormat,
  useMediaIndex,
  useMemoObservable,
  useMiddlewareComponents,
  useObservableCallback,
  usePortableTextEditor,
  usePortableTextEditorSelection,
  usePortal,
  usePresenceStore,
  useProjectId,
  useRelativeTime,
  useRouter,
  useRouterState,
  useSchema,
  useSearchMaxFieldDepth,
  useSource,
  useSyncState,
  useTelemetry,
  useTemplatePermissions,
  useTemplates,
  useTimelineSelector,
  useTimelineStore,
  useToast,
  useTools,
  useTranslation,
  useTranslation2,
  useUnique,
  useUser,
  useUserListWithPermissions,
  useValidationStatus,
  useWorkspace,
  useWorkspaceLoader,
  useZIndex,
  ut,
  v4_default,
  visitDiff,
  white
} from "./chunk-MGEEO53U.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  EMPTY,
  Subject,
  asyncScheduler,
  catchError,
  concat,
  debounce,
  debounceTime,
  defer,
  delay,
  distinctUntilChanged,
  filter,
  firstValueFrom,
  from,
  fromEvent,
  map,
  mapTo,
  merge,
  mergeMap,
  of,
  partition,
  scan,
  share,
  shareReplay,
  startWith,
  switchMap,
  take,
  tap,
  throttleTime,
  throwError,
  timer
} from "./chunk-KKFEH43J.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/lodash/assignInWith.js
var require_assignInWith = __commonJS({
  "node_modules/lodash/assignInWith.js"(exports, module) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    module.exports = assignInWith;
  }
});

// node_modules/lodash/isError.js
var require_isError = __commonJS({
  "node_modules/lodash/isError.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var isPlainObject = require_isPlainObject();
    var domExcTag = "[object DOMException]";
    var errorTag = "[object Error]";
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
    }
    module.exports = isError;
  }
});

// node_modules/lodash/attempt.js
var require_attempt = __commonJS({
  "node_modules/lodash/attempt.js"(exports, module) {
    var apply2 = require_apply();
    var baseRest = require_baseRest();
    var isError = require_isError();
    var attempt = baseRest(function(func, args) {
      try {
        return apply2(func, void 0, args);
      } catch (e2) {
        return isError(e2) ? e2 : new Error(e2);
      }
    });
    module.exports = attempt;
  }
});

// node_modules/lodash/_customDefaultsAssignIn.js
var require_customDefaultsAssignIn = __commonJS({
  "node_modules/lodash/_customDefaultsAssignIn.js"(exports, module) {
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    module.exports = customDefaultsAssignIn;
  }
});

// node_modules/lodash/_escapeStringChar.js
var require_escapeStringChar = __commonJS({
  "node_modules/lodash/_escapeStringChar.js"(exports, module) {
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    module.exports = escapeStringChar;
  }
});

// node_modules/lodash/_reInterpolate.js
var require_reInterpolate = __commonJS({
  "node_modules/lodash/_reInterpolate.js"(exports, module) {
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    module.exports = reInterpolate;
  }
});

// node_modules/lodash/_escapeHtmlChar.js
var require_escapeHtmlChar = __commonJS({
  "node_modules/lodash/_escapeHtmlChar.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    module.exports = escapeHtmlChar;
  }
});

// node_modules/lodash/escape.js
var require_escape = __commonJS({
  "node_modules/lodash/escape.js"(exports, module) {
    var escapeHtmlChar = require_escapeHtmlChar();
    var toString2 = require_toString();
    var reUnescapedHtml = /[&<>"']/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
      string = toString2(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape;
  }
});

// node_modules/lodash/_reEscape.js
var require_reEscape = __commonJS({
  "node_modules/lodash/_reEscape.js"(exports, module) {
    var reEscape = /<%-([\s\S]+?)%>/g;
    module.exports = reEscape;
  }
});

// node_modules/lodash/_reEvaluate.js
var require_reEvaluate = __commonJS({
  "node_modules/lodash/_reEvaluate.js"(exports, module) {
    var reEvaluate = /<%([\s\S]+?)%>/g;
    module.exports = reEvaluate;
  }
});

// node_modules/lodash/templateSettings.js
var require_templateSettings = __commonJS({
  "node_modules/lodash/templateSettings.js"(exports, module) {
    var escape = require_escape();
    var reEscape = require_reEscape();
    var reEvaluate = require_reEvaluate();
    var reInterpolate = require_reInterpolate();
    var templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "escape": reEscape,
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "evaluate": reEvaluate,
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "interpolate": reInterpolate,
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      "variable": "",
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      "imports": {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        "_": { "escape": escape }
      }
    };
    module.exports = templateSettings;
  }
});

// node_modules/lodash/template.js
var require_template = __commonJS({
  "node_modules/lodash/template.js"(exports, module) {
    var assignInWith = require_assignInWith();
    var attempt = require_attempt();
    var baseValues = require_baseValues();
    var customDefaultsAssignIn = require_customDefaultsAssignIn();
    var escapeStringChar = require_escapeStringChar();
    var isError = require_isError();
    var isIterateeCall = require_isIterateeCall();
    var keys = require_keys();
    var reInterpolate = require_reInterpolate();
    var templateSettings = require_templateSettings();
    var toString2 = require_toString();
    var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var reEmptyStringLeading = /\b__p \+= '';/g;
    var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
    var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function template2(string, options, guard) {
      var settings = templateSettings.imports._.templateSettings || templateSettings;
      if (guard && isIterateeCall(string, options, guard)) {
        options = void 0;
      }
      string = toString2(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);
      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
      var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
        "g"
      );
      var sourceURL = hasOwnProperty.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";
      var variable = hasOwnProperty.call(options, "variable") && options.variable;
      if (!variable) {
        source = "with (obj) {\n" + source + "\n}\n";
      } else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
      source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
      var result = attempt(function() {
        return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
      });
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }
    module.exports = template2;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase2;
  }
});

// node_modules/lodash/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/lodash/kebabCase.js"(exports, module) {
    var createCompounder = require_createCompounder();
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    module.exports = kebabCase2;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "âŒ˜" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format2("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text, options);
          if (onCopy) {
            onCopy(text, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module.exports = CopyToClipboard2;
  }
});

// node_modules/sanity/lib/_chunks-es/StructureToolProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_orderBy = __toESM(require_orderBy());
var import_isEqual2 = __toESM(require_isEqual());
var import_template = __toESM(require_template());
var import_deburr = __toESM(require_deburr());
var import_react_copy_to_clipboard = __toESM(require_lib2());
var import_isNumber = __toESM(require_isNumber());
var import_isString = __toESM(require_isString());
var import_omit = __toESM(require_omit());
var import_uniqBy = __toESM(require_uniqBy());
var import_negate = __toESM(require_negate());
var import_throttle2 = __toESM(require_throttle());
var import_findIndex = __toESM(require_findIndex());
var import_is_hotkey = __toESM(require_lib());
var import_react_json_inspector = __toESM(require_json_inspector());
var import_hashlru = __toESM(require_hashlru());
var import_shallow_equals = __toESM(require_shallow_equals());

// node_modules/sanity/lib/_internalBrowser.esm.js
var import_isEqual = __toESM(require_isEqual());
var import_react = __toESM(require_react());
var import_throttle = __toESM(require_throttle());

// node_modules/sanity/lib/_chunks-es/StructureToolProvider.js
var import_camelCase = __toESM(require_camelCase());
var import_speakingurl = __toESM(require_speakingurl());
var import_uniqueId = __toESM(require_uniqueId());
var import_react_is = __toESM(require_react_is());
var import_uniq = __toESM(require_uniq());
var import_kebabCase = __toESM(require_kebabCase());
var import_find = __toESM(require_find());
var import_startCase = __toESM(require_startCase());
var import_image_url = __toESM(require_image_url_umd());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var import_debounce = __toESM(require_debounce());
var commentsLocaleNamespace = "comments";
var commentsUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: commentsLocaleNamespace,
  resources: () => import("./resources-VUTVESAD.js")
});
var DOCUMENT_PANEL_MIN_WIDTH = 320;
var DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
var DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
var DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
var EMPTY_PARAMS$2 = {};
var INSPECT_ACTION_PREFIX = "inspect:";
var DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }];
var HISTORY_INSPECTOR_NAME = "sanity/structure/history";
var VALIDATION_INSPECTOR_NAME = "sanity/structure/validation";
var COMMENTS_INSPECTOR_NAME = "sanity/structure/comments";
var separator = (0, import_jsx_runtime.jsx)(Text, { muted: true, children: (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}) });
var renderItem = (item, index) => (0, import_jsx_runtime.jsx)(Box, { as: "li", children: (0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, `${item}-${index}`);
function CommentBreadcrumbs(props) {
  const { titlePath, maxLength } = props, items = (0, import_react2.useMemo)(() => {
    const len = titlePath.length, beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    return maxLength && len > maxLength ? [
      ...titlePath.slice(0, beforeLength - 1),
      titlePath.slice(beforeLength - 1, len - afterLength),
      ...titlePath.slice(len - afterLength)
    ] : titlePath;
  }, [maxLength, titlePath]), nodes = (0, import_react2.useMemo)(() => items.map((item, index) => {
    const key = `${item}-${index}`, showSeparator = index < items.length - 1;
    return Array.isArray(item) ? (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(
        Tooltip,
        {
          content: (0, import_jsx_runtime.jsx)(Stack, { space: 2, padding: 2, children: item.map(renderItem) }),
          children: (0, import_jsx_runtime.jsx)(Box, { children: renderItem("...", index) })
        }
      ),
      showSeparator && separator
    ] }, key) : (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [
      renderItem(item, index),
      showSeparator && separator
    ] }, key);
  }), [items]);
  return (0, import_jsx_runtime.jsx)(Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
function getDialogCopy(t) {
  return {
    thread: {
      title: t("delete-thread.title"),
      body: t("delete-thread.body"),
      confirmButtonText: t("delete-thread.confirm")
    },
    comment: {
      title: t("delete-comment.title"),
      body: t("delete-comment.body"),
      confirmButtonText: t("delete-comment.confirm")
    }
  };
}
function CommentDeleteDialog(props) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props, { t } = useTranslation2(commentsLocaleNamespace), dialogCopy = getDialogCopy(t), { title, body, confirmButtonText } = dialogCopy[isParent ? "thread" : "comment"], handleDelete = (0, import_react2.useCallback)(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      footer: {
        cancelButton: {
          onClick: onClose
        },
        confirmButton: {
          loading,
          onClick: handleDelete,
          text: confirmButtonText,
          tone: "critical"
        }
      },
      header: title,
      id: "delete-comment-dialog",
      onClose,
      width: 0,
      children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
        (0, import_jsx_runtime.jsx)(Text, { size: 1, children: body }),
        error && (0, import_jsx_runtime.jsx)(TextWithTone, { tone: "critical", children: t("delete-dialog.error") })
      ] })
    }
  );
}
var CommentDisabledIcon = (0, import_react2.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      "data-sanity-icon": "comment-disabled",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M5.92627 14.5381H7.92627V18.5381L11.9263 14.5381H15.9263C17.0308 14.5381 17.9263 13.6427 17.9263 12.5381V6.53809C17.9263 5.43352 17.0308 4.53809 15.9263 4.53809H5.92627C4.8217 4.53809 3.92627 5.43352 3.92627 6.53809V12.5381C3.92627 13.6427 4.8217 14.5381 5.92627 14.5381Z",
            stroke: "currentColor",
            strokeWidth: "1.2",
            strokeLinejoin: "round"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M2.77256 2.66835C2.54413 2.51319 2.23317 2.57259 2.07802 2.80103L1.40378 3.7937C1.32927 3.9034 1.30139 4.0382 1.32627 4.16845C1.35115 4.29871 1.42676 4.41374 1.53646 4.48825L19.5861 16.7479C19.8146 16.903 20.1255 16.8436 20.2807 16.6152L20.9549 15.6225C21.0294 15.5128 21.0573 15.378 21.0324 15.2478C21.0076 15.1175 20.9319 15.0025 20.8222 14.928L2.77256 2.66835Z",
            fill: "currentColor",
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
var CommentIcon2 = (0, import_react2.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    {
      "data-sanity-icon": "comment",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z",
          stroke: "currentColor",
          strokeLinejoin: "round",
          strokeWidth: "1.2"
        }
      )
    }
  );
});
var MentionIcon = (0, import_react2.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      "data-sanity-icon": "mention",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        (0, import_jsx_runtime.jsx)("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
});
var ReactionIcon = (0, import_react2.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      "data-sanity-icon": "add-reaction",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M10.1044 10.4011L10.1044 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M14.2393 10.4011L14.2393 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M7.12128 14.1151C7.70803 15.0226 9.66113 16.8377 11.7735 16.8377C13.8859 16.8377 15.6713 15.0226 16.4257 14.1151",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M16.703 6.43905C15.3486 5.36511 13.6357 4.72374 11.773 4.72374C7.38731 4.72374 3.83203 8.27902 3.83203 12.6647C3.83203 17.0503 7.38731 20.6056 11.773 20.6056C16.0995 20.6056 19.618 17.1455 19.712 12.8415",
            stroke: "currentColor",
            strokeWidth: 1.2
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.1135 9.03425L19.1135 11.4903L20.3135 11.4903L20.3135 9.03425L22.7693 9.03425L22.7693 7.83425L20.3135 7.83425L20.3135 5.37941L19.1135 5.37941L19.1135 7.83425L16.6584 7.83425L16.6584 9.03425L19.1135 9.03425Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
var SendIcon = (0, import_react2.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    {
      "data-sanity-icon": "send",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          clipRule: "evenodd",
          d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
var CommentsAuthoringPathContext = (0, import_react2.createContext)(
  null
);
function CommentsAuthoringPathProvider(props) {
  const { children } = props, [authoringPath, setAuthoringPath] = (0, import_react2.useState)(null), handleSetAuthoringPath = (0, import_react2.useCallback)((nextAuthoringPath) => {
    setAuthoringPath(nextAuthoringPath);
  }, []), value = (0, import_react2.useMemo)(
    () => ({
      authoringPath,
      setAuthoringPath: handleSetAuthoringPath
    }),
    [authoringPath, handleSetAuthoringPath]
  );
  return (0, import_jsx_runtime.jsx)(CommentsAuthoringPathContext.Provider, { value, children });
}
var CommentsContext = (0, import_react2.createContext)(null);
function getSchemaField(schemaType, fieldPath) {
  var _a;
  const paths = fromString(fieldPath), firstPath = paths[0];
  if (firstPath && isObjectSchemaType(schemaType)) {
    const field = (_a = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = toString(paths.slice(1));
      return nextPath ? getSchemaField(field.type, nextPath) : field;
    }
  }
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = (0, import_findIndex.default)(array, pathSegment);
  return index === -1 ? false : index;
}
function buildCommentBreadcrumbs(props) {
  const { currentUser, schemaType, fieldPath, documentValue } = props, paths = fromString(fieldPath), fieldPaths = [];
  let currentSchemaType = null;
  return paths.forEach((seg, index) => {
    var _a, _b, _c, _d, _e;
    const currentPath = paths.slice(0, index + 1), previousPath = paths.slice(0, index), field = getSchemaField(schemaType, toString(currentPath)), isKeySegment2 = seg.hasOwnProperty("_key"), parentValue = getValueAtPath(documentValue, previousPath), currentValue = getValueAtPath(documentValue, currentPath), conditionalContext = {
      document: documentValue,
      currentUser,
      parent: parentValue,
      value: currentValue
    };
    if (isKeySegment2 && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg), isNumber2 = typeof arrayItemIndex == "number";
      fieldPaths.push({
        invalid: arrayItemIndex === false,
        isArrayItem: true,
        title: isNumber2 ? `#${Number(arrayItemIndex) + 1}` : "Unknown array item"
      });
      return;
    }
    if (field != null && field.type) {
      const hidden = resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({
        invalid: hidden,
        isArrayItem: false,
        title: getSchemaTypeTitle(field.type)
      }), currentSchemaType = field.type;
      return;
    }
    if (isArraySchemaType(currentSchemaType)) {
      const arrayValue = getValueAtPath(documentValue, previousPath), objectType = arrayValue == null ? void 0 : arrayValue._type, objectField = (_a = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a.find(
        (type) => type.name === objectType
      ), currentField = (_b = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b.find(
        (f) => f.name === seg
      );
      if (!objectType && currentValue) {
        const allCurrentFields = (_c = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat(), anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg), hidden = resolveConditionalProperty((_d = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d.hidden, conditionalContext);
        anonymousField && (fieldPaths.push({
          invalid: hidden,
          isArrayItem: false,
          title: getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type)
        }), currentSchemaType = anonymousField == null ? void 0 : anonymousField.type);
        return;
      }
      if (!currentField) {
        fieldPaths.push({
          invalid: true,
          isArrayItem: false,
          title: "Unknown field"
        });
        return;
      }
      const currentTitle = getSchemaTypeTitle(currentField == null ? void 0 : currentField.type), objectFieldHidden = resolveConditionalProperty(
        (_e = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e.hidden,
        conditionalContext
      ), currentFieldHidden = resolveConditionalProperty(
        currentField == null ? void 0 : currentField.type.hidden,
        conditionalContext
      ), isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({
        invalid: isHidden,
        isArrayItem: false,
        title: currentTitle
      }), currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({
      invalid: true,
      isArrayItem: false,
      title: "Unknown field"
    });
  }), fieldPaths;
}
function useCommentHasChanged(message) {
  const prevMessage = (0, import_react2.useRef)(message);
  return (0, import_react2.useMemo)(() => !(0, import_isEqual2.default)(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  return value ? value == null ? void 0 : value.some(
    (block) => {
      var _a;
      return isPortableTextTextBlock(block) && ((_a = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a.some((c) => isPortableTextSpan(c) ? c.text : c.userId));
    }
  ) : false;
}
function commentIntentIfDiffers(parent, comment) {
  var _a, _b;
  const parentIntent = (_a = parent == null ? void 0 : parent.context) == null ? void 0 : _a.intent, intent = (_b = comment == null ? void 0 : comment.context) == null ? void 0 : _b.intent;
  if (intent && (!parentIntent || "preview" in intent.params && "preview" in parentIntent.params && intent.params.preview !== parentIntent.params.preview))
    return intent;
}
function isTextSelectionComment(comment) {
  var _a, _b, _c, _d, _e, _f;
  return comment ? !!(((_c = (_b = (_a = comment == null ? void 0 : comment.target) == null ? void 0 : _a.path) == null ? void 0 : _b.selection) == null ? void 0 : _c.type) === "text" && (_f = (_e = (_d = comment == null ? void 0 : comment.target) == null ? void 0 : _d.path) == null ? void 0 : _e.selection) != null && _f.value) : false;
}
var EMPTY_ARRAY$j = [];
function buildCommentThreadItems(props) {
  const { comments: comments2, currentUser, documentValue, schemaType, type } = props, parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  return type === "task" ? parentComments.map((parentComment) => {
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
    return {
      commentsCount: [parentComment, ...replies].length,
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue: false,
      breadcrumbs: EMPTY_ARRAY$j,
      fieldPath: ""
    };
  }) : type === "field" ? parentComments.map((parentComment) => {
    var _a, _b, _c;
    const crumbs = buildCommentBreadcrumbs({
      currentUser,
      documentValue,
      fieldPath: ((_a = parentComment.target.path) == null ? void 0 : _a.field) || "",
      schemaType
    });
    let hasTextSelection = false;
    if (isTextSelectionComment(parentComment) && (hasTextSelection = !!((_b = parentComment.target.path) != null && _b.selection && parentComment.target.path.selection.value.some((v) => v.text))), crumbs.some((bc) => bc.invalid))
      return;
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id), commentsCount = [parentComment, ...replies].length, hasReferencedValue = hasTextSelection;
    return {
      breadcrumbs: crumbs,
      commentsCount,
      fieldPath: ((_c = parentComment.target.path) == null ? void 0 : _c.field) || "",
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue
    };
  }).filter(Boolean) : EMPTY_ARRAY$j;
}
var DMP_MARGIN = 15;
function diffText(current, next) {
  const diff2 = diff(current, next), diffs = cleanupEfficiency(diff2), levenshtein = diffsLevenshtein(diffs);
  return { patches: make(current, diffs, { margin: DMP_MARGIN }), levenshtein };
}
function diffApply(current, patches) {
  return apply(patches, current, {
    allowExceedingIndices: true,
    margin: DMP_MARGIN
  })[0];
}
var CHILD_SYMBOL = "ïƒ";
function toPlainTextWithChildSeparators(inputBlock) {
  return inputBlock.children.map((child) => isPortableTextSpan(child) ? child.text.replaceAll(CHILD_SYMBOL, " ") : "").join(CHILD_SYMBOL);
}
var COMMENT_INDICATORS = ["ï€€", "ï€"];
var COMMENT_INDICATORS_REGEX = new RegExp(`[${COMMENT_INDICATORS.join("")}]`, "g");
var EMPTY_ARRAY$i = [];
function buildRangeDecorationSelectionsFromComments(props) {
  const { value, comments: comments2 } = props;
  if (!value || value.length === 0)
    return EMPTY_ARRAY$i;
  const textSelections = comments2.filter(isTextSelectionComment), decorators = [];
  return textSelections.forEach((comment) => {
    var _a, _b;
    (_b = (_a = comment.target.path) == null ? void 0 : _a.selection) == null || _b.value.forEach((selectionMember) => {
      const matchedBlock = value.find((block) => block._key === selectionMember._key);
      if (!matchedBlock || !isPortableTextTextBlock(matchedBlock))
        return;
      const selectionText = selectionMember.text.replaceAll(COMMENT_INDICATORS_REGEX, ""), textWithChildSeparators = toPlainTextWithChildSeparators(matchedBlock), { patches } = diffText(selectionText, selectionMember.text), diffedText = diffApply(textWithChildSeparators, patches), startIndex = diffedText.indexOf(COMMENT_INDICATORS[0]), endIndex = diffedText.replaceAll(COMMENT_INDICATORS[0], "").indexOf(COMMENT_INDICATORS[1]), textWithoutCommentTags = diffedText.replaceAll(COMMENT_INDICATORS_REGEX, ""), oldCommentedText = selectionMember.text.substring(
        selectionMember.text.indexOf(COMMENT_INDICATORS[0]) + 1,
        selectionMember.text.indexOf(COMMENT_INDICATORS[1])
      ), newCommentedText = textWithoutCommentTags.substring(startIndex, endIndex), { levenshtein } = diffText(newCommentedText, oldCommentedText), threshold = Math.round(newCommentedText.length + oldCommentedText.length / 2);
      let nullSelection = false;
      if (newCommentedText.length === 0 && (nullSelection = true), levenshtein > threshold && (nullSelection = true), startIndex + 1 === endIndex && (nullSelection = true), startIndex !== -1 && endIndex !== -1) {
        let childIndexAnchor = 0, anchorOffset = 0, childIndexFocus = 0, focusOffset = 0;
        for (let i = 0; i < textWithoutCommentTags.length && (textWithoutCommentTags[i] === CHILD_SYMBOL && (i <= startIndex && (anchorOffset = -1, childIndexAnchor++), focusOffset = -1, childIndexFocus++), i < startIndex && anchorOffset++, i < startIndex + newCommentedText.length && focusOffset++, i !== startIndex + newCommentedText.length); i++)
          ;
        decorators.push({
          selection: {
            anchor: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexAnchor]._key }
              ],
              offset: anchorOffset
            },
            focus: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexFocus]._key }
              ],
              offset: focusOffset
            }
          },
          comment,
          range: { _key: matchedBlock._key, text: nullSelection ? "" : diffedText }
        });
      }
    });
  }), decorators.length === 0 ? EMPTY_ARRAY$i : decorators;
}
function diffsLevenshtein(diffs) {
  let levenshtein = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
    }
  }
  return levenshtein += Math.max(insertions, deletions), levenshtein;
}
var CommentRangeDecoration = (0, import_react2.memo)(function(props) {
  const {
    children,
    commentId,
    currentHoveredCommentId,
    onClick,
    onHoverEnd,
    onHoverStart,
    selectedThreadId,
    threadId
  } = props, decoratorRef = (0, import_react2.useRef)(null), isNestedRef = (0, import_react2.useRef)(false), parentCommentId = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    var _a, _b;
    const prevEl = (_a = decoratorRef.current) == null ? void 0 : _a.previousSibling, nextEl = (_b = decoratorRef.current) == null ? void 0 : _b.nextSibling;
    if (!prevEl || !nextEl) {
      isNestedRef.current = false;
      return;
    }
    const [key] = Object.keys(applyInlineCommentIdAttr("")), prevId = prevEl.getAttribute(key), nextId = nextEl.getAttribute(key), isNestedDecorator = !!(prevId && nextId && prevId === nextId);
    parentCommentId.current = isNestedDecorator ? prevId : null, isNestedRef.current = isNestedDecorator;
  }, []);
  const handleMouseEnter = (0, import_react2.useCallback)(() => onHoverStart(commentId), [commentId, onHoverStart]), handleMouseLeave = (0, import_react2.useCallback)(() => onHoverEnd(null), [onHoverEnd]), handleClick = (0, import_react2.useCallback)(() => onClick(commentId), [commentId, onClick]), hovered = currentHoveredCommentId === commentId || currentHoveredCommentId === parentCommentId.current && isNestedRef.current;
  return (0, import_jsx_runtime.jsx)(
    CommentInlineHighlightSpan,
    {
      isAdded: true,
      isHovered: hovered || selectedThreadId === threadId,
      isNested: isNestedRef.current,
      onClick: handleClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: decoratorRef,
      ...applyInlineCommentIdAttr(threadId),
      children
    }
  );
});
function buildRangeDecorations(props) {
  const {
    comments: comments2,
    currentHoveredCommentId,
    onDecorationClick,
    onDecorationHoverEnd,
    onDecorationHoverStart,
    onDecorationMoved,
    selectedThreadId,
    value
  } = props;
  return buildRangeDecorationSelectionsFromComments({ comments: comments2, value }).map(({ selection, comment, range }) => ({
    component: ({ children }) => (0, import_jsx_runtime.jsx)(
      CommentRangeDecoration,
      {
        commentId: comment._id,
        currentHoveredCommentId,
        onClick: onDecorationClick,
        onHoverEnd: onDecorationHoverEnd,
        onHoverStart: onDecorationHoverStart,
        selectedThreadId,
        threadId: comment.threadId,
        children
      }
    ),
    onMoved: onDecorationMoved,
    selection,
    payload: {
      commentId: comment._id,
      range
    }
  }));
}
function buildTextSelectionFromFragment(props) {
  const { fragment, value, selection } = props;
  if (!selection)
    throw new Error("Selection is required");
  const normalizedSelection = selection.backward ? { backward: false, anchor: selection.focus, focus: selection.anchor } : selection;
  return {
    type: "text",
    value: fragment.map((fragmentBlock) => {
      const originalBlock = value.find((b) => b._key === fragmentBlock._key);
      if (!isPortableTextTextBlock(originalBlock))
        return {
          _key: fragmentBlock._key,
          text: ""
        };
      const anchorBlockKey = isKeySegment(normalizedSelection.anchor.path[0]) && normalizedSelection.anchor.path[0]._key, focusBlockKey = isKeySegment(normalizedSelection.focus.path[0]) && normalizedSelection.focus.path[0]._key, fragmentBlockText = toPlainText([fragmentBlock]), fragmentStartSpan = isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[0] : void 0, fragmentEndSpan = isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[fragmentBlock.children.length - 1] : void 0;
      let originalTextBeforeSelection = "", startChildIndex = -1;
      if (anchorBlockKey === originalBlock._key)
        for (const child of originalBlock.children) {
          if (startChildIndex++, child._key === (fragmentStartSpan == null ? void 0 : fragmentStartSpan._key)) {
            originalTextBeforeSelection += isPortableTextSpan(child) && child.text.substring(0, normalizedSelection.anchor.offset) || "";
            break;
          }
          originalTextBeforeSelection += child.text;
        }
      let originalTextAfterSelection = "";
      if (focusBlockKey === originalBlock._key)
        for (const child of originalBlock.children.slice(startChildIndex).reverse()) {
          if (child._key === (fragmentEndSpan == null ? void 0 : fragmentEndSpan._key)) {
            originalTextAfterSelection = (isPortableTextSpan(child) && child.text.substring(normalizedSelection.focus.offset, child.text.length) || "") + originalTextAfterSelection;
            break;
          }
          originalTextAfterSelection = child.text + originalTextAfterSelection;
        }
      return {
        _key: originalBlock._key,
        text: `${originalTextBeforeSelection}${COMMENT_INDICATORS[0]}${fragmentBlockText}${COMMENT_INDICATORS[1]}${originalTextAfterSelection}`
      };
    })
  };
}
function mergeCommentReactions(reactionsA, reactionsB) {
  const mergedReactions = {};
  for (const reaction of reactionsA)
    mergedReactions[reaction._key] = { ...reaction };
  for (const reaction of reactionsB)
    mergedReactions[reaction._key] = { ...mergedReactions[reaction._key], ...reaction };
  return Object.values(mergedReactions);
}
function createCommentsSet(comments2) {
  return comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
}
function commentsReducer(state2, action) {
  var _a;
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return {
        ...state2,
        comments: commentsById
      };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload, nextCommentValue = nextCommentResult, nextComment = {
        [nextCommentResult._id]: {
          ...state2.comments[nextCommentResult._id],
          ...nextCommentValue,
          _state: nextCommentResult._state || void 0,
          // If the comment is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the comments correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the comment.
          // Once the comment is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          ...nextComment
        }
      };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [nextCommentResult._id]: nextCommentResult
        }
      };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state2.comments;
      return Object.keys(restComments).forEach((commentId) => {
        restComments[commentId].parentCommentId === action.id && delete restComments[commentId];
      }), {
        ...state2,
        comments: restComments
      };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload, id = updatedComment._id, comment = state2.comments[id], optimisticReactions = ((_a = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a.filter((v) => v == null ? void 0 : v._optimisticState)) || [], incomingReactions = updatedComment.reactions || [], nextReactions = mergeCommentReactions(optimisticReactions, incomingReactions), nextComment = {
        // Add existing comment data
        ...comment,
        // Add incoming comment data
        ...updatedComment,
        // Add reactions merged with optimistic reactions
        reactions: nextReactions
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [id]: nextComment
        }
      };
    }
    default:
      return state2;
  }
}
var INITIAL_STATE$2 = {
  comments: {}
};
var LISTEN_OPTIONS$1 = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: true,
  visibility: "query"
};
var SORT_FIELD$1 = "_createdAt";
var SORT_ORDER$1 = "desc";
var QUERY_FILTERS$1 = ['_type == "comment"', "target.document._ref == $documentId"];
var QUERY_PROJECTION$1 = `{
  _createdAt,
  _id,
  authorId,
  contentSnapshot,
  context,
  lastEditedAt,
  message,
  parentCommentId,
  reactions,
  status,
  target,
  threadId
}`;
var QUERY_SORT_ORDER$1 = `order(${SORT_FIELD$1} ${SORT_ORDER$1})`;
var QUERY$1 = `*[${QUERY_FILTERS$1.join(" && ")}] ${QUERY_PROJECTION$1} | ${QUERY_SORT_ORDER$1}`;
function useCommentsStore(opts) {
  const { client, documentId, onLatestTransactionIdReceived, transactionsIdMap } = opts, [state2, dispatch] = (0, import_react2.useReducer)(commentsReducer, INITIAL_STATE$2), [loading, setLoading] = (0, import_react2.useState)(client !== null), [error, setError] = (0, import_react2.useState)(null), didInitialFetch = (0, import_react2.useRef)(false), params = (0, import_react2.useMemo)(() => ({ documentId: getPublishedId(documentId) }), [documentId]), initialFetch = (0, import_react2.useCallback)(async () => {
    if (!client) {
      setLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY$1, params);
      dispatch({ type: "COMMENTS_SET", comments: res }), setLoading(false);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = (0, import_react2.useCallback)(
    async (event) => {
      var _a;
      if (event.type === "welcome" && !didInitialFetch.current && (setLoading(true), await initialFetch(), setLoading(false), didInitialFetch.current = true), event.type === "reconnect" && (setLoading(true), didInitialFetch.current = false), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextComment = event.result;
          nextComment && dispatch({
            type: "COMMENT_RECEIVED",
            payload: nextComment
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "COMMENT_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedComment = event.result, id = ((_a = event.result) == null ? void 0 : _a._id) || "", transactionId = event.transactionId, latestTransactionId = transactionsIdMap.get(id), isLatestTransaction = transactionId === latestTransactionId;
          if (!isLatestTransaction && latestTransactionId)
            return;
          updatedComment && (dispatch({
            type: "COMMENT_UPDATED",
            payload: updatedComment
          }), isLatestTransaction && onLatestTransactionIdReceived(id));
        }
      }
    },
    [initialFetch, onLatestTransactionIdReceived, transactionsIdMap]
  ), listener$ = (0, import_react2.useMemo)(() => client ? client.observable.listen(QUERY$1, params, LISTEN_OPTIONS$1).pipe(
    catchError((err) => (setError(err), of(err)))
  ) : of(), [client, params]);
  return (0, import_react2.useEffect)(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: (0, import_react2.useMemo)(() => Object.values(state2.comments), [state2.comments]),
    dispatch,
    error,
    loading
  };
}
var EMPTY_ARRAY$h = [];
var EMPTY_COMMENTS_DATA = {
  open: EMPTY_ARRAY$h,
  resolved: EMPTY_ARRAY$h
};
var CommentsProvider = (0, import_react2.memo)(function(props) {
  const { children, documentId, documentType, isCommentsOpen, onCommentsOpen, sortOrder, type } = props, commentsEnabled = useCommentsEnabled(), [status, setStatus] = (0, import_react2.useState)("open"), { client, createAddonDataset, isCreatingDataset } = useAddonDataset(), publishedId = getPublishedId(documentId), editState = useEditState(publishedId, documentType, "low"), schemaType = useSchema().get(documentType), currentUser = useCurrentUser(), { name: workspaceName, dataset, projectId } = useWorkspace(), documentValue = (0, import_react2.useMemo)(() => editState.draft || editState.published, [editState.draft, editState.published]), documentRevisionId = (0, import_react2.useMemo)(() => documentValue == null ? void 0 : documentValue._rev, [documentValue]), transactionsIdMap = (0, import_react2.useMemo)(() => /* @__PURE__ */ new Map(), []), handleOnLatestTransactionIdReceived = (0, import_react2.useCallback)(
    (commentDocumentId) => {
      transactionsIdMap.delete(commentDocumentId);
    },
    [transactionsIdMap]
  ), {
    dispatch,
    data = EMPTY_ARRAY$h,
    error,
    loading
  } = useCommentsStore({
    documentId: publishedId,
    client,
    transactionsIdMap,
    onLatestTransactionIdReceived: handleOnLatestTransactionIdReceived
  }), handleOnTransactionStart = (0, import_react2.useCallback)(
    (commentDocumentId, transactionId) => {
      transactionsIdMap.set(commentDocumentId, transactionId);
    },
    [transactionsIdMap]
  ), handleSetStatus = (0, import_react2.useCallback)(
    (newStatus) => commentsEnabled.mode === "upsell" && newStatus === "resolved" ? null : setStatus(newStatus),
    [setStatus, commentsEnabled]
  ), mentionOptions = useUserListWithPermissions(
    (0, import_react2.useMemo)(() => ({ documentValue, permission: "read" }), [documentValue])
  ), threadItemsByStatus = (0, import_react2.useMemo)(() => {
    if (!schemaType || !currentUser)
      return EMPTY_COMMENTS_DATA;
    const sorted = (0, import_orderBy.default)(data, ["_createdAt"], [sortOrder]), items = buildCommentThreadItems({
      comments: sorted,
      currentUser,
      documentValue,
      schemaType,
      type
    });
    return {
      open: items.filter((item) => item.parentComment.status === "open"),
      resolved: items.filter((item) => item.parentComment.status === "resolved")
    };
  }, [currentUser, data, documentValue, schemaType, sortOrder, type]), getThreadLength = (0, import_react2.useCallback)(
    (threadId) => threadItemsByStatus.open.filter((item) => item.threadId === threadId).length,
    [threadItemsByStatus.open]
  ), getComment = (0, import_react2.useCallback)((id) => data == null ? void 0 : data.find((c) => c._id === id), [data]), handleOnCreate = (0, import_react2.useCallback)(
    (payload) => {
      var _a, _b;
      const hasError = ((_b = (_a = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a._state) == null ? void 0 : _b.type) === "createError";
      dispatch({
        type: "COMMENT_ADDED",
        payload: {
          ...payload,
          _state: hasError ? { type: "createRetrying" } : void 0
        }
      });
    },
    [data, dispatch]
  ), handleOnUpdate = (0, import_react2.useCallback)(
    (id, payload) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          ...payload
        }
      });
    },
    [dispatch]
  ), handleOnCreateError = (0, import_react2.useCallback)(
    (id, err) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          _state: {
            error: err,
            type: "createError"
          }
        }
      });
    },
    [dispatch]
  ), { operation } = useCommentOperations(
    (0, import_react2.useMemo)(
      () => ({
        client,
        currentUser,
        dataset,
        documentId: publishedId,
        documentRevisionId,
        documentType,
        getComment,
        getThreadLength,
        projectId,
        schemaType,
        workspace: workspaceName,
        // This function runs when the first comment creation is executed.
        // It is used to create the addon dataset and configure a client for
        // the addon dataset.
        createAddonDataset,
        // The following callbacks runs when the comment operation are executed.
        // They are used to update the local state of the comments immediately after
        // a comment operation has been executed. This is done to avoid waiting for
        // the real time listener to update the comments and make the UI feel more
        // responsive. The comment will be updated again when we receive an mutation
        // event from the real time listener.
        onCreate: handleOnCreate,
        onCreateError: handleOnCreateError,
        onUpdate: handleOnUpdate,
        onTransactionStart: handleOnTransactionStart
      }),
      [
        client,
        currentUser,
        dataset,
        documentRevisionId,
        documentType,
        getComment,
        createAddonDataset,
        getThreadLength,
        handleOnCreate,
        handleOnCreateError,
        handleOnTransactionStart,
        handleOnUpdate,
        projectId,
        publishedId,
        schemaType,
        workspaceName
      ]
    )
  ), ctxValue = (0, import_react2.useMemo)(
    () => ({
      isCreatingDataset,
      status,
      setStatus: handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      comments: {
        data: threadItemsByStatus,
        error,
        loading: loading || isCreatingDataset
      },
      operation: {
        create: operation.create,
        react: operation.react,
        remove: operation.remove,
        update: operation.update
      },
      mentionOptions
    }),
    [
      isCreatingDataset,
      status,
      handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      threadItemsByStatus,
      error,
      loading,
      operation.create,
      operation.react,
      operation.remove,
      operation.update,
      mentionOptions
    ]
  );
  return (0, import_jsx_runtime.jsx)(CommentsContext.Provider, { value: ctxValue, children });
});
var CommentsEnabledContext = (0, import_react2.createContext)(null);
var CommentsEnabledProvider = React.memo(function(props) {
  const { children, documentId, documentType } = props, value = useResolveCommentsEnabled(documentId, documentType);
  return (0, import_jsx_runtime.jsx)(CommentsEnabledContext.Provider, { value, children });
});
var CommentsIntentContext = (0, import_react2.createContext)(
  void 0
);
var CommentsIntentProvider = (0, import_react2.memo)(function(props) {
  const { children, getIntent: getIntent2 } = props;
  return (0, import_jsx_runtime.jsx)(CommentsIntentContext.Provider, { value: getIntent2, children });
});
var CommentsOnboardingContext = (0, import_react2.createContext)(null);
var VERSION = 1;
var LOCAL_STORAGE_KEY = `sanityStudio:comments:inspector:onboarding:dismissed:v${VERSION}`;
var setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(value));
  } catch {
  }
};
var getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    return value ? JSON.parse(value) : false;
  } catch {
    return false;
  }
};
function CommentsOnboardingProvider(props) {
  const { children } = props, [dismissed, setDismissed] = (0, import_react2.useState)(getLocalStorage()), handleDismiss = (0, import_react2.useCallback)(() => {
    setDismissed(true), setLocalStorage(true);
  }, [setDismissed]), ctxValue = (0, import_react2.useMemo)(
    () => ({
      setDismissed: handleDismiss,
      isDismissed: dismissed
    }),
    [handleDismiss, dismissed]
  );
  return (0, import_jsx_runtime.jsx)(CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
var CommentsSelectedPathContext = (0, import_react2.createContext)(
  null
);
var CommentsSelectedPathProvider = import_react2.default.memo(function(props) {
  const { children } = props, [selectedPath, setSelectedPath] = (0, import_react2.useState)(null), handleSelectPath = (0, import_react2.useCallback)(
    (nextPath) => {
      (0, import_isEqual2.default)(selectedPath, nextPath) || setSelectedPath(nextPath);
    },
    [selectedPath]
  ), ctxValue = (0, import_react2.useMemo)(
    () => ({
      selectedPath,
      setSelectedPath: handleSelectPath
    }),
    [selectedPath, handleSelectPath]
  );
  return (0, import_jsx_runtime.jsx)(CommentsSelectedPathContext.Provider, { value: ctxValue, children });
});
var CommentsUpsellContext = (0, import_react2.createContext)(null);
var UPSELL_CLIENT_OPTIONS = {
  apiVersion: "2023-12-11",
  useProjectHostname: false,
  withCredentials: false,
  useCdn: true
};
var FEATURE = "comments";
var TEMPLATE_OPTIONS = { interpolate: /{{([\s\S]+?)}}/g };
var BASE_URL = "www.sanity.io";
function CommentsUpsellProvider(props) {
  const [upsellDialogOpen, setUpsellDialogOpen] = (0, import_react2.useState)(false), [upsellData, setUpsellData] = (0, import_react2.useState)(null), projectId = useProjectId(), telemetry = useTelemetry(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), telemetryLogs = (0, import_react2.useMemo)(
    () => ({
      dialogSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      panelViewed: (source) => telemetry.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry.log(UpsellDialogDismissed, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      })
    }),
    [telemetry]
  ), handlePrimaryButtonClick = (0, import_react2.useCallback)(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = (0, import_react2.useCallback)(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = (0, import_react2.useCallback)(() => {
    setUpsellDialogOpen(false), telemetry.log(UpsellDialogDismissed, {
      feature: FEATURE,
      type: "modal"
    });
  }, [telemetry]);
  (0, import_react2.useEffect)(() => {
    const sub = client.withConfig(UPSELL_CLIENT_OPTIONS).observable.request({
      uri: "/journey/comments"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = (0, import_template.default)(data.ctaButton.url, TEMPLATE_OPTIONS);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL, projectId });
            const secondaryUrl = (0, import_template.default)(data.secondaryButton.url, TEMPLATE_OPTIONS);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client, projectId]);
  const handleOpenDialog = (0, import_react2.useCallback)(
    (source) => {
      setUpsellDialogOpen(true), telemetry.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "modal",
        source
      });
    },
    [telemetry]
  ), ctxValue = (0, import_react2.useMemo)(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return (0, import_jsx_runtime.jsxs)(CommentsUpsellContext.Provider, { value: ctxValue, children: [
    props.children,
    upsellData && upsellDialogOpen && (0, import_jsx_runtime.jsx)(
      CommentsUpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function useCommentsIntent() {
  return (0, import_react2.useContext)(CommentsIntentContext);
}
var structureLocaleNamespace = "structure";
var structureUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: structureLocaleNamespace,
  resources: () => import("./resources2-AZPUJIAP.js")
});
function DocTitle(props) {
  const { document: documentValue } = props, schemaType = useSchema().get(documentValue._type), { t } = useTranslation2(structureLocaleNamespace), { error, value } = useDocumentPreview({
    schemaType,
    value: documentValue
  });
  return schemaType ? error ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("doc-title.error.text", { errorMessage: error.message }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) }) : (0, import_jsx_runtime.jsx)("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
}
var ChevronWrapper = ut(Box)`
  margin-left: auto;
`;
var CrossDatasetReferencesDetails = ut.details`
  flex: none;

  &[open] ${ChevronWrapper} {
    transform: rotate(180deg);
  }
`;
var CrossDatasetReferencesSummary = ut.summary`
  list-style: none;

  &::-webkit-details-marker {
    display: none;
  }
`;
var Table = ut.table`
  width: 100%;
  text-align: left;
  padding: 0 ${({ theme }) => rem(theme.sanity.space[2])};
  border-collapse: collapse;

  th {
    padding: ${({ theme }) => rem(theme.sanity.space[1])};
  }

  td {
    padding: 0 ${({ theme }) => rem(theme.sanity.space[1])};
  }

  tr > *:last-child {
    text-align: right;
  }
`;
var DocumentIdFlex = ut(Flex)`
  min-height: 33px;
`;
var OtherReferenceCount = (props) => {
  const { t } = useTranslation2(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  return difference ? (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsxs)(Inline, { space: 2, children: [
    (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }),
    (0, import_jsx_runtime.jsx)(
      Tooltip,
      {
        portal: true,
        placement: "top",
        content: t("confirm-delete-dialog.other-reference-count.tooltip"),
        children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime.jsx)(InfoOutlineIcon, {}) })
      }
    )
  ] }) }) : null;
};
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props, title = isRecord$4(value.title) && (0, import_react2.isValidElement)(value.title) || (0, import_isString.default)(value.title) || (0, import_isNumber.default)(value.title) ? value.title : null, { draft, published, isLoading } = useMemoObservable(
    () => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title),
    [props.documentPreviewStore, schemaType, value._id, title]
  ), status = isLoading ? null : (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && (0, import_jsx_runtime.jsx)(DocumentPreviewPresence, { presence }),
    (0, import_jsx_runtime.jsx)(DocumentStatusIndicator, { draft, published })
  ] }) }), tooltip = (0, import_jsx_runtime.jsx)(DocumentStatus, { draft, published });
  return (0, import_jsx_runtime.jsx)(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({ value, draft, published }),
      isPlaceholder: isLoading,
      icon,
      layout,
      status,
      tooltip
    }
  );
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
var PaneRouterContext = (0, import_react2.createContext)({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: false,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrentAndAfter: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext(),
  createPathWithParams: () => missingContext()
});
var BackLink = (0, import_react2.forwardRef)(function(props, ref) {
  const { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext), panes = (0, import_react2.useMemo)(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]), state2 = (0, import_react2.useMemo)(() => ({ panes }), [panes]);
  return (0, import_jsx_runtime.jsx)(StateLink, { ...props, ref, state: state2 });
});
var PaneLayoutContext = (0, import_react2.createContext)(null);
function usePaneLayout() {
  const pane = (0, import_react2.useContext)(PaneLayoutContext);
  if (!pane)
    throw new Error("PaneLayout: missing context value");
  return pane;
}
var ChildLink = (0, import_react2.forwardRef)(function(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props, { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext);
  return (0, import_jsx_runtime.jsx)(
    StateLink,
    {
      ...rest,
      ref,
      state: {
        panes: [
          ...routerPanesState.slice(0, groupIndex + 1),
          [{ id: childId, params: childParameters, payload: childPayload }]
        ]
      }
    }
  );
});
var ParameterizedLink = (0, import_react2.forwardRef)(function(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = (0, import_react2.useContext)(PaneRouterContext), { params, payload, ...rest } = props, nextParams = useUnique(params), nextPayload = useUnique(payload), nextState = (0, import_react2.useMemo)(() => {
    const currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    }, nextGroup = [
      ...currentGroup.slice(0, siblingIndex),
      nextSibling,
      ...currentGroup.slice(siblingIndex + 1)
    ];
    return { panes: [
      ...currentPanes.slice(0, groupIndex),
      nextGroup,
      ...currentPanes.slice(groupIndex + 1)
    ] };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return (0, import_jsx_runtime.jsx)(StateLink, { ref, ...rest, state: nextState });
});
var ReferenceChildLink = (0, import_react2.forwardRef)(function({ documentId, documentType, parentRefPath, children, template: template2, ...rest }, ref) {
  return (0, import_jsx_runtime.jsx)(
    ChildLink,
    {
      ...rest,
      ref,
      childId: documentId,
      childPayload: template2 == null ? void 0 : template2.params,
      childParameters: {
        type: documentType,
        parentRefPath: toString(parentRefPath),
        ...template2 && { template: template2 == null ? void 0 : template2.id }
      },
      children
    }
  );
});
function usePaneRouter() {
  return (0, import_react2.useContext)(PaneRouterContext);
}
var EMPTY_ARRAY$g = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props, publishedId = getPublishedId(value == null ? void 0 : value._id), documentPresence = useDocumentPresence(publishedId), documentPreviewStore = useDocumentPreviewStore(), { ReferenceChildLink: ReferenceChildLink2 } = usePaneRouter(), Link2 = (0, import_react2.useCallback)(
    function(linkProps) {
      return (0, import_jsx_runtime.jsx)(
        ReferenceChildLink2,
        {
          documentId: value == null ? void 0 : value._id,
          documentType: type == null ? void 0 : type.name,
          parentRefPath: EMPTY_ARRAY$g,
          ...linkProps
        }
      );
    },
    [ReferenceChildLink2, type == null ? void 0 : type.name, value == null ? void 0 : value._id]
  );
  return (0, import_jsx_runtime.jsx)(PreviewCard, { __unstable_focusRing: true, as: Link2, "data-as": "a", onClick, radius: 2, children: (0, import_jsx_runtime.jsx)(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "compact",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$g,
      schemaType: type,
      value
    }
  ) });
}
function ConfirmDeleteDialogBody({
  crossDatasetReferences,
  internalReferences,
  documentTitle,
  totalCount,
  action,
  datasetNames,
  hasUnknownDatasetNames,
  onReferenceLinkClick
}) {
  const schema2 = useSchema(), toast = useToast(), { t } = useTranslation2(structureLocaleNamespace), renderPreviewItem = (0, import_react2.useCallback)(
    (item) => {
      const type = schema2.get(item._type);
      return type ? (0, import_jsx_runtime.jsx)(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : (
        // Padding added to match the ReferencePreviewLink styling
        (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(
          SanityDefaultPreview,
          {
            icon: UnknownIcon,
            title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"),
            subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
              documentId: item._id
            }),
            layout: "default"
          }
        ) })
      );
    },
    [schema2, t, onReferenceLinkClick]
  );
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0)
    return (0, import_jsx_runtime.jsx)(Text, { as: "p", size: 1, children: (0, import_jsx_runtime.jsx)(
      Translate,
      {
        t,
        i18nKey: "confirm-delete-dialog.confirmation.text",
        context: action,
        components: { DocumentTitle: () => (0, import_jsx_runtime.jsx)("strong", { children: documentTitle }) }
      }
    ) });
  const normalizedDatasetNames = [
    ...datasetNames,
    ...hasUnknownDatasetNames ? ["unavailable"] : []
  ], datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", {
    count: normalizedDatasetNames.length,
    datasets: normalizedDatasetNames.join(", "),
    context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : ""
  });
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 4, children: [
    (0, import_jsx_runtime.jsx)(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: (0, import_jsx_runtime.jsxs)(Flex, { children: [
      (0, import_jsx_runtime.jsx)(Text, { "aria-hidden": "true", size: 1, children: (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {}) }),
      (0, import_jsx_runtime.jsx)(Box, { flex: 1, marginLeft: 3, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          i18nKey: "confirm-delete-dialog.referring-document-count.text",
          components: { DocumentTitle: () => documentTitle },
          t,
          values: { count: totalCount }
        }
      ) }) })
    ] }) }),
    (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) }),
    (0, import_jsx_runtime.jsx)(Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", children: [
      internalReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [
        internalReferences == null ? void 0 : internalReferences.references.map((item) => (0, import_jsx_runtime.jsx)(Box, { as: "li", children: renderPreviewItem(item) }, item._id)),
        internalReferences.totalCount > internalReferences.references.length && (0, import_jsx_runtime.jsx)(Box, { as: "li", padding: 3, children: (0, import_jsx_runtime.jsx)(OtherReferenceCount, { ...internalReferences }) })
      ] }),
      crossDatasetReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(
        CrossDatasetReferencesDetails,
        {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [
            (0, import_jsx_runtime.jsx)(CrossDatasetReferencesSummary, { children: (0, import_jsx_runtime.jsx)(
              Card,
              {
                as: "a",
                marginTop: internalReferences.totalCount > 0 ? 2 : 0,
                radius: 2,
                shadow: 1,
                paddingY: 1,
                children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
                  (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentsIcon, {}) }),
                  (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
                    (0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", {
                      count: normalizedDatasetNames.length,
                      documentCount: t("confirm-delete-dialog.cdr-summary.document-count", {
                        count: crossDatasetReferences.totalCount
                      })
                    }) }),
                    (0, import_jsx_runtime.jsx)(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: true, children: datasetSubtitle })
                  ] }),
                  (0, import_jsx_runtime.jsx)(ChevronWrapper, { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronDownIcon, {}) }) })
                ] })
              }
            ) }),
            (0, import_jsx_runtime.jsxs)(Box, { overflow: "auto", paddingTop: 2, children: [
              (0, import_jsx_runtime.jsxs)(Table, { children: [
                (0, import_jsx_runtime.jsx)("thead", { children: (0, import_jsx_runtime.jsxs)("tr", { children: [
                  (0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }),
                  (0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }),
                  (0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })
                ] }) }),
                (0, import_jsx_runtime.jsx)("tbody", { children: crossDatasetReferences.references.filter((reference) => "projectId" in reference).map(({ projectId, datasetName, documentId }, index) => (
                  // eslint-disable-next-line react/no-array-index-key
                  (0, import_jsx_runtime.jsxs)("tr", { children: [
                    (0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: projectId }) }),
                    (0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: datasetName || "unavailable" }) }),
                    (0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsxs)(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
                      (0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }),
                      documentId && (0, import_jsx_runtime.jsx)(
                        import_react_copy_to_clipboard.default,
                        {
                          text: documentId,
                          onCopy: () => {
                            toast.push({
                              title: t(
                                "confirm-delete-dialog.cdr-table.id-copied-toast.title"
                              ),
                              status: "success"
                            });
                          },
                          children: (0, import_jsx_runtime.jsx)(
                            Button2,
                            {
                              mode: "bleed",
                              icon: CopyIcon,
                              tooltipProps: {
                                content: t(
                                  "confirm-delete-dialog.cdr-table.copy-id-button.tooltip"
                                )
                              }
                            }
                          )
                        }
                      )
                    ] }) })
                  ] }, `${documentId}-${index}`)
                )) })
              ] }),
              (0, import_jsx_runtime.jsx)(OtherReferenceCount, { ...crossDatasetReferences })
            ] })
          ]
        }
      )
    ] }) }),
    (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) })
  ] });
}
function isClientError(e2) {
  return typeof e2 != "object" || !e2 ? false : "statusCode" in e2 && "response" in e2;
}
var POLL_INTERVAL = 5e3;
var visiblePoll$;
var getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  startWith(null),
  map(() => document.visibilityState === "visible"),
  distinctUntilChanged(),
  switchMap(
    (visible) => visible ? (
      // using timer instead of interval since timer will emit on creation
      timer(0, POLL_INTERVAL)
    ) : EMPTY
  ),
  shareReplay({ refCount: true, bufferSize: 1 })
)), visiblePoll$);
function getDocumentExistence(documentId, { versionedClient }) {
  const draftId = getDraftId(documentId), publishedId = getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: true,
    query: { excludeContent: "true" },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(
    map(({ omitted }) => {
      const nonExistant = omitted.filter((doc) => doc.reason === "existence");
      if (nonExistant.length !== 2)
        return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
    })
  );
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(
    switchMap(() => getDocumentExistence(documentId, context)),
    switchMap((checkDocumentId) => {
      if (!checkDocumentId)
        return of({ totalCount: 0, references: [] });
      const currentDataset = versionedClient.config().dataset;
      return versionedClient.observable.request({
        url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
        tag: "use-referring-documents.external"
      }).pipe(
        catchError((e2) => {
          if (isClientError(e2) && e2.statusCode === 404)
            return of({ totalCount: 0, references: [] });
          throw e2;
        })
      );
    })
  );
}
var useInternalReferences = createHookFromObservableFactory(
  ([documentId, documentStore]) => documentStore.listenQuery(
    { fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}', listen: "*[references($documentId)]" },
    { documentId },
    { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 }
  )
);
var useCrossDatasetReferences = createHookFromObservableFactory(
  ([documentId, versionedClient]) => getVisiblePoll$().pipe(
    switchMap(
      () => fetchCrossDatasetReferences(documentId, {
        versionedClient
      })
    )
  )
);
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = useDocumentStore(), publishedId = getPublishedId(documentId), [internalReferences, isInternalReferencesLoading] = useInternalReferences(
    (0, import_react2.useMemo)(() => [publishedId, documentStore], [documentStore, publishedId])
  ), [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(
    (0, import_react2.useMemo)(() => [publishedId, versionedClient], [publishedId, versionedClient])
  ), projectIds = (0, import_react2.useMemo)(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean)
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), datasetNames = (0, import_react2.useMemo)(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => !!datasetName && datasetName !== "")
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), hasUnknownDatasetNames = (0, import_react2.useMemo)(() => !!(crossDatasetReferences != null && crossDatasetReferences.references.some(
    (crossDatasetReference) => typeof crossDatasetReference.datasetName != "string"
  )), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
var DialogBody = ut(Box)`
  box-sizing: border-box;
`;
var LoadingContainer = ut(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function ConfirmDeleteDialog({
  id,
  type,
  action = "delete",
  onCancel,
  onConfirm
}) {
  const { t } = useTranslation2(structureLocaleNamespace), dialogId = `deletion-confirmation-${(0, import_react2.useId)()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id), documentTitle = (0, import_jsx_runtime.jsx)(DocTitle, { document: (0, import_react2.useMemo)(() => ({ _id: id, _type: type }), [id, type]) }), showConfirmButton = !isLoading;
  return (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      width: 1,
      id: dialogId,
      header: t("confirm-delete-dialog.header.text", { context: action }),
      footer: {
        cancelButton: {
          onClick: onCancel,
          text: t("confirm-delete-dialog.cancel-button.text")
        },
        confirmButton: showConfirmButton ? {
          text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }),
          onClick: onConfirm
        } : void 0
      },
      onClose: onCancel,
      onClickOutside: onCancel,
      children: (0, import_jsx_runtime.jsx)(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? (0, import_jsx_runtime.jsx)(
        ConfirmDeleteDialogBody,
        {
          crossDatasetReferences,
          internalReferences,
          documentTitle,
          isLoading,
          totalCount,
          action,
          projectIds,
          datasetNames,
          hasUnknownDatasetNames,
          onReferenceLinkClick: onCancel
        }
      ) : (0, import_jsx_runtime.jsx)(LoadingContainer, { "data-testid": "loading-container", children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t("confirm-delete-dialog.loading.text") }) }) })
    }
  );
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = useTranslation2(structureLocaleNamespace), id = (0, import_react2.useId)(), [error, setError] = (0, import_react2.useState)(null), handleRetry = (0, import_react2.useCallback)(() => setError(null), []);
  return error ? (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      id: `dialog-error-${id}`,
      "data-testid": "confirm-delete-error-dialog",
      header: t("confirm-delete-dialog.error.title.text"),
      footer: {
        confirmButton: {
          text: t("confirm-delete-dialog.error.retry-button.text"),
          onClick: handleRetry,
          tone: "default"
        }
      },
      onClose: props.onCancel,
      children: (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) })
    }
  ) : (0, import_jsx_runtime.jsx)(ErrorBoundary, { onCatch: setError, children: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialog, { ...props }) });
}
function Delay({
  children,
  ms = 0
}) {
  const [ready, setReady] = (0, import_react2.useState)(ms <= 0);
  return (0, import_react2.useEffect)(() => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]), !ready || !children ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}) : typeof children == "function" ? children() : children;
}
var PANE_DEBUG = false;
var PANE_COLLAPSED_WIDTH = 51;
var PANE_DEFAULT_MIN_WIDTH = 204;
var PaneContext = (0, import_react2.createContext)(null);
var Root$g = ut(Layer)`
  position: relative;
  width: 1px;
  min-width: 1px;

  &:before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--card-border-color);
  }

  &:not([data-disabled]) {
    cursor: ew-resize;
    width: 9px;
    min-width: 9px;
    margin: 0 -4px;

    &:before {
      left: 4px;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    &[data-dragging]:after,
    &:hover:after {
      opacity: 0.2;
    }
  }
`;
function PaneDivider({
  disabled,
  element
}) {
  const { resize } = usePaneLayout(), [dragging, setDragging] = (0, import_react2.useState)(false), handleMouseDown = (0, import_react2.useCallback)(
    (event) => {
      if (!element)
        return;
      setDragging(true), event.preventDefault();
      const startX = event.pageX;
      resize("start", element, 0);
      const handleMouseMove = (e2) => {
        e2.preventDefault();
        const deltaX = e2.pageX - startX;
        resize("move", element, deltaX);
      }, handleMouseUp = (e2) => {
        e2.preventDefault(), setDragging(false), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [element, resize]
  );
  return (0, import_jsx_runtime.jsx)(
    Root$g,
    {
      "data-disabled": disabled ? "" : void 0,
      "data-dragging": dragging ? "" : void 0,
      onMouseDown: handleMouseDown
    }
  );
}
var Root$f = ut(Card)`
  outline: none;

  // NOTE: This will render a border to the right side of each pane
  // without taking up physical space.
  box-shadow: 1px 0 0 var(--card-border-color);
`;
var Pane = (0, import_react2.forwardRef)(function(props, ref) {
  var _a, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = false,
    ...restProps
  } = props, [rootElement, setRootElement] = (0, import_react2.useState)(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout(), pane = panes.find((p) => p.element === rootElement), paneIndex = pane && panes.indexOf(pane), nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false, nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false, forwardedRef = useForwardedRef(ref), flex = (_a = pane == null ? void 0 : pane.flex) != null ? _a : flexProp, currentMinWidth = (_b = pane == null ? void 0 : pane.currentMinWidth) != null ? _b : currentMinWidthProp, currentMaxWidth = (_c = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c : currentMaxWidthProp, setRef = (0, import_react2.useCallback)(
    (refValue) => {
      setRootElement(refValue), forwardedRef.current = refValue;
    },
    [forwardedRef]
  );
  (0, import_react2.useEffect)(() => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, [
    currentMinWidthProp,
    currentMaxWidthProp,
    flexProp,
    id,
    minWidthProp,
    maxWidthProp,
    mount,
    rootElement
  ]);
  const handleCollapse = (0, import_react2.useCallback)(() => {
    rootElement && collapse(rootElement);
  }, [collapse, rootElement]), handleExpand = (0, import_react2.useCallback)(() => {
    rootElement && expand(rootElement);
  }, [expand, rootElement]), contextValue = (0, import_react2.useMemo)(
    () => ({
      collapse: handleCollapse,
      collapsed: layoutCollapsed ? false : collapsed,
      expand: handleExpand,
      index: paneIndex,
      isLast,
      rootElement
    }),
    [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]
  ), minWidth = (0, import_react2.useMemo)(() => {
    if (!layoutCollapsed)
      return collapsed ? PANE_COLLAPSED_WIDTH : currentMinWidth === 0 || isLast ? minWidthProp || PANE_DEFAULT_MIN_WIDTH : currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]), maxWidth = (0, import_react2.useMemo)(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (!(layoutCollapsed && isLast))
      return isLast ? maxWidthProp ? currentMaxWidth != null ? currentMaxWidth : maxWidthProp : void 0 : currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]), hidden = layoutCollapsed && !isLast, divider = (0, import_react2.useMemo)(
    () => !isLast && !layoutCollapsed && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneResizer", children: (0, import_jsx_runtime.jsx)(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }),
    [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]
  ), style = (0, import_react2.useMemo)(
    () => ({
      flex,
      minWidth,
      maxWidth: maxWidth === 1 / 0 ? void 0 : maxWidth
    }),
    [flex, minWidth, maxWidth]
  );
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "pane", children: (0, import_jsx_runtime.jsx)(PaneContext.Provider, { value: contextValue, children: (0, import_jsx_runtime.jsxs)(
      Root$f,
      {
        "data-testid": "pane",
        "data-ui": "Pane",
        tone: "inherit",
        hidden,
        id,
        overflow: layoutCollapsed ? void 0 : "hidden",
        ...restProps,
        "data-pane-collapsed": collapsed ? "" : void 0,
        "data-pane-index": paneIndex,
        "data-pane-selected": selected ? "" : void 0,
        ref: setRef,
        style,
        children: [
          PANE_DEBUG,
          (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: rootElement, children: !hidden && (0, import_jsx_runtime.jsx)(Flex, { direction: "column", height: "fill", children }) })
        ]
      }
    ) }) }),
    divider
  ] });
});
var Root$e = ut(Card)`
  position: relative;
  outline: none;
`;
Root$e.displayName = "PaneContent__root";
function usePane() {
  const pane = (0, import_react2.useContext)(PaneContext);
  if (!pane)
    throw new Error("Pane: missing context value");
  return pane;
}
var PaneContent = (0, import_react2.forwardRef)(function(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props, { collapsed } = usePane(), { collapsed: layoutCollapsed } = usePaneLayout();
  return (0, import_jsx_runtime.jsx)(
    Root$e,
    {
      "data-testid": "pane-content",
      forwardedAs: as,
      ...restProps,
      flex: 1,
      hidden: collapsed,
      overflow: layoutCollapsed ? void 0 : overflow,
      padding,
      ref,
      tone: "inherit",
      children
    }
  );
});
var MENU_GROUP_POPOVER_PROPS = {
  constrainSize: true,
  placement: "left-start",
  portal: true
};
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props, getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider")
    return (0, import_jsx_runtime.jsx)(MenuDivider, {});
  const { title } = getI18nText(node);
  return node.type === "group" ? node.children.length === 0 ? null : node.expanded ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}),
    node.children.map((child, childIndex) => {
      var _a;
      return (0, import_jsx_runtime.jsx)(
        PaneMenuButtonItem,
        {
          disabled: disabled || !!node.disabled,
          isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
          node: child
        },
        child.key
      );
    })
  ] }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}),
    (0, import_jsx_runtime.jsx)(
      MenuGroup,
      {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return (0, import_jsx_runtime.jsx)(
            PaneMenuButtonItem,
            {
              disabled: disabled || !!node.disabled,
              isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
              node: child
            },
            child.key
          );
        })
      }
    )
  ] }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}),
    (0, import_jsx_runtime.jsx)(PaneContextMenuItemResolver, { disabled, node })
  ] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  return node.intent ? (0, import_jsx_runtime.jsx)(PaneContextIntentMenuItem, { ...props, intent: node.intent }) : (0, import_jsx_runtime.jsx)(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a;
  const { disabled, node } = props, tooltipContent = typeof node.disabled == "object" && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: node.disabled.reason }), { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime.jsx)(
    MenuItem2,
    {
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const { disabled, intent, node } = props, tooltipContent = typeof node.disabled == "object" && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: node.disabled.reason }), intentLink = useIntentLink({ intent: intent.type, params: intent.params }), handleClick = (0, import_react2.useCallback)(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime.jsx)(
    MenuItem2,
    {
      as: "a",
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
var CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const { nodes, actionsNodes } = props, id = (0, import_react2.useId)(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution");
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(
        ContextMenuButton,
        {
          tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0,
          "data-testid": "pane-context-menu-button"
        }
      ),
      id,
      menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [
        actionsNodes && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
          actionsNodes,
          (0, import_jsx_runtime.jsx)(MenuDivider, {})
        ] }),
        nodes.map((node, nodeIndex) => {
          var _a;
          const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
          return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
        })
      ] }),
      popover: CONTEXT_MENU_POPOVER_PROPS
    }
  );
}
var Root$d = ut(Layer)`
  position: sticky;
  bottom: 0;

  &:before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-bottom: 1px solid var(--card-border-color);
  }
`;
var RootCard$2 = ut(Card)`
  padding-bottom: env(safe-area-inset-bottom);
`;
var PaneFooter = (0, import_react2.forwardRef)(function(props, ref) {
  const { children, padding } = props, { collapsed } = usePane();
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(Root$d, { "data-testid": "pane-footer", hidden: collapsed, ref, children: (0, import_jsx_runtime.jsx)(RootCard$2, { tone: "inherit", children: (0, import_jsx_runtime.jsx)(Box, { padding, children }) }) }) });
});
var Root$c = ut(Layer)(({ $border }) => at`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `);
var Layout = ut(Flex)`
  transform-origin: calc(51px / 2);

  [data-collapsed] > div > & {
    transform: rotate(90deg);
  }
`;
var TitleCard = ut(Card)(({ theme }) => {
  const { fg, bg } = theme.sanity.color.card.enabled;
  return at`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
});
var TitleTextSkeleton = ut(TextSkeleton)`
  width: 66%;
  max-width: 175px;
`;
var TitleText = ut(Text)`
  cursor: default;
  outline: none;
`;
var TabsBox = ut(Box)(({ theme }) => {
  const { color, space } = theme.sanity;
  return at`
    overflow: hidden;
    overflow: clip;
    position: relative;

    & > div {
      white-space: nowrap;
      overflow: auto;
      /* Hide scrollbars */
      scrollbar-width: none;
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    /* right padding */
    & > div:after {
      content: '';
      display: inline-block;
      top: 0;
      right: 0;
      bottom: 0;
      width: ${space[3]}px;
      height: 1px;
    }

    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */
    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to right, ${rgba(color.base.bg, 0)}, var(--card-bg-color));
      width: ${space[3]}px;
      pointer-events: none;
    }
  `;
});
var PaneHeader = (0, import_react2.forwardRef)(function(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props, { collapse, collapsed, expand, rootElement: paneElement } = usePane(), paneRect = useElementRect(paneElement || null), layoutStyle = (0, import_react2.useMemo)(
    () => ({
      width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
    }),
    [collapsed, paneRect]
  ), handleTitleClick = (0, import_react2.useCallback)(() => {
    collapsed || collapse();
  }, [collapse, collapsed]), handleLayoutClick = (0, import_react2.useCallback)(() => {
    collapsed && expand();
  }, [collapsed, expand]);
  return (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime.jsx)(
    Root$c,
    {
      $border: border,
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: (0, import_jsx_runtime.jsxs)(Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [
        (0, import_jsx_runtime.jsxs)(
          Layout,
          {
            gap: 1,
            onClick: handleLayoutClick,
            padding: 3,
            paddingBottom: collapsed ? 3 : 2,
            sizing: "border",
            style: layoutStyle,
            children: [
              backButton && (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: backButton }),
              (0, import_jsx_runtime.jsxs)(
                TitleCard,
                {
                  __unstable_focusRing: true,
                  flex: 1,
                  forwardedAs: "button",
                  onClick: handleTitleClick,
                  paddingLeft: backButton ? 1 : 2,
                  padding: 2,
                  tabIndex,
                  children: [
                    loading && (0, import_jsx_runtime.jsx)(TitleTextSkeleton, { animated: true, radius: 1, size: 1 }),
                    !loading && (0, import_jsx_runtime.jsx)(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })
                  ]
                }
              ),
              actions && (0, import_jsx_runtime.jsx)(Flex, { align: "center", hidden: collapsed, children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })
            ]
          }
        ),
        !!(!collapsed && (tabs || subActions)) && (0, import_jsx_runtime.jsxs)(
          Flex,
          {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            children: [
              (0, import_jsx_runtime.jsx)(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
              subActions && subActions
            ]
          }
        ),
        !collapsed && contentAfter && contentAfter
      ] }) })
    }
  ) });
});
function getDisabledReason$1(node) {
  var _a;
  if (!node.disabled)
    return { disabledReason: void 0, ariaLabel: void 0, isDisabled: false };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof ((_a = node.disabled) == null ? void 0 : _a.reason) == "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: !!node.disabled };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  return node.type === "item" ? (0, import_jsx_runtime.jsx)(PaneHeaderMenuItemActionButton, { node }) : node.type === "group" ? (0, import_jsx_runtime.jsx)(PaneHeaderMenuGroupActionButton, { node }) : (console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null);
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props, { title } = useI18nText(node);
  if (node.intent)
    return (0, import_jsx_runtime.jsx)(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime.jsx)(
    StatusButton,
    {
      disabled: isDisabled,
      icon: node.icon,
      onClick: node.onAction,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : title
      }
    }
  );
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props, intentLink = useIntentLink({ intent: intent.type, params: intent.params }), handleClick = (0, import_react2.useCallback)(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime.jsx)(
    StatusButton,
    {
      forwardedAs: "a",
      disabled: isDisabled,
      href: intentLink.href,
      icon: node.icon,
      onClick: handleClick,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : node.title,
        placement: "bottom",
        portal: true
      }
    }
  );
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const { node } = props, { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          disabled: !!node.disabled,
          icon: (_a = node.icon) != null ? _a : UnknownIcon,
          label: title,
          mode: "bleed",
          tooltipProps: { content: node.title, portal: true }
        }
      ),
      id: (0, import_react2.useId)(),
      menu: (0, import_jsx_runtime.jsx)(Menu, { children: node.children.map((child, idx) => {
        var _a2;
        return (0, import_jsx_runtime.jsx)(
          PaneMenuButtonItem,
          {
            disabled: !!node.disabled,
            isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          },
          child.key
        );
      }) })
    }
  );
}
var Root$b = ut(Card)`
  transition: opacity 200ms;
  position: relative;
  z-index: 1;
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  opacity: 0;

  &:not([hidden]) {
    display: flex;
  }

  &:not([data-collapsed]) {
    overflow: auto;
  }

  &[data-mounted] {
    opacity: 1;
  }

  &[data-resizing] {
    pointer-events: none;
  }
`;
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH, rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum.width * sum.flex, rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e2 = el;
  for (; e2 !== rootElement; ) {
    const parentElement = e2.parentElement;
    if (!parentElement)
      return path;
    const index = Array.from(parentElement.childNodes).indexOf(e2);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e2 = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map2.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, { ...options, original: options }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = true, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(
          cache,
          leftOptions,
          rightOptions,
          deltaX
        );
        resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW }), resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW }), _notifyObservers();
      }
      if (type === "end") {
        resizing = false;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : 1 / 0,
          flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : 1 / 0,
          flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? false : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props, controller = (0, import_react2.useMemo)(() => createPaneLayoutController(), []), [rootElement, setRootElement] = (0, import_react2.useState)(null), rootRect = useElementRect(rootElement), width = (rootRect == null ? void 0 : rootRect.width) || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth, [state2, setState] = (0, import_react2.useState)({
    expandedElement: null,
    panes: [],
    resizing: false
  });
  (0, import_react2.useEffect)(() => controller.setRootElement(rootElement), [controller, rootElement]), (0, import_react2.useEffect)(() => controller.setRootWidth(width), [controller, width]), (0, import_react2.useEffect)(() => controller.subscribe(setState), [controller]), (0, import_react2.useEffect)(() => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = (0, import_react2.useMemo)(
    () => ({
      collapse: controller.collapse,
      collapsed,
      expand: controller.expand,
      expandedElement: state2.expandedElement,
      mount: controller.mount,
      panes: state2.panes,
      resize: controller.resize,
      resizing: state2.resizing
    }),
    [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]
  );
  return (0, import_jsx_runtime.jsx)(PaneLayoutContext.Provider, { value: paneLayout, children: (0, import_jsx_runtime.jsx)(
    Root$b,
    {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state2.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    }
  ) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
var isNotMenuNodeButton = (0, import_negate.default)(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const { fieldActions = [], menuItems, menuItemGroups } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: true,
      renderAsButton: false,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      expanded: true,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: false
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_a = item.showAsAction) != null ? _a : false,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_b = item.showAsAction) != null ? _b : false,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map(
      (child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)
    ),
    disabled: a.disabled,
    expanded: (_a = a.expanded) != null ? _a : true,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: (_b = a.renderAsButton) != null ? _b : false
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : false,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
var IntentButton = (0, import_react2.forwardRef)(function(props, ref) {
  const { intent, ...restProps } = props, Link2 = (0, import_react2.useMemo)(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      (0, import_react2.forwardRef)(function(linkProps, linkRef) {
        return (0, import_jsx_runtime.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
      })
    ),
    [intent]
  );
  return props.disabled ? (0, import_jsx_runtime.jsx)(Button2, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : (0, import_jsx_runtime.jsx)(
    Button2,
    {
      ...restProps,
      as: Link2,
      "data-as": "a",
      ref
    }
  );
});
function InsufficientPermissionsMessageTooltip({
  reveal,
  context,
  loading,
  children
}) {
  const currentUser = useCurrentUser(), { t } = useTranslation2(structureLocaleNamespace);
  return reveal ? (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context, currentUser }),
      portal: true,
      children: (0, import_jsx_runtime.jsx)("div", { children })
    }
  ) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
}
var POPOVER_PROPS$1 = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
var getIntent = (schema2, templates, item) => {
  var _a;
  const typeName = (_a = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName)
    return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton({ templateItems }) {
  const schema2 = useSchema(), templates = useTemplates(), { t } = useTranslation2(structureLocaleNamespace), getI18nText = useGetI18nText([...templateItems, ...templates]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), nothingGranted = (0, import_react2.useMemo)(() => !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted)), [isTemplatePermissionsLoading, templatePermissions]), permissionsById = (0, import_react2.useMemo)(() => templatePermissions ? templatePermissions.reduce(
    (acc, permission) => (acc[permission.id] = permission, acc),
    {}
  ) : {}, [templatePermissions]);
  if (nothingGranted)
    return (0, import_jsx_runtime.jsx)(
      InsufficientPermissionsMessageTooltip,
      {
        context: "create-document-type",
        reveal: true,
        loading: isTemplatePermissionsLoading,
        children: (0, import_jsx_runtime.jsx)(
          Button2,
          {
            "aria-label": t("pane-header.disabled-created-button.aria-label"),
            icon: AddIcon,
            "data-testid": "action-intent-button",
            disabled: true,
            mode: "bleed",
            tooltipProps: null
          }
        )
      }
    );
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], permissions = permissionsById[firstItem.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, firstItem);
    return intent ? (0, import_jsx_runtime.jsx)(
      InsufficientPermissionsMessageTooltip,
      {
        reveal: disabled,
        loading: isTemplatePermissionsLoading,
        context: "create-document-type",
        children: (0, import_jsx_runtime.jsx)(
          IntentButton,
          {
            "aria-label": getI18nText(firstItem).title,
            icon: firstItem.icon || AddIcon,
            intent,
            mode: "bleed",
            disabled,
            "data-testid": "action-intent-button",
            tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") }
          }
        )
      }
    ) : null;
  }
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          icon: AddIcon,
          mode: "bleed",
          "data-testid": "multi-action-intent-button",
          tooltipProps: { content: t("pane-header.create-new-button.tooltip") }
        }
      ),
      id: "create-menu",
      menu: (0, import_jsx_runtime.jsx)(Menu, { children: templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, item), template2 = templates.find((i) => i.id === item.templateId);
        if (!template2 || !intent)
          return null;
        const Link2 = (0, import_react2.forwardRef)(
          (linkProps, linkRef) => disabled ? (0, import_jsx_runtime.jsx)("button", { type: "button", disabled: true, ...linkProps, ref: linkRef }) : (0, import_jsx_runtime.jsx)(
            IntentLink,
            {
              ...linkProps,
              intent: intent.type,
              params: intent.params,
              ref: linkRef
            }
          )
        );
        Link2.displayName = "Link";
        const { title } = getI18nText({
          ...item,
          // replace the title with the template title
          title: item.title || getI18nText(template2).title
        });
        return (0, import_jsx_runtime.jsx)(
          InsufficientPermissionsMessageTooltip,
          {
            context: "create-document-type",
            reveal: disabled,
            loading: isTemplatePermissionsLoading,
            children: (0, import_jsx_runtime.jsx)(
              MenuItem2,
              {
                as: Link2,
                "data-as": disabled ? "button" : "a",
                text: title,
                "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title,
                disabled,
                "data-testid": `action-intent-button-${itemIndex}`
              }
            )
          },
          item.id
        );
      }) }),
      popover: POPOVER_PROPS$1
    }
  );
}
function isNonNullable(value) {
  return value != null;
}
var hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
};
var PaneHeaderActions = (0, import_react2.memo)(function(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$b,
    menuItems = EMPTY_ARRAY$b,
    menuItemGroups = EMPTY_ARRAY$b,
    actionHandlers = EMPTY_OBJECT
  } = props, templates = useTemplates(), handleAction = (0, import_react2.useCallback)(
    (item) => {
      if (typeof item.action == "string" && !(item.action in actionHandlers))
        return console.warn("No handler for action:", item.action), false;
      const handler = (
        // eslint-disable-next-line no-nested-ternary
        typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null
      );
      return handler ? (handler(item.params), true) : false;
    },
    [actionHandlers]
  ), menuNodes = (0, import_react2.useMemo)(
    () => resolveMenuNodes({
      actionHandler: handleAction,
      menuItemGroups,
      menuItems: menuItems.filter((item) => {
        var _a;
        return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
      })
    }),
    [handleAction, menuItemGroups, menuItems]
  ), actionNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), initialValueTemplateItemFromMenuItems = (0, import_react2.useMemo)(() => menuItems.map((item, menuItemIndex) => {
    var _a;
    if (((_a = item.intent) == null ? void 0 : _a.type) !== "create")
      return null;
    const { params } = item.intent;
    if (!params)
      return null;
    const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
    if (!templateId)
      return null;
    const template2 = templates.find((t) => t.id === templateId);
    if (!template2)
      return null;
    const initialDocumentId = intentParams.id;
    return {
      item,
      template: template2,
      templateParams,
      menuItemIndex,
      initialDocumentId
    };
  }).filter(isNonNullable).map(({ initialDocumentId, item, template: template2, menuItemIndex, templateParams }) => ({
    id: `menuItem${menuItemIndex}`,
    initialDocumentId,
    templateId: template2.id,
    type: "initialValueTemplateItem",
    title: item.title || template2.title,
    i18n: item.i18n || template2.i18n,
    icon: item.icon,
    description: template2.description,
    parameters: templateParams,
    schemaType: template2.schemaType
  })), [menuItems, templates]), combinedInitialValueTemplates = (0, import_react2.useMemo)(() => (0, import_uniqBy.default)(
    [...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure],
    (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters])
  ), [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [
    combinedInitialValueTemplates.length > 0 && (0, import_jsx_runtime.jsx)(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }),
    actionNodes.map((node) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, { node }, node.key)),
    contextMenuNodes.length > 0 && (0, import_jsx_runtime.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes })
  ] });
});
function MissingSchemaType(props) {
  const { t } = useTranslation2(structureLocaleNamespace), { layout, value } = props;
  return (0, import_jsx_runtime.jsx)(
    SanityDefaultPreview,
    {
      title: (0, import_jsx_runtime.jsx)("em", { children: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.title",
          components: { Code: "code" },
          values: { documentType: value._type }
        }
      ) }),
      subtitle: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.subtitle",
          components: { Code: "code" },
          values: { documentId: value._id }
        }
      ),
      media: () => (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {}),
      layout
    }
  );
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === false ? false : icon || schemaType && schemaType.icon || defaultIcon || false;
}
function PaneItem(props) {
  const {
    icon,
    id,
    layout = "default",
    pressed,
    schemaType,
    selected,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, schema2 = useSchema(), documentPreviewStore = useDocumentPreviewStore(), { ChildLink: ChildLink2 } = usePaneRouter(), documentPresence = useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema2.get(schemaType.name)), [clicked, setClicked] = (0, import_react2.useState)(false), preview = (0, import_react2.useMemo)(() => value && isSanityDocument(value) ? !schemaType || !hasSchemaType ? (0, import_jsx_runtime.jsx)(MissingSchemaType, { value }) : (0, import_jsx_runtime.jsx)(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: getIconWithFallback(icon, schemaType, DocumentIcon),
      layout,
      schemaType,
      value,
      presence: documentPresence
    }
  ) : (0, import_jsx_runtime.jsx)(
    SanityDefaultPreview,
    {
      status: (0, import_jsx_runtime.jsx)(Box, { style: { opacity: 0.5 }, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}) }) }),
      icon: getIconWithFallback(icon, schemaType, FolderIcon),
      layout: "compact",
      title
    }
  ), [
    documentPreviewStore,
    hasSchemaType,
    icon,
    layout,
    schemaType,
    title,
    value,
    documentPresence
  ]), Link2 = (0, import_react2.useMemo)(
    () => function(linkProps) {
      return (0, import_jsx_runtime.jsx)(ChildLink2, { ...linkProps, childId: id });
    },
    [ChildLink2, id]
  ), handleClick = (0, import_react2.useCallback)((e2) => {
    if (e2.metaKey) {
      setClicked(false);
      return;
    }
    setClicked(true);
  }, []);
  return (0, import_react2.useEffect)(() => setClicked(false), [selected]), (0, import_jsx_runtime.jsx)(
    PreviewCard,
    {
      __unstable_focusRing: true,
      as: Link2,
      "data-as": "a",
      margin,
      marginBottom,
      marginTop,
      onClick: handleClick,
      pressed,
      radius: 2,
      selected: selected || clicked,
      sizing: "border",
      tabIndex: -1,
      tone: "inherit",
      children: preview
    }
  );
}
var RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete, group } = props;
  return (0, import_jsx_runtime.jsx)(
    GetHookCollectionState,
    {
      onReset: onActionComplete,
      hooks: actions,
      args: actionProps,
      group,
      children
    }
  );
};
var RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return (0, import_jsx_runtime.jsx)(GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function useNotificationTarget(opts) {
  const { documentId, documentType } = opts || {}, schemaType = useSchema().get(documentType), { title: workspaceTitle } = useWorkspace(), { createPathWithParams, params } = usePaneRouter(), documentPreviewStore = useDocumentPreviewStore(), previewState = useMemoObservable(() => !documentId || !schemaType ? of(null) : getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  return {
    getNotificationValue: (0, import_react2.useCallback)(
      ({ commentId }) => {
        const path = createPathWithParams({
          ...params,
          comment: commentId,
          inspect: COMMENTS_INSPECTOR_NAME
        }), url = `${window.location.origin}${path}`;
        return { documentTitle, url, workspaceTitle };
      },
      [createPathWithParams, documentTitle, params, workspaceTitle]
    )
  };
}
async function createOperation(props) {
  const {
    activeTool,
    client,
    comment,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getIntent: getIntent2,
    getNotificationValue,
    getThreadLength,
    onCreate,
    onCreateError,
    projectId,
    createAddonDataset,
    workspace
  } = props, commentId = (comment == null ? void 0 : comment.id) || v4_default(), authorId = currentUser.id, currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
  let nextComment;
  if (comment.type === "task" && (nextComment = {
    _id: commentId,
    _type: "comment",
    authorId,
    message: comment.message,
    lastEditedAt: void 0,
    parentCommentId: comment.parentCommentId,
    status: comment.status,
    threadId: comment.threadId,
    reactions: comment.reactions,
    context: {
      payload: {
        workspace
      },
      notification: comment.context.notification,
      tool: (activeTool == null ? void 0 : activeTool.name) || ""
    },
    target: {
      document: {
        _ref: documentId,
        _type: "reference",
        _weak: true
      },
      documentType
    }
  }), comment.type === "field") {
    const {
      documentTitle = "",
      url = "",
      workspaceTitle = ""
    } = getNotificationValue({ commentId }) || {}, notification = {
      currentThreadLength,
      documentTitle,
      url,
      workspaceTitle
    }, intent = getIntent2 == null ? void 0 : getIntent2({ id: documentId, type: documentType, path: comment.fieldPath });
    nextComment = {
      _id: commentId,
      _type: "comment",
      authorId,
      message: comment.message,
      lastEditedAt: void 0,
      parentCommentId: comment.parentCommentId,
      status: comment.status,
      threadId: comment.threadId,
      reactions: comment.reactions,
      context: {
        payload: {
          workspace
        },
        intent,
        notification,
        tool: (activeTool == null ? void 0 : activeTool.name) || ""
      },
      contentSnapshot: comment.contentSnapshot,
      target: {
        documentRevisionId: documentRevisionId || "",
        path: {
          field: comment.fieldPath,
          selection: comment.selection
        },
        document: {
          _dataset: dataset,
          _projectId: projectId,
          _ref: documentId,
          _type: "crossDatasetReference",
          _weak: true
        },
        documentType
      }
    };
  }
  if (nextComment) {
    if (onCreate == null || onCreate(nextComment), !client) {
      try {
        const newAddonClient = await createAddonDataset();
        if (!newAddonClient)
          throw new Error("Failed to create addon dataset client");
        await newAddonClient.create(nextComment);
      } catch (err) {
        throw onCreateError == null || onCreateError(nextComment._id, err), err;
      }
      return;
    }
    try {
      await client.create(nextComment);
    } catch (err) {
      throw onCreateError == null || onCreateError(nextComment._id, err), err;
    }
  }
}
function createReactionKey(userId, shortName) {
  return `${userId}-${shortName}`;
}
async function reactOperation(props) {
  var _a;
  const { client, currentUser, id, reaction, getComment, onUpdate } = props, reactions = ((_a = getComment == null ? void 0 : getComment(id)) == null ? void 0 : _a.reactions) || [], currentUserReactions = reactions.filter((r) => r.userId === currentUser.id), _key = createReactionKey(currentUser.id, reaction.shortName), currentReaction = currentUserReactions.find(
    (r) => r._key === _key && r._optimisticState !== "removed"
  );
  if (currentReaction) {
    const next = reactions.map((r) => r._key === currentReaction._key ? { ...r, _optimisticState: "removed" } : r);
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).unset([`reactions[_key=="${_key}"]`]).commit();
    return;
  }
  if (!currentReaction) {
    const reactionItem = {
      _key,
      addedAt: (/* @__PURE__ */ new Date()).toISOString(),
      shortName: reaction.shortName,
      userId: currentUser.id
    }, optimisticReactionItem = { ...reactionItem, _optimisticState: "added" }, next = reactions.concat(optimisticReactionItem).filter((r) => !(r._key === reactionItem._key && r._optimisticState === "removed"));
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).setIfMissing({ reactions: [] }).append("reactions", [reactionItem]).commit();
  }
}
async function removeOperation(props) {
  const { client, id, onRemove } = props;
  onRemove == null || onRemove(id), await Promise.all([
    client.delete({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }),
    client.delete(id)
  ]);
}
var THROTTLE_TIME_MS = 1e3;
var THROTTLE_SETTINGS = {
  trailing: true,
  leading: false
};
var throttleFunctionsMap = /* @__PURE__ */ new Map();
function getThrottledFunction(id) {
  if (!throttleFunctionsMap.has(id)) {
    const throttledFunction = (0, import_throttle2.default)(postCommentUpdate, THROTTLE_TIME_MS, THROTTLE_SETTINGS);
    return throttleFunctionsMap.set(id, throttledFunction), throttledFunction;
  }
  return throttleFunctionsMap.get(id);
}
async function postCommentUpdate(props) {
  const { client, id, comment, transactionId: transactionIdProp, onUpdate } = props, transactionId = transactionIdProp || v4_default(), patch = client == null ? void 0 : client.patch(id).set(comment), transaction = client.transaction().transactionId(transactionId).patch(patch);
  onUpdate == null || onUpdate(id, comment), comment.status ? (await transaction.commit(), await client.patch({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }).set({
    status: comment.status
  }).commit()) : await transaction.commit(), throttleFunctionsMap.delete(id);
}
async function updateOperation(props) {
  const { id, comment, throttled: throttledProp } = props, hasEditedMessage = "message" in comment, editedComment = {
    ...comment,
    lastEditedAt: (/* @__PURE__ */ new Date()).toISOString()
  }, nextComment = hasEditedMessage ? editedComment : comment;
  if (!throttledProp) {
    await postCommentUpdate({
      ...props,
      comment: nextComment
    });
    return;
  }
  await getThrottledFunction(id)({
    ...props,
    comment: nextComment
  });
}
function useCommentOperations(opts) {
  const {
    client,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getComment,
    getThreadLength,
    onCreate,
    onCreateError,
    onRemove,
    onTransactionStart,
    onUpdate,
    projectId,
    createAddonDataset,
    workspace
  } = opts, getIntent2 = useCommentsIntent(), activeToolName = useRouterState(
    (0, import_react2.useCallback)(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), tools = useTools(), activeTool = (0, import_react2.useMemo)(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), { getNotificationValue } = useNotificationTarget({ documentId, documentType }), handleCreate = (0, import_react2.useCallback)(
    async (comment) => {
      currentUser != null && currentUser.id && await createOperation({
        activeTool,
        client,
        comment,
        currentUser,
        dataset,
        documentId,
        documentRevisionId,
        documentType,
        getIntent: getIntent2,
        getNotificationValue,
        getThreadLength,
        onCreate,
        onCreateError,
        projectId,
        createAddonDataset,
        workspace
      });
    },
    [
      activeTool,
      client,
      currentUser,
      dataset,
      documentId,
      documentRevisionId,
      documentType,
      getIntent2,
      getNotificationValue,
      getThreadLength,
      onCreate,
      onCreateError,
      projectId,
      createAddonDataset,
      workspace
    ]
  ), handleRemove = (0, import_react2.useCallback)(
    async (id) => {
      client && await removeOperation({
        client,
        id,
        onRemove
      });
    },
    [client, onRemove]
  ), handleUpdate = (0, import_react2.useCallback)(
    async (id, comment, updateOpts) => {
      if (!client)
        return;
      const { throttled } = updateOpts || {}, nextTransactionId = v4_default();
      onTransactionStart(id, nextTransactionId), await updateOperation({
        client,
        comment,
        throttled,
        id,
        onUpdate,
        transactionId: nextTransactionId
      });
    },
    [client, onTransactionStart, onUpdate]
  ), handleReact = (0, import_react2.useCallback)(
    async (id, reaction) => {
      !client || !(currentUser != null && currentUser.id) || await reactOperation({
        client,
        currentUser,
        id,
        reaction,
        getComment,
        onUpdate
      });
    },
    [client, currentUser, getComment, onUpdate]
  );
  return (0, import_react2.useMemo)(
    () => ({
      operation: {
        create: handleCreate,
        react: handleReact,
        remove: handleRemove,
        update: handleUpdate
      }
    }),
    [handleCreate, handleRemove, handleUpdate, handleReact]
  );
}
function useComments() {
  const value = (0, import_react2.useContext)(CommentsContext);
  if (!value)
    throw new Error("useComments must be used within a CommentsProvider");
  return value;
}
function useCommentsAuthoringPath() {
  const value = (0, import_react2.useContext)(CommentsAuthoringPathContext);
  if (!value)
    throw new Error("useCommentsAuthoringPath: missing context value");
  return value;
}
function useCommentsEnabled() {
  const ctx = (0, import_react2.useContext)(CommentsEnabledContext);
  if (ctx === null)
    throw new Error("useCommentsEnabled: missing context value");
  return ctx;
}
function useCommentsOnboarding() {
  const ctx = (0, import_react2.useContext)(CommentsOnboardingContext);
  if (!ctx)
    throw new Error("useCommentsOnboarding: missing context value");
  return ctx;
}
var BASE_SCROLL_OPTIONS = {
  behavior: "smooth",
  inline: "center",
  scrollMode: "if-needed"
};
var GROUP_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "start"
};
var INLINE_COMMENT_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
};
var SCROLL_TO_FIELD_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
};
var SCROLL_TO_COMMENT_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
};
var SCROLL_OPTIONS_BY_TYPE = {
  comment: SCROLL_TO_COMMENT_OPTIONS,
  field: SCROLL_TO_FIELD_OPTIONS,
  group: GROUP_SCROLL_OPTIONS,
  "inline-comment": INLINE_COMMENT_SCROLL_OPTIONS
};
function generateValidAttrValue(id) {
  const symbolsToRemove = /[[\]_"_=.]/g;
  return id.replace(symbolsToRemove, "");
}
function applyCommentIdAttr(id) {
  return {
    "data-comments-comment-id": generateValidAttrValue(id)
  };
}
function applyCommentsFieldAttr(id) {
  return {
    "data-comments-field-id": generateValidAttrValue(id)
  };
}
function applyCommentsGroupAttr(id) {
  return {
    "data-comments-group-id": generateValidAttrValue(id)
  };
}
function applyInlineCommentIdAttr(id) {
  return {
    "data-comments-inline-comment-id": generateValidAttrValue(id)
  };
}
function useCommentsScroll(opts) {
  const { boundaryElement } = opts || {}, [scrollTarget, setScrollTarget] = (0, import_react2.useState)(null), scrollOpts = (0, import_react2.useMemo)(() => ({
    ...SCROLL_OPTIONS_BY_TYPE[(scrollTarget == null ? void 0 : scrollTarget.type) || "comment"],
    boundary: boundaryElement
  }), [boundaryElement, scrollTarget == null ? void 0 : scrollTarget.type]), handleScrollToComment = (0, import_react2.useCallback)((commentId) => {
    setScrollTarget({ type: "comment", id: commentId });
  }, []), handleScrollToGroup = (0, import_react2.useCallback)((threadId) => {
    setScrollTarget({ type: "group", id: threadId });
  }, []), handleScrollToField = (0, import_react2.useCallback)((fieldPath) => {
    setScrollTarget({ type: "field", id: fieldPath });
  }, []), handleScrollToInlineComment = (0, import_react2.useCallback)((commentId) => {
    setScrollTarget({ type: "inline-comment", id: commentId });
  }, []);
  return (0, import_react2.useEffect)(() => {
    const raf = requestAnimationFrame(() => {
      if (!scrollTarget)
        return;
      const { type, id } = scrollTarget, element = document == null ? void 0 : document.querySelector(
        `[data-comments-${type}-id="${generateValidAttrValue(id)}"]`
      );
      element && e(element, scrollOpts);
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [scrollOpts, scrollTarget]), (0, import_react2.useMemo)(
    () => ({
      scrollToComment: handleScrollToComment,
      scrollToField: handleScrollToField,
      scrollToGroup: handleScrollToGroup,
      scrollToInlineComment: handleScrollToInlineComment
    }),
    [handleScrollToComment, handleScrollToField, handleScrollToGroup, handleScrollToInlineComment]
  );
}
function useCommentsSelectedPath() {
  const ctx = (0, import_react2.useContext)(CommentsSelectedPathContext);
  if (!ctx)
    throw new Error("useCommentsSelectedPath: missing context value");
  return ctx;
}
function useCommentsUpsell() {
  return (0, import_react2.useContext)(CommentsUpsellContext) || {
    upsellData: null,
    handleOpenDialog: () => null,
    upsellDialogOpen: false,
    telemetryLogs: {
      dialogSecondaryClicked: () => null,
      dialogPrimaryClicked: () => null,
      panelViewed: () => null,
      panelDismissed: () => null,
      panelPrimaryClicked: () => null,
      panelSecondaryClicked: () => null
    }
  };
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading, error } = useFeatureEnabled("studioComments"), { enabled } = useSource().document.unstable_comments, enabledFromConfig = (0, import_react2.useMemo)(
    () => enabled({ documentType, documentId: getPublishedId(documentId) }),
    [documentId, documentType, enabled]
  );
  return (0, import_react2.useMemo)(() => isLoading || !enabledFromConfig || error ? { enabled: false, mode: null } : {
    enabled: true,
    mode: featureEnabled ? "default" : "upsell"
  }, [isLoading, enabledFromConfig, error, featureEnabled]);
}
var StyledAvatar = ut(Avatar)`
  svg > ellipse {
    stroke: transparent;
  }
`;
var SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu;
var WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function CommentsAvatar(props) {
  const { user: userProp, ...restProps } = props, user = userProp, initials = (0, import_react2.useMemo)(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  return user ? (0, import_jsx_runtime.jsx)(
    StyledAvatar,
    {
      initials,
      src: user == null ? void 0 : user.imageUrl,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  ) : (0, import_jsx_runtime.jsx)(StyledAvatar, { ...restProps });
}
var SpacerAvatar = ut.div((props) => {
  var _a;
  const theme = getTheme_v2(props.theme), { $size = 1 } = props;
  return at`
    min-width: ${(_a = theme.avatar.sizes[$size]) == null ? void 0 : _a.size}px;
  `;
});
var mentionObject = defineField({
  name: "mention",
  type: "object",
  fields: [
    {
      name: "userId",
      type: "string"
    }
  ]
});
var blockType = defineField({
  type: "block",
  name: "block",
  of: [mentionObject],
  marks: {
    annotations: []
  },
  styles: [{ title: "Normal", value: "normal" }],
  lists: []
});
var portableTextType = defineArrayMember({
  type: "array",
  name: "body",
  of: [blockType]
});
var schema = Schema2.compile({
  name: "comments",
  types: [portableTextType]
});
var editorSchemaType = schema.get("body");
var Span$1 = ut.span(({ theme }) => {
  var _a, _b, _c;
  const { regular } = ((_a = theme.sanity.fonts) == null ? void 0 : _a.text.weights) || {}, { hovered } = ((_b = theme.sanity.color) == null ? void 0 : _b.card) || {}, { bg } = ((_c = theme.sanity.color.selectable) == null ? void 0 : _c.caution.pressed) || {};
  return at`
    font-weight: ${regular};
    color: var(--card-link-fg-color);
    border-radius: 2px;
    background-color: ${hovered.bg};
    padding: 1px;
    box-sizing: border-box;

    &[data-active='true'] {
      background-color: ${bg};
    }
  `;
});
function MentionInlineBlock(props) {
  const { selected, userId } = props, [user, loading] = useUser(userId), currentUser = useCurrentUser();
  return !user || loading ? (0, import_jsx_runtime.jsx)(
    TextSkeleton,
    {
      "data-testid": "comment-mentions-loading-skeleton",
      style: { width: "10ch" },
      size: 0,
      muted: true,
      radius: 1,
      animated: true
    }
  ) : (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      portal: true,
      content: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(CommentsAvatar, { user }) }),
        (0, import_jsx_runtime.jsx)(Text, { size: 1, children: user.displayName })
      ] }),
      children: (0, import_jsx_runtime.jsxs)(Span$1, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: [
        "@",
        user.displayName
      ] })
    }
  );
}
var NormalText$1 = ut(Text)`
  word-break: break-word;
`;
function NormalBlock(props) {
  const { children } = props;
  return (0, import_jsx_runtime.jsx)(NormalText$1, { size: 1, children });
}
var renderBlock$1 = (blockProps) => {
  const { children } = blockProps;
  return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
};
var renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  return value._type === "mention" && value.userId ? (0, import_jsx_runtime.jsx)(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId }) : children;
};
var Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props) {
  const { t } = useTranslation2(commentsLocaleNamespace), { onClose, onConfirm } = props, handleCancelClick = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), onClose();
    },
    [onClose]
  ), handleConfirmClick = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), onConfirm();
    },
    [onConfirm]
  );
  return (0, import_jsx_runtime.jsx)(ThemeColorProvider, { tone: "default", children: (0, import_jsx_runtime.jsx)(DialogProvider, { zOffset: Z_OFFSET, children: (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      header: t("discard.header"),
      id: "discard-comment-dialog",
      onClose,
      width: 0,
      onClickOutside: onClose,
      footer: {
        cancelButton: {
          onClick: handleCancelClick
        },
        confirmButton: {
          onClick: handleConfirmClick,
          text: t("discard.button-confirm"),
          tone: "critical"
        }
      },
      children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("discard.text") })
    }
  ) }) });
}
var InnerFlex = ut(Flex)``;
var SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props) {
  const { user, onSelect } = props, [loadedUser] = useUser(user.id), { t } = useTranslation2(commentsLocaleNamespace), avatar = (0, import_jsx_runtime.jsx)(CommentsAvatar, { user: loadedUser, status: user.granted ? void 0 : "inactive" }), text = loadedUser ? (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 }), handleSelect = (0, import_react2.useCallback)(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return (0, import_jsx_runtime.jsx)(Card, { as: "button", disabled: !user.granted, onClick: handleSelect, padding: 2, radius: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
    (0, import_jsx_runtime.jsxs)(InnerFlex, { align: "center", gap: 2, flex: 1, children: [
      avatar,
      (0, import_jsx_runtime.jsx)(Box, { children: text })
    ] }),
    !user.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: t("mentions.unauthorized-user") })
  ] }) });
}
var EMPTY_ARRAY$f = [];
var Root$a = ut(Stack)({
  maxWidth: "220px"
  // todo: improve
});
var ITEM_HEIGHT = 41;
var LIST_PADDING = 4;
var MAX_ITEMS = 7;
var FlexWrap = ut(Flex)({
  maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2
});
var MentionsMenu$1 = React.forwardRef(function(props, ref) {
  const { t } = useTranslation2(commentsLocaleNamespace), { loading, onSelect, options = [], inputElement } = props, [searchTerm, setSearchTerm] = (0, import_react2.useState)(""), commandListRef = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(
    ref,
    () => ({
      setSearchTerm(term) {
        setSearchTerm(term);
      }
    }),
    []
  );
  const renderItem2 = (0, import_react2.useCallback)(
    (itemProps) => (0, import_jsx_runtime.jsx)(MentionsMenuItem, { user: itemProps, onSelect }),
    [onSelect]
  ), getItemDisabled = (0, import_react2.useCallback)(
    (index) => {
      var _a;
      return !((_a = options == null ? void 0 : options[index]) != null && _a.granted);
    },
    [options]
  ), filteredOptions = (0, import_react2.useMemo)(() => {
    var _a;
    if (!searchTerm)
      return options || EMPTY_ARRAY$f;
    const deburredSearchTerm = (0, import_deburr.default)(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      displayName: (0, import_deburr.default)(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a2;
      return (_a2 = option == null ? void 0 : option.displayName) == null ? void 0 : _a2.includes(deburredSearchTerm);
    })) == null ? void 0 : _a.sort((a, b) => {
      var _a2, _b;
      const matchA = (_a2 = a.displayName) == null ? void 0 : _a2.startsWith(deburredSearchTerm), matchB = (_b = b.displayName) == null ? void 0 : _b.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || EMPTY_ARRAY$f;
  }, [options, searchTerm]);
  if (loading)
    return (0, import_jsx_runtime.jsx)(Root$a, { children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) });
  const _inputElement = inputElement || void 0;
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [
    filteredOptions.length === 0 && (0, import_jsx_runtime.jsx)(Box, { padding: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: t("mentions.no-users-found") }) }),
    filteredOptions.length > 0 && (0, import_jsx_runtime.jsx)(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: (0, import_jsx_runtime.jsx)(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: t("mentions.user-list-aria-label"),
        fixedHeight: true,
        getItemDisabled,
        inputElement: _inputElement,
        itemHeight: 41,
        items: filteredOptions,
        padding: 1,
        ref: commandListRef,
        renderItem: renderItem2
      }
    ) })
  ] });
});
var CommentInputContext = import_react2.default.createContext(null);
function CommentInputProvider(props) {
  const {
    children,
    expandOnFocus = false,
    focused,
    focusOnMount = false,
    mentionOptions,
    onMentionMenuOpenChange,
    value,
    readOnly
  } = props, editor = usePortableTextEditor(), [mentionsMenuOpen, setMentionsMenuOpen] = (0, import_react2.useState)(false), [mentionsSearchTerm, setMentionsSearchTerm] = (0, import_react2.useState)(""), [selectionAtMentionInsert, setSelectionAtMentionInsert] = (0, import_react2.useState)(null), canSubmit = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), hasChanges = useCommentHasChanged(value), focusEditor = (0, import_react2.useCallback)(() => {
    readOnly || PortableTextEditor.focus(editor);
  }, [editor, readOnly]), closeMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(false), setMentionsSearchTerm(""), setSelectionAtMentionInsert(null);
  }, []), openMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true), setMentionsSearchTerm(""), setMentionsMenuOpen(true), setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]), onBeforeInput = (0, import_react2.useCallback)(
    (event) => {
      const selection = PortableTextEditor.getSelection(editor), cursorOffset = selection ? selection.focus.offset : 0, focusChild = PortableTextEditor.focusChild(editor), focusSpan = isPortableTextSpan(focusChild) && focusChild || void 0, isInsertText = event.inputType === "insertText", isDeleteText = event.inputType === "deleteContentBackward", isInsertingAtChar = isInsertText && event.data === "@", lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.substring(0, cursorOffset).lastIndexOf("@")) || 0, isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.substring(cursorOffset - 1, cursorOffset)) === " ", filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
      if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
        openMentions();
        return;
      }
      if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
        closeMentions();
        return;
      }
      if (isPortableTextSpan(focusChild)) {
        let term = focusChild.text.substring(lastIndexOfAt + 1, cursorOffset);
        isInsertText && (term += event.data), isDeleteText && (term = term.substring(0, term.length - 1)), setMentionsSearchTerm(term);
      }
    },
    [closeMentions, editor, mentionsSearchTerm, openMentions]
  ), insertAtChar = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true), PortableTextEditor.focus(editor), PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: "@" }), setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = (0, import_react2.useCallback)(
    (userId) => {
      var _a;
      const mentionSchemaType = editor.schemaTypes.inlineObjects.find((t) => t.name === "mention"), [span, spanPath] = selectionAtMentionInsert && PortableTextEditor.findByPath(editor, selectionAtMentionInsert.focus.path) || [];
      if (span && isPortableTextSpan(span) && spanPath && mentionSchemaType) {
        PortableTextEditor.focus(editor);
        const offset = (_a = PortableTextEditor.getSelection(editor)) == null ? void 0 : _a.focus.offset;
        typeof offset < "u" && (PortableTextEditor.delete(
          editor,
          {
            anchor: { path: spanPath, offset: span.text.lastIndexOf("@") },
            focus: { path: spanPath, offset }
          },
          { mode: "selected" }
        ), PortableTextEditor.insertChild(editor, mentionSchemaType, {
          userId
        }), PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: " " }));
      }
    },
    [editor, selectionAtMentionInsert]
  ), ctxValue = (0, import_react2.useMemo)(
    () => ({
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly: !!readOnly,
      value
    }),
    [
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly,
      value
    ]
  );
  return (0, import_jsx_runtime.jsx)(CommentInputContext.Provider, { value: ctxValue, children });
}
function useCommentInput() {
  const ctx = (0, import_react2.useContext)(CommentInputContext);
  if (!ctx)
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  return ctx;
}
var EVENT_LISTENER_OPTIONS = { passive: true };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts, [cursorRect, setCursorRect] = (0, import_react2.useState)(null), cursorElement = (0, import_react2.useMemo)(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]), handleSelectionChange = (0, import_react2.useCallback)(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0)
      return;
    const range = sel.getRangeAt(0);
    if (!(rootElement != null && rootElement.contains(range.commonAncestorContainer))) {
      setCursorRect(null);
      return;
    }
    const rect = range == null ? void 0 : range.getBoundingClientRect();
    rect && setCursorRect(rect);
  }, [disabled, rootElement]);
  return (0, import_react2.useEffect)(() => (document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]), cursorElement;
}
var POPOVER_FALLBACK_PLACEMENTS$4 = ["bottom", "top"];
var INLINE_STYLE = { outline: "none" };
var EMPTY_ARRAY$e = [];
var PlaceholderWrapper = ut.span((props) => {
  const { color } = getTheme_v2(props.theme);
  return at`
    color: ${color.input.default.enabled.placeholder};
    overflow: hidden;
    text-overflow: ellipsis;
    text-wrap: nowrap;
    display: block;
  `;
});
var StyledPopover$1 = ut(Popover2)(({ theme }) => {
  const { space, radius } = theme.sanity;
  return at`
    &[data-placement='bottom'] {
      transform: translateY(${space[1]}px);
    }

    &[data-placement='top'] {
      transform: translateY(-${space[1]}px);
    }

    [data-ui='Popover__wrapper'] {
      border-radius: ${radius[3]}px;
      display: flex;
      flex-direction: column;
      overflow: clip;
      overflow: hidden;
      position: relative;
      width: 300px; // todo: improve
    }
  `;
});
function Editable(props) {
  const { t } = useTranslation2(commentsLocaleNamespace), {
    focusLock,
    onFocus,
    onBlur,
    onKeyDown,
    onSubmit,
    placeholder = t("compose.create-comment-placeholder"),
    renderBlock: renderBlock2
  } = props, [popoverElement, setPopoverElement] = (0, import_react2.useState)(null), rootElementRef = (0, import_react2.useRef)(null), editableRef = (0, import_react2.useRef)(null), mentionsMenuRef = (0, import_react2.useRef)(null), selection = usePortableTextEditorSelection(), {
    canSubmit,
    closeMentions,
    insertMention,
    mentionOptions,
    mentionsMenuOpen,
    mentionsSearchTerm,
    onBeforeInput,
    value
  } = useCommentInput(), cursorElement = useCursorElement({
    disabled: !mentionsMenuOpen,
    rootElement: rootElementRef.current
  }), renderPlaceholder = (0, import_react2.useCallback)(
    () => (0, import_jsx_runtime.jsx)(PlaceholderWrapper, { children: placeholder }),
    [placeholder]
  ), handleClickOutside = (0, import_react2.useCallback)(() => {
    mentionsMenuOpen && closeMentions();
  }, [closeMentions, mentionsMenuOpen]);
  useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = (0, import_react2.useCallback)(
    (event) => {
      switch (event.key) {
        case "Enter":
          if (event.shiftKey)
            break;
          if (mentionsMenuOpen) {
            event.preventDefault(), event.stopPropagation(), closeMentions();
            break;
          }
          onSubmit && canSubmit && (event.preventDefault(), event.stopPropagation(), onSubmit());
          break;
        case "Escape":
        case "ArrowLeft":
        case "ArrowRight":
          mentionsMenuOpen && (event.preventDefault(), event.stopPropagation(), closeMentions());
          break;
      }
      onKeyDown && onKeyDown(event);
    },
    [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]
  ), initialSelectionAtEndOfContent = (0, import_react2.useMemo)(() => {
    if (selection)
      return;
    const lastBlock = (value || EMPTY_ARRAY$e).slice(-1)[0], lastChild = isPortableTextTextBlock(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild)
      return;
    const point = {
      path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }],
      offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0
    };
    return {
      focus: point,
      anchor: point
    };
  }, [value, selection]);
  (0, import_react2.useEffect)(() => {
    var _a;
    (_a = mentionsMenuRef.current) == null || _a.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]), (0, import_react2.useEffect)(() => {
    mentionsMenuOpen && selection && !(0, import_isEqual2.default)(selection.anchor, selection.focus) && closeMentions();
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = (0, import_jsx_runtime.jsx)(
    MentionsMenu$1,
    {
      inputElement: editableRef.current,
      loading: mentionOptions.loading,
      onSelect: insertMention,
      options: mentionOptions.data || EMPTY_ARRAY$e,
      ref: mentionsMenuRef
    }
  );
  return (0, import_jsx_runtime.jsxs)("div", { ref: rootElementRef, children: [
    (0, import_jsx_runtime.jsx)(
      StyledPopover$1,
      {
        arrow: false,
        constrainSize: true,
        content: popoverContent,
        disabled: !mentionsMenuOpen,
        fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$4,
        open: mentionsMenuOpen,
        placement: "bottom",
        ref: setPopoverElement,
        referenceElement: cursorElement
      }
    ),
    (0, import_jsx_runtime.jsx)(
      PortableTextEditable,
      {
        "data-testid": "comment-input-editable",
        "data-ui": "EditableElement",
        onBeforeInput,
        onBlur,
        onFocus,
        onKeyDown: handleKeyDown,
        ref: editableRef,
        renderBlock: renderBlock2,
        renderChild,
        renderPlaceholder,
        selection: initialSelectionAtEndOfContent,
        style: INLINE_STYLE,
        tabIndex: focusLock ? 0 : void 0
      }
    )
  ] });
}
var EditableWrap = ut(Box)`
  max-height: 20vh;
  overflow-y: auto;
`;
var ButtonDivider = ut(MenuDivider)({
  height: 20,
  width: 1
});
function focusRingBorderStyle(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
var RootCard$1 = ut(Card)(({ theme }) => {
  const { color, input, radius } = getTheme_v2(theme), radii = radius[2];
  return at`
    border-radius: ${radii}px;
    box-shadow: var(--input-box-shadow);

    --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

    &:not([data-expand-on-focus='false'], :focus-within) {
      background: transparent;
      box-shadow: unset;
    }

    &[data-focused='true']:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }

      /* box-shadow: inset 0 0 0 1px var(--card-focus-ring-color); */
      --input-box-shadow: ${focusRingBorderStyle({
    color: "var(--card-focus-ring-color)",
    width: input.border.width
  })};
    }

    &:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='false'] {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='true'] {
      [data-ui='CommentInputActions']:not([hidden]) {
        display: none;
      }

      &:focus-within {
        [data-ui='CommentInputActions'] {
          display: flex;
        }
      }
    }
    &:hover {
      --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
    }
  `;
});
var AvatarContainer = ut.div((props) => {
  var _a;
  return `
    min-height: ${(_a = getTheme_v2(props.theme).avatar.sizes[1]) == null ? void 0 : _a.size}px;
    display: flex;
    align-items: center;
  `;
});
function CommentInputInner(props) {
  const {
    avatarSize = 1,
    currentUser,
    focusLock,
    onBlur,
    onFocus,
    onKeyDown,
    onSubmit,
    placeholder,
    renderBlock: renderBlock2,
    withAvatar
  } = props, [user] = useUser(currentUser.id), { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput(), { t } = useTranslation2(commentsLocaleNamespace), avatar = withAvatar ? (0, import_jsx_runtime.jsx)(AvatarContainer, { children: (0, import_jsx_runtime.jsx)(CommentsAvatar, { user, size: avatarSize }) }) : null, handleMentionButtonClicked = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), insertAtChar(), openMentions();
    },
    [insertAtChar, openMentions]
  );
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 2, children: [
    avatar,
    (0, import_jsx_runtime.jsx)(
      RootCard$1,
      {
        id: "comment-input-root",
        "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false",
        "data-focused": focused ? "true" : "false",
        flex: 1,
        sizing: "border",
        tone: readOnly ? "transparent" : "default",
        children: (0, import_jsx_runtime.jsxs)(Stack, { children: [
          (0, import_jsx_runtime.jsx)(EditableWrap, { paddingX: 1, paddingY: 2, sizing: "border", "data-ui": "editable-wrap", children: (0, import_jsx_runtime.jsx)(
            Editable,
            {
              focusLock,
              onBlur,
              onFocus,
              onKeyDown,
              onSubmit,
              placeholder,
              renderBlock: renderBlock2
            }
          ) }),
          (0, import_jsx_runtime.jsx)(Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: (0, import_jsx_runtime.jsxs)(TooltipDelayGroupProvider, { children: [
            (0, import_jsx_runtime.jsx)(
              Button2,
              {
                "aria-label": t("compose.mention-user-aria-label"),
                "data-testid": "comment-input-mention-button",
                disabled: readOnly,
                icon: MentionIcon,
                mode: "bleed",
                type: "button",
                onClick: handleMentionButtonClicked,
                tooltipProps: { content: t("compose.mention-user-tooltip") }
              }
            ),
            onSubmit && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
              (0, import_jsx_runtime.jsx)(ButtonDivider, {}),
              (0, import_jsx_runtime.jsx)(
                Button2,
                {
                  "aria-label": t("compose.send-comment-aria-label"),
                  "data-testid": "comment-input-send-button",
                  disabled: !canSubmit || !hasChanges || readOnly,
                  icon: SendIcon,
                  mode: hasChanges && canSubmit ? "default" : "bleed",
                  onClick: onSubmit,
                  tone: hasChanges && canSubmit ? "primary" : "default",
                  tooltipProps: { content: t("compose.send-comment-tooltip") }
                }
              )
            ] })
          ] }) })
        ] })
      }
    )
  ] });
}
var EMPTY_ARRAY$d = [];
var SCROLL_INTO_VIEW_OPTIONS = {
  behavior: "smooth",
  block: "center",
  inline: "center"
};
var CommentInput = (0, import_react2.forwardRef)(
  function(props, ref) {
    const {
      avatarSize,
      currentUser,
      expandOnFocus,
      focusLock = false,
      focusOnMount,
      mentionOptions,
      onBlur,
      onChange,
      onDiscardCancel,
      onDiscardConfirm,
      onFocus,
      onKeyDown,
      onMentionMenuOpenChange,
      onSubmit,
      placeholder,
      readOnly,
      renderBlock: renderBlock2 = renderBlock$1,
      value = EMPTY_ARRAY$d,
      withAvatar = true
    } = props, [focused, setFocused] = (0, import_react2.useState)(false), editorRef = (0, import_react2.useRef)(null), editorContainerRef = (0, import_react2.useRef)(null), [showDiscardDialog, setShowDiscardDialog] = (0, import_react2.useState)(false), preDivRef = (0, import_react2.useRef)(null), postDivRef = (0, import_react2.useRef)(null), innerRef = (0, import_react2.useRef)(null), [editorInstanceKey, setEditorInstanceKey] = (0, import_react2.useState)(defaultKeyGenerator()), requestFocus = (0, import_react2.useCallback)(() => {
      requestAnimationFrame(() => {
        editorRef.current && PortableTextEditor.focus(editorRef.current);
      });
    }, []), resetEditorInstance = (0, import_react2.useCallback)(() => {
      setEditorInstanceKey(defaultKeyGenerator());
    }, []), handleChange = (0, import_react2.useCallback)(
      (change) => {
        if (change.type === "ready" && focusOnMount && requestFocus(), change.type === "focus" && setFocused(true), change.type === "blur" && setFocused(false), change.type === "patch" && editorRef.current) {
          const editorStateValue = PortableTextEditor.getValue(editorRef.current);
          onChange(editorStateValue || EMPTY_ARRAY$d);
        }
      },
      [focusOnMount, onChange, requestFocus]
    ), scrollToEditor = (0, import_react2.useCallback)(() => {
      var _a;
      (_a = editorContainerRef.current) == null || _a.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
    }, []), handleSubmit = (0, import_react2.useCallback)(() => {
      onSubmit == null || onSubmit(), resetEditorInstance(), requestFocus(), scrollToEditor();
    }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]), handleDiscardConfirm = (0, import_react2.useCallback)(() => {
      onDiscardConfirm(), resetEditorInstance();
    }, [onDiscardConfirm, resetEditorInstance]), discardDialogController = (0, import_react2.useMemo)(() => ({
      open: () => {
        setShowDiscardDialog(true);
      },
      close: () => {
        setShowDiscardDialog(false), requestFocus();
      }
    }), [requestFocus]);
    (0, import_react2.useImperativeHandle)(
      ref,
      () => ({
        focus: requestFocus,
        blur() {
          editorRef.current && PortableTextEditor.blur(editorRef.current);
        },
        scrollTo: scrollToEditor,
        reset: resetEditorInstance,
        discardDialogController
      }),
      [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]
    );
    const handleFocus = (0, import_react2.useCallback)(
      (event) => {
        if (!focusLock)
          return;
        const target = event.target, innerEl = innerRef.current;
        if (innerEl && target === preDivRef.current) {
          focusLastDescendant(innerEl);
          return;
        }
        innerEl && target === postDivRef.current && focusFirstDescendant(innerEl);
      },
      [focusLock]
    );
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      showDiscardDialog && onDiscardCancel && (0, import_jsx_runtime.jsx)(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }),
      (0, import_jsx_runtime.jsx)(Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: (0, import_jsx_runtime.jsx)(
        PortableTextEditor,
        {
          onChange: handleChange,
          readOnly,
          ref: editorRef,
          schemaType: editorSchemaType,
          value: value || EMPTY_ARRAY$d,
          children: (0, import_jsx_runtime.jsxs)(
            CommentInputProvider,
            {
              expandOnFocus,
              focused,
              focusOnMount,
              mentionOptions,
              onMentionMenuOpenChange,
              readOnly,
              value,
              children: [
                focusLock && (0, import_jsx_runtime.jsx)("div", { ref: preDivRef, tabIndex: 0 }),
                (0, import_jsx_runtime.jsx)(Stack, { ref: innerRef, children: (0, import_jsx_runtime.jsx)(
                  CommentInputInner,
                  {
                    avatarSize,
                    currentUser,
                    focusLock,
                    onBlur,
                    onFocus,
                    onKeyDown,
                    onSubmit: onSubmit && handleSubmit,
                    placeholder,
                    renderBlock: renderBlock2,
                    withAvatar
                  }
                ) }),
                focusLock && (0, import_jsx_runtime.jsx)("div", { ref: postDivRef, tabIndex: 0 })
              ]
            }
          )
        },
        editorInstanceKey
      ) })
    ] });
  }
);
var COMMENTS_HIGHLIGHT_HUE_KEY = "yellow";
var COMMENT_REACTION_OPTIONS = [
  {
    shortName: ":+1:",
    title: "Thumbs up"
  },
  {
    shortName: ":-1:",
    title: "Thumbs down"
  },
  {
    shortName: ":heart:",
    title: "Heart"
  },
  {
    shortName: ":rocket:",
    title: "Rocket"
  },
  {
    shortName: ":heavy_plus_sign:",
    title: "Heavy plus sign"
  },
  {
    shortName: ":eyes:",
    title: "Eyes"
  }
];
var COMMENT_REACTION_EMOJIS = {
  ":-1:": "ðŸ‘Ž",
  ":+1:": "ðŸ‘",
  ":eyes:": "ðŸ‘€",
  ":heart:": "â¤ï¸",
  ":heavy_plus_sign:": "âž•",
  ":rocket:": "ðŸš€"
};
var HighlightSpan = ut.span(({ theme }) => {
  var _a;
  const isDark = (_a = theme.sanity.v2) == null ? void 0 : _a.color._dark, addedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 800 : 100].hex, addedBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 300].hex, addedHoverBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedHoverBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex, addedNestedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedNesterBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  return at`
    box-sizing: border-box;
    transition:
      background-color 100ms ease,
      border-color 100ms ease;

    // Make sure that child elements appropriately blend with the
    // background of the highlight span
    * {
      mix-blend-mode: ${isDark ? "screen" : "multiply"};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='true'] {
      background-color: ${addedNestedBg};
      border-bottom: 2px solid ${addedNesterBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'][data-hovered='true'] {
      background-color: ${addedHoverBg};
      border-bottom: 2px solid ${addedHoverBorder};
    }

    &[data-inline-comment-state='authoring'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }
  `;
});
var CommentInlineHighlightSpan = (0, import_react2.forwardRef)(function(props, ref) {
  const { children, isAdded, isAuthoring, isHovered, isNested, ...rest } = props;
  return (0, import_jsx_runtime.jsx)(
    HighlightSpan,
    {
      ...rest,
      "data-hovered": isHovered ? "true" : "false",
      "data-inline-comment-nested": isNested ? "true" : "false",
      "data-inline-comment-state": isAdded ? "added" : isAuthoring ? "authoring" : void 0,
      ref,
      children
    }
  );
});
var PortableTextWrap = ut(Stack)(() => at`
    & > [data-ui='Text']:not(:first-child) {
      margin-top: 1em; // todo: improve
    }

    & > [data-ui='Text']:has(> span:empty) {
      display: none;
    }
  `);
var EMPTY_ARRAY$c = [];
var components = {
  block: {
    normal: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    h1: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    h2: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    h3: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    h4: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    h5: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    h6: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    blockquote: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    code: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    checkmarks: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children })
  },
  listItem: {
    bullet: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    number: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children }),
    checkmarks: ({ children }) => (0, import_jsx_runtime.jsx)(NormalBlock, { children })
  },
  marks: {
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    strong: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    em: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    code: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    underline: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    strikeThrough: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }),
    link: ({ children }) => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children })
  },
  types: {
    mention: (props) => {
      var _a;
      return (0, import_jsx_runtime.jsx)(MentionInlineBlock, { userId: (_a = props == null ? void 0 : props.value) == null ? void 0 : _a.userId, selected: false });
    }
  }
};
function CommentMessageSerializer(props) {
  const { blocks } = props;
  return (0, import_jsx_runtime.jsx)(PortableTextWrap, { children: (0, import_jsx_runtime.jsx)(PortableText, { value: blocks || EMPTY_ARRAY$c, components }) });
}
var FLEX_GAP = 3;
var EmojiText = ut(Text)`
  font-family: 'Twemoji Mozilla', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif;
`;
var GRID_COLUMNS = 6;
function CommentReactionsMenu(props) {
  const { options, onSelect } = props, { t } = useTranslation2(commentsLocaleNamespace), [focusableElements, setFocusableElements] = (0, import_react2.useState)([]), [rootElement, setRootElement] = (0, import_react2.useState)(null), [focusedIndex, setFocusedIndex] = (0, import_react2.useState)(0), handleRootKeyDown = (0, import_react2.useCallback)(
    (event) => {
      const focusableLen = focusableElements.length;
      event.key === "ArrowRight" && setFocusedIndex((prev) => (prev + 1) % focusableLen), event.key === "ArrowLeft" && setFocusedIndex((prev) => (prev - 1 + focusableLen) % focusableLen);
    },
    [focusableElements.length]
  ), handleOptionClick = (0, import_react2.useCallback)(
    (event) => {
      const index = focusableElements.indexOf(event.currentTarget);
      setFocusedIndex(index), onSelect(options[index]);
    },
    [focusableElements, onSelect, options]
  );
  return (0, import_react2.useEffect)(() => {
    if (rootElement) {
      const buttons = rootElement.querySelectorAll("button");
      setFocusableElements(Array.from(buttons));
    }
  }, [rootElement]), (0, import_react2.useEffect)(() => {
    focusableElements.length > 0 && focusableElements[focusedIndex].focus();
  }, [focusableElements, focusedIndex]), (0, import_jsx_runtime.jsx)(
    Grid,
    {
      columns: GRID_COLUMNS,
      gap: 1,
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      role: "menu",
      children: options.map((o) => {
        const emoji = COMMENT_REACTION_EMOJIS[o.shortName];
        return (0, import_jsx_runtime.jsx)(
          Button,
          {
            "aria-label": t("reactions.react-with-aria-label", {
              reactionName: o.title || o.shortName
            }),
            mode: "bleed",
            onClick: handleOptionClick,
            padding: 2,
            role: "menuitem",
            tabIndex: -1,
            children: (0, import_jsx_runtime.jsx)(EmojiText, { align: "center", size: 2, children: emoji })
          },
          o.shortName
        );
      })
    }
  );
}
var POPOVER_FALLBACK_PLACEMENTS$3 = ["top", "bottom"];
function CommentReactionsMenuButton(props) {
  const { onMenuClose, onMenuOpen, onSelect, options, readOnly, renderMenuButton: renderMenuButton2, mode } = props, [buttonElement, setButtonElement] = (0, import_react2.useState)(null), [popoverElement, setPopoverElement] = (0, import_react2.useState)(null), [open, setOpen] = (0, import_react2.useState)(false), { t } = useTranslation2(commentsLocaleNamespace), handleClick = (0, import_react2.useCallback)(() => {
    const next = !open;
    setOpen(next), next ? onMenuOpen == null || onMenuOpen() : onMenuClose == null || onMenuClose();
  }, [onMenuClose, onMenuOpen, open]), handleClose = (0, import_react2.useCallback)(() => {
    open && (setOpen(false), onMenuClose == null || onMenuClose(), buttonElement == null || buttonElement.focus());
  }, [buttonElement, onMenuClose, open]), handleClickOutside = (0, import_react2.useCallback)(handleClose, [handleClose]), handleKeyDown = (0, import_react2.useCallback)(
    (event) => {
      const { key, shiftKey } = event;
      (shiftKey && key === "Tab" || key === "Escape" || key === "Tab") && handleClose();
    },
    [handleClose]
  );
  useClickOutside(handleClickOutside, [popoverElement, buttonElement]);
  const handleSelect = (0, import_react2.useCallback)(
    (option) => {
      onSelect(option), handleClose();
    },
    [handleClose, onSelect]
  ), button = (0, import_react2.useMemo)(() => {
    const btn = renderMenuButton2({
      open,
      tooltipContent: t(mode === "upsell" ? "list-item.context-menu-add-reaction-upsell" : "list-item.context-menu-add-reaction"),
      t
    });
    return (0, import_react2.cloneElement)(btn, {
      "aria-expanded": open,
      "aria-haspopup": "true",
      disabled: readOnly || mode === "upsell",
      id: "reactions-menu-button",
      onClick: handleClick,
      ref: setButtonElement
    });
  }, [handleClick, open, readOnly, renderMenuButton2, t, mode]);
  return (0, import_jsx_runtime.jsx)(
    Popover2,
    {
      constrainSize: true,
      content: (0, import_jsx_runtime.jsx)(
        Card,
        {
          "aria-labelledby": "reactions-menu-button",
          onKeyDown: handleKeyDown,
          padding: 1,
          radius: 3,
          tone: "default",
          children: (0, import_jsx_runtime.jsx)(CommentReactionsMenu, { onSelect: handleSelect, options })
        }
      ),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$3,
      open,
      placement: "bottom",
      portal: true,
      ref: setPopoverElement,
      tone: "default",
      children: button
    }
  );
}
var TEXT_SIZE = 1;
var ContentStack$1 = ut(Stack)`
  max-width: 180px;
`;
var TextGroup = ut.div`
  display: inline-block;
`;
var InlineText = ut(Text).attrs({ size: TEXT_SIZE })`
  display: inline-block !important;

  & > span {
    white-space: break-spaces;
  }
`;
var TextBox = ut(Box)`
  line-height: 1;
  text-align: center;
`;
var LEADING_NON_WHITESPACE_RE = /^\S+/;
function UserDisplayName(props) {
  const { currentUserId, isFirst, userId } = props, [user] = useUser(userId), { t } = useTranslation2(commentsLocaleNamespace);
  return currentUserId === userId ? t("reactions.user-list.you", { context: isFirst ? "leading" : void 0, replace: { name: user == null ? void 0 : user.displayName } }) : (user == null ? void 0 : user.displayName) || t("reactions.user-list.unknown-user-fallback-name");
}
function CommentReactionsUsersTooltip(props) {
  const { children, ...restProps } = props;
  return (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      content: (0, import_jsx_runtime.jsx)(CommentReactionsUsersTooltipContent, { ...restProps }),
      placement: "bottom",
      portal: true,
      children: (0, import_jsx_runtime.jsx)("div", { children })
    }
  );
}
function FormattedUserList({ currentUserId, userIds }) {
  const listFormat = useListFormat({ style: "long", type: "conjunction" });
  if (userIds.length === 0)
    return null;
  const parts = listFormat.formatToParts(userIds), elements = [];
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    if (item.type === "literal") {
      elements.push((0, import_jsx_runtime.jsx)(InlineText, { children: item.value }, `literal-${i}`));
      continue;
    }
    const nextItem = parts[i + 1];
    if (nextItem && nextItem.type === "literal" && LEADING_NON_WHITESPACE_RE.test(nextItem.value)) {
      const [nonWhitespace = ""] = nextItem.value.match(LEADING_NON_WHITESPACE_RE) || [];
      elements.push(
        // Key (value) is user ID, thus unique
        (0, import_jsx_runtime.jsxs)(TextGroup, { children: [
          (0, import_jsx_runtime.jsx)(InlineText, { weight: "medium", children: (0, import_jsx_runtime.jsx)(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }),
          (0, import_jsx_runtime.jsx)(InlineText, { children: nonWhitespace })
        ] }, item.value)
      ), nextItem.value = nextItem.value.slice(nonWhitespace.length);
      continue;
    }
    elements.push(
      // Key (value) is user ID, thus unique
      (0, import_jsx_runtime.jsx)(InlineText, { weight: "medium", children: (0, import_jsx_runtime.jsx)(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }, item.value)
    );
  }
  return elements;
}
function CommentReactionsUsersTooltipContent(props) {
  const { currentUser, reactionName, userIds } = props, { t } = useTranslation2(commentsLocaleNamespace), UserList = (0, import_react2.useCallback)(() => currentUser ? (0, import_jsx_runtime.jsx)(FormattedUserList, { currentUserId: currentUser.id, userIds }) : null, [currentUser, userIds]);
  return (0, import_jsx_runtime.jsxs)(ContentStack$1, { padding: 1, children: [
    (0, import_jsx_runtime.jsx)(Flex, { justify: "center", paddingBottom: 2, paddingTop: 1, children: (0, import_jsx_runtime.jsx)(EmojiText, { size: 4, children: COMMENT_REACTION_EMOJIS[reactionName] }) }),
    (0, import_jsx_runtime.jsx)(TextBox, { children: (0, import_jsx_runtime.jsx)(
      Translate,
      {
        t,
        i18nKey: "reactions.users-reacted-with-reaction",
        values: { reactionName },
        components: {
          UserList,
          ReactionName: () => (0, import_jsx_runtime.jsx)(InlineText, { muted: true, children: reactionName }),
          Text: ({ children }) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
            (0, import_jsx_runtime.jsx)(InlineText, { muted: true, children }),
            " ",
            (0, import_jsx_runtime.jsx)("wbr", {}),
            " "
          ] })
        }
      }
    ) })
  ] });
}
var TransparentCard = ut(Card)`
  background: none;
`;
function groupReactionsByName(reactions) {
  const grouped = reactions.reduce(
    (acc, reaction) => {
      const { shortName } = reaction;
      return acc[shortName] || (acc[shortName] = []), acc[shortName].push(reaction), acc;
    },
    {}
  );
  return Object.entries(grouped).sort(([nameA], [nameB]) => {
    const indexA = reactions.findIndex((r) => r.shortName === nameA), indexB = reactions.findIndex((r) => r.shortName === nameB);
    return indexA - indexB;
  });
}
var renderMenuButton$1 = ({ open, tooltipContent }) => (0, import_jsx_runtime.jsx)(Button, { fontSize: 1, mode: "ghost", padding: 0, radius: "full", selected: open, children: (0, import_jsx_runtime.jsx)(Flex, { paddingX: 3, paddingY: 2, children: (0, import_jsx_runtime.jsx)(Tooltip, { animate: true, content: tooltipContent, disabled: open, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(ReactionIcon, {}) }) }) }) });
var CommentReactionsBar = import_react2.default.memo(function(props) {
  const { currentUser, onSelect, reactions, readOnly, mode } = props, handleSelect = (0, import_react2.useCallback)(
    (name) => {
      const option = COMMENT_REACTION_OPTIONS.find((o) => o.shortName === name);
      option && onSelect(option);
    },
    [onSelect]
  ), currentUserReactionNames = (0, import_react2.useMemo)(() => reactions.filter((r) => r.userId === (currentUser == null ? void 0 : currentUser.id)).map((r) => r.shortName), [currentUser == null ? void 0 : currentUser.id, reactions]), groupedReactions = (0, import_react2.useMemo)(() => groupReactionsByName(reactions).filter(([name]) => COMMENT_REACTION_EMOJIS[name]), [reactions]), sortOrder = (0, import_react2.useRef)(Object.keys(Object.fromEntries(groupedReactions))), sortedReactions = (0, import_react2.useMemo)(() => {
    const sorted = groupedReactions.sort(([nameA], [nameB]) => {
      const indexA = sortOrder.current.indexOf(nameA), indexB = sortOrder.current.indexOf(nameB);
      return indexA === -1 ? 1 : indexB === -1 ? -1 : indexA - indexB;
    });
    return sortOrder.current = sorted.map(([name]) => name), sorted;
  }, [groupedReactions]);
  return (0, import_jsx_runtime.jsx)(Flex, { align: "center", gap: 1, wrap: "wrap", children: (0, import_jsx_runtime.jsxs)(TooltipDelayGroupProvider, { children: [
    sortedReactions.map(([name, reactionsList]) => {
      const hasReacted = currentUserReactionNames.includes(name), userIds = reactionsList.map((r) => r.userId), emoji = COMMENT_REACTION_EMOJIS[name];
      return (0, import_jsx_runtime.jsx)(
        CommentReactionsUsersTooltip,
        {
          currentUser,
          reactionName: name,
          userIds,
          children: (0, import_jsx_runtime.jsx)(TransparentCard, { tone: "default", children: (0, import_jsx_runtime.jsx)(
            Button,
            {
              disabled: readOnly || mode === "upsell",
              mode: "ghost",
              onClick: () => handleSelect(name),
              padding: 2,
              radius: "full",
              selected: hasReacted,
              tone: hasReacted ? "primary" : "default",
              children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
                (0, import_jsx_runtime.jsx)(EmojiText, { size: 1, children: emoji }),
                (0, import_jsx_runtime.jsx)(Text, { size: 0, weight: hasReacted ? "semibold" : "medium", children: reactionsList == null ? void 0 : reactionsList.length })
              ] })
            }
          ) })
        },
        name
      );
    }),
    (0, import_jsx_runtime.jsx)(TransparentCard, { tone: "default", children: (0, import_jsx_runtime.jsx)(
      CommentReactionsMenuButton,
      {
        mode,
        onSelect: (o) => handleSelect(o.shortName),
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton: renderMenuButton$1
      }
    ) })
  ] }) });
});
var renderMenuButton = ({
  open,
  tooltipContent,
  t
}) => (0, import_jsx_runtime.jsx)(
  Button2,
  {
    "aria-label": t("list-item.context-menu-add-reaction-aria-label"),
    icon: ReactionIcon,
    mode: "bleed",
    selected: open,
    tooltipProps: { content: tooltipContent }
  }
);
var POPOVER_PROPS = {
  placement: "bottom-end"
};
var FloatingCard = ut(Card)`
  &:empty {
    display: none;
  }
`;
function CommentsListItemContextMenu(props) {
  const {
    canDelete,
    canEdit,
    isParent,
    mode,
    onCopyLink,
    onDeleteStart,
    onEditStart,
    onMenuClose,
    onMenuOpen,
    onReactionSelect,
    onStatusChange,
    readOnly,
    status
  } = props, showMenuButton = !!(onCopyLink || onDeleteStart || onEditStart), { t } = useTranslation2(commentsLocaleNamespace), hasContextMenuOptions = !!(canDelete || canEdit || onCopyLink);
  return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsxs)(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [
    onReactionSelect && (0, import_jsx_runtime.jsx)(
      CommentReactionsMenuButton,
      {
        mode,
        onMenuClose,
        onMenuOpen,
        onSelect: onReactionSelect,
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton
      }
    ),
    isParent && onStatusChange && (0, import_jsx_runtime.jsx)(
      Button2,
      {
        "aria-label": t(status === "open" ? "list-item.resolved-tooltip-aria-label" : "list-item.re-open-resolved-aria-label"),
        "data-testid": "comments-list-item-status-button",
        disabled: readOnly,
        icon: status === "open" ? CheckmarkCircleIcon : UndoIcon,
        mode: "bleed",
        onClick: onStatusChange,
        tooltipProps: {
          content: t(status === "open" ? "list-item.resolved-tooltip-content" : "list-item.re-open-resolved")
        }
      }
    ),
    hasContextMenuOptions && (0, import_jsx_runtime.jsx)(
      MenuButton,
      {
        id: "comment-actions-menu",
        button: (0, import_jsx_runtime.jsx)(
          ContextMenuButton,
          {
            "aria-label": t("list-item.open-menu-aria-label"),
            disabled: readOnly,
            hidden: !showMenuButton
          }
        ),
        onOpen: onMenuOpen,
        onClose: onMenuClose,
        menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              hidden: !canEdit,
              icon: EditIcon,
              onClick: onEditStart,
              text: t("list-item.edit-comment"),
              tooltipProps: mode === "upsell" ? { content: t("list-item.edit-comment-upsell") } : void 0,
              disabled: mode === "upsell"
            }
          ),
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              hidden: !canDelete,
              icon: TrashIcon,
              onClick: onDeleteStart,
              text: t("list-item.delete-comment"),
              tone: "critical"
            }
          ),
          onCopyLink && (0, import_jsx_runtime.jsx)(MenuDivider, { hidden: !canDelete && !canEdit }),
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              hidden: !onCopyLink,
              icon: LinkIcon,
              onClick: onCopyLink,
              text: t("list-item.copy-link")
            }
          )
        ] }),
        popover: POPOVER_PROPS
      }
    )
  ] }) }) });
}
function truncate(str, length = 250) {
  return str.length <= length ? str : `${str.slice(0, length)}...`;
}
var InlineBox = ut(Box).attrs({ marginLeft: 1, marginRight: 2 })`
  &:not([data-hidden]) {
    display: inline;
  }
`;
var BlockQuoteStack = ut(Stack)(({ theme, $hasReferencedValue }) => {
  var _a;
  const isDark = (_a = theme.sanity.v2) == null ? void 0 : _a.color._dark, hue = $hasReferencedValue ? COMMENTS_HIGHLIGHT_HUE_KEY : "gray", borderColor = isDark ? hues[hue][700].hex : hues[hue][300].hex;
  return at`
    border-left: 2px solid ${borderColor};
    word-break: break-word;
  `;
});
function CommentsListItemReferencedValue(props) {
  const { hasReferencedValue, value } = props, { t } = useTranslation(commentsLocaleNamespace), tooltipText = t("list-item.missing-referenced-value-tooltip-content"), resolvedValue = (0, import_react2.useMemo)(() => {
    if (Array.isArray(value) && (value == null ? void 0 : value.filter(isPortableTextTextBlock).length) > 0) {
      const text = value == null ? void 0 : value.map(toPlainText).join(" ");
      return truncate(text);
    }
    return null;
  }, [value]);
  return resolvedValue ? (0, import_jsx_runtime.jsx)(
    BlockQuoteStack,
    {
      $hasReferencedValue: !!hasReferencedValue,
      "data-testid": "comments-list-item-referenced-value",
      flex: 1,
      forwardedAs: "blockquote",
      padding: 1,
      paddingLeft: 2,
      sizing: "border",
      children: (0, import_jsx_runtime.jsx)(Flex, { align: "flex-start", children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, muted: true, children: [
        !hasReferencedValue && (0, import_jsx_runtime.jsx)(Tooltip, { content: tooltipText, children: (0, import_jsx_runtime.jsx)(InlineBox, { children: (0, import_jsx_runtime.jsx)(LinkRemovedIcon, {}) }) }),
        resolvedValue
      ] }) })
    }
  ) : null;
}
var stopPropagation = (e2) => e2.stopPropagation();
var ContextMenuBox = ut(Box)``;
var SKELETON_INLINE_STYLE = { width: "50%" };
var EMPTY_ARRAY$b2 = [];
var TimeText = ut(Text)(({ theme }) => {
  const isDark = theme.sanity.color.dark, fg = hues.gray[isDark ? 200 : 800].hex;
  return at`
    min-width: max-content;
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
});
var HeaderFlex$1 = ut(Flex)((props) => {
  var _a;
  const theme = getTheme_v2(props.theme);
  return at`
    min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
});
var IntentText = ut(Text)(({ theme }) => {
  const isDark = theme.sanity.color.dark, fg = hues.gray[isDark ? 200 : 800].hex;
  return at`
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
});
var InnerStack = ut(Stack)`
  transition: opacity 200ms ease;

  &[data-muted='true'] {
    transition: unset;
    opacity: 0.5;
  }
`;
var ErrorFlex = ut(Flex)((props) => {
  var _a;
  const theme = getTheme_v2(props.theme);
  return at`
    min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
});
var RetryCardButton = ut(Card)`
  // Add not on hover
  &:not(:hover) {
    background-color: transparent;
  }
`;
var RootStack$1 = ut(Stack)(({ theme }) => {
  const { space } = theme.sanity;
  return at`
    position: relative;

    // Only show the floating layer on hover when hover is supported.
    // Else, the layer is always visible.
    @media (hover: hover) {
      ${ContextMenuBox} {
        opacity: 0;
        position: absolute;
        right: 0;
        top: 0;
        transform: translate(${space[1]}px, -${space[1]}px);
      }

      ${ContextMenuBox} {
        &:focus-within {
          opacity: 1;
        }
      }

      &:hover {
        ${ContextMenuBox} {
          opacity: 1;
        }
      }
    }

    &[data-menu-open='true'] {
      ${ContextMenuBox} {
        opacity: 1;
      }
    }
  `;
});
var RELATIVE_TIME_OPTIONS$1 = { useTemporalPhrase: true };
function CommentsListItemLayout(props) {
  var _a;
  const {
    avatarSize = 1,
    canDelete,
    canEdit,
    comment,
    currentUser,
    hasError,
    hasReferencedValue,
    intent,
    isParent,
    isRetrying,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onInputKeyDown,
    onReactionSelect,
    onStatusChange,
    readOnly,
    withAvatar = true
  } = props, { _createdAt, authorId, message, _id, lastEditedAt } = comment, [user] = useUser(authorId), { t } = useTranslation2(commentsLocaleNamespace), [value, setValue] = (0, import_react2.useState)(message), [isEditing, setIsEditing] = (0, import_react2.useState)(false), [rootElement, setRootElement] = (0, import_react2.useState)(null), startMessage = (0, import_react2.useRef)(message), [menuOpen, setMenuOpen] = (0, import_react2.useState)(false), commentInputRef = (0, import_react2.useRef)(null), hasChanges = useCommentHasChanged(value), hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), reactions = (0, import_react2.useMemo)(
    () => {
      var _a2;
      return (((_a2 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a2.filter((r) => (r == null ? void 0 : r._optimisticState) !== "removed")) || EMPTY_ARRAY$b2).filter(
        (r) => "userId" in r && "shortName" in r
      );
    },
    [comment == null ? void 0 : comment.reactions]
  ), hasReactions = !!(reactions != null && reactions.length), createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date(), editedDate = lastEditedAt ? new Date(lastEditedAt) : null, createdTimeAgo = useRelativeTime(createdDate, RELATIVE_TIME_OPTIONS$1), dateTimeFormat = useDateTimeFormat({ dateStyle: "full", timeStyle: "medium" }), formattedCreatedAt = dateTimeFormat.format(createdDate), formattedLastEditAt = editedDate ? dateTimeFormat.format(editedDate) : null, displayError = hasError || isRetrying;
  (0, import_react2.useEffect)(() => {
    isEditing || (startMessage.current = message, setValue(message));
  }, [isEditing, message]);
  const handleMenuOpen = (0, import_react2.useCallback)(() => setMenuOpen(true), []), handleMenuClose = (0, import_react2.useCallback)(() => setMenuOpen(false), []), handleCopyLink = (0, import_react2.useCallback)(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]), handleCreateRetry = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), onCreateRetry == null || onCreateRetry(_id);
    },
    [_id, onCreateRetry]
  ), handleDelete = (0, import_react2.useCallback)(() => onDelete(_id), [_id, onDelete]), cancelEdit = (0, import_react2.useCallback)(() => {
    setIsEditing(false), setValue(startMessage.current);
  }, []), startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue]), handleInputKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onInputKeyDown && onInputKeyDown(event));
    },
    [onInputKeyDown, startDiscard]
  ), cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close(), cancelEdit();
  }, [cancelEdit]), handleReactionSelect = (0, import_react2.useCallback)(
    (reaction) => {
      onReactionSelect == null || onReactionSelect(_id, reaction);
    },
    [_id, onReactionSelect]
  ), handleEditSubmit = (0, import_react2.useCallback)(() => {
    onEdit(_id, { message: value }), setIsEditing(false);
  }, [_id, onEdit, value]), handleOpenStatusChange = (0, import_react2.useCallback)(() => {
    onStatusChange == null || onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]), toggleEdit = (0, import_react2.useCallback)(() => {
    setIsEditing((v) => !v);
  }, []), handleCloseMenu = (0, import_react2.useCallback)(() => setMenuOpen(false), []), handleClickOutside = (0, import_react2.useCallback)(() => {
    hasChanges || cancelEdit();
  }, [cancelEdit, hasChanges]), handleRootKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.key === "Escape" && !hasChanges && cancelEdit();
    },
    [cancelEdit, hasChanges]
  );
  useDidUpdate(isEditing, handleCloseMenu), useClickOutside(handleClickOutside, [rootElement]);
  const name = user != null && user.displayName ? (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return (0, import_jsx_runtime.jsxs)(
    RootStack$1,
    {
      "data-menu-open": menuOpen ? "true" : "false",
      "data-testid": "comments-list-item-layout",
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      space: 4,
      children: [
        (0, import_jsx_runtime.jsxs)(InnerStack, { space: 1, "data-muted": displayError, children: [
          (0, import_jsx_runtime.jsxs)(HeaderFlex$1, { align: "center", gap: FLEX_GAP, flex: 1, $size: avatarSize, children: [
            withAvatar && (0, import_jsx_runtime.jsx)(CommentsAvatar, { user, size: avatarSize }),
            (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, paddingY: intent ? 2 : 0, children: [
              (0, import_jsx_runtime.jsx)(
                Flex,
                {
                  align: "center",
                  paddingBottom: (_a = comment.context) != null && _a.intent ? 0 : 1,
                  sizing: "border",
                  flex: 1,
                  children: (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-end", gap: 2, children: [
                    (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: name }),
                    !displayError && (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
                      (0, import_jsx_runtime.jsx)(TimeText, { muted: true, size: 0, children: (0, import_jsx_runtime.jsx)("time", { dateTime: createdDate.toISOString(), title: formattedCreatedAt, children: createdTimeAgo }) }),
                      formattedLastEditAt && editedDate && (0, import_jsx_runtime.jsx)(TimeText, { muted: true, size: 0, title: formattedLastEditAt, children: (0, import_jsx_runtime.jsxs)("time", { dateTime: editedDate.toISOString(), title: formattedLastEditAt, children: [
                        "(",
                        t("list-item.layout-edited"),
                        ")"
                      ] }) })
                    ] })
                  ] })
                }
              ),
              intent && (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(IntentText, { muted: true, size: 0, textOverflow: "ellipsis", children: (0, import_jsx_runtime.jsx)(
                Translate,
                {
                  t,
                  i18nKey: "list-item.layout-context",
                  values: { title: intent.title, intent: "edit" },
                  components: {
                    IntentLink: ({ children }) => intent ? (0, import_jsx_runtime.jsx)(IntentLink, { params: intent.params, intent: intent.name, children }) : void 0
                  }
                }
              ) }) })
            ] }),
            !isEditing && !displayError && (0, import_jsx_runtime.jsx)(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: stopPropagation, children: (0, import_jsx_runtime.jsx)(
              CommentsListItemContextMenu,
              {
                canDelete,
                canEdit,
                isParent,
                mode,
                onCopyLink: onCopyLink ? handleCopyLink : void 0,
                onDeleteStart: handleDelete,
                onEditStart: toggleEdit,
                onMenuClose: handleMenuClose,
                onMenuOpen: handleMenuOpen,
                onReactionSelect: handleReactionSelect,
                onStatusChange: onStatusChange ? handleOpenStatusChange : void 0,
                readOnly,
                status: comment.status
              }
            ) })
          ] }),
          isTextSelectionComment(comment) && !!(comment != null && comment.contentSnapshot) && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, marginBottom: 3, children: [
            withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }),
            (0, import_jsx_runtime.jsx)(
              CommentsListItemReferencedValue,
              {
                hasReferencedValue,
                value: comment == null ? void 0 : comment.contentSnapshot
              }
            )
          ] }),
          isEditing && (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 2, children: [
            withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }),
            (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(
              CommentInput,
              {
                currentUser,
                focusOnMount: true,
                mentionOptions,
                onChange: setValue,
                onDiscardCancel: cancelDiscard,
                onDiscardConfirm: confirmDiscard,
                onKeyDown: handleInputKeyDown,
                onSubmit: handleEditSubmit,
                readOnly,
                ref: commentInputRef,
                value,
                withAvatar: false
              }
            ) })
          ] }),
          !isEditing && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, children: [
            withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }),
            (0, import_jsx_runtime.jsx)(CommentMessageSerializer, { blocks: message })
          ] }),
          hasReactions && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, marginTop: 2, children: [
            withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }),
            (0, import_jsx_runtime.jsx)(Box, { onClick: stopPropagation, children: (0, import_jsx_runtime.jsx)(
              CommentReactionsBar,
              {
                currentUser,
                mode,
                onSelect: handleReactionSelect,
                reactions,
                readOnly
              }
            ) })
          ] })
        ] }),
        displayError && (0, import_jsx_runtime.jsxs)(ErrorFlex, { gap: FLEX_GAP, $size: avatarSize, children: [
          withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }),
          (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, flex: 1, children: [
            (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [
              hasError && t("list-item.layout-failed-sent"),
              isRetrying && t("list-item.layout-posting")
            ] }),
            (0, import_jsx_runtime.jsx)(Flex, { hidden: isRetrying, children: (0, import_jsx_runtime.jsx)(
              RetryCardButton,
              {
                __unstable_focusRing: true,
                display: "flex",
                forwardedAs: "button",
                onClick: handleCreateRetry,
                padding: 1,
                radius: 2,
                tone: "primary",
                children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("list-item.layout-retry") })
              }
            ) })
          ] })
        ] })
      ]
    }
  );
}
var ThreadCard = ut(Card).attrs({ padding: 3, radius: 3, sizing: "border" })(
  (props) => {
    const { theme } = props, isDark = theme.sanity.color.dark, activeBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 900 : 50].hex, defaultBg = hues.gray[isDark ? 900 : 50].hex;
    return at`
      background-color: ${defaultBg};

      &[data-active='true'] {
        background-color: ${activeBg};
      }
    `;
  }
);
var EMPTY_ARRAY$a = [];
var MAX_COLLAPSED_REPLIES = 5;
var DEFAULT_AVATAR_CONFIG = {
  avatarSize: 1,
  parentCommentAvatar: true,
  replyAvatar: true,
  threadCommentsAvatar: true
};
var StyledThreadCard = ut(ThreadCard)(() => at`
    position: relative;

    &:has(> [data-ui='GhostButton']:focus:focus-visible) {
      box-shadow:
        inset 0 0 0 1px var(--card-border-color),
        0 0 0 1px var(--card-bg-color),
        0 0 0 2px var(--card-focus-ring-color);
    }

    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class
    // since we want to show the hover styles when hovering over the menu items in the context menu as well.
    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over
    // the menu items.
    &:not([data-active='true']) {
      @media (hover: hover) {
        &[data-hovered='true'] {
          [data-root-menu='true'] {
            opacity: 1;
          }
        }
      }
    }
  `);
var ExpandButton = ut(Button2)(({ theme }) => {
  const { medium } = theme.sanity.fonts.text.weights;
  return at`
    font-weight: ${medium};
  `;
});
var GhostButton = ut.button`
  opacity: 0;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  left: 0;
`;
var CommentsListItem = import_react2.default.memo(function(props) {
  var _a, _b, _c, _d, _e;
  const {
    avatarConfig = DEFAULT_AVATAR_CONFIG,
    canReply,
    currentUser,
    hasReferencedValue,
    innerPadding,
    isSelected,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onKeyDown,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    parentComment,
    readOnly,
    replies = EMPTY_ARRAY$a
  } = props, { t } = useTranslation2(commentsLocaleNamespace), [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$a), [collapsed, setCollapsed] = (0, import_react2.useState)(true), didExpand = (0, import_react2.useRef)(false), replyInputRef = (0, import_react2.useRef)(null), { isTopLayer } = useLayer(), hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), [mouseOver, setMouseOver] = (0, import_react2.useState)(false), handleMouseEnter = (0, import_react2.useCallback)(() => setMouseOver(true), []), handleMouseLeave = (0, import_react2.useCallback)(() => setMouseOver(false), []), handleReplySubmit = (0, import_react2.useCallback)(() => {
    var _a2;
    const nextComment = {
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId,
      // A new comment will not have any reactions
      reactions: EMPTY_ARRAY$a,
      payload: {
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || ""
      }
    };
    onReply == null || onReply(nextComment), setValue(EMPTY_ARRAY$a);
  }, [
    onReply,
    parentComment._id,
    parentComment == null ? void 0 : parentComment.status,
    (_a = parentComment.target.path) == null ? void 0 : _a.field,
    parentComment.threadId,
    value
  ]), startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue) {
      setValue(EMPTY_ARRAY$a);
      return;
    }
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.open();
  }, [hasValue]), handleInputKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.isDefaultPrevented() || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a2, _b2;
    setValue(EMPTY_ARRAY$a), (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close(), (_b2 = replyInputRef.current) == null || _b2.focus();
  }, []), handleThreadRootClick = (0, import_react2.useCallback)(
    (e2) => {
      var _a2;
      e2.stopPropagation(), isTopLayer && (onPathSelect == null || onPathSelect({
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || "",
        origin: "inspector",
        threadId: parentComment.threadId
      }));
    },
    [isTopLayer, onPathSelect, (_b = parentComment.target.path) == null ? void 0 : _b.field, parentComment.threadId]
  ), handleExpand = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation(), setCollapsed(false), didExpand.current = true;
  }, []), splicedReplies = (0, import_react2.useMemo)(() => collapsed ? replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES) : replies, [replies, collapsed]), showCollapseButton = (0, import_react2.useMemo)(() => replies ? replies.length > MAX_COLLAPSED_REPLIES : false, [replies]), expandButtonText = (0, import_react2.useMemo)(() => `${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES} more ${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments"}`, [replies == null ? void 0 : replies.length]);
  (0, import_react2.useEffect)(() => {
    replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current && setCollapsed(true);
  }, [replies]);
  const renderedReplies = (0, import_react2.useMemo)(
    () => splicedReplies.map((reply) => {
      var _a2, _b2;
      return (0, import_jsx_runtime.jsx)(Stack, { as: "li", ...applyCommentIdAttr(reply._id), children: (0, import_jsx_runtime.jsx)(
        CommentsListItemLayout,
        {
          avatarSize: avatarConfig.avatarSize,
          canDelete: reply.authorId === currentUser.id,
          canEdit: reply.authorId === currentUser.id,
          comment: reply,
          currentUser,
          hasError: ((_a2 = reply._state) == null ? void 0 : _a2.type) === "createError",
          isRetrying: ((_b2 = reply._state) == null ? void 0 : _b2.type) === "createRetrying",
          intent: commentIntentIfDiffers(parentComment, reply),
          mentionOptions,
          mode,
          onCopyLink,
          onCreateRetry,
          onDelete,
          onEdit,
          onInputKeyDown: handleInputKeyDown,
          onReactionSelect,
          readOnly,
          withAvatar: avatarConfig.threadCommentsAvatar
        }
      ) }, reply._id);
    }),
    [
      avatarConfig.threadCommentsAvatar,
      avatarConfig.avatarSize,
      currentUser,
      handleInputKeyDown,
      mentionOptions,
      onCopyLink,
      onCreateRetry,
      onDelete,
      onEdit,
      onReactionSelect,
      parentComment,
      readOnly,
      splicedReplies,
      mode
    ]
  );
  return (0, import_jsx_runtime.jsxs)(
    StyledThreadCard,
    {
      "data-active": isSelected ? "true" : "false",
      "data-hovered": mouseOver ? "true" : "false",
      "data-testid": "comments-list-item",
      onClick: handleThreadRootClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [
        (0, import_jsx_runtime.jsx)(
          GhostButton,
          {
            "data-ui": "GhostButton",
            "aria-label": t("list-item.go-to-field-button.aria-label")
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          Stack,
          {
            as: "ul",
            padding: innerPadding,
            paddingBottom: canReply ? void 0 : 1,
            space: 4,
            children: [
              (0, import_jsx_runtime.jsx)(Stack, { as: "li", ...applyCommentIdAttr(parentComment._id), children: (0, import_jsx_runtime.jsx)(
                CommentsListItemLayout,
                {
                  avatarSize: avatarConfig.avatarSize,
                  canDelete: parentComment.authorId === currentUser.id,
                  canEdit: parentComment.authorId === currentUser.id,
                  comment: parentComment,
                  currentUser,
                  hasError: ((_c = parentComment._state) == null ? void 0 : _c.type) === "createError",
                  hasReferencedValue,
                  intent: (_d = parentComment.context) == null ? void 0 : _d.intent,
                  isParent: true,
                  isRetrying: ((_e = parentComment._state) == null ? void 0 : _e.type) === "createRetrying",
                  mentionOptions,
                  mode,
                  onCopyLink,
                  onCreateRetry,
                  onDelete,
                  onEdit,
                  onInputKeyDown: onKeyDown,
                  onReactionSelect,
                  onStatusChange,
                  readOnly,
                  withAvatar: avatarConfig.parentCommentAvatar
                }
              ) }),
              showCollapseButton && !didExpand.current && (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, paddingY: 1, sizing: "border", children: [
                (0, import_jsx_runtime.jsx)(SpacerAvatar, {}),
                (0, import_jsx_runtime.jsx)(
                  ExpandButton,
                  {
                    iconRight: ChevronDownIcon,
                    mode: "bleed",
                    onClick: handleExpand,
                    text: expandButtonText
                  }
                )
              ] }),
              renderedReplies,
              canReply && (0, import_jsx_runtime.jsx)(
                CommentInput,
                {
                  avatarSize: avatarConfig.avatarSize,
                  currentUser,
                  expandOnFocus: true,
                  mentionOptions,
                  onChange: setValue,
                  onDiscardCancel: cancelDiscard,
                  onDiscardConfirm: confirmDiscard,
                  onKeyDown: handleInputKeyDown,
                  onSubmit: handleReplySubmit,
                  placeholder: t(mode === "upsell" ? "compose.reply-placeholder-upsell" : "compose.reply-placeholder"),
                  readOnly: readOnly || mode === "upsell",
                  ref: replyInputRef,
                  value,
                  withAvatar: avatarConfig.replyAvatar
                }
              )
            ]
          }
        )
      ]
    }
  );
});
function getEmptyStateMessages(t) {
  return {
    open: {
      title: t("list-status.empty-state-open-title"),
      message: t("list-status.empty-state-open-text")
    },
    resolved: {
      title: t("list-status.empty-state-resolved-title"),
      message: t("list-status.empty-state-resolved-text")
    }
  };
}
function CommentsListStatus(props) {
  const { status, error, loading, hasNoComments } = props, { t } = useTranslation2(commentsLocaleNamespace), emptyStateMessages = getEmptyStateMessages(t);
  return error ? (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("list-status.error") }) }) }) : loading ? (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t("list-status.loading") }) : hasNoComments ? (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: (0, import_jsx_runtime.jsx)(Container, { width: 0, padding: 4, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, weight: "medium", children: emptyStateMessages[status].title }),
    (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: emptyStateMessages[status].message })
  ] }) }) }) : null;
}
function CreateNewThreadInput(props) {
  const {
    currentUser,
    fieldTitle,
    mentionOptions,
    mode,
    onBlur,
    onFocus,
    onKeyDown,
    onNewThreadCreate,
    readOnly
  } = props, { t } = useTranslation2(commentsLocaleNamespace), [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$b), commentInputHandle = (0, import_react2.useRef)(null), handleSubmit = (0, import_react2.useCallback)(() => {
    onNewThreadCreate == null || onNewThreadCreate(value), setValue(EMPTY_ARRAY$b);
  }, [onNewThreadCreate, value]), hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), startDiscard = (0, import_react2.useCallback)(() => {
    var _a;
    hasValue && ((_a = commentInputHandle.current) == null || _a.discardDialogController.open());
  }, [hasValue]), handleInputKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onKeyDown && onKeyDown(event));
    },
    [onKeyDown, startDiscard]
  ), confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a, _b;
    setValue(EMPTY_ARRAY$b), (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), (_b = commentInputHandle.current) == null || _b.focus();
  }, []), cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), placeholder = mode === "upsell" ? t("compose.add-comment-input-placeholder-upsell") : (0, import_jsx_runtime.jsx)(
    Translate,
    {
      t,
      i18nKey: "compose.add-comment-input-placeholder",
      values: { field: fieldTitle }
    }
  );
  return (0, import_jsx_runtime.jsx)(
    CommentInput,
    {
      currentUser,
      expandOnFocus: true,
      mentionOptions,
      onBlur,
      onChange: setValue,
      onDiscardCancel: cancelDiscard,
      onDiscardConfirm: confirmDiscard,
      onKeyDown: handleInputKeyDown,
      onFocus,
      onSubmit: handleSubmit,
      placeholder,
      readOnly: readOnly || mode === "upsell",
      ref: commentInputHandle,
      value
    }
  );
}
var HeaderFlex = ut(Flex)`
  min-height: 25px;
`;
var BreadcrumbsButton = ut(Button)(({ theme }) => {
  const fg = theme.sanity.color.base.fg;
  return at`
    --card-fg-color: ${fg};

    // The width is needed to make the text ellipsis work
    // in the breadcrumbs component
    max-width: 100%;
  `;
});
function CommentThreadLayout(props) {
  const {
    breadcrumbs,
    canCreateNewThread,
    children,
    currentUser,
    fieldPath,
    isSelected,
    mentionOptions,
    mode,
    onNewThreadCreate,
    onPathSelect,
    readOnly
  } = props, { t } = useTranslation2(commentsLocaleNamespace), handleNewThreadCreate = (0, import_react2.useCallback)(
    (payload) => {
      const nextComment = {
        message: payload,
        parentCommentId: void 0,
        status: "open",
        // Since this is a new comment, we generate a new thread ID
        threadId: v4_default(),
        // New comments have no reactions
        reactions: [],
        payload: {
          fieldPath
        }
      };
      onNewThreadCreate == null || onNewThreadCreate(nextComment);
    },
    [onNewThreadCreate, fieldPath]
  ), handleBreadcrumbsClick = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      });
    },
    [fieldPath, onPathSelect]
  ), handleNewThreadClick = (0, import_react2.useCallback)(
    (e2) => {
      e2.stopPropagation(), e2.detail !== 0 && (onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      }));
    },
    [fieldPath, onPathSelect]
  ), crumbsTitlePath = (0, import_react2.useMemo)(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]), lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
    (0, import_jsx_runtime.jsx)(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime.jsx)(
      BreadcrumbsButton,
      {
        "aria-label": t("list-item.breadcrumb-button-go-to-field-aria-label", {
          field: lastCrumb
        }),
        mode: "bleed",
        onClick: handleBreadcrumbsClick,
        padding: 2,
        space: 2,
        children: (0, import_jsx_runtime.jsx)(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath })
      }
    ) }) }) }),
    canCreateNewThread && (0, import_jsx_runtime.jsx)(ThreadCard, { onClick: handleNewThreadClick, "data-active": isSelected, children: (0, import_jsx_runtime.jsx)(
      CreateNewThreadInput,
      {
        currentUser,
        fieldTitle: lastCrumb,
        mentionOptions,
        mode,
        onNewThreadCreate: handleNewThreadCreate,
        readOnly
      }
    ) }),
    (0, import_jsx_runtime.jsx)(Stack, { space: 2, children })
  ] });
}
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    return acc[field] || (acc[field] = []), acc[field].push(comment), acc;
  }, {});
}
var CommentsListInner = (0, import_react2.forwardRef)(function(props, ref) {
  const {
    beforeListNode,
    comments: comments2,
    currentUser,
    error,
    loading,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onNewThreadCreate,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    readOnly,
    selectedPath,
    status
  } = props, [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null), groupedThreads = (0, import_react2.useMemo)(() => Object.entries(groupThreads(comments2)), [comments2]), showComments = !loading && !error && groupedThreads.length > 0;
  return (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      "data-testid": "comments-list",
      direction: "column",
      flex: 1,
      height: "fill",
      overflow: "hidden",
      ref: setBoundaryElement,
      sizing: "border",
      children: [
        mode !== "upsell" && (0, import_jsx_runtime.jsx)(
          CommentsListStatus,
          {
            error,
            hasNoComments: groupedThreads.length === 0,
            loading,
            status
          }
        ),
        (showComments || beforeListNode) && (0, import_jsx_runtime.jsxs)(
          Stack,
          {
            as: "ul",
            flex: 1,
            overflow: "auto",
            padding: 3,
            paddingTop: 1,
            paddingBottom: 6,
            sizing: "border",
            space: 1,
            ref,
            children: [
              beforeListNode,
              (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map(([fieldPath, group]) => {
                const breadcrumbs = group[0].breadcrumbs, firstThreadId = group[0].threadId, newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
                return (0, import_jsx_runtime.jsx)(
                  Stack,
                  {
                    as: "li",
                    paddingTop: 3,
                    ...applyCommentsGroupAttr(firstThreadId),
                    children: (0, import_jsx_runtime.jsx)(
                      CommentThreadLayout,
                      {
                        breadcrumbs,
                        canCreateNewThread: status === "open",
                        currentUser,
                        fieldPath,
                        isSelected: newThreadSelected,
                        mentionOptions,
                        mode,
                        onNewThreadCreate,
                        onPathSelect,
                        readOnly,
                        children: group.map((item) => {
                          var _a, _b, _c;
                          const replies = item.replies.slice().reverse(), canReply = status === "open" && ((_a = item.parentComment._state) == null ? void 0 : _a.type) !== "createError" && ((_b = item.parentComment._state) == null ? void 0 : _b.type) !== "createRetrying", threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === ((_c = item.parentComment.target.path) == null ? void 0 : _c.field);
                          return (0, import_jsx_runtime.jsx)(
                            CommentsListItem,
                            {
                              canReply,
                              currentUser,
                              hasReferencedValue: item.hasReferencedValue,
                              isSelected: threadIsSelected,
                              mentionOptions,
                              mode,
                              onCopyLink,
                              onCreateRetry,
                              onDelete,
                              onEdit,
                              onPathSelect,
                              onReactionSelect,
                              onReply,
                              onStatusChange,
                              parentComment: item.parentComment,
                              readOnly,
                              replies
                            },
                            item.parentComment._id
                          );
                        })
                      },
                      fieldPath
                    )
                  },
                  fieldPath
                );
              }) })
            ]
          }
        )
      ]
    }
  );
});
var CommentsList = (0, import_react2.memo)(CommentsListInner);
var Root$9 = ut(Box)`
  max-width: 280px;
`;
var fadeInKeyFrame = ht`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
var StyledPopover = ut(Popover2)`
  opacity: 0;
  // Fade in the popover after 500ms
  animation: ${fadeInKeyFrame} 200ms 500ms forwards;
`;
function CommentsOnboardingPopover(props) {
  const { onDismiss } = props, { t } = useTranslation2(commentsLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(
    StyledPopover,
    {
      content: (0, import_jsx_runtime.jsx)(Root$9, { padding: 4, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
        (0, import_jsx_runtime.jsx)(Text, { weight: "medium", size: 1, children: t("onboarding.header") }),
        (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("onboarding.body") }),
        (0, import_jsx_runtime.jsx)(Flex, { justify: "flex-end", marginTop: 2, children: (0, import_jsx_runtime.jsx)(Button2, { text: t("onboarding.dismiss"), tone: "primary", onClick: onDismiss }) })
      ] }) }),
      open: true,
      portal: true,
      ...props
    }
  );
}
var StyledButton$1 = ut(Button2)(({ theme }) => {
  const { space } = getTheme_v2(theme);
  return `
      position: absolute;
      top: ${space[3]}px;
      right: ${space[3]}px;
      z-index: 20;
      background: transparent;
      border-radius: 9999px;
      box-shadow: none;
      color: ${white.hex};
      --card-fg-color: ${white.hex};
      :hover {
        --card-fg-color: ${white.hex};
      }
    `;
});
var Image$1 = ut.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 200px;
`;
function CommentsUpsellDialog(props) {
  var _a, _b, _c;
  const { data, onClose, onPrimaryClick, onSecondaryClick } = props;
  return (0, import_jsx_runtime.jsxs)(
    Dialog2,
    {
      id: "comments-upsell",
      onClose,
      onClickOutside: onClose,
      __unstable_hideCloseButton: true,
      bodyHeight: "fill",
      padding: false,
      footer: {
        cancelButton: (_a = data.secondaryButton) != null && _a.text ? {
          text: data.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          iconRight: LaunchIcon,
          ...data.secondaryButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.secondaryButton.url
          },
          onClick: onSecondaryClick
        } : void 0,
        confirmButton: {
          text: (_b = data.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...data.ctaButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.ctaButton.url
          },
          onClick: onPrimaryClick
        }
      },
      children: [
        (0, import_jsx_runtime.jsx)(
          StyledButton$1,
          {
            icon: CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: onClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        data.image && (0, import_jsx_runtime.jsx)(Image$1, { src: data.image.asset.url, alt: (_c = data.image.asset.altText) != null ? _c : "" }),
        (0, import_jsx_runtime.jsx)(Box, { padding: 3, marginTop: 2, children: (0, import_jsx_runtime.jsx)(Stack, { space: 4, paddingBottom: 2, children: (0, import_jsx_runtime.jsx)(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }) })
      ]
    }
  );
}
var Image = ut.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
`;
function CommentsUpsellPanel(props) {
  var _a;
  const { data, onPrimaryClick, onSecondaryClick } = props;
  return (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { marginBottom: 6, children: (0, import_jsx_runtime.jsxs)(Card, { radius: 3, overflow: "hidden", border: true, children: [
    data.image && (0, import_jsx_runtime.jsx)(Image, { src: data.image.asset.url, alt: (_a = data.image.asset.altText) != null ? _a : "" }),
    (0, import_jsx_runtime.jsxs)(Box, { padding: 3, marginTop: 2, children: [
      (0, import_jsx_runtime.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime.jsx)(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }),
      (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, justify: "flex-end", marginTop: 5, children: [
        (0, import_jsx_runtime.jsx)(
          Button2,
          {
            mode: "bleed",
            text: data.secondaryButton.text,
            tone: "primary",
            iconRight: LaunchIcon,
            ...data.secondaryButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.secondaryButton.url
            },
            onClick: onSecondaryClick
          }
        ),
        (0, import_jsx_runtime.jsx)(
          Button2,
          {
            text: data.ctaButton.text,
            tone: "primary",
            ...data.ctaButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.ctaButton.url
            },
            onClick: onPrimaryClick
          }
        )
      ] })
    ] })
  ] }) }) });
}
function CommentsDocumentLayout(props) {
  const { documentId, documentType } = props;
  return (0, import_jsx_runtime.jsx)(CommentsEnabledProvider, { documentId, documentType, children: (0, import_jsx_runtime.jsx)(CommentsDocumentLayoutInner, { ...props }) });
}
function CommentsDocumentLayoutInner(props) {
  const { documentId, documentType } = props, commentsEnabled = useCommentsEnabled(), { openInspector, inspector } = useDocumentPane(), handleOpenCommentsInspector = (0, import_react2.useCallback)(() => {
    (inspector == null ? void 0 : inspector.name) !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  return commentsEnabled.enabled ? (0, import_jsx_runtime.jsx)(
    CommentsProvider,
    {
      documentId,
      documentType,
      isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME,
      onCommentsOpen: handleOpenCommentsInspector,
      sortOrder: "desc",
      type: "field",
      children: (0, import_jsx_runtime.jsx)(CommentsSelectedPathProvider, { children: (0, import_jsx_runtime.jsx)(CommentsAuthoringPathProvider, { children: props.renderDefault(props) }) })
    }
  ) : props.renderDefault(props);
}
var ContentStack = ut(Stack)`
  width: 320px;
`;
function CommentsFieldButton(props) {
  const {
    count,
    currentUser,
    fieldTitle,
    isCreatingDataset,
    mentionOptions,
    onChange,
    onClick,
    onClose,
    onCommentAdd,
    onDiscard,
    onInputKeyDown,
    open,
    value
  } = props, { t } = useTranslation2(commentsLocaleNamespace), [popoverElement, setPopoverElement] = (0, import_react2.useState)(null), [addCommentButtonElement, setAddCommentButtonElement] = (0, import_react2.useState)(
    null
  ), commentInputHandle = (0, import_react2.useRef)(null), hasComments = count > 0, closePopover = (0, import_react2.useCallback)(() => {
    open && (onClose(), addCommentButtonElement == null || addCommentButtonElement.focus());
  }, [addCommentButtonElement, open, onClose]), handleSubmit = (0, import_react2.useCallback)(() => {
    onCommentAdd(), closePopover();
  }, [closePopover, onCommentAdd]), hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), startDiscard = (0, import_react2.useCallback)(() => {
    var _a;
    if (!hasValue) {
      closePopover();
      return;
    }
    (_a = commentInputHandle.current) == null || _a.discardDialogController.open();
  }, [closePopover, hasValue]), handleInputKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.isDefaultPrevented() || onInputKeyDown && onInputKeyDown(event);
    },
    [onInputKeyDown]
  ), handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), closePopover(), onDiscard();
  }, [closePopover, onDiscard]), handlePopoverKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), handleClickOutside = (0, import_react2.useCallback)(() => {
    open && startDiscard();
  }, [open, startDiscard]);
  return useClickOutside(handleClickOutside, [popoverElement]), hasComments ? (0, import_jsx_runtime.jsx)(Tooltip, { portal: true, placement: "top", content: t("field-button.content", { count }), children: (0, import_jsx_runtime.jsx)(
    Button,
    {
      "aria-label": t("field-button.aria-label-open"),
      mode: "bleed",
      onClick,
      padding: 2,
      space: 2,
      children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(CommentIcon2, {}) }),
        (0, import_jsx_runtime.jsx)(Text, { size: 0, children: count > 9 ? "9+" : count })
      ] })
    }
  ) }) : (0, import_jsx_runtime.jsx)(
    Popover2,
    {
      constrainSize: true,
      content: (0, import_jsx_runtime.jsx)(ContentStack, { padding: 2, space: 4, children: (0, import_jsx_runtime.jsx)(
        CommentInput,
        {
          currentUser,
          focusLock: true,
          focusOnMount: true,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onKeyDown: handleInputKeyDown,
          onSubmit: handleSubmit,
          placeholder: (0, import_jsx_runtime.jsx)(
            Translate,
            {
              t,
              i18nKey: "compose.add-comment-input-placeholder",
              values: { field: fieldTitle }
            }
          ),
          readOnly: isCreatingDataset,
          ref: commentInputHandle,
          value
        }
      ) }),
      fallbackPlacements: ["bottom-end"],
      open,
      placement: "right-start",
      portal: true,
      ref: setPopoverElement,
      onKeyDown: handlePopoverKeyDown,
      children: (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          "aria-label": t("field-button.aria-label-add"),
          disabled: isCreatingDataset,
          icon: AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setAddCommentButtonElement,
          selected: open,
          tooltipProps: {
            content: t("field-button.title"),
            placement: "top"
          }
        }
      ) })
    }
  );
}
var messageCache = /* @__PURE__ */ new Map();
var EMPTY_ARRAY$9 = [];
var HIGHLIGHT_BLOCK_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
};
function CommentsField(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(CommentFieldInner, { ...props, mode }) : props.renderDefault(props);
}
var HighlightDiv = ut(motion.div)(({ theme }) => {
  const { radius, space, color } = theme.sanity, bg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][color.dark ? 900 : 50].hex;
  return at`
    mix-blend-mode: ${color.dark ? "screen" : "multiply"};
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    left: -${space[2]}px;
    bottom: -${space[2]}px;
    right: -${space[2]}px;
    pointer-events: none;
    position: absolute;
    z-index: 1;
    width: calc(100% + ${space[2] * 2}px);
    height: calc(100% + ${space[2] * 2}px);
    background-color: ${bg};
  `;
});
var FieldStack = ut(Stack)`
  position: relative;
`;
function CommentFieldInner(props) {
  const { mode } = props, currentUser = useCurrentUser(), { element: boundaryElement } = useBoundaryElement(), rootRef = (0, import_react2.useRef)(null), {
    comments: comments2,
    isCommentsOpen,
    isCreatingDataset,
    mentionOptions,
    onCommentsOpen,
    operation,
    setStatus,
    status
  } = useComments(), { upsellData, handleOpenDialog } = useCommentsUpsell(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { authoringPath, setAuthoringPath } = useCommentsAuthoringPath(), { scrollToGroup } = useCommentsScroll({
    boundaryElement
  }), fieldTitle = (0, import_react2.useMemo)(() => getSchemaTypeTitle(props.schemaType), [props.schemaType]), stringPath = (0, import_react2.useMemo)(() => toString(props.path), [props.path]), cachedValue = messageCache.get(stringPath) || null, [value, setValue] = (0, import_react2.useState)(cachedValue), isOpen = (0, import_react2.useMemo)(() => authoringPath === stringPath, [authoringPath, stringPath]), isSelected = (0, import_react2.useMemo)(() => !isCommentsOpen || (selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url" ? false : (selectedPath == null ? void 0 : selectedPath.fieldPath) === stringPath, [isCommentsOpen, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin, stringPath]), isInlineCommentThread = (0, import_react2.useMemo)(() => comments2.data.open.filter((c) => c.threadId === (selectedPath == null ? void 0 : selectedPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)), [comments2.data.open, selectedPath == null ? void 0 : selectedPath.threadId]), count = (0, import_react2.useMemo)(() => comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0) || 0, [comments2.data.open, stringPath]), hasComments = count > 0, resetMessageValue = (0, import_react2.useCallback)(() => {
    setValue(null), messageCache.delete(stringPath);
  }, [stringPath]), handleClick = (0, import_react2.useCallback)(() => {
    var _a;
    if (hasComments) {
      status === "resolved" && setStatus("open"), setAuthoringPath(null), onCommentsOpen == null || onCommentsOpen();
      const scrollToThreadId = (_a = comments2.data.open.find(
        (c) => c.fieldPath === toString(props.path)
      )) == null ? void 0 : _a.threadId;
      scrollToThreadId && (setSelectedPath({
        threadId: scrollToThreadId,
        origin: "form",
        fieldPath: toString(props.path)
      }), scrollToGroup(scrollToThreadId));
      return;
    }
    if (mode === "upsell") {
      upsellData ? handleOpenDialog("field_action") : onCommentsOpen == null || onCommentsOpen();
      return;
    }
    setAuthoringPath(isOpen ? null : stringPath);
  }, [
    comments2.data.open,
    handleOpenDialog,
    hasComments,
    isOpen,
    mode,
    onCommentsOpen,
    props.path,
    scrollToGroup,
    setAuthoringPath,
    setSelectedPath,
    setStatus,
    status,
    stringPath,
    upsellData
  ]), handleCommentAdd = (0, import_react2.useCallback)(() => {
    if (value) {
      const newThreadId = v4_default(), nextComment = {
        type: "field",
        fieldPath: toString(props.path),
        message: value,
        parentCommentId: void 0,
        status: "open",
        threadId: newThreadId,
        // New comments have no reactions
        reactions: EMPTY_ARRAY$9
      };
      operation.create(nextComment), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), resetMessageValue(), setSelectedPath({
        threadId: newThreadId,
        origin: "form",
        fieldPath: toString(props.path)
      }), scrollToGroup(newThreadId);
    }
  }, [
    onCommentsOpen,
    operation,
    props.path,
    resetMessageValue,
    scrollToGroup,
    setSelectedPath,
    setStatus,
    status,
    value
  ]), handleClose = (0, import_react2.useCallback)(() => setAuthoringPath(null), [setAuthoringPath]), handleOnChange = (0, import_react2.useCallback)(
    (nextValue) => {
      setValue(nextValue), messageCache.set(stringPath, nextValue);
    },
    [stringPath]
  ), internalComments = (0, import_react2.useMemo)(
    () => ({
      button: currentUser && (0, import_jsx_runtime.jsx)(
        CommentsFieldButton,
        {
          count: Number(count),
          currentUser,
          fieldTitle,
          isCreatingDataset,
          mentionOptions,
          onChange: handleOnChange,
          onClick: handleClick,
          onClose: handleClose,
          onCommentAdd: handleCommentAdd,
          onDiscard: resetMessageValue,
          open: isOpen,
          value
        }
      ),
      hasComments,
      isAddingComment: isOpen
    }),
    [
      currentUser,
      count,
      fieldTitle,
      isCreatingDataset,
      mentionOptions,
      handleOnChange,
      handleClick,
      handleClose,
      handleCommentAdd,
      resetMessageValue,
      isOpen,
      value,
      hasComments
    ]
  );
  return (0, import_jsx_runtime.jsxs)(FieldStack, { ...applyCommentsFieldAttr(toString(props.path)), ref: rootRef, children: [
    props.renderDefault({
      ...props,
      // eslint-disable-next-line camelcase
      __internal_comments: internalComments
    }),
    (0, import_jsx_runtime.jsx)(AnimatePresence, { children: isSelected && !isInlineCommentThread && (0, import_jsx_runtime.jsx)(
      HighlightDiv,
      {
        animate: "animate",
        exit: "exit",
        initial: "initial",
        variants: HIGHLIGHT_BLOCK_VARIANTS
      }
    ) })
  ] });
}
function createDomRectFromElements(elements) {
  if (!elements || !elements.length)
    return null;
  const rects = elements.map((el) => el.getBoundingClientRect()), minX = Math.min(...rects.map((r) => r.x)) || 0, minY = Math.min(...rects.map((r) => r.y)) || 0, maxRight = Math.max(...rects.map((r) => r.right)) || 0, maxBottom = Math.max(...rects.map((r) => r.bottom)) || 0;
  return {
    x: minX,
    y: minY,
    width: maxRight - minX,
    height: maxBottom - minY,
    top: minY,
    right: maxRight,
    bottom: maxBottom,
    left: minX
  };
}
function useRectFromElements(props) {
  const { scrollElement, disabled, selector } = props, [rect, setRect] = (0, import_react2.useState)(null), handleSetRect = (0, import_react2.useCallback)(() => {
    const elements = document == null ? void 0 : document.querySelectorAll(selector);
    if (!elements)
      return;
    const nextRect = createDomRectFromElements(Array.from(elements));
    setRect(nextRect);
  }, [selector]);
  return (0, import_react2.useEffect)(() => {
    if (disabled)
      return;
    const timeout = setTimeout(() => {
      handleSetRect();
    }, 1);
    return () => {
      clearTimeout(timeout);
    };
  }, [handleSetRect, disabled]), (0, import_react2.useEffect)(() => {
    if (!(disabled || !scrollElement))
      return scrollElement.addEventListener("wheel", handleSetRect), () => {
        scrollElement.removeEventListener("wheel", handleSetRect);
      };
  }, [handleSetRect, disabled, scrollElement]), rect;
}
function useAuthoringReferenceElement(props) {
  const { scrollElement, disabled, selector } = props, rect = useRectFromElements({
    scrollElement,
    disabled,
    selector
  });
  return (0, import_react2.useMemo)(() => rect ? {
    getBoundingClientRect: () => rect
  } : null, [rect]);
}
function getSelectionBoundingRect() {
  const selection = window.getSelection(), range = selection == null ? void 0 : selection.getRangeAt(0);
  return (range == null ? void 0 : range.getBoundingClientRect()) || null;
}
var MotionPopover$1 = ut(motion(Popover2))`
  user-select: none;
`;
var POPOVER_FALLBACK_PLACEMENTS$2 = ["bottom", "top"];
var VARIANTS$4 = {
  hidden: { opacity: 0, y: -4 },
  visible: { opacity: 1, y: 0 }
};
function FloatingButtonPopover(props) {
  const { disabled, onClick, onClickOutside, referenceElement } = props, [popoverElement, setPopoverElement] = (0, import_react2.useState)(null), { t } = useTranslation(commentsLocaleNamespace);
  useClickOutside(onClickOutside, [popoverElement]);
  const disabledText = t("inline-add-comment-button.disabled-overlap-title"), enabledText = t("inline-add-comment-button.title");
  return (0, import_jsx_runtime.jsx)(
    MotionPopover$1,
    {
      animate: "visible",
      content: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          "data-testid": "inline-comment-button",
          disabled,
          icon: disabled ? CommentDisabledIcon : AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setPopoverElement,
          text: disabled ? disabledText : enabledText
        }
      ),
      contentEditable: false,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2,
      initial: "hidden",
      open: true,
      padding: 1,
      placement: "bottom",
      portal: true,
      referenceElement,
      variants: VARIANTS$4
    }
  );
}
var POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"];
var MotionPopover = motion(Popover2);
var RootStack = ut(Stack)`
  width: 250px;
`;
var VARIANTS$3 = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};
function InlineCommentInputPopover(props) {
  const {
    currentUser,
    mentionOptions,
    onChange,
    onClickOutside,
    onDiscardConfirm,
    onSubmit,
    referenceElement,
    value
  } = props, commentInputRef = (0, import_react2.useRef)(null), [contentElement, setContentElement] = (0, import_react2.useState)(null), handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close(), onDiscardConfirm();
  }, [onDiscardConfirm]), handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close();
  }, []), handleClickOutside = (0, import_react2.useCallback)(() => {
    var _a;
    if (hasCommentMessageValue(value)) {
      (_a = commentInputRef.current) == null || _a.discardDialogController.open();
      return;
    }
    onClickOutside();
  }, [onClickOutside, value]);
  return useClickOutside(handleClickOutside, [contentElement]), (0, import_jsx_runtime.jsx)(
    MotionPopover,
    {
      animate: "visible",
      content: (0, import_jsx_runtime.jsx)(RootStack, { padding: 2, ref: setContentElement, children: (0, import_jsx_runtime.jsx)(
        CommentInput,
        {
          currentUser,
          focusLock: true,
          focusOnMount: true,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onSubmit,
          ref: commentInputRef,
          value
        }
      ) }),
      "data-ui": "InlineCommentInputPopover",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1,
      initial: "hidden",
      open: true,
      placement: "bottom",
      portal: true,
      referenceElement,
      variants: VARIANTS$3
    }
  );
}
var EMPTY_ARRAY$8 = [];
var AI_ASSIST_TYPE = "sanity.assist.instruction.prompt";
function CommentsPortableTextInput(props) {
  const { enabled, mode } = useCommentsEnabled(), isAiAssist = props.schemaType.name === AI_ASSIST_TYPE;
  return !enabled || isAiAssist ? props.renderDefault(props) : (0, import_jsx_runtime.jsx)(CommentsPortableTextInputInner, { ...props, mode });
}
var CommentsPortableTextInputInner = import_react2.default.memo(function(props) {
  var _a, _b;
  const { mode } = props, currentUser = useCurrentUser(), portal = usePortal(), { comments: comments2, getComment, mentionOptions, onCommentsOpen, operation, setStatus, status } = useComments(), { setSelectedPath, selectedPath } = useCommentsSelectedPath(), { scrollToComment, scrollToGroup } = useCommentsScroll(), { handleOpenDialog } = useCommentsUpsell(), editorRef = (0, import_react2.useRef)(null), mouseDownRef = (0, import_react2.useRef)(false), [nextCommentValue, setNextCommentValue] = (0, import_react2.useState)(null), [nextCommentSelection, setNextCommentSelection] = (0, import_react2.useState)(null), [currentSelection, setCurrentSelection] = (0, import_react2.useState)(null), [currentSelectionRect, setCurrenSelectionRect] = (0, import_react2.useState)(null), [currentHoveredCommentId, setCurrentHoveredCommentId] = (0, import_react2.useState)(null), [canSubmit, setCanSubmit] = (0, import_react2.useState)(false), [rootElement, setRootElement] = (0, import_react2.useState)(null), [isFullScreen, setIsFullScreen] = (0, import_react2.useState)(false), [addedCommentsDecorations, setAddedCommentsDecorations] = (0, import_react2.useState)(EMPTY_ARRAY$8), stringFieldPath = (0, import_react2.useMemo)(() => toString(props.path), [props.path]), handleSetCurrentSelectionRect = (0, import_react2.useCallback)(() => {
    const rect = getSelectionBoundingRect();
    setCurrenSelectionRect(rect);
  }, []), resetStates = (0, import_react2.useCallback)(() => {
    setCurrentSelection(null), setCurrenSelectionRect(null), setNextCommentSelection(null), setNextCommentValue(null), setCanSubmit(false);
  }, []), handleSelectCurrentSelection = (0, import_react2.useCallback)(() => {
    if (mode === "upsell") {
      handleOpenDialog("pte");
      return;
    }
    setNextCommentSelection(currentSelection);
  }, [currentSelection, handleOpenDialog, mode]), handleCommentDiscardConfirm = (0, import_react2.useCallback)(() => {
    resetStates();
  }, [resetStates]), textComments = (0, import_react2.useMemo)(() => comments2.data.open.filter((comment) => comment.fieldPath === stringFieldPath).filter((c) => isTextSelectionComment(c.parentComment)).map((c) => c.parentComment), [comments2.data.open, stringFieldPath]), getFragment = (0, import_react2.useCallback)(() => editorRef.current ? PortableTextEditor.getFragment(editorRef.current) : EMPTY_ARRAY$8, []), handleSubmit = (0, import_react2.useCallback)(() => {
    if (!nextCommentSelection || !editorRef.current)
      return;
    const fragment = getFragment() || EMPTY_ARRAY$8, editorValue = PortableTextEditor.getValue(editorRef.current);
    if (!editorValue)
      return;
    const textSelection = buildTextSelectionFromFragment({
      fragment,
      selection: nextCommentSelection,
      value: editorValue
    }), threadId = v4_default();
    operation.create({
      type: "field",
      contentSnapshot: fragment,
      fieldPath: stringFieldPath,
      message: nextCommentValue,
      parentCommentId: void 0,
      reactions: EMPTY_ARRAY$8,
      selection: textSelection,
      status: "open",
      threadId
    }), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), setSelectedPath({
      fieldPath: stringFieldPath,
      threadId,
      origin: "form"
    }), scrollToGroup(threadId), resetStates();
  }, [
    nextCommentSelection,
    getFragment,
    operation,
    stringFieldPath,
    nextCommentValue,
    onCommentsOpen,
    status,
    setSelectedPath,
    scrollToGroup,
    resetStates,
    setStatus
  ]), handleDecoratorClick = (0, import_react2.useCallback)(
    (commentId) => {
      var _a2;
      const comment = getComment(commentId);
      comment && (setSelectedPath({
        fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || "",
        threadId: comment.threadId,
        origin: "form"
      }), onCommentsOpen == null || onCommentsOpen(), scrollToComment(comment._id));
    },
    [getComment, onCommentsOpen, scrollToComment, setSelectedPath]
  ), handleSelectionChange = (0, import_react2.useCallback)(
    (selection) => {
      const isRangeSelected = (selection == null ? void 0 : selection.anchor.offset) !== (selection == null ? void 0 : selection.focus.offset), fragment = getFragment();
      if (!(fragment != null && fragment.every(isPortableTextTextBlock)) || !isRangeSelected) {
        setCanSubmit(false);
        return;
      }
      mouseDownRef.current || handleSetCurrentSelectionRect(), setCurrentSelection(selection), setCanSubmit(true);
    },
    [getFragment, handleSetCurrentSelectionRect]
  ), debounceSelectionChange = (0, import_react2.useMemo)(
    () => (0, import_debounce.default)(handleSelectionChange, 200),
    [handleSelectionChange]
  ), handleMouseDown = (0, import_react2.useCallback)(() => {
    mouseDownRef.current = true;
  }, []), handleMouseUp = (0, import_react2.useCallback)(() => {
    mouseDownRef.current = false, handleSetCurrentSelectionRect();
  }, [handleSetCurrentSelectionRect]), handleRangeDecorationMoved = (0, import_react2.useCallback)((details) => {
    var _a2;
    const { rangeDecoration, newSelection } = details, commentId = (_a2 = rangeDecoration.payload) == null ? void 0 : _a2.commentId;
    setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a3;
      return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === commentId ? {
        ...rangeDecoration,
        selection: newSelection,
        payload: { ...rangeDecoration.payload, dirty: true }
      } : p;
    }));
  }, []), updateCommentRange = (0, import_react2.useCallback)(() => {
    const decoratorsToUpdate = addedCommentsDecorations.filter(
      (decorator) => {
        var _a2;
        return (_a2 = decorator.payload) == null ? void 0 : _a2.dirty;
      }
    );
    decoratorsToUpdate.length !== 0 && (decoratorsToUpdate.forEach((decorator) => {
      var _a2, _b2, _c, _d, _e;
      const commentId = (_a2 = decorator.payload) == null ? void 0 : _a2.commentId, comment = getComment(commentId || "");
      if (!comment || !editorRef.current)
        return;
      const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8, [updatedDecoration] = buildRangeDecorationSelectionsFromComments({
        comments: [comment],
        value: editorValue
      }), nextRange = updatedDecoration != null && updatedDecoration.range ? [updatedDecoration.range] : EMPTY_ARRAY$8, nextValue = updatedDecoration ? [
        ...((_c = (_b2 = comment.target.path) == null ? void 0 : _b2.selection) == null ? void 0 : _c.value.filter((r) => {
          var _a3;
          return r._key !== ((_a3 = nextRange[0]) == null ? void 0 : _a3._key);
        }).concat(nextRange).flat()) || EMPTY_ARRAY$8
      ] : EMPTY_ARRAY$8, nextComment = {
        target: {
          ...comment.target,
          path: {
            ...((_d = comment.target) == null ? void 0 : _d.path) || {},
            field: ((_e = comment.target.path) == null ? void 0 : _e.field) || "",
            selection: {
              type: "text",
              value: nextValue
            }
          }
        }
      };
      operation.update(comment._id, nextComment);
    }), setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a2, _b2;
      return (_b2 = (_a2 = decoratorsToUpdate.find(
        (d) => {
          var _a3, _b3;
          return ((_a3 = d.payload) == null ? void 0 : _a3.commentId) === ((_b3 = p.payload) == null ? void 0 : _b3.commentId);
        }
      )) == null ? void 0 : _a2.payload) != null && _b2.dirty ? {
        ...p,
        payload: { ...p.payload, dirty: false }
      } : p;
    }).filter((p) => p.selection !== null)));
  }, [addedCommentsDecorations, getComment, operation]), handleBuildRangeDecorations = (0, import_react2.useCallback)(
    (commentsToDecorate) => {
      if (!editorRef.current)
        return EMPTY_ARRAY$8;
      const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8;
      return buildRangeDecorations({
        comments: commentsToDecorate,
        currentHoveredCommentId,
        onDecorationClick: handleDecoratorClick,
        onDecorationHoverEnd: setCurrentHoveredCommentId,
        onDecorationHoverStart: setCurrentHoveredCommentId,
        onDecorationMoved: handleRangeDecorationMoved,
        selectedThreadId: (selectedPath == null ? void 0 : selectedPath.threadId) || null,
        value: editorValue
      });
    },
    [
      currentHoveredCommentId,
      handleDecoratorClick,
      handleRangeDecorationMoved,
      selectedPath == null ? void 0 : selectedPath.threadId
    ]
  ), onEditorChange = (0, import_react2.useCallback)(
    (change) => {
      change.type === "mutation" && updateCommentRange(), change.type === "selection" && debounceSelectionChange(change.selection);
    },
    [debounceSelectionChange, updateCommentRange]
  ), authoringDecoration = (0, import_react2.useMemo)(() => nextCommentSelection ? {
    component: ({ children }) => (0, import_jsx_runtime.jsx)(CommentInlineHighlightSpan, { isAuthoring: true, children }),
    selection: nextCommentSelection
  } : null, [nextCommentSelection]), rangeDecorations = (0, import_react2.useMemo)(() => [
    // Existing range decorations
    ...(props == null ? void 0 : props.rangeDecorations) || EMPTY_ARRAY$8,
    // The range decoration when adding a comment
    ...authoringDecoration ? [authoringDecoration] : EMPTY_ARRAY$8,
    // The range decorations for existing comments
    ...addedCommentsDecorations
  ], [addedCommentsDecorations, authoringDecoration, props == null ? void 0 : props.rangeDecorations]), currentSelectionIsOverlapping = (0, import_react2.useMemo)(() => !currentSelection || addedCommentsDecorations.length === 0 ? false : addedCommentsDecorations.some((d) => {
    if (!editorRef.current)
      return false;
    const testA = PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      currentSelection,
      d.selection
    ), testB = PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      d.selection,
      currentSelection
    );
    return testA || testB;
  }), [addedCommentsDecorations, currentSelection]), scrollElement = isFullScreen ? document.body : ((_a = portal.elements) == null ? void 0 : _a.documentScrollElement) || document.body, boundaryElement = isFullScreen ? ((_b = portal.elements) == null ? void 0 : _b.documentScrollElement) || document.body : rootElement, popoverAuthoringReferenceElement = useAuthoringReferenceElement({
    scrollElement,
    disabled: !nextCommentSelection,
    selector: '[data-inline-comment-state="authoring"]'
  }), selectionReferenceElement = (0, import_react2.useMemo)(() => currentSelectionRect ? {
    getBoundingClientRect: () => currentSelectionRect
  } : null, [currentSelectionRect]);
  (0, import_react2.useEffect)(() => {
    if (currentSelection)
      return scrollElement == null || scrollElement.addEventListener("wheel", handleSetCurrentSelectionRect), () => {
        scrollElement == null || scrollElement.removeEventListener("wheel", handleSetCurrentSelectionRect);
      };
  }, [currentSelection, scrollElement, handleSetCurrentSelectionRect]), (0, import_react2.useEffect)(() => {
    const nextDecorations = handleBuildRangeDecorations(textComments);
    setAddedCommentsDecorations((current) => nextDecorations.map((nextDecoration) => {
      var _a2;
      const prevDecoration = current.find(
        (p) => {
          var _a3, _b2;
          return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === ((_b2 = nextDecoration.payload) == null ? void 0 : _b2.commentId);
        }
      );
      return (_a2 = prevDecoration == null ? void 0 : prevDecoration.payload) != null && _a2.dirty ? {
        ...nextDecoration,
        payload: { ...nextDecoration.payload, dirty: prevDecoration.payload.dirty }
      } : nextDecoration;
    }));
  }, [handleBuildRangeDecorations, textComments]);
  const showFloatingButton = !!(currentSelection && canSubmit && selectionReferenceElement && !mouseDownRef.current), showFloatingInput = !!(nextCommentSelection && popoverAuthoringReferenceElement);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: boundaryElement, children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { children: [
      showFloatingInput && currentUser && (0, import_jsx_runtime.jsx)(
        InlineCommentInputPopover,
        {
          currentUser,
          mentionOptions,
          onChange: setNextCommentValue,
          onClickOutside: resetStates,
          onDiscardConfirm: handleCommentDiscardConfirm,
          onSubmit: handleSubmit,
          referenceElement: popoverAuthoringReferenceElement,
          value: nextCommentValue
        }
      ),
      showFloatingButton && !showFloatingInput && (0, import_jsx_runtime.jsx)(
        FloatingButtonPopover,
        {
          disabled: currentSelectionIsOverlapping,
          onClick: handleSelectCurrentSelection,
          onClickOutside: resetStates,
          referenceElement: selectionReferenceElement
        }
      )
    ] }) }),
    (0, import_jsx_runtime.jsx)(Stack, { ref: setRootElement, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, children: props.renderDefault({
      ...props,
      onEditorChange,
      editorRef,
      rangeDecorations,
      onFullScreenChange: setIsFullScreen
    }) })
  ] });
});
function isPortableTextInputProps(inputProps) {
  return isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function CommentsInput(props) {
  return isPortableTextInputProps(props) ? (0, import_jsx_runtime.jsx)(CommentsPortableTextInput, { ...props }) : props.renderDefault(props);
}
var _DEBUG = false;
var EMPTY_PARAMS$1 = {};
var LOADING_PANE = Symbol("LOADING_PANE");
var DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
var DocumentPaneContext = (0, import_react2.createContext)(null);
function useDocumentPane() {
  const documentPane = (0, import_react2.useContext)(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
var FEEDBACK_FORM_LINK = "https://snty.link/comments-beta-feedback";
var Span = ut.span`
  margin-right: 0.2em;
`;
var Link = ut.a`
  white-space: nowrap;
`;
var FooterCard = ut(Card)({
  position: "relative",
  zIndex: 1
});
function CommentsInspectorFeedbackFooter() {
  const { t } = useTranslation2(commentsLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(FooterCard, { padding: 4, children: (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [
    t("feature-feedback.title"),
    " ",
    (0, import_jsx_runtime.jsxs)(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [
      (0, import_jsx_runtime.jsxs)(Span, { children: [
        t("feature-feedback.link"),
        " "
      ] }),
      " ",
      (0, import_jsx_runtime.jsx)(LaunchIcon, {})
    ] })
  ] }) });
}
var Root$8 = ut(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
var CommentsInspectorHeader = (0, import_react2.forwardRef)(function(props, ref) {
  const { t } = useTranslation2(commentsLocaleNamespace), { onClose, onViewChange, view, mode } = props, handleSetOpenView = (0, import_react2.useCallback)(() => onViewChange("open"), [onViewChange]), handleSetResolvedView = (0, import_react2.useCallback)(() => onViewChange("resolved"), [onViewChange]);
  return (0, import_jsx_runtime.jsx)(Root$8, { ref, children: (0, import_jsx_runtime.jsxs)(Flex, { padding: 2, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: [
      (0, import_jsx_runtime.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: t("feature-name") }),
      (0, import_jsx_runtime.jsx)(BetaBadge, {})
    ] }),
    (0, import_jsx_runtime.jsxs)(Flex, { flex: "none", padding: 1, gap: 2, children: [
      (0, import_jsx_runtime.jsx)(
        MenuButton,
        {
          id: "comment-status-menu-button",
          button: (0, import_jsx_runtime.jsx)(
            Button2,
            {
              text: t(view === "open" ? "status-filter.status-open" : "status-filter.status-resolved"),
              mode: "bleed",
              iconRight: ChevronDownIcon
            }
          ),
          menu: (0, import_jsx_runtime.jsxs)(Menu, { style: { width: "180px" }, children: [
            (0, import_jsx_runtime.jsx)(
              MenuItem2,
              {
                iconRight: view === "open" ? CheckmarkIcon : void 0,
                onClick: handleSetOpenView,
                text: t("status-filter.status-open-full")
              }
            ),
            (0, import_jsx_runtime.jsx)(
              MenuItem2,
              {
                iconRight: view === "resolved" ? CheckmarkIcon : void 0,
                onClick: handleSetResolvedView,
                text: t("status-filter.status-resolved-full"),
                tooltipProps: mode === "upsell" ? { content: t("status-filter.status-resolved-full-upsell") } : void 0,
                disabled: mode === "upsell"
              }
            )
          ] }),
          popover: { placement: "bottom-end" }
        }
      ),
      (0, import_jsx_runtime.jsx)(
        Button2,
        {
          "aria-label": t("close-pane-button-text-aria-label"),
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("close-pane-button-text") }
        }
      )
    ] })
  ] }) });
});
var RootLayer = ut(Layer)`
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
`;
function CommentsInspector(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(RootLayer, { children: (0, import_jsx_runtime.jsx)(CommentsInspectorInner, { ...props, mode }) }) : null;
}
function CommentsInspectorInner(props) {
  const { t } = useTranslation2(commentsLocaleNamespace), { onClose, mode } = props, [showDeleteDialog, setShowDeleteDialog] = (0, import_react2.useState)(false), [commentToDelete, setCommentToDelete] = (0, import_react2.useState)(null), [deleteLoading, setDeleteLoading] = (0, import_react2.useState)(false), [deleteError, setDeleteError] = (0, import_react2.useState)(null), rootRef = (0, import_react2.useRef)(null), currentUser = useCurrentUser(), { params, createPathWithParams, setParams } = usePaneRouter(), uniqueParams = useUnique(params) || EMPTY_PARAMS$1, commentIdParamRef = (0, import_react2.useRef)(uniqueParams == null ? void 0 : uniqueParams.comment), didScrollToCommentFromParam = (0, import_react2.useRef)(false), pushToast = useToast().push, { isTopLayer } = useLayer(), { onPathOpen, connectionState } = useDocumentPane(), { scrollToComment, scrollToField, scrollToInlineComment } = useCommentsScroll(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { isDismissed, setDismissed } = useCommentsOnboarding(), { comments: comments2, getComment, isCreatingDataset, mentionOptions, setStatus, status, operation } = useComments(), { upsellData, telemetryLogs } = useCommentsUpsell(), currentComments = (0, import_react2.useMemo)(() => comments2.data[status], [comments2, status]), loading = (0, import_react2.useMemo)(() => comments2.loading || connectionState === "connecting", [comments2.loading, connectionState]);
  (0, import_react2.useEffect)(() => (mode === "upsell" && ((selectedPath == null ? void 0 : selectedPath.origin) === "form" ? telemetryLogs.panelViewed("field_action") : commentIdParamRef.current ? telemetryLogs.panelViewed("link") : telemetryLogs.panelViewed("document_action")), () => {
    mode === "upsell" && telemetryLogs.panelDismissed();
  }), []);
  const handleChangeView = (0, import_react2.useCallback)(
    (nextView) => {
      setStatus(nextView), setSelectedPath(null);
    },
    [setSelectedPath, setStatus]
  ), handleCloseInspector = (0, import_react2.useCallback)(() => {
    onClose(), setSelectedPath(null);
  }, [onClose, setSelectedPath]), handleCopyLink = (0, import_react2.useCallback)(
    (id) => {
      const path = createPathWithParams({
        ...params,
        comment: id
      }), url = `${window.location.origin}${path}`;
      navigator.clipboard.writeText(url).then(() => {
        pushToast({
          closable: true,
          status: "info",
          title: t("copy-link-success-message")
        });
      }).catch(() => {
        pushToast({
          closable: true,
          status: "error",
          title: t("copy-link-error-message")
        });
      });
    },
    [createPathWithParams, params, pushToast, t]
  ), handleCreateRetry = (0, import_react2.useCallback)(
    (id) => {
      var _a;
      const comment = getComment(id);
      comment && operation.create({
        type: "field",
        fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || "",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || [],
        status: comment.status,
        threadId: comment.threadId
      });
    },
    [getComment, operation]
  ), closeDeleteDialog = (0, import_react2.useCallback)(() => {
    deleteLoading || (setShowDeleteDialog(false), setCommentToDelete(null));
  }, [deleteLoading]), handlePathSelect = (0, import_react2.useCallback)(
    (nextPath) => {
      if (setSelectedPath(nextPath), nextPath != null && nextPath.fieldPath) {
        const path = fromString(nextPath.fieldPath);
        onPathOpen(path), scrollToField(nextPath.fieldPath), comments2.data.open.filter((c) => c.threadId === (nextPath == null ? void 0 : nextPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)) && nextPath.threadId && scrollToInlineComment(nextPath.threadId);
      }
    },
    [comments2.data.open, onPathOpen, scrollToField, scrollToInlineComment, setSelectedPath]
  ), handleNewThreadCreate = (0, import_react2.useCallback)(
    (nextComment) => {
      var _a;
      const fieldPath = ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || "";
      operation.create({
        type: "field",
        fieldPath,
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: nextComment.reactions,
        status: nextComment.status,
        threadId: nextComment.threadId
      }), setSelectedPath({
        fieldPath,
        origin: "inspector",
        threadId: nextComment.threadId
      });
    },
    [operation, setSelectedPath]
  ), handleReply = (0, import_react2.useCallback)(
    (nextComment) => {
      var _a;
      operation.create({
        ...nextComment,
        type: "field",
        fieldPath: ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || ""
      });
    },
    [operation]
  ), handleEdit = (0, import_react2.useCallback)(
    (id, nextComment) => {
      operation.update(id, nextComment);
    },
    [operation]
  ), onDeleteStart = (0, import_react2.useCallback)(
    (id) => {
      var _a;
      const parent = currentComments.find((c) => {
        var _a2;
        return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === id;
      }), isParent = !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
      setShowDeleteDialog(true), setCommentToDelete({
        commentId: id,
        isParent
      });
    },
    [currentComments]
  ), handleDeleteConfirm = (0, import_react2.useCallback)(
    async (id) => {
      try {
        setDeleteLoading(true), await operation.remove(id), closeDeleteDialog();
      } catch (err) {
        setDeleteError(err);
      } finally {
        setDeleteLoading(false);
      }
    },
    [closeDeleteDialog, operation]
  ), handleStatusChange = (0, import_react2.useCallback)(
    (id, nextStatus) => {
      var _a;
      if (operation.update(id, {
        status: nextStatus
      }), nextStatus === "open") {
        setStatus("open");
        const comment = getComment(id);
        if (!comment)
          return;
        setSelectedPath({
          fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || null,
          origin: "inspector",
          threadId: comment.threadId || null
        }), scrollToComment(id);
      }
    },
    [getComment, operation, scrollToComment, setSelectedPath, setStatus]
  ), handleReactionSelect = (0, import_react2.useCallback)(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeselectPath = (0, import_react2.useCallback)(() => {
    selectedPath && isTopLayer && setSelectedPath(null);
  }, [isTopLayer, selectedPath, setSelectedPath]), handleClickOutside = (0, import_react2.useCallback)(
    (e2) => {
      var _a;
      e2.target instanceof HTMLElement && ((_a = e2.target) != null && _a.hasAttribute("data-slate-string")) || handleDeselectPath();
    },
    [handleDeselectPath]
  );
  useClickOutside(handleClickOutside, [rootRef.current]), (0, import_react2.useEffect)(() => {
    var _a;
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    !loading && commentToScrollTo && didScrollToCommentFromParam.current === false && (setStatus(commentToScrollTo.status || "open"), setSelectedPath({
      fieldPath: ((_a = commentToScrollTo.target.path) == null ? void 0 : _a.field) || null,
      origin: "url",
      threadId: commentToScrollTo.threadId || null
    }), scrollToComment(commentToScrollTo._id), didScrollToCommentFromParam.current = true, commentIdParamRef.current = void 0, setParams({
      ...params,
      comment: void 0
    }));
  }, [getComment, loading, params, scrollToComment, setParams, setSelectedPath, setStatus]);
  const beforeListNode = (0, import_react2.useMemo)(() => mode === "upsell" && upsellData ? (0, import_jsx_runtime.jsx)(
    CommentsUpsellPanel,
    {
      data: upsellData,
      onPrimaryClick: telemetryLogs.panelPrimaryClicked,
      onSecondaryClick: telemetryLogs.panelSecondaryClicked
    }
  ) : null, [mode, telemetryLogs.panelPrimaryClicked, telemetryLogs.panelSecondaryClicked, upsellData]);
  return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [
    commentToDelete && showDeleteDialog && (0, import_jsx_runtime.jsx)(
      CommentDeleteDialog,
      {
        ...commentToDelete,
        error: deleteError,
        loading: deleteLoading,
        onClose: closeDeleteDialog,
        onConfirm: handleDeleteConfirm
      }
    ),
    (0, import_jsx_runtime.jsxs)(
      Flex,
      {
        direction: "column",
        flex: 1,
        height: "fill",
        onClick: handleDeselectPath,
        overflow: "hidden",
        ref: rootRef,
        children: [
          (0, import_jsx_runtime.jsx)(
            CommentsOnboardingPopover,
            {
              onDismiss: setDismissed,
              open: !isDismissed,
              placement: "left-start",
              children: (0, import_jsx_runtime.jsx)(
                CommentsInspectorHeader,
                {
                  onClose: handleCloseInspector,
                  onViewChange: handleChangeView,
                  view: status,
                  mode
                }
              )
            }
          ),
          currentUser && (0, import_jsx_runtime.jsx)(
            CommentsList,
            {
              beforeListNode,
              comments: currentComments,
              currentUser,
              error: comments2.error,
              loading,
              mentionOptions,
              mode,
              onCopyLink: handleCopyLink,
              onCreateRetry: handleCreateRetry,
              onDelete: onDeleteStart,
              onEdit: handleEdit,
              onNewThreadCreate: handleNewThreadCreate,
              onPathSelect: handlePathSelect,
              onReactionSelect: handleReactionSelect,
              onReply: handleReply,
              onStatusChange: handleStatusChange,
              readOnly: isCreatingDataset,
              selectedPath,
              status
            }
          ),
          mode === "default" && (0, import_jsx_runtime.jsx)(CommentsInspectorFeedbackFooter, {})
        ]
      }
    )
  ] });
}
function useMenuItem$1() {
  const { t } = useTranslation2(commentsLocaleNamespace), { enabled } = useCommentsEnabled();
  return {
    hidden: !enabled,
    icon: CommentIcon,
    showAsAction: true,
    title: t("feature-name")
  };
}
var commentsInspector = defineDocumentInspector({
  name: COMMENTS_INSPECTOR_NAME,
  component: CommentsInspector,
  useMenuItem: useMenuItem$1
});
function CommentsStudioLayout(props) {
  const { enabled, isLoading } = useFeatureEnabled("studioComments");
  return (0, import_jsx_runtime.jsx)(AddonDatasetProvider, { children: (0, import_jsx_runtime.jsx)(CommentsOnboardingProvider, { children: (0, import_jsx_runtime.jsx)(
    ConditionalWrapper,
    {
      condition: !enabled && !isLoading,
      wrapper: (children) => (0, import_jsx_runtime.jsx)(CommentsUpsellProvider, { children }),
      children: props.renderDefault(props)
    }
  ) }) });
}
var comments = definePlugin({
  name: "sanity/structure/comments",
  document: {
    inspectors: [commentsInspector],
    components: {
      unstable_layout: CommentsDocumentLayout
    }
  },
  form: {
    components: {
      field: CommentsField,
      input: CommentsInput
    }
  },
  studio: {
    components: {
      layout: CommentsStudioLayout
    }
  },
  i18n: { bundles: [commentsUsEnglishLocaleBundle] }
});
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return (0, import_jsx_runtime.jsxs)(
    Pane,
    {
      currentMinWidth,
      flex,
      id: paneKey,
      minWidth,
      tone,
      children: [
        (0, import_jsx_runtime.jsx)(PaneHeader, { title }),
        (0, import_jsx_runtime.jsx)(PaneContent, { overflow: "auto", children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children }) })
      ]
    }
  );
}
function getWaitMessages(path) {
  const thresholds = [
    { ms: 300, messageKey: "panes.resolving.default-message" },
    { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }
  ];
  if (isDev) {
    const message = [
      "Check console for errors?",
      "Is your observable/promise resolving?",
      path.length > 0 ? `Structure path: ${path.join(" âž ")}` : ""
    ];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = of(null);
  return merge(
    ...thresholds.map(
      (threshold) => src.pipe(
        mapTo(
          "messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }
        ),
        delay(threshold.ms)
      )
    )
  );
}
var DEFAULT_MESSAGE_KEY = "panes.resolving.default-message";
var Content$1 = ut(Flex)`
  opacity: 0;
  transition: opacity 200ms;

  &[data-mounted] {
    opacity: 1;
  }
`;
var LoadingPane = (0, import_react2.memo)((props) => {
  const {
    delay: delay2 = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, { t } = useTranslation2(structureLocaleNamespace), resolvedMessage = (0, import_react2.useMemo)(() => typeof messageProp == "function" ? messageProp(path ? path.split(";") : []) : messageProp, [messageProp, path]), [currentMessage, setCurrentMessage] = (0, import_react2.useState)(() => typeof resolvedMessage == "string" ? resolvedMessage : t(DEFAULT_MESSAGE_KEY));
  (0, import_react2.useEffect)(() => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function")
      return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = (0, import_react2.useState)(null), [mounted, setMounted] = (0, import_react2.useState)(false);
  return (0, import_react2.useEffect)(() => {
    if (contentElement)
      return _raf2(() => setMounted(true));
  }, [contentElement]), (0, import_jsx_runtime.jsx)(Pane, { flex, id: paneKey, minWidth, selected, tone, children: (0, import_jsx_runtime.jsx)(PaneContent, { children: (0, import_jsx_runtime.jsx)(
    Content$1,
    {
      align: "center",
      "data-mounted": mounted ? "" : void 0,
      direction: "column",
      height: "fill",
      justify: "center",
      ref: setContentElement,
      children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: title || currentMessage })
    }
  ) }) });
});
LoadingPane.displayName = "LoadingPane";
var StructureToolContext = (0, import_react2.createContext)(null);
function useStructureTool() {
  const structureTool2 = (0, import_react2.useContext)(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
var InspectorMenuItem = (0, import_react2.memo)(function(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props, node = useUnique(
    useMenuItem2({
      documentId,
      documentType
    })
  );
  return (0, import_react2.useEffect)(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]), (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props, len = inspectors2.length, lenRef = (0, import_react2.useRef)(len), [menuItems, setMenuItems] = (0, import_react2.useState)(
    () => Array.from(new Array(len))
  ), menuItemsRef = (0, import_react2.useRef)(menuItems);
  (0, import_react2.useEffect)(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItemsRef.current[i];
      lenRef.current = len, setMenuItems(() => (menuItemsRef.current = newFieldActions, newFieldActions));
    }
  }, [len]);
  const setMenuItem = (0, import_react2.useCallback)((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, menuItemsRef.current = next, next;
    });
  }, []);
  return (0, import_react2.useEffect)(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]), (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: inspectors2.map(
    (inspector, inspectorIndex) => inspector.useMenuItem && (0, import_jsx_runtime.jsx)(
      InspectorMenuItem,
      {
        documentId,
        documentType,
        index: inspectorIndex,
        setMenuItem,
        useMenuItem: inspector.useMenuItem
      },
      inspector.name
    )
  ) });
}
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = useDocumentPreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  return connectionState === "connecting" ? { error: void 0, title: void 0 } : title ? { error: void 0, title } : documentValue ? error ? { error: `Error: ${error.message}`, title: void 0 } : { error: void 0, title: value == null ? void 0 : value.title } : { error: void 0, title: `New ${(schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)}` };
}
var IGNORE_OPS = ["patch", "commit"];
var DocumentOperationResults = (0, import_react2.memo)(function() {
  const { push: pushToast } = useToast(), { documentId, documentType } = useDocumentPane(), { title } = useDocumentTitle(), event = useDocumentOperationEvent(documentId, documentType), prevEvent = (0, import_react2.useRef)(event), paneRouter = usePaneRouter(), { t } = useTranslation2(structureLocaleNamespace), documentTitleBase = title || t("panes.document-operation-results.operation-undefined-title"), documentTitle = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase;
  return (0, import_react2.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    return event.type === "error" && pushToast({
      closable: true,
      duration: 3e4,
      // 30s
      status: "error",
      title: t("panes.document-operation-results.operation-error", { context: event.op }),
      description: (0, import_jsx_runtime.jsxs)("details", { children: [
        (0, import_jsx_runtime.jsx)("summary", { children: t("panes.document-operation-results.error.summary.title") }),
        event.error.message
      ] })
    }), event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: true,
      status: "success",
      title: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          context: event.op,
          i18nKey: "panes.document-operation-results.operation-success",
          t,
          values: {
            title: documentTitle
          },
          components: {
            Strong: "strong"
          }
        }
      )
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t, documentTitle]), null;
});
var Root$7 = ut(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props, { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsxs)(Root$7, { ...restProps, as: forwardedAs, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { padding: 2, children: [
      (0, import_jsx_runtime.jsx)(Box, { flex: 1, padding: 3, children: (0, import_jsx_runtime.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: title }) }),
      (0, import_jsx_runtime.jsx)(Box, { flex: "none", padding: 1, children: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          "aria-label": closeButtonLabel,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("document-inspector.close-button.tooltip") }
        }
      ) })
    ] }),
    children
  ] });
}
var Root$6 = ut.div`
  position: absolute;
  top: 0;
  left: -4px;
  bottom: 0;
  width: 9px;
  z-index: 201;
  cursor: ew-resize;

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  /* Hover effect */
  & > span:nth-child(2) {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 9px;
    bottom: 0;
    background-color: var(--card-border-color);
    opacity: 0;
    transition: opacity 150ms;
  }

  @media (hover: hover) {
    &:hover > span:nth-child(2) {
      opacity: 0.2;
    }
  }
`;
function Resizer(props) {
  const { onResize, onResizeStart } = props, mouseXRef = (0, import_react2.useRef)(0), handleMouseDown = (0, import_react2.useCallback)(
    (event) => {
      event.preventDefault(), mouseXRef.current = event.pageX, onResizeStart();
      const handleMouseMove = (e2) => {
        e2.preventDefault(), onResize(e2.pageX - mouseXRef.current);
      }, handleMouseUp = () => {
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [onResize, onResizeStart]
  );
  return (0, import_jsx_runtime.jsxs)(Root$6, { onMouseDown: handleMouseDown, children: [
    (0, import_jsx_runtime.jsx)("span", {}),
    (0, import_jsx_runtime.jsx)("span", {})
  ] });
}
var Root$5 = ut(Box)`
  position: relative;
  flex: 1;
  padding-left: 1px;
`;
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props, [element, setElement] = (0, import_react2.useState)(null), elementWidthRef = (0, import_react2.useRef)(), [targetWidth, setTargetWidth] = (0, import_react2.useState)(), handleResizeStart = (0, import_react2.useCallback)(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]), handleResize = (0, import_react2.useCallback)(
    (deltaX) => {
      const w = elementWidthRef.current;
      w && setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
    },
    [minWidth, maxWidth]
  ), style = (0, import_react2.useMemo)(
    () => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth },
    [minWidth, maxWidth, targetWidth]
  );
  return (0, import_jsx_runtime.jsxs)(Root$5, { as: forwardedAs, ...restProps, ref: setElement, style, children: [
    children,
    (0, import_jsx_runtime.jsx)(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })
  ] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props, { collapsed } = usePane(), { closeInspector, inspector } = useDocumentPane(), { features } = useStructureTool(), handleClose = (0, import_react2.useCallback)(() => {
    inspector && closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = (0, import_react2.createElement)(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  return features.resizablePanes ? (0, import_jsx_runtime.jsx)(
    Resizable,
    {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    }
  ) : (0, import_jsx_runtime.jsx)(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
var STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const keyValueStore = useKeyValueStore(), [value, setValue] = (0, import_react2.useState)(defaultValue), keyValueStoreKey = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean).join("."), settings = (0, import_react2.useMemo)(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  (0, import_react2.useEffect)(() => {
    const sub = settings.pipe(
      startWith(defaultValue),
      map((fetchedValue) => fetchedValue === null ? defaultValue : fetchedValue)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, keyValueStoreKey, settings]);
  const set2 = (0, import_react2.useCallback)(
    (newValue) => {
      newValue !== value && (setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue));
    },
    [keyValueStore, keyValueStoreKey, value]
  );
  return (0, import_react2.useMemo)(() => [value, set2], [set2, value]);
}
var VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" };
var VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" };
var VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
var lru = (0, import_hashlru.default)(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || isRecord$4(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const { path } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return isRecord$4(value) && isString(value._id) && isString(value._type);
}
var JSONInspectorWrapper = ut.div(({ theme }) => {
  const { color, fonts, space } = theme.sanity;
  return at`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: 'â–¸ ';
      margin-left: calc(0 - ${rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: 'â–¾ ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: 'â†”';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const { onChange, query } = props, handleChange = (0, import_react2.useCallback)(
    (event) => onChange(event.target.value),
    [onChange]
  ), { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(
    TextInput,
    {
      icon: SearchIcon,
      onChange: handleChange,
      placeholder: t("document-inspector.search.placeholder"),
      radius: 2,
      value: query || ""
    }
  );
}
function InspectDialog(props) {
  const { value } = props, { onInspectClose, paneKey } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting(
    "inspect-view-mode",
    null,
    "parsed"
  ), viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId), setParsedViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]), setRawViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]), { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      bodyHeight: "fill",
      id: `${dialogIdPrefix}dialog`,
      header: isDocumentLike(value) ? (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "document-inspector.dialog.title",
          components: {
            DocumentTitle: () => (0, import_jsx_runtime.jsx)("em", { children: (0, import_jsx_runtime.jsx)(DocTitle, { document: value }) })
          }
        }
      ) : (0, import_jsx_runtime.jsx)("em", { children: t("document-inspector.dialog.title-no-value") }),
      onClose: onInspectClose,
      onClickOutside: onInspectClose,
      padding: false,
      width: 2,
      children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", children: [
        (0, import_jsx_runtime.jsx)(
          Card,
          {
            padding: 3,
            paddingTop: 0,
            shadow: 1,
            style: { position: "sticky", bottom: 0, zIndex: 3 },
            children: (0, import_jsx_runtime.jsxs)(TabList, { space: 1, children: [
              (0, import_jsx_runtime.jsx)(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`,
                  label: t(VIEW_MODE_PARSED.title),
                  onClick: setParsedViewMode,
                  selected: viewMode === VIEW_MODE_PARSED
                }
              ),
              (0, import_jsx_runtime.jsx)(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`,
                  label: t(VIEW_MODE_RAW.title),
                  onClick: setRawViewMode,
                  selected: viewMode === VIEW_MODE_RAW
                }
              )
            ] })
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          TabPanel,
          {
            "aria-labelledby": `${dialogIdPrefix}tab-${viewModeId}`,
            flex: 1,
            id: `${dialogIdPrefix}tabpanel`,
            overflow: "auto",
            padding: 4,
            style: { outline: "none" },
            children: [
              viewMode === VIEW_MODE_PARSED && (0, import_jsx_runtime.jsx)(JSONInspectorWrapper, { children: (0, import_jsx_runtime.jsx)(
                import_react_json_inspector.default,
                {
                  data: value,
                  isExpanded,
                  onClick: toggleExpanded,
                  search: Search
                }
              ) }),
              viewMode === VIEW_MODE_RAW && (0, import_jsx_runtime.jsx)(
                Code,
                {
                  language: "json",
                  tabIndex: 0,
                  onKeyDown: maybeSelectAll,
                  onDoubleClick: select,
                  onFocus: select,
                  size: 1,
                  children: JSON.stringify(value, null, 2)
                }
              )
            ]
          }
        )
      ] })
    }
  );
}
function SpacerButton({ size }) {
  return (0, import_jsx_runtime.jsx)(
    Button2,
    {
      "aria-hidden": true,
      disabled: true,
      size,
      style: {
        pointerEvents: "none",
        visibility: "hidden",
        width: 0
      },
      text: "-"
    }
  );
}
function Banner(props) {
  const { action, content, icon: Icon, tone = "transparent", ...rest } = props;
  return (0, import_jsx_runtime.jsx)(Card, { borderBottom: true, paddingX: 4, paddingY: 2, tone, ...rest, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
    Icon && (0, import_jsx_runtime.jsx)(Text, { size: 0, children: (0, import_jsx_runtime.jsx)(Icon, {}) }),
    (0, import_jsx_runtime.jsx)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }),
    (0, import_jsx_runtime.jsx)(SpacerButton, {}),
    action && (0, import_jsx_runtime.jsx)(
      Button2,
      {
        as: action == null ? void 0 : action.as,
        mode: "ghost",
        onClick: action == null ? void 0 : action.onClick,
        text: action.text,
        tone: action.tone || "default"
      }
    )
  ] }) });
}
function DeletedDocumentBanner({ revisionId }) {
  const { documentId, documentType } = useDocumentPane(), { restore } = useDocumentOperation(documentId, documentType), { navigateIntent } = useRouter(), handleRestore = (0, import_react2.useCallback)(() => {
    revisionId && (restore.execute(revisionId), navigateIntent("edit", { id: documentId, type: documentType }));
  }, [documentId, documentType, navigateIntent, restore, revisionId]), { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(
    Banner,
    {
      action: revisionId ? {
        onClick: handleRestore,
        text: t("banners.deleted-document-banner.restore-button.text")
      } : void 0,
      content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }),
      "data-testid": "deleted-document-banner",
      icon: ReadOnlyIcon
    }
  );
}
function DeprecatedDocumentTypeBanner() {
  const { schemaType } = useDocumentPane(), { t } = useTranslation2(structureLocaleNamespace);
  return isDeprecatedSchemaType(schemaType) ? (0, import_jsx_runtime.jsx)(
    Banner,
    {
      content: (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "medium", children: [
        (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }),
        " ",
        schemaType.deprecated.reason
      ] }),
      "data-testid": "deprecated-document-type-banner",
      icon: ErrorOutlineIcon
    }
  ) : null;
}
function PermissionCheckBanner({ granted, requiredPermission }) {
  const currentUser = useCurrentUser(), listFormat = useListFormat({ style: "short" }), { t } = useTranslation2(structureLocaleNamespace);
  if (granted)
    return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title), roles = listFormat.formatToParts(roleTitles).map(
    (part) => part.type === "element" ? (0, import_jsx_runtime.jsx)("code", { children: part.value }, part.value) : part.value
  );
  return (0, import_jsx_runtime.jsx)(
    Banner,
    {
      content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "banners.permission-check-banner.missing-permission",
          components: { Roles: () => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: roles }) },
          values: { count: roles.length, roles: roleTitles },
          context: requiredPermission
        }
      ) }),
      "data-testid": "permission-check-banner",
      icon: ReadOnlyIcon
    }
  );
}
var ReferenceChangedBanner = (0, import_react2.memo)(() => {
  var _a, _b, _c, _d, _e, _f, _g;
  const documentPreviewStore = useDocumentPreviewStore(), { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink2 } = usePaneRouter(), routerReferenceId = (_a = routerPanesState[groupIndex]) == null ? void 0 : _a[0].id, parentGroup = routerPanesState[groupIndex - 1], parentSibling = parentGroup == null ? void 0 : parentGroup[0], parentId = parentSibling == null ? void 0 : parentSibling.id, hasHistoryOpen = !!((_b = parentSibling == null ? void 0 : parentSibling.params) != null && _b.rev), parentRefPath = (0, import_react2.useMemo)(() => (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null, [params == null ? void 0 : params.parentRefPath]), { t } = useTranslation2(structureLocaleNamespace), referenceInfo = useMemoObservable(
    () => {
      const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
      if (!parentId || !parentRefPathSegment || !parentRefPath)
        return of({ loading: false });
      const publishedId = getPublishedId(parentId), path = fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex(
        (p) => typeof p == "object" && "_key" in p
      );
      return concat(
        // emit a loading state instantly
        of({ loading: true }),
        // then emit the values from watching the published ID's path
        documentPreviewStore.unstable_observePathsDocumentPair(
          publishedId,
          keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)
        ).pipe(
          // this debounce time is needed to prevent flashing banners due to
          // the router state updating faster than the content-lake state. we
          // debounce to wait for more emissions because the value pulled
          // initially could be stale.
          debounceTime(750),
          map(
            ({ draft, published }) => {
              var _a2;
              return {
                loading: false,
                result: {
                  availability: {
                    draft: draft.availability,
                    published: published.availability
                  },
                  refValue: (_a2 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a2._ref
                }
              };
            }
          )
        )
      );
    },
    [documentPreviewStore, parentId, parentRefPath],
    { loading: true }
  ), handleReloadReference = (0, import_react2.useCallback)(() => {
    var _a2;
    referenceInfo.loading || (_a2 = referenceInfo.result) != null && _a2.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  return (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c = referenceInfo.result) != null && _c.availability.draft.available) && !((_d = referenceInfo.result) != null && _d.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId ? null : (0, import_jsx_runtime.jsx)(
      Banner,
      {
        action: (_f = referenceInfo.result) != null && _f.refValue ? {
          onClick: handleReloadReference,
          icon: SyncIcon,
          text: t("banners.reference-changed-banner.reason-changed.reload-button.text")
        } : {
          as: BackLink2,
          icon: CloseIcon,
          text: t("banners.reference-changed-banner.reason-removed.close-button.text")
        },
        "data-testid": "reference-changed-banner",
        content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: (_g = referenceInfo.result) != null && _g.refValue ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }),
        icon: WarningOutlineIcon,
        tone: "caution"
      }
    )
  );
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
var TitleContainer = ut(Stack)`
  ${({ theme }) => at`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}
`;
var FormHeader = ({ documentId, schemaType, title }) => {
  var _a;
  const isSingleton = documentId === schemaType.name, { t } = useTranslation(structureLocaleNamespace);
  return schemaType.__experimental_formPreviewTitle === false ? null : (0, import_jsx_runtime.jsxs)(TitleContainer, { marginBottom: 6, space: 4, children: [
    !isSingleton && (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (_a = schemaType.title) != null ? _a : schemaType.name }),
    (0, import_jsx_runtime.jsx)(Heading, { as: "h2", "data-heading": true, muted: !title, children: title != null ? title : t("document-view.form-view.form-title-fallback") })
  ] });
};
function usePrevious(value) {
  const ref = (0, import_react2.useRef)();
  return (0, import_react2.useEffect)(() => {
    ref.current = value;
  }, [value]), ref.current;
}
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast(), wasEnabled = usePrevious(params.enabled);
  (0, import_react2.useEffect)(() => {
    !wasEnabled && params.enabled && toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG }), wasEnabled && !params.enabled && toast.push({
      ...params,
      // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
      duration: 0.01
    });
  }, [params, toast, wasEnabled]);
}
var preventDefault = (ev) => ev.preventDefault();
var FormView = (0, import_react2.forwardRef)(function(props, ref) {
  var _a;
  const { hidden, margins } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), { title } = useDocumentTitle(), patchChannel = (0, import_react2.useMemo)(() => createPatchChannel(), []), isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled, { t } = useTranslation2(structureLocaleNamespace);
  useConditionalToast({
    id: `sync-lock-${documentId}`,
    status: "warning",
    enabled: isLocked,
    title: t("document-view.form-view.sync-lock-toast.title"),
    description: t("document-view.form-view.sync-lock-toast.description")
  }), (0, import_react2.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!(value != null && value._rev);
  (0, import_react2.useEffect)(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const [formRef, setFormRef] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    ready && !(formState != null && formState.focusPath.length) && formRef && focusFirstDescendant(formRef);
  }, [ready]);
  const setRef = (0, import_react2.useCallback)(
    (node) => {
      setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
    },
    [ref]
  );
  return (0, import_jsx_runtime.jsx)(
    Container,
    {
      hidden,
      paddingX: 4,
      paddingTop: 5,
      paddingBottom: 9,
      sizing: "border",
      width: 1,
      children: (0, import_jsx_runtime.jsx)(PresenceOverlay, { margins, children: (0, import_jsx_runtime.jsx)(Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: connectionState === "connecting" ? (0, import_jsx_runtime.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
        (0, import_jsx_runtime.jsx)(Spinner, { muted: true }),
        (0, import_jsx_runtime.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, size: 1, children: t("document-view.form-view.loading") }) })
      ] }) }) : formState === null || hidden ? (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { children: t("document-view.form-view.form-hidden") }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(FormHeader, { documentId, schemaType: formState.schemaType, title }),
        (0, import_jsx_runtime.jsx)(
          FormBuilder,
          {
            __internal_fieldActions: fieldActions,
            __internal_patchChannel: patchChannel,
            collapsedFieldSets,
            collapsedPaths,
            focusPath: formState.focusPath,
            changed: formState.changed,
            focused: formState.focused,
            groups: formState.groups,
            id: "root",
            members: formState.members,
            onChange,
            onFieldGroupSelect: onSetActiveFieldGroup,
            onPathBlur: onBlur,
            onPathFocus: onFocus,
            onPathOpen,
            onSetFieldSetCollapsed: onSetCollapsedFieldSet,
            onSetPathCollapsed: onSetCollapsedPath,
            presence,
            readOnly: connectionState === "reconnecting" || formState.readOnly,
            schemaType: formState.schemaType,
            validation,
            value: (
              // note: the form state doesn't have a typed concept of a "document" value
              // but these should be compatible
              formState.value
            )
          }
        )
      ] }) }) })
    }
  );
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(
      fromMutationPatches("local", localPatches)
    )
  };
}
var DocumentBox = ut(Box)({
  position: "relative"
});
var Scroller$1 = ut(ScrollContainer)(({ $disabled }) => $disabled ? { height: "100%" } : at`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `);
var DocumentPanel = function(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views: views2,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore
  } = useDocumentPane(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed } = usePane(), parentPortal = usePortal(), { features } = useStructureTool(), portalRef = (0, import_react2.useRef)(null), [documentScrollElement, setDocumentScrollElement] = (0, import_react2.useState)(null), formContainerElement = (0, import_react2.useRef)(null), requiredPermission = value._createdAt ? "update" : "create", activeView = (0, import_react2.useMemo)(
    () => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" },
    [activeViewId, views2]
  ), portalElement = features.splitPanes && portalRef.current || parentPortal.element, margins = (0, import_react2.useMemo)(() => layoutCollapsed ? [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0] : [0, 0, 2, 0], [layoutCollapsed, footerHeight, headerHeight]), formViewHidden = activeView.type !== "form", activeViewNode = (0, import_react2.useMemo)(
    () => activeView.type === "component" && activeView.component && (0, import_react2.createElement)(activeView.component, {
      document: {
        draft: (editState == null ? void 0 : editState.draft) || null,
        displayed: displayed || value,
        historical: displayed,
        published: (editState == null ? void 0 : editState.published) || null
      },
      documentId,
      options: activeView.options,
      schemaType
    }),
    [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]
  ), lastNonDeletedRevId = useTimelineSelector(
    timelineStore,
    (state2) => state2.lastNonDeletedRevId
  );
  (0, import_react2.useEffect)(() => {
    documentScrollElement != null && documentScrollElement.scrollTo && documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]), (0, import_react2.useEffect)(() => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = (0, import_react2.useMemo)(() => isInspectOpen ? (0, import_jsx_runtime.jsx)(InspectDialog, { value: displayed || value }) : null, [isInspectOpen, displayed, value]), showInspector = !!(!collapsed && inspector);
  return (0, import_jsx_runtime.jsx)(PaneContent, { children: (0, import_jsx_runtime.jsxs)(Flex, { height: "fill", children: [
    (features.resizablePanes || !showInspector) && (0, import_jsx_runtime.jsx)(DocumentBox, { flex: 2, overflow: "hidden", children: (0, import_jsx_runtime.jsx)(
      PortalProvider,
      {
        element: portalElement,
        __unstable_elements: { documentScrollElement },
        children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: documentScrollElement, children: (0, import_jsx_runtime.jsxs)(
          VirtualizerScrollInstanceProvider,
          {
            scrollElement: documentScrollElement,
            containerElement: formContainerElement,
            children: [
              activeView.type === "form" && !isPermissionsLoading && ready && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
                (0, import_jsx_runtime.jsx)(
                  PermissionCheckBanner,
                  {
                    granted: !!(permissions != null && permissions.granted),
                    requiredPermission
                  }
                ),
                !isDeleting && isDeleted && (0, import_jsx_runtime.jsx)(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }),
                (0, import_jsx_runtime.jsx)(ReferenceChangedBanner, {}),
                (0, import_jsx_runtime.jsx)(DeprecatedDocumentTypeBanner, {})
              ] }),
              (0, import_jsx_runtime.jsxs)(
                Scroller$1,
                {
                  $disabled: layoutCollapsed || false,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [
                    (0, import_jsx_runtime.jsx)(
                      FormView,
                      {
                        hidden: formViewHidden,
                        margins,
                        ref: formContainerElement
                      },
                      documentId + (ready ? "_ready" : "_pending")
                    ),
                    activeViewNode
                  ]
                }
              ),
              inspectDialog,
              (0, import_jsx_runtime.jsx)("div", { "data-testid": "document-panel-portal", ref: portalRef })
            ]
          }
        ) })
      }
    ) }),
    showInspector && (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: rootElement, children: (0, import_jsx_runtime.jsx)(
      DocumentInspectorPanel,
      {
        documentId,
        documentType: schemaType.name,
        flex: 1
      }
    ) })
  ] }) });
};
var POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
var DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime.jsx)(
    Popover,
    {
      content: (0, import_jsx_runtime.jsx)(ConfirmDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: true,
      placement: "top",
      portal: true,
      preventOverflow: true,
      referenceElement
    }
  );
}
function ConfirmDialogContent(props) {
  const { dialog } = props, {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog, { t } = useTranslation2(structureLocaleNamespace), { isTopLayer } = useLayer(), [element, setElement] = (0, import_react2.useState)(null), handleClickOutside = (0, import_react2.useCallback)(() => {
    isTopLayer && onCancel();
  }, [isTopLayer, onCancel]), handleGlobalKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.key === "Escape" && isTopLayer && onCancel();
    },
    [isTopLayer, onCancel]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", ref: setElement, style: { minWidth: 304, maxWidth: 400 }, children: [
    (0, import_jsx_runtime.jsx)(Box, { flex: 1, overflow: "auto", padding: 4, children: (0, import_jsx_runtime.jsx)(Text, { children: message }) }),
    (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: (0, import_jsx_runtime.jsxs)(Grid, { columns: 2, gap: 2, children: [
      (0, import_jsx_runtime.jsx)(
        Button,
        {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text")
        }
      ),
      (0, import_jsx_runtime.jsx)(
        Button,
        {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"),
          tone
        }
      )
    ] }) })
  ] });
}
function ModalDialog(props) {
  const { dialog } = props, dialogId = (0, import_react2.useId)(), footer = dialog.footer && (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "fullscreen", children: (0, import_jsx_runtime.jsx)(
    Dialog,
    {
      __unstable_hideCloseButton: dialog.showCloseButton === false,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: dialog.content })
    }
  ) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime.jsx)(
    Popover,
    {
      content: (0, import_jsx_runtime.jsx)(PopoverDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: true,
      placement: "top",
      portal: true,
      preventOverflow: true,
      referenceElement
    }
  );
}
function PopoverDialogContent(props) {
  const { dialog } = props, { content, onClose } = dialog, { isTopLayer } = useLayer(), [element, setElement] = (0, import_react2.useState)(null), handleClickOutside = (0, import_react2.useCallback)(() => {
    isTopLayer && onClose();
  }, [isTopLayer, onClose]), handleGlobalKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.key === "Escape" && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), (0, import_jsx_runtime.jsx)("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props, { element, elements } = usePortal(), portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return (0, import_jsx_runtime.jsx)(PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props, modalId = (0, import_react2.useId)();
  if (dialog.type === "confirm")
    return (0, import_jsx_runtime.jsx)(ConfirmDialog, { dialog, referenceElement });
  if (dialog.type === "popover")
    return (0, import_jsx_runtime.jsx)(PopoverDialog, { dialog, referenceElement });
  if (dialog.type === "dialog" || !dialog.type)
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, { children: (0, import_jsx_runtime.jsx)(ModalDialog, { dialog }) });
  if (dialog.type === "custom")
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  const unknownModal = dialog;
  return console.warn(`Unsupported modal type ${unknownModal.type}`), (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      id: modalId,
      onClose: unknownModal.onClose,
      onClickOutside: unknownModal.onClose,
      width: 1,
      children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
      (0, import_jsx_runtime.jsxs)(Text, { size: 1, children: [
        "Unexpected modal type (",
        (0, import_jsx_runtime.jsx)("code", { children: unknownModal.type }),
        ")"
      ] })
    }
  );
}
function ActionDialogWrapper({
  actionStates,
  children,
  referenceElement
}) {
  const [actionIndex, setActionIndex] = (0, import_react2.useState)(-1), currentAction = actionStates[actionIndex], handleAction = (0, import_react2.useCallback)((idx) => {
    setActionIndex(idx);
  }, []);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    currentAction && currentAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }),
    children({ handleAction })
  ] });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props, idPrefix = (0, import_react2.useId)(), [referenceElement, setReferenceElement] = (0, import_react2.useState)(null), popoverProps = (0, import_react2.useMemo)(
    () => ({
      placement: "top-end",
      portal: true,
      preventOverflow: true
    }),
    []
  ), { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(ActionDialogWrapper, { actionStates, referenceElement, children: ({ handleAction }) => (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      id: `${idPrefix}-action-menu`,
      button: (0, import_jsx_runtime.jsx)(
        ContextMenuButton,
        {
          "aria-label": t("buttons.action-menu-button.aria-label"),
          disabled,
          "data-testid": "action-menu-button",
          size: "large",
          tooltipProps: { content: t("buttons.action-menu-button.tooltip") }
        }
      ),
      menu: (0, import_jsx_runtime.jsx)(Menu, { padding: 1, children: actionStates.map((actionState, idx) => (0, import_jsx_runtime.jsx)(
        ActionMenuListItem,
        {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        },
        idx
      )) }),
      popover: popoverProps,
      ref: setReferenceElement
    }
  ) });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props, { onHandle } = actionState, handleClick = (0, import_react2.useCallback)(() => {
    onAction(index), onHandle && onHandle();
  }, [index, onAction, onHandle]), hotkeys = (0, import_react2.useMemo)(() => actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0, [actionState.shortcut]);
  return (0, import_jsx_runtime.jsx)(
    MenuItem2,
    {
      "data-testid": `action-${actionState.label.replace(" ", "")}`,
      disabled: disabled || !!actionState.disabled,
      hotkeys,
      icon: actionState.icon,
      onClick: handleClick,
      text: actionState.label,
      tone: actionState.tone,
      ...actionState.disabled && { tooltipProps: { content: actionState.title } }
    }
  );
}
var TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
var StackWrapper = ut(Stack)`
  max-width: 200px;
`;
var ListWrapper = ut(Flex)`
  max-height: calc(100vh - 198px);
  min-width: 244px;
`;
var Root$4 = ut(Box)(({ $visible }) => at`
    opacity: 0;
    pointer-events: none;

    ${$visible && at`
      opacity: 1;
      pointer-events: auto;
    `}
  `);
var TIMELINE_ITEM_I18N_KEY_MAPPING = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
};
var IconWrapper = ut(Flex)(({ theme }) => {
  var _a;
  const borderColor = (_a = theme.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return at`
    --timeline-hairline-width: 1px;
    position: relative;
    z-index: 2;
    margin: 0;
    padding: 0;

    &::before {
      position: absolute;
      content: '';
      height: 100%;
      width: var(--timeline-hairline-width);
      background: ${borderColor};
      top: 0;
      left: calc((100% - var(--timeline-hairline-width)) / 2);
      z-index: 1;
    }
  `;
});
var Root$3 = ut(Button)(({ $selected, $disabled }) => at`
    position: relative;
    width: 100%;

    /* Line styling */
    &[data-first] ${IconWrapper}::before {
      height: 50%;
      top: unset;
      bottom: 0;
    }

    &[data-last] ${IconWrapper}::before {
      height: 50%;
    }

    ${$selected && at`
      ${IconWrapper}::before {
        background: transparent;
      }
    `}

    ${$disabled && at`
      cursor: not-allowed;
    `}
  `);
var IconBox = ut(Box)`
  background: var(--card-bg-color);
  border-radius: 50px;
  position: relative;
  z-index: 2;
`;
var TimestampBox = ut(Box)`
  min-width: 1rem;
  margin-left: ${({ theme }) => `-${rem(theme.sanity.space[1])}`};
`;
function UserAvatarStack({ maxLength, userIds }) {
  return (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength, children: userIds.map((userId) => (0, import_jsx_runtime.jsx)(UserAvatar, { user: userId, withTooltip: true }, userId)) });
}
var TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem({
  chunk,
  isFirst,
  isLast,
  isLatest,
  isSelected,
  onSelect,
  timestamp,
  type
}) {
  const { t } = useTranslation2("studio"), iconComponent = getTimelineEventIconComponent(type), authorUserIds = Array.from(chunk.authors), isSelectable = type !== "delete", dateFormat = useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" }), formattedTimestamp = (0, import_react2.useMemo)(() => {
    const parsedDate = new Date(timestamp);
    return dateFormat.format(parsedDate);
  }, [timestamp, dateFormat]), handleClick = (0, import_react2.useCallback)(
    (evt) => {
      evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
    },
    [onSelect, chunk, isSelectable]
  );
  return (0, import_jsx_runtime.jsx)(
    Root$3,
    {
      $selected: isSelected,
      $disabled: !isSelectable,
      "data-chunk-id": chunk.id,
      "data-first": isFirst ? true : void 0,
      "data-last": isLast ? true : void 0,
      "data-ui": "timelineItem",
      mode: isSelected ? "default" : "bleed",
      onClick: handleClick,
      padding: 0,
      radius: 2,
      tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
      children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "stretch", children: [
        (0, import_jsx_runtime.jsx)(IconWrapper, { align: "center", children: (0, import_jsx_runtime.jsx)(IconBox, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, children: iconComponent && (0, import_react2.createElement)(iconComponent) }) }) }),
        (0, import_jsx_runtime.jsxs)(Stack, { space: 2, margin: 2, children: [
          isLatest && (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(
            Card,
            {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 0, weight: "medium", children: t("timeline.latest") })
            }
          ) }),
          (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || (0, import_jsx_runtime.jsx)("code", { children: type }) }) }),
          (0, import_jsx_runtime.jsx)(TimestampBox, { paddingX: 1, children: (0, import_jsx_runtime.jsx)(Text, { as: "time", size: 0, muted: true, dateTime: timestamp, children: formattedTimestamp }) })
        ] }),
        (0, import_jsx_runtime.jsx)(Flex, { flex: 1, justify: "flex-end", align: "center", children: (0, import_jsx_runtime.jsx)(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })
      ] }) })
    }
  );
}
var Timeline = ({
  chunks,
  disabledBeforeFirstChunk,
  hasMoreChunks,
  lastChunk,
  onLoadMore,
  onSelect,
  firstChunk
}) => {
  const [mounted, setMounted] = (0, import_react2.useState)(false), { t } = useTranslation2("studio"), filteredChunks = (0, import_react2.useMemo)(() => chunks.filter((c) => disabledBeforeFirstChunk && firstChunk ? c.index < firstChunk.index : true), [chunks, disabledBeforeFirstChunk, firstChunk]), selectedIndex = (0, import_react2.useMemo)(
    () => lastChunk != null && lastChunk.id ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1,
    [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]
  ), renderItem2 = (0, import_react2.useCallback)(
    (chunk, { activeIndex }) => {
      const isFirst = activeIndex === 0, isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
      return (0, import_jsx_runtime.jsxs)(Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [
        (0, import_jsx_runtime.jsx)(
          TimelineItem,
          {
            chunk,
            isFirst,
            isLast,
            isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
            isSelected: activeIndex === selectedIndex,
            onSelect,
            timestamp: chunk.endTimestamp,
            type: chunk.type
          }
        ),
        activeIndex === filteredChunks.length - 1 && hasMoreChunks && (0, import_jsx_runtime.jsx)(LoadingBlock, {})
      ] });
    },
    [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]
  );
  return (0, import_react2.useEffect)(() => setMounted(true), []), (0, import_jsx_runtime.jsxs)(
    Root$4,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: [
        filteredChunks.length === 0 && (0, import_jsx_runtime.jsxs)(StackWrapper, { padding: 3, space: 3, children: [
          (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
          (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t("timeline.error.no-document-history-description") })
        ] }),
        filteredChunks.length > 0 && (0, import_jsx_runtime.jsx)(ListWrapper, { direction: "column", children: (0, import_jsx_runtime.jsx)(
          CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t("timeline.list.aria-label"),
            autoFocus: "list",
            initialIndex: selectedIndex,
            initialScrollAlign: "center",
            itemHeight: 40,
            items: filteredChunks,
            onEndReached: onLoadMore,
            onEndReachedIndexOffset: 20,
            overscan: 5,
            renderItem: renderItem2,
            wrapAround: false
          }
        ) })
      ]
    }
  );
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = useTranslation2("studio");
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    (0, import_jsx_runtime.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime.jsx)(ErrorOutlineIcon, {}) }),
    (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
      (0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }),
      (0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })
    ] })
  ] });
}
var Root$2 = ut(Popover2)`
  overflow: hidden;
  overflow: clip;
`;
function TimelineMenu({ chunk, mode, placement }) {
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane(), [open, setOpen] = (0, import_react2.useState)(false), [button, setButton] = (0, import_react2.useState)(null), [popover, setPopover] = (0, import_react2.useState)(null), toast = useToast(), chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks), loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading), hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks), realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), { t } = useTranslation2("studio"), handleOpen = (0, import_react2.useCallback)(() => {
    setTimelineMode(mode), setOpen(true);
  }, [mode, setTimelineMode]), handleClose = (0, import_react2.useCallback)(() => {
    setTimelineMode("closed"), setOpen(false);
  }, [setTimelineMode]), handleClickOutside = (0, import_react2.useCallback)(() => {
    open && handleClose();
  }, [handleClose, open]), handleGlobalKeyDown = (0, import_react2.useCallback)(
    (event) => {
      open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button == null || button.focus());
    },
    [button, handleClose, open]
  );
  useClickOutside(handleClickOutside, [button, popover]), useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = (0, import_react2.useCallback)(
    (revChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: true,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), selectSince = (0, import_react2.useCallback)(
    (sinceChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: true,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), handleLoadMore = (0, import_react2.useCallback)(() => {
    loading || timelineStore.loadMore();
  }, [loading, timelineStore]), content = timelineError ? (0, import_jsx_runtime.jsx)(TimelineError, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    mode === "rev" && (0, import_jsx_runtime.jsx)(
      Timeline,
      {
        chunks,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: realRevChunk,
        onLoadMore: handleLoadMore,
        onSelect: selectRev
      }
    ),
    mode === "since" && (0, import_jsx_runtime.jsx)(
      Timeline,
      {
        chunks,
        disabledBeforeFirstChunk: true,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: sinceTime,
        onLoadMore: handleLoadMore,
        onSelect: selectSince
      }
    )
  ] }), formatParams = {
    timestamp: { dateStyle: "medium", timeStyle: "short" }
  }, revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], {
    context: "timestamp",
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.latest-version"), sinceLabel = chunk ? t("timeline.since", {
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.since-version-missing");
  return (0, import_jsx_runtime.jsx)(
    Root$2,
    {
      constrainSize: true,
      content: open && content,
      "data-ui": "versionMenu",
      open,
      placement,
      portal: true,
      ref: setPopover,
      children: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          disabled: !ready,
          mode: "bleed",
          iconRight: ChevronDownIcon,
          onClick: open ? handleClose : handleOpen,
          ref: setButton,
          selected: open,
          style: { maxWidth: "100%" },
          text: ready ? mode === "rev" ? revLabel : sinceLabel : t("timeline.loading-history")
        }
      )
    }
  );
}
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  return (0, import_jsx_runtime.jsx)(TabList, { space: 1, children: views2.map((view, index) => {
    var _a;
    return (0, import_jsx_runtime.jsx)(
      DocumentHeaderTab,
      {
        icon: view.icon,
        id: `${paneKey}tab-${view.id}`,
        isActive: activeViewId === view.id,
        label: view.title,
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      },
      view.id
    );
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props, { ready } = useDocumentPane(), { setView } = usePaneRouter(), handleClick = (0, import_react2.useCallback)(() => setView(viewId), [setView, viewId]);
  return (0, import_jsx_runtime.jsx)(
    Tab,
    {
      ...rest,
      "aria-controls": tabPanelId,
      disabled: !ready,
      icon,
      id,
      label,
      onClick: handleClick,
      selected: isActive
    }
  );
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = useDocumentPreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  }), { t } = useTranslation2(structureLocaleNamespace);
  return connectionState === "connecting" ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}) : title ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: title }) : documentValue ? error ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("panes.document-header-title.error.text", { error: error.message }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("panes.document-header-title.new.text", {
    schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)
  }) });
}
var DocumentPanelHeader = (0, import_react2.memo)(
  (0, import_react2.forwardRef)(function(_props, ref) {
    const { menuItems } = _props, {
      actions,
      editState,
      onMenuAction,
      onPaneClose,
      onPaneSplit,
      menuItemGroups,
      schemaType,
      timelineStore,
      connectionState,
      views: views2,
      unstable_languageFilter
    } = useDocumentPane(), { features } = useStructureTool(), { index, BackLink: BackLink2, hasGroupSiblings } = usePaneRouter(), { actions: fieldActions } = useFieldActions(), [referenceElement, setReferenceElement] = (0, import_react2.useState)(null), menuNodes = (0, import_react2.useMemo)(
      () => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }),
      [onMenuAction, fieldActions, menuItemGroups, menuItems]
    ), menuButtonNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), showTabs = views2.length > 1, rev = useTimelineSelector(timelineStore, (state2) => state2.revTime), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, { t } = useTranslation2(structureLocaleNamespace);
    return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(
      PaneHeader,
      {
        border: true,
        ref,
        loading: connectionState === "connecting",
        title: (0, import_jsx_runtime.jsx)(DocumentHeaderTitle, {}),
        tabs: showTabs && (0, import_jsx_runtime.jsx)(DocumentHeaderTabs, {}),
        tabIndex,
        backButton: showBackButton && (0, import_jsx_runtime.jsx)(
          Button2,
          {
            as: BackLink2,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: t("pane-header.back-button.text") }
          }
        ),
        subActions: (0, import_jsx_runtime.jsx)(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }),
        actions: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
          unstable_languageFilter.length > 0 && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: unstable_languageFilter.map((languageFilterComponent, idx) => (0, import_react2.createElement)(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: `language-filter-${idx}`,
            schemaType
          })) }),
          menuButtonNodes.map((item) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, { node: item }, item.key)),
          editState && (0, import_jsx_runtime.jsx)(
            RenderActionCollectionState,
            {
              actions: actions || [],
              actionProps: editState,
              group: "paneActions",
              children: ({ states }) => (0, import_jsx_runtime.jsx)(ActionDialogWrapper, { actionStates: states, referenceElement, children: ({ handleAction }) => (0, import_jsx_runtime.jsx)("div", { ref: setReferenceElement, children: (0, import_jsx_runtime.jsx)(
                PaneContextMenuButton,
                {
                  nodes: contextMenuNodes,
                  actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => (0, import_jsx_runtime.jsx)(
                    ActionMenuListItem,
                    {
                      actionState,
                      disabled: !!actionState.disabled,
                      index: actionIndex,
                      onAction: handleAction
                    },
                    actionState.label
                  )) : void 0
                },
                "context-menu"
              ) }) })
            }
          ),
          showSplitPaneButton && (0, import_jsx_runtime.jsx)(
            Button2,
            {
              "aria-label": t("buttons.split-pane-button.aria-label"),
              icon: SplitVerticalIcon,
              mode: "bleed",
              onClick: onPaneSplit,
              tooltipProps: { content: t("buttons.split-pane-button.tooltip") }
            },
            "split-pane-button"
          ),
          showSplitPaneCloseButton && (0, import_jsx_runtime.jsx)(
            Button2,
            {
              icon: CloseIcon,
              mode: "bleed",
              onClick: onPaneClose,
              tooltipProps: { content: t("buttons.split-pane-close-button.title") }
            },
            "close-view-button"
          ),
          showPaneGroupCloseButton && (0, import_jsx_runtime.jsx)(
            Button2,
            {
              icon: CloseIcon,
              mode: "bleed",
              tooltipProps: { content: t("buttons.split-pane-close-group-button.title") },
              as: BackLink2
            },
            "close-view-button"
          )
        ] })
      }
    ) });
  })
);
var BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner({ states }) {
  return states.length === 0 ? null : (0, import_jsx_runtime.jsx)(Inline, { space: 1, children: states.map((badge, index) => (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      content: badge.title,
      disabled: !badge.title,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime.jsx)(
        Badge,
        {
          fontSize: 1,
          mode: "outline",
          paddingX: 2,
          paddingY: 1,
          radius: 4,
          tone: badge.color ? BADGE_TONES[badge.color] : void 0,
          style: { whiteSpace: "nowrap" },
          children: badge.label
        }
      )
    },
    String(index)
  )) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  return !editState || !badges ? null : (0, import_jsx_runtime.jsx)(RenderBadgeCollectionState, { badges, badgeProps: editState, children: ({ states }) => (0, import_jsx_runtime.jsx)(DocumentBadgesInner, { states }) });
}
var DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
};
var DeleteAction = ({ id, type, draft, onComplete }) => {
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane(), { delete: deleteOp } = useDocumentOperation(id, type), [isDeleting, setIsDeleting] = (0, import_react2.useState)(false), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), { t } = useTranslation2(structureLocaleNamespace), handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false), onComplete();
  }, [onComplete]), handleConfirm = (0, import_react2.useCallback)(() => {
    setIsDeleting(true), setConfirmDialogOpen(false), paneSetIsDeleting(true), deleteOp.execute(), onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]), handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  }), currentUser = useCurrentUser();
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: TrashIcon,
    disabled: true,
    label: t("action.delete.label"),
    title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "delete-document", currentUser })
  } : {
    tone: "critical",
    icon: TrashIcon,
    disabled: isDeleting || !!deleteOp.disabled || isPermissionsLoading,
    title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "",
    label: t(isDeleting ? "action.delete.running.label" : "action.delete.label"),
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: (0, import_jsx_runtime.jsx)(
        ConfirmDeleteDialogContainer,
        {
          action: "delete",
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }
      )
    }
  };
};
DeleteAction.action = "delete";
var DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-changes",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
};
var DiscardChangesAction = ({
  id,
  type,
  published,
  liveEdit,
  onComplete
}) => {
  const { discardChanges } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  }), currentUser = useCurrentUser(), { t } = useTranslation2(structureLocaleNamespace), handleConfirm = (0, import_react2.useCallback)(() => {
    discardChanges.execute(), onComplete();
  }, [discardChanges, onComplete]), handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []), dialog = (0, import_react2.useMemo)(
    () => isConfirmDialogOpen && {
      type: "confirm",
      tone: "critical",
      onCancel: onComplete,
      onConfirm: handleConfirm,
      message: t("action.discard-changes.confirm-dialog.confirm-discard-changes")
    },
    [handleConfirm, isConfirmDialogOpen, onComplete, t]
  );
  return !published || liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: ResetIcon,
    disabled: true,
    label: t("action.discard-changes.label"),
    title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "discard-changes", currentUser })
  } : {
    tone: "critical",
    icon: ResetIcon,
    disabled: !!discardChanges.disabled || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "",
    label: t("action.discard-changes.label"),
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
var DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
};
var DuplicateAction = ({ id, type, onComplete }) => {
  const documentStore = useDocumentStore(), { duplicate } = useDocumentOperation(id, type), { navigateIntent } = useRouter(), [isDuplicating, setDuplicating] = (0, import_react2.useState)(false), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  }), { t } = useTranslation2(structureLocaleNamespace), currentUser = useCurrentUser(), handle = (0, import_react2.useCallback)(async () => {
    const dupeId = v4_default();
    setDuplicating(true);
    const duplicateSuccess = firstValueFrom(
      documentStore.pair.operationEvents(id, type).pipe(filter((e2) => e2.op === "duplicate" && e2.type === "success"))
    );
    duplicate.execute(dupeId), await duplicateSuccess, navigateIntent("edit", { id: dupeId, type }), onComplete();
  }, [documentStore.pair, duplicate, id, navigateIntent, onComplete, type]);
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    icon: CopyIcon,
    disabled: true,
    label: t("action.duplicate.label"),
    title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser })
  } : {
    icon: CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading,
    label: t(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"),
    title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
var HistoryRestoreAction = ({ id, type, revision, onComplete }) => {
  const { restore } = useDocumentOperation(id, type), event = useDocumentOperationEvent(id, type), { navigateIntent } = useRouter(), prevEvent = (0, import_react2.useRef)(event), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), { t } = useTranslation2(structureLocaleNamespace), handleConfirm = (0, import_react2.useCallback)(() => {
    restore.execute(revision), onComplete();
  }, [restore, revision, onComplete]);
  (0, import_react2.useEffect)(() => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", { id, type }), prevEvent.current = event);
  }, [event, id, navigateIntent, type]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []), dialog = (0, import_react2.useMemo)(() => isConfirmDialogOpen ? {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: t("action.restore.confirm.message")
  } : null, [handleConfirm, isConfirmDialogOpen, onComplete, t]), isRevisionInitialVersion = revision === "@initial";
  return revision === void 0 ? null : {
    label: t("action.restore.label"),
    color: "primary",
    onHandle: handle,
    title: t(
      isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"
    ),
    icon: RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
var DocumentPublished = defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
});
var DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
function getDisabledReason(reason, publishedAt, t) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? (0, import_jsx_runtime.jsx)(AlreadyPublished, { publishedAt }) : t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished({ publishedAt }) {
  const { t } = useTranslation2(structureLocaleNamespace), timeSincePublished = useRelativeTime(publishedAt);
  return (0, import_jsx_runtime.jsx)("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
var PublishAction = (props) => {
  var _a;
  const { id, type, liveEdit, draft, published } = props, [publishState, setPublishState] = (0, import_react2.useState)(null), { publish } = useDocumentOperation(id, type), validationStatus = useValidationStatus(id, type), syncState = useSyncState(id, type), { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane(), editState = useEditState(documentId, documentType), { t } = useTranslation2(structureLocaleNamespace), revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev, hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker), [publishScheduled, setPublishScheduled] = (0, import_react2.useState)(false), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating, [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  }), currentUser = useCurrentUser(), title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "", hasDraft = !!draft, doPublish = (0, import_react2.useCallback)(() => {
    publish.execute(), setPublishState("publishing");
  }, [publish]);
  (0, import_react2.useEffect)(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors || doPublish(), setPublishScheduled(false));
  }, [
    isSyncing,
    doPublish,
    hasValidationErrors,
    publishScheduled,
    validationStatus.revision,
    revision,
    isValidating,
    validationStatus.isValidating
  ]), (0, import_react2.useEffect)(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    didPublish && changesOpen && onHistoryOpen();
    const nextState = didPublish ? "published" : null, timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const telemetry = useTelemetry(), handle = (0, import_react2.useCallback)(() => {
    telemetry.log(DocumentPublished, {
      publishedImmediately: !(draft != null && draft._createdAt),
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(true) : doPublish();
  }, [
    telemetry,
    draft == null ? void 0 : draft._createdAt,
    published,
    syncState.isSyncing,
    validationStatus.isValidating,
    validationStatus.revision,
    revision,
    doPublish
  ]);
  if (liveEdit)
    return {
      tone: "default",
      icon: PublishIcon,
      label: t("action.publish.live-edit.label"),
      title: t("action.publish.live-edit.tooltip"),
      disabled: true
    };
  if (!isPermissionsLoading && !(permissions != null && permissions.granted))
    return {
      tone: "default",
      icon: PublishIcon,
      label: "Publish",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "publish-document", currentUser }),
      disabled: true
    };
  const disabled = !!(publishScheduled || (_a = editState == null ? void 0 : editState.transactionSyncLock) != null && _a.enabled || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      t(publishState === "published" ? "action.publish.published.label" : publishScheduled || publishState === "publishing" ? "action.publish.running.label" : "action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
var DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
};
var UnpublishAction = ({
  id,
  type,
  draft,
  onComplete,
  liveEdit
}) => {
  const { unpublish } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  }), currentUser = useCurrentUser(), { t } = useTranslation2(structureLocaleNamespace), handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false), onComplete();
  }, [onComplete]), handleConfirm = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false), unpublish.execute(), onComplete();
  }, [onComplete, unpublish]), dialog = (0, import_react2.useMemo)(() => isConfirmDialogOpen ? {
    type: "dialog",
    onClose: onComplete,
    content: (0, import_jsx_runtime.jsx)(
      ConfirmDeleteDialogContainer,
      {
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        action: "unpublish",
        onCancel: handleCancel,
        onConfirm: handleConfirm
      }
    )
  } : null, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  return liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: UnpublishIcon,
    label: "Unpublish",
    title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: true
  } : {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t("action.unpublish.label"),
    title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(true),
    dialog
  };
};
UnpublishAction.action = "unpublish";
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props, { __internal_tasks } = useDocumentPane(), [firstActionState, ...menuActionStates] = states, [buttonElement, setButtonElement] = (0, import_react2.useState)(null), tooltipContent = (0, import_react2.useMemo)(() => !firstActionState || !firstActionState.title && !firstActionState.shortcut ? null : (0, import_jsx_runtime.jsxs)(Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [
    firstActionState.title && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: firstActionState.title }),
    firstActionState.shortcut && (0, import_jsx_runtime.jsx)(
      Hotkeys,
      {
        fontSize: 1,
        style: { marginTop: -4, marginBottom: -4 },
        keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
      }
    )
  ] }), [firstActionState]);
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
    __internal_tasks && __internal_tasks.footerAction,
    firstActionState && (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 200, children: (0, import_jsx_runtime.jsx)(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: (0, import_jsx_runtime.jsx)(Stack, { children: (0, import_jsx_runtime.jsx)(
      Button2,
      {
        "data-testid": `action-${firstActionState.label}`,
        disabled: disabled || !!firstActionState.disabled,
        icon: firstActionState.icon,
        onClick: firstActionState.onHandle,
        ref: setButtonElement,
        size: "large",
        text: firstActionState.label,
        tone: firstActionState.tone || "primary"
      }
    ) }) }) }),
    showMenu && menuActionStates.length > 0 && (0, import_jsx_runtime.jsx)(ActionMenuButton, { actionStates: menuActionStates, disabled }),
    firstActionState && firstActionState.dialog && (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })
  ] });
}
var DocumentStatusBarActions = (0, import_react2.memo)(function() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  return !actions || !editState ? null : (0, import_jsx_runtime.jsx)(
    RenderActionCollectionState,
    {
      actions,
      actionProps: editState,
      group: "default",
      children: ({ states }) => (0, import_jsx_runtime.jsx)(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected",
          showMenu: actions.length > 1,
          states
        },
        documentId
      )
    }
  );
});
var HistoryStatusBarActions = (0, import_react2.memo)(function() {
  const { connectionState, editState, timelineStore } = useDocumentPane(), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), revision = (revTime == null ? void 0 : revTime.id) || "", disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision, actionProps = (0, import_react2.useMemo)(() => ({ ...editState || {}, revision }), [editState, revision]), historyActions = (0, import_react2.useMemo)(() => [HistoryRestoreAction], []);
  return (0, import_jsx_runtime.jsx)(
    RenderActionCollectionState,
    {
      actions: historyActions,
      actionProps,
      group: "default",
      children: ({ states }) => (0, import_jsx_runtime.jsx)(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected" || !!disabled,
          showMenu: false,
          states
        }
      )
    }
  );
});
var StyledMotionPath = ut(motion.path)`
  transform-origin: center;
`;
var Circle = (props) => (0, import_jsx_runtime.jsx)(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props });
var Arrows = (props) => (0, import_jsx_runtime.jsx)(
  StyledMotionPath,
  {
    fill: "none",
    d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
    ...props
  }
);
var Checkmark = (props) => (0, import_jsx_runtime.jsx)(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props });
var rotateAnimation = ht`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`;
var RotateGroup = ut.g`
  transform-origin: center;

  &[data-rotate] {
    animation: ${rotateAnimation} 1s ease-in-out infinite;
  }
`;
var root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: { transition: { duration: 0 } }
};
var circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
};
var arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
};
var checkmark = {
  syncing: {
    pathLength: 0,
    transition: { duration: 0 }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const { status } = props;
  return status ? (0, import_jsx_runtime.jsx)(
    "svg",
    {
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.2",
      "data-sanity-icon": "animated-status-icon",
      children: (0, import_jsx_runtime.jsxs)(motion.g, { variants: root, initial: status, animate: status, children: [
        (0, import_jsx_runtime.jsxs)(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [
          (0, import_jsx_runtime.jsx)(Arrows, { variants: arrows, initial: status, animate: status }),
          (0, import_jsx_runtime.jsx)(Circle, { variants: circle, initial: status, animate: status })
        ] }),
        (0, import_jsx_runtime.jsx)(Checkmark, { variants: checkmark, initial: status, animate: status })
      ] })
    }
  ) : null;
}
var STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
};
var DocumentStatusPulse = (props) => {
  const { status } = props, { t } = useTranslation2(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [
    (0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: currentStatus.tone, children: (0, import_jsx_runtime.jsx)(AnimatedStatusIcon, { status }) }),
    (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t(currentStatus.i18nKey) })
  ] });
};
var SYNCING_TIMEOUT = 1e3;
var SAVED_TIMEOUT = 3e3;
function DocumentStatusLine({ singleLine }) {
  const { documentId, documentType, editState, value } = useDocumentPane(), [status, setStatus] = (0, import_react2.useState)(null), syncState = useSyncState(documentId, documentType), lastUpdated = value == null ? void 0 : value._updatedAt;
  return (0, import_react2.useEffect)(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]), (0, import_react2.useLayoutEffect)(() => {
    setStatus(null);
  }, [documentId]), (0, import_react2.useLayoutEffect)(() => {
    syncState.isSyncing && setStatus("syncing");
  }, [syncState.isSyncing, lastUpdated]), status ? (0, import_jsx_runtime.jsx)(DocumentStatusPulse, { status: status || void 0 }) : (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      content: (0, import_jsx_runtime.jsx)(DocumentStatus, { absoluteDate: true, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
      placement: "top",
      children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
        (0, import_jsx_runtime.jsx)(DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
        (0, import_jsx_runtime.jsx)(
          DocumentStatus,
          {
            draft: editState == null ? void 0 : editState.draft,
            published: editState == null ? void 0 : editState.published,
            singleLine
          }
        )
      ] })
    }
  );
}
function useResizeObserver({
  element,
  onResize
}) {
  (0, import_react2.useLayoutEffect)(() => (element && resizeObserver.observe(element, onResize), () => {
    element && resizeObserver.unobserve(element);
  }), [element, onResize]);
}
var CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props, { editState, timelineStore } = useDocumentPane(), showingRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), [collapsed, setCollapsed] = (0, import_react2.useState)(null), [rootElement, setRootElement] = (0, import_react2.useState)(null), handleResize = (0, import_react2.useCallback)((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed == "boolean";
  return (0, import_jsx_runtime.jsx)(Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      align: "stretch",
      gap: 1,
      justify: "space-between",
      paddingY: 2,
      paddingLeft: 4,
      paddingRight: 3,
      children: [
        (0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
          (0, import_jsx_runtime.jsxs)(Flex, { align: "center", children: [
            (0, import_jsx_runtime.jsx)(DocumentStatusLine, { singleLine: !collapsed }),
            (0, import_jsx_runtime.jsx)(SpacerButton, { size: "large" })
          ] }),
          (0, import_jsx_runtime.jsx)(DocumentBadges, {})
        ] }),
        (0, import_jsx_runtime.jsxs)(
          Flex,
          {
            align: "flex-start",
            justify: "flex-end",
            ref: actionsBoxRef,
            style: { flexShrink: 0, marginLeft: "auto" },
            children: [
              (0, import_jsx_runtime.jsx)(SpacerButton, { size: "large" }),
              showingRevision ? (0, import_jsx_runtime.jsx)(HistoryStatusBarActions, {}) : (0, import_jsx_runtime.jsx)(DocumentStatusBarActions, {})
            ]
          }
        )
      ]
    }
  ) });
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, activeAction = states[activeIndex], handleKeyDown = (0, import_react2.useCallback)(
    (event) => {
      const matchingStates = states.filter(
        (state2) => state2.shortcut && (0, import_is_hotkey.default)(state2.shortcut, event)
      ), matchingState = matchingStates[0];
      if (matchingStates.length > 1 && console.warn(
        `Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`
      ), matchingState && !matchingState.disabled && matchingState.onHandle) {
        event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onActionStart, onKeyDown, states]
  );
  return (0, import_react2.createElement)(
    as,
    {
      id,
      onKeyDown: handleKeyDown,
      tabIndex: -1,
      ...rest,
      ref: rootRef
    },
    [
      children,
      activeAction && activeAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })
    ]
  );
}
var DocumentActionShortcuts = React.memo(
  (props) => {
    const { actionsBoxElement, as = "div", children, ...rest } = props, { actions, editState } = useDocumentPane(), [activeIndex, setActiveIndex] = (0, import_react2.useState)(-1), onActionStart = (0, import_react2.useCallback)((idx) => {
      setActiveIndex(idx);
    }, []), actionProps = (0, import_react2.useMemo)(
      () => editState && {
        ...editState,
        // @todo: what to call here?
        onComplete: () => {
        },
        // @todo: get revision string
        revision: void 0
      },
      [editState]
    );
    return !actionProps || !actions ? null : (0, import_jsx_runtime.jsx)(RenderActionCollectionState, { actionProps, actions, children: ({ states }) => (0, import_jsx_runtime.jsx)(
      KeyboardShortcutResponder,
      {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      }
    ) });
  }
);
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({ hasValue, t }) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t("document-inspector.menu-item.title"),
    icon: JsonIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem({ previewUrl, t }) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t("production-preview.menu-item.title"),
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
var isSanityDocument2 = (value) => isRecord$4(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = (0, import_react2.useState)(void 0), [error, setError] = (0, import_react2.useState)(null), { resolveProductionUrl } = useSource().document, value$ = useAsObservable(value);
  if (error)
    throw error;
  return (0, import_react2.useEffect)(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap(
        (document2) => isSanityDocument2(document2) ? from(resolveProductionUrl({ document: document2 })) : of(void 0)
      ),
      catchError((e2) => {
        const message = isRecord$4(e2) && typeof e2.message == "string" ? e2.message : "Unknown error";
        throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
      })
    ).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]), previewUrl;
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props, { t } = useTranslation2();
  return (0, import_jsx_runtime.jsx)(
    ErrorPane,
    {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-unknown-type.title",
          values: { documentType }
        }
      ),
      tone: "caution",
      children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
        documentType && (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(
          Translate,
          {
            t,
            i18nKey: "panes.document-pane.document-unknown-type.text",
            values: { documentType }
          }
        ) }),
        !documentType && (0, import_jsx_runtime.jsx)(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }),
        isDev && value && /* eslint-disable i18next/no-literal-string */
        (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
          (0, import_jsx_runtime.jsx)(Text, { as: "p", children: "Here is the JSON representation of the document:" }),
          (0, import_jsx_runtime.jsx)(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: (0, import_jsx_runtime.jsx)(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
        ] })
      ] })
    }
  );
}
var EMPTY_ARRAY$7 = [];
var DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
var StyledChangeConnectorRoot = ut(ChangeConnectorRoot)`
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
`;
function DocumentLayout() {
  const {
    changesOpen,
    documentId,
    documentType,
    fieldActions,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value
  } = useDocumentPane(), { features } = useStructureTool(), { t } = useTranslation(structureLocaleNamespace), { collapsed: layoutCollapsed } = usePaneLayout(), zOffsets = useZIndex(), previewUrl = usePreviewUrl(value), [rootElement, setRootElement] = (0, import_react2.useState)(null), [footerElement, setFooterElement] = (0, import_react2.useState)(null), [headerElement, setHeaderElement] = (0, import_react2.useState)(null), [actionsBoxElement, setActionsBoxElement] = (0, import_react2.useState)(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = (0, import_react2.useState)(
    null
  ), [inspectorMenuItems, setInspectorMenuItems] = (0, import_react2.useState)([]), [rootFieldActionNodes, setRootFieldActionNodes] = (0, import_react2.useState)([]), footerRect = useElementRect(footerElement), headerRect = useElementRect(headerElement), footerHeight = footerRect == null ? void 0 : footerRect.height, headerHeight = headerRect == null ? void 0 : headerRect.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), currentInspector = (0, import_react2.useMemo)(
    () => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)),
    [inspectors2, inspector == null ? void 0 : inspector.name]
  ), hasValue = !!value, menuItems = (0, import_react2.useMemo)(
    () => getMenuItems({
      currentInspector,
      features,
      hasValue,
      inspectorMenuItems,
      inspectors: inspectors2,
      previewUrl,
      t
    }),
    [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]
  ), handleKeyUp = (0, import_react2.useCallback)(
    (event) => {
      for (const item of menuItems)
        if (item.shortcut && (0, import_is_hotkey.default)(item.shortcut, event)) {
          event.preventDefault(), event.stopPropagation(), onMenuAction(item);
          return;
        }
    },
    [onMenuAction, menuItems]
  ), onConnectorSetFocus = (0, import_react2.useCallback)(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onPathOpen, onFocus]
  );
  return schemaType ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    inspectors2.length > 0 && (0, import_jsx_runtime.jsx)(
      DocumentInspectorMenuItemsResolver,
      {
        documentId,
        documentType,
        inspectors: inspectors2,
        onMenuItems: setInspectorMenuItems
      }
    ),
    fieldActions.length > 0 && schemaType && (0, import_jsx_runtime.jsx)(
      FieldActionsResolver,
      {
        actions: fieldActions,
        documentId,
        documentType,
        onActions: setRootFieldActionNodes,
        path: EMPTY_ARRAY$7,
        schemaType
      }
    ),
    (0, import_jsx_runtime.jsx)(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$7, children: (0, import_jsx_runtime.jsxs)(
      DocumentActionShortcuts,
      {
        actionsBoxElement,
        as: Pane,
        currentMinWidth,
        "data-testid": "document-pane",
        flex: 2.5,
        id: paneKey,
        minWidth,
        onKeyUp: handleKeyUp,
        rootRef: setRootElement,
        children: [
          (0, import_jsx_runtime.jsx)(DocumentPanelHeader, { ref: setHeaderElement, menuItems }),
          (0, import_jsx_runtime.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: (0, import_jsx_runtime.jsx)(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: (0, import_jsx_runtime.jsx)(
            StyledChangeConnectorRoot,
            {
              "data-testid": "change-connector-root",
              isReviewChangesOpen: changesOpen,
              onOpenReviewChanges: onHistoryOpen,
              onSetFocus: onConnectorSetFocus,
              children: (0, import_jsx_runtime.jsx)(
                DocumentPanel,
                {
                  footerHeight: footerHeight || null,
                  headerHeight: headerHeight || null,
                  isInspectOpen: inspectOpen,
                  rootElement,
                  setDocumentPanelPortalElement
                }
              )
            }
          ) }) }),
          (0, import_jsx_runtime.jsx)(
            PortalProvider,
            {
              __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement },
              children: (0, import_jsx_runtime.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: (0, import_jsx_runtime.jsx)(PaneFooter, { ref: setFooterElement, children: (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) })
            }
          ),
          (0, import_jsx_runtime.jsx)(DocumentOperationResults, {})
        ]
      }
    ) })
  ] }) : (0, import_jsx_runtime.jsx)(
    DocumentLayoutError,
    {
      currentMinWidth,
      documentType,
      minWidth,
      paneKey,
      value
    }
  );
}
function pick(plugin) {
  var _a, _b;
  return (_b = (_a = plugin.document) == null ? void 0 : _a.components) == null ? void 0 : _b.unstable_layout;
}
function useDocumentLayoutComponent() {
  return useMiddlewareComponents({
    pick,
    defaultComponent: DocumentLayout
  });
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(
    `Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`
  );
  const template2 = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t) => t.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template2;
  return !template2 && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), { templateName, templateParams };
}
var DocumentPaneProvider = (0, import_react2.memo)((props) => {
  const { children, index, pane, paneKey, onFocusPath } = props, schema2 = useSchema(), templates = useTemplates(), {
    __internal_tasks,
    document: {
      actions: documentActions2,
      badges: documentBadges2,
      unstable_fieldActions: fieldActionsResolver,
      unstable_languageFilter: languageFilterResolver,
      inspectors: inspectorsResolver
    }
  } = useSource(), presenceStore = usePresenceStore(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, { features } = useStructureTool(), { push: pushToast } = useToast(), {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane, paneOptions = useUnique(options), documentIdRaw = paneOptions.id, documentId = getPublishedId(documentIdRaw), documentType = options.type, params = useUnique(paneRouter.params) || EMPTY_PARAMS$2, panePayload = useUnique(paneRouter.payload), { templateName, templateParams } = (0, import_react2.useMemo)(
    () => getInitialValueTemplateOpts(templates, {
      documentType,
      templateName: paneOptions.template,
      templateParams: paneOptions.templateParameters,
      panePayload,
      urlTemplate: params.template
    }),
    [documentType, paneOptions, params, panePayload, templates]
  ), initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  }), initialValue = useUnique(initialValueRaw), { patch } = useDocumentOperation(documentId, documentType), editState = useEditState(documentId, documentType), { validation: validationRaw } = useValidationStatus(documentId, documentType), connectionState = useConnectionState(documentId, documentType), schemaType = schema2.get(documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value, [isDeleting, setIsDeleting] = (0, import_react2.useState)(false), actions = (0, import_react2.useMemo)(
    () => documentActions2({ schemaType: documentType, documentId }),
    [documentActions2, documentId, documentType]
  ), badges = (0, import_react2.useMemo)(
    () => documentBadges2({ schemaType: documentType, documentId }),
    [documentBadges2, documentId, documentType]
  ), languageFilter = (0, import_react2.useMemo)(
    () => languageFilterResolver({ schemaType: documentType, documentId }),
    [documentId, documentType, languageFilterResolver]
  ), validation = useUnique(validationRaw), views2 = useUnique(viewsProp), [focusPath, setFocusPath] = (0, import_react2.useState)(
    () => params.path ? fromString(params.path) : EMPTY_ARRAY$b
  ), focusPathRef = (0, import_react2.useRef)(focusPath), activeViewId = params.view || views2[0] && views2[0].id || null, [timelineMode, setTimelineMode] = (0, import_react2.useState)("closed"), [timelineError, setTimelineError] = (0, import_react2.useState)(null), timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes), timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed), timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady), isPristine = useTimelineSelector(timelineStore, (state2) => state2.isPristine), isDeleted = (0, import_react2.useMemo)(() => timelineReady ? !(editState != null && editState.draft) && !(editState != null && editState.published) && !isPristine : false, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]), previewUrl = usePreviewUrl(value), [presence, setPresence] = (0, import_react2.useState)([]);
  (0, import_react2.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = (0, import_react2.useMemo)(
    () => inspectorsResolver({ documentId, documentType }),
    [documentId, documentType, inspectorsResolver]
  ), [inspectorName, setInspectorName] = (0, import_react2.useState)(() => params.inspect || null), inspectParamRef = (0, import_react2.useRef)(params.inspect);
  (0, import_react2.useEffect)(() => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName), resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME), changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME, { t } = useTranslation2(structureLocaleNamespace), inspectOpen = params.inspect === "on", compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null, fieldActions = (0, import_react2.useMemo)(
    () => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [],
    [documentId, documentType, fieldActionsResolver, schemaType]
  ), ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError), displayed = (0, import_react2.useMemo)(
    () => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value,
    [onOlderRevision, timelineDisplayed, value]
  ), setTimelineRange = (0, import_react2.useCallback)(
    (newSince, newRev) => {
      setPaneParams({
        ...params,
        since: newSince,
        rev: newRev || void 0
      });
    },
    [params, setPaneParams]
  ), handleFocus = (0, import_react2.useCallback)(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath), focusPathRef.current !== nextFocusPath && (focusPathRef.current = nextFocusPath, onFocusPath == null || onFocusPath(nextFocusPath)), presenceStore.setLocation([
        {
          type: "document",
          documentId,
          path: nextFocusPath,
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      ]);
    },
    [documentId, onFocusPath, presenceStore, setFocusPath]
  ), handleBlur = (0, import_react2.useCallback)(
    (blurredPath) => {
      disableBlurRef.current || (setFocusPath(EMPTY_ARRAY$b), focusPathRef.current !== EMPTY_ARRAY$b && (focusPathRef.current = EMPTY_ARRAY$b, onFocusPath == null || onFocusPath(EMPTY_ARRAY$b)));
    },
    [onFocusPath, setFocusPath]
  ), patchRef = (0, import_react2.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = (0, import_react2.useCallback)((event) => patchRef.current(event), []), closeInspector = (0, import_react2.useCallback)(
    (closeInspectorName) => {
      var _a, _b, _c, _d;
      const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
      if (closeInspectorName && !inspector) {
        console.warn(`No inspector named "${closeInspectorName}"`);
        return;
      }
      if (currentInspector) {
        if (inspector) {
          const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, { params })) != null ? _b : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
          return;
        }
        if (currentInspector) {
          const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, { params })) != null ? _d : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
        }
      }
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), openInspector = (0, import_react2.useCallback)(
    (nextInspectorName, paneParams) => {
      var _a, _b, _c, _d;
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (!nextInspector) {
        console.warn(`No inspector named "${nextInspectorName}"`);
        return;
      }
      if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
        setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
        return;
      }
      let currentParams = params;
      currentInspector && (currentParams = ((_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, { params: currentParams })) != null ? _b : {
        params: currentParams
      }).params);
      const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, { params: currentParams })) != null ? _d : { params: currentParams };
      setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), handleHistoryClose = (0, import_react2.useCallback)(() => {
    resolvedChangesInspector && closeInspector(resolvedChangesInspector.name);
  }, [closeInspector, resolvedChangesInspector]), handleHistoryOpen = (0, import_react2.useCallback)(() => {
    features.reviewChanges && resolvedChangesInspector && openInspector(resolvedChangesInspector.name);
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]), handlePaneClose = (0, import_react2.useCallback)(() => paneRouter.closeCurrent(), [paneRouter]), handlePaneSplit = (0, import_react2.useCallback)(() => paneRouter.duplicateCurrent(), [paneRouter]), toggleLegacyInspect = (0, import_react2.useCallback)(
    (toggle = !inspectOpen) => {
      setPaneParams(toggle ? { ...params, inspect: "on" } : (0, import_omit.default)(params, "inspect"));
    },
    [inspectOpen, params, setPaneParams]
  ), handleMenuAction = (0, import_react2.useCallback)(
    (item) => {
      if (item.action === "production-preview" && previewUrl)
        return window.open(previewUrl), true;
      if (item.action === "inspect")
        return toggleLegacyInspect(true), true;
      if (item.action === "reviewChanges")
        return handleHistoryOpen(), true;
      if (typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
        const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
        if (nextInspector)
          return nextInspector.name === inspectorName ? closeInspector(nextInspector.name) : openInspector(nextInspector.name), true;
      }
      return false;
    },
    [
      closeInspector,
      handleHistoryOpen,
      inspectorName,
      inspectors2,
      openInspector,
      previewUrl,
      toggleLegacyInspect
    ]
  ), handleLegacyInspectClose = (0, import_react2.useCallback)(
    () => toggleLegacyInspect(false),
    [toggleLegacyInspect]
  ), [openPath, onSetOpenPath] = (0, import_react2.useState)([]), [fieldGroupState, onSetFieldGroupState] = (0, import_react2.useState)(), [collapsedPaths, onSetCollapsedPath] = (0, import_react2.useState)(), [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react2.useState)(), handleOnSetCollapsedPath = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = (0, import_react2.useCallback)(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), requiredPermission = value._createdAt ? "update" : "create", liveEdit = !!(schemaType != null && schemaType.liveEdit), docId = value._id ? value._id : "dummy-id", docPermissionsInput = (0, import_react2.useMemo)(() => ({
    ...value,
    _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
  }), [liveEdit, value, docId]), [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  }), isNonExistent = !(value != null && value._id), readOnly = (0, import_react2.useMemo)(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions != null && permissions.granted), updateActionDisabled = !isActionEnabled(schemaType, "update"), createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create"), reconnecting = connectionState === "reconnecting", isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [
    connectionState,
    editState.transactionSyncLock,
    isNonExistent,
    isDeleted,
    isDeleting,
    isPermissionsLoading,
    permissions == null ? void 0 : permissions.granted,
    ready,
    revTime,
    schemaType
  ]), formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  }), formStateRef = (0, import_react2.useRef)(formState);
  formStateRef.current = formState;
  const setOpenPath = (0, import_react2.useCallback)(
    (path) => {
      getExpandOperations(formStateRef.current, path).forEach((op) => {
        op.type === "expandPath" && onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, false)), op.type === "expandFieldSet" && onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, false)), op.type === "setSelectedGroup" && onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }), onSetOpenPath(path);
    },
    [formStateRef]
  ), documentPane = (0, import_react2.useMemo)(
    () => ({
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      inspector: currentInspector || null,
      inspectors: inspectors2,
      __internal_tasks,
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus,
      onPathOpen: setOpenPath,
      onHistoryClose: handleHistoryClose,
      onHistoryOpen: handleHistoryOpen,
      onInspectClose: handleLegacyInspectClose,
      onMenuAction: handleMenuAction,
      onPaneClose: handlePaneClose,
      onPaneSplit: handlePaneSplit,
      onSetActiveFieldGroup: handleSetActiveFieldGroup,
      onSetCollapsedPath: handleOnSetCollapsedPath,
      onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
      openInspector,
      index,
      inspectOpen,
      validation,
      menuItemGroups: menuItemGroups || [],
      paneKey,
      previewUrl,
      ready,
      schemaType,
      isPermissionsLoading,
      permissions,
      setTimelineMode,
      setTimelineRange,
      setIsDeleting,
      isDeleting,
      isDeleted,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      value,
      views: views2,
      formState,
      unstable_languageFilter: languageFilter
    }),
    [
      __internal_tasks,
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      currentInspector,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      formState,
      handleBlur,
      handleChange,
      handleFocus,
      handleHistoryClose,
      handleHistoryOpen,
      handleLegacyInspectClose,
      handleMenuAction,
      handleOnSetCollapsedFieldSet,
      handleOnSetCollapsedPath,
      handlePaneClose,
      handlePaneSplit,
      handleSetActiveFieldGroup,
      index,
      inspectOpen,
      inspectors2,
      isDeleted,
      isDeleting,
      isPermissionsLoading,
      languageFilter,
      menuItemGroups,
      openInspector,
      paneKey,
      permissions,
      previewUrl,
      ready,
      schemaType,
      setOpenPath,
      setTimelineRange,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      validation,
      value,
      views2
    ]
  );
  (0, import_react2.useEffect)(() => {
    connectionState === "reconnecting" && pushToast({
      id: "sanity/structure/reconnecting",
      status: "warning",
      title: t("panes.document-pane-provider.reconnecting.title")
    });
  }, [connectionState, pushToast, t]);
  const disableBlurRef = (0, import_react2.useRef)(false);
  return (0, import_react2.useEffect)(() => {
    var _a;
    if (ready && params.path) {
      const { path, ...restParams } = params, pathFromUrl = resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, fromString(path));
      disableBlurRef.current = true, setFocusPath(pathFromUrl), setOpenPath(pathFromUrl), focusPathRef.current !== pathFromUrl && (focusPathRef.current = pathFromUrl, onFocusPath == null || onFocusPath(pathFromUrl));
      const timeout = setTimeout(() => {
        disableBlurRef.current = false;
      }, 0);
      return paneRouter.setParams(restParams), () => clearTimeout(timeout);
    }
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]), (0, import_jsx_runtime.jsx)(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var DocumentPane = (0, import_react2.memo)(function(props) {
  const { name: parentSourceName } = useSource();
  return (0, import_jsx_runtime.jsx)(SourceProvider, { name: props.pane.source || parentSourceName, children: (0, import_jsx_runtime.jsx)(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a;
  const { pane, paneKey } = props, { resolveNewDocumentOptions } = useSource().document, paneRouter = usePaneRouter(), options = usePaneOptions(pane.options, paneRouter.params), { documentType, isLoaded: isDocumentLoaded } = useDocumentType(options.id, options.type), DocumentLayout2 = useDocumentLayoutComponent(), templateItems = (0, import_react2.useMemo)(() => resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), [options.id, options.type, resolveNewDocumentOptions]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading, providerProps = (0, import_react2.useMemo)(() => isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, [props, documentType, isLoaded, options]), { ReferenceChildLink: ReferenceChildLink2, handleEditReference, groupIndex, routerPanesState } = paneRouter, childParams = ((_a = routerPanesState[groupIndex + 1]) == null ? void 0 : _a[0].params) || {}, routerPanesStateLength = routerPanesState.length, { parentRefPath } = childParams, activePath = (0, import_react2.useMemo)(() => parentRefPath ? {
    path: fromString(parentRefPath),
    state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    )
  } : { path: [], state: "none" }, [parentRefPath, groupIndex, routerPanesStateLength]), { t } = useTranslation2(structureLocaleNamespace);
  return options.type === "*" && !isLoaded ? (0, import_jsx_runtime.jsx)(
    LoadingPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.loading")
    }
  ) : documentType ? (0, import_jsx_runtime.jsx)(
    DocumentPaneProvider,
    {
      ...providerProps,
      children: (0, import_jsx_runtime.jsx)(
        ReferenceInputOptionsProvider,
        {
          EditReferenceLinkComponent: ReferenceChildLink2,
          onEditReference: handleEditReference,
          initialValueTemplateItems: templatePermissions,
          activePath,
          children: (0, import_jsx_runtime.jsx)(DocumentLayout2, { documentId: options.id, documentType: options.type })
        }
      )
    },
    `${documentType}-${options.id}`
  ) : (0, import_jsx_runtime.jsx)(
    ErrorPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.title"),
      children: (0, import_jsx_runtime.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-not-found.text",
          values: { id: options.id }
        }
      ) }) })
    }
  );
}
function usePaneOptions(options, params = {}) {
  const templates = useTemplates();
  return (0, import_react2.useMemo)(() => {
    if (options.type && options.type !== "*")
      return options;
    const templateName = options.template || params.template, template2 = templateName ? templates.find((t) => t.id === templateName) : void 0, documentType = template2 == null ? void 0 : template2.schemaType;
    return documentType ? { ...options, type: documentType } : options;
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: { ...options, type: documentType }
    }
  };
}
var PARTIAL_PAGE_LIMIT = 100;
var FULL_LIST_LIMIT = 2e3;
var DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] };
var EMPTY_RECORD = {};
var RootBox = ut(Box)`
  position: relative;
`;
var CommandListBox = ut(Box)`
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
`;
var SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return (0, import_jsx_runtime.jsx)(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { isPlaceholder: true, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const {
    childItemId,
    error,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    isLoading,
    items,
    layout,
    loadingVariant,
    onListChange,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons
  } = props, schema2 = useSchema(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed, index } = usePane(), [shouldRender, setShouldRender] = (0, import_react2.useState)(false), { t } = useTranslation2(structureLocaleNamespace), handleEndReached = (0, import_react2.useCallback)(() => {
    isLoading || isLazyLoading || !shouldRender || onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  (0, import_react2.useEffect)(() => {
    if (collapsed)
      return;
    const timer2 = setTimeout(() => {
      setShouldRender(true);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, [collapsed, items]);
  const renderItem2 = (0, import_react2.useCallback)(
    (item, { activeIndex }) => {
      const publishedId = getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(
          PaneItem,
          {
            icon: showIcons === false ? false : void 0,
            id: publishedId,
            layout,
            marginBottom: 1,
            pressed,
            schemaType: schema2.get(item._type),
            selected,
            value: item
          }
        ),
        showSpinner && (0, import_jsx_runtime.jsx)(LoadingBlock, {}),
        showMaxItemsMessage && (0, import_jsx_runtime.jsx)(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })
      ] });
    },
    [childItemId, isActive, items.length, layout, schema2, showIcons, hasMaxItems, isLazyLoading, t]
  ), noDocumentsContent = (0, import_react2.useMemo)(() => hasSearchQuery ? (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, children: t("panes.document-list-pane.no-documents.text") }) }) }) }) : (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, children: t(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text") }) }) }) }), [filterIsSimpleTypeConstraint, hasSearchQuery, t]), mainContent = (0, import_react2.useMemo)(() => {
    if (!shouldRender)
      return null;
    if (error)
      return (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        (0, import_jsx_runtime.jsx)(Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }),
        (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(
          Translate,
          {
            t,
            i18nKey: "panes.document-list-pane.error.text",
            values: { error: error.message },
            components: { Code: ({ children }) => (0, import_jsx_runtime.jsx)("code", { children }) }
          }
        ) }),
        onRetry && (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(
          Button2,
          {
            icon: SyncIcon,
            onClick: onRetry,
            text: t("panes.document-list-pane.error.retry-button.text"),
            tone: "primary"
          }
        ) })
      ] }) }) });
    if (!isLoading && items.length === 0)
      return noDocumentsContent;
    if (loadingVariant === "initial" && isLoading)
      return (0, import_jsx_runtime.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime.jsx)(LoadingView, { layout }) });
    if (loadingVariant === "spinner" && isLoading)
      return null;
    const key = `${index}-${collapsed}`;
    return (0, import_jsx_runtime.jsx)(RootBox, { overflow: "hidden", height: "fill", children: (0, import_jsx_runtime.jsx)(CommandListBox, { children: (0, import_jsx_runtime.jsx)(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: paneTitle,
        canReceiveFocus: true,
        inputElement: searchInputElement,
        itemHeight: 51,
        items,
        onEndReached: handleEndReached,
        onlyShowSelectionWhenActive: true,
        overscan: 10,
        paddingBottom: 1,
        paddingX: 3,
        renderItem: renderItem2,
        wrapAround: false
      },
      key
    ) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem2,
    searchInputElement,
    shouldRender
  ]);
  return (0, import_jsx_runtime.jsx)(PaneContent, { overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto", children: mainContent });
}
var DocumentListPaneHeader = (0, import_react2.memo)(
  ({
    contentAfter,
    index,
    initialValueTemplates = [],
    menuItemGroups = [],
    menuItems = [],
    setLayout,
    setSortOrder,
    title
  }) => {
    const { features } = useStructureTool(), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, actionHandlers = (0, import_react2.useMemo)(() => ({
      setLayout: ({ layout: value }) => {
        setLayout(value);
      },
      setSortOrder: (sort) => {
        setSortOrder(sort);
      }
    }), [setLayout, setSortOrder]);
    return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(
      PaneHeader,
      {
        actions: (0, import_jsx_runtime.jsx)(
          PaneHeaderActions,
          {
            initialValueTemplateItems: initialValueTemplates,
            actionHandlers,
            menuItemGroups,
            menuItems
          }
        ),
        backButton: features.backButton && index > 0 && (0, import_jsx_runtime.jsx)(
          Button2,
          {
            as: BackLink,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: "Back" }
          }
        ),
        contentAfter,
        tabIndex,
        title
      }
    ) });
  }
);
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => ({
    ...entry.draft || entry.published,
    hasPublished: !!entry.published,
    hasDraft: !!entry.draft
  }));
}
var RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter2, params = {}) {
  const matches = filter2.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches)
    return null;
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1), v = params[k];
    return typeof v == "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter2) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter2.trim());
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy2 = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? { ...by, mapWith: "dateTime" } : fieldType.jsonType === "string" ? { ...by, mapWith: "lower" } : by : by;
  });
  return orderBy2.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy2 };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(isKeySegment(segment) || isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return true;
    current = current.type;
  }
  return false;
}
var IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path, strict = false) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType))
    return "";
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = `The current ordering config targeted the nonexistent field "${head}" on schema type "${schemaType.name}". It should be one of ${schemaType.fields.map((field) => field.name).join(", ")}`;
      if (strict)
        throw new Error(errorMessage);
      console.warn(errorMessage);
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return `${head}->{${refTypes.map((refType) => joinReferences(refType, tail)).join(",")}}`;
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail), tailWrapper = tailFields ? `{${tailFields}}` : "";
  return tail.length > 0 ? `${head}${tailWrapper}` : head;
}
function getExtendedProjection(schemaType, orderBy2, strict = false) {
  return orderBy2.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
function listenSearchQuery(options) {
  const {
    client,
    schema: schema2,
    sort,
    limit,
    params,
    filter: filter2,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    unstable_enableNewSearch
  } = options, sortBy = sort.by, extendedProjection = sort == null ? void 0 : sort.extendedProjection, events$ = defer(() => client.listen(`*[${filter2}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: false,
    visibility: "query"
  })).pipe(
    mergeMap((ev, i) => i === 0 && ev.type !== "welcome" ? throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : of(ev)),
    share()
  ), [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome");
  return merge(
    welcome$.pipe(take(1)),
    mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, { leading: true, trailing: true }))
  ).pipe(
    exhaustMapWithTrailing((event) => (staticTypeNames ? of(staticTypeNames) : client.observable.fetch(`array::unique(*[${filter2}][]._type)`, params)).pipe(
      mergeMap((typeNames) => {
        const types = getSearchableTypes(schema2).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, true), true) : false), search = createSearch(types, client, {
          filter: filter2,
          params,
          unstable_enableNewSearch,
          maxDepth: maxFieldDepth
        }), doFetch = () => search({
          filter: filter2,
          query: searchQuery || "",
          types
        }, {
          __unstable_extendedProjection: extendedProjection,
          comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
          limit,
          skipSortByScore: true,
          sort: sortBy
        }).pipe(
          map(
            (result) => (
              // eslint-disable-next-line max-nested-callbacks
              result.hits.map(({ hit }) => hit)
            )
          )
        );
        return event.type === "mutation" && event.visibility !== "query" ? timer(1200).pipe(mergeMap(doFetch)) : doFetch();
      })
    ))
  );
}
var EMPTY_ARRAY$6 = [];
var INITIAL_STATE$1 = {
  error: null,
  onRetry: void 0,
  result: null
};
var INITIAL_QUERY_RESULTS = {
  result: null,
  error: null
};
function useDocumentList(opts) {
  const { filter: filter2, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts, client = useClient({
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), { unstable_enableNewSearch = false } = useWorkspace().search, schema2 = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), [resultState, setResult] = (0, import_react2.useState)(INITIAL_STATE$1), { onRetry, error, result } = resultState, documents = result == null ? void 0 : result.documents, items = (0, import_react2.useMemo)(
    () => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY$6,
    [documents]
  ), [isLazyLoading, setIsLazyLoading] = (0, import_react2.useState)(false), [hasFullList, setHasFullList] = (0, import_react2.useState)(false), [shouldFetchFullList, setShouldFetchFullList] = (0, import_react2.useState)(false), typeNameFromFilter = (0, import_react2.useMemo)(
    () => getTypeNameFromSingleTypeFilter(filter2, paramsProp),
    [filter2, paramsProp]
  ), isLoading = result === null && !error, hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT, onListChange = (0, import_react2.useCallback)(() => {
    isLoading || hasFullList || shouldFetchFullList || setShouldFetchFullList(true);
  }, [isLoading, hasFullList, shouldFetchFullList]), handleSetResult = (0, import_react2.useCallback)(
    (res) => {
      var _a, _b;
      if (res.error) {
        setResult(res);
        return;
      }
      const documentsLength = ((_b = (_a = res.result) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) || 0;
      if (!res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList) {
        setIsLazyLoading(true);
        return;
      }
      if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList && setHasFullList(true), (res == null ? void 0 : res.result) === null) {
        setResult((prev) => ({ ...prev.error ? res : prev }));
        return;
      }
      setIsLazyLoading(false), setResult(res);
    },
    [shouldFetchFullList]
  ), queryResults$ = (0, import_react2.useMemo)(() => {
    const onRetry$ = new Subject(), _onRetry = () => onRetry$.next();
    return listenSearchQuery({
      client,
      filter: filter2,
      limit: shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema: schema2,
      searchQuery: searchQuery || "",
      sort: sortOrder || DEFAULT_ORDERING,
      staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : void 0,
      maxFieldDepth,
      unstable_enableNewSearch
    }).pipe(
      map((results) => ({
        result: { documents: results },
        error: null
      })),
      startWith(INITIAL_QUERY_RESULTS),
      catchError((err) => err instanceof ProgressEvent ? throwError(() => new Error("Request error")) : throwError(() => err)),
      catchError((err, caught$) => concat(
        of({ result: null, error: err }),
        merge(fromEvent(window, "online"), onRetry$).pipe(
          take(1),
          mergeMap(() => caught$)
        )
      )),
      scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry }))
    );
  }, [
    shouldFetchFullList,
    sortOrder,
    client,
    filter2,
    paramsProp,
    schema2,
    searchQuery,
    typeNameFromFilter,
    maxFieldDepth,
    unstable_enableNewSearch
  ]);
  (0, import_react2.useEffect)(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = (0, import_react2.useCallback)(() => {
    setHasFullList(false), setIsLazyLoading(false), setResult(INITIAL_STATE$1), setShouldFetchFullList(false);
  }, []);
  return (0, import_react2.useEffect)(() => {
    reset();
  }, [reset, filter2, paramsProp, sortOrder, searchQuery]), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady: !error,
    items,
    onListChange,
    onRetry
  };
}
var EMPTY_ARRAY$5 = [];
var rotate = ht`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
var AnimatedSpinnerIcon = ut(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function useShallowUnique(value) {
  const valueRef = (0, import_react2.useRef)(value);
  return (0, import_shallow_equals.default)(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
var addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a, _b, _c, _d;
    return (_a = item.params) != null && _a.layout ? {
      ...item,
      selected: layout === ((_b = item.params) == null ? void 0 : _b.layout)
    } : (_c = item == null ? void 0 : item.params) != null && _c.by ? {
      ...item,
      selected: (0, import_isEqual2.default)(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d = item == null ? void 0 : item.params) == null ? void 0 : _d.by) || EMPTY_ARRAY$5)
    } : { ...item, selected: false };
  });
};
var DocumentListPane = (0, import_react2.memo)(function(props) {
  const { childItemId, index, isActive, isSelected, pane, paneKey } = props, schema2 = useSchema(), { name: parentSourceName } = useSource(), {
    defaultLayout = "default",
    displayOptions,
    initialValueTemplates = EMPTY_ARRAY$5,
    menuItemGroups,
    menuItems,
    options
  } = pane, { apiVersion, defaultOrdering = EMPTY_ARRAY$5, filter: filter2 } = options, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane.source, typeName = (0, import_react2.useMemo)(() => getTypeNameFromSingleTypeFilter(filter2, params), [filter2, params]), showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== false, [layout, setLayout] = useStructureToolSetting(
    "layout",
    typeName,
    defaultLayout
  ), { t } = useTranslation2(structureLocaleNamespace), { title } = useI18nText(pane), [searchQuery, setSearchQuery] = (0, import_react2.useState)(""), [searchInputValue, setSearchInputValue] = (0, import_react2.useState)(""), [searchInputElement, setSearchInputElement] = (0, import_react2.useState)(null), showSearchLoadingRef = (0, import_react2.useRef)(false), defaultSortOrder = (0, import_react2.useMemo)(() => (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING, [defaultOrdering]), [sortOrderRaw, setSortOrder] = useStructureToolSetting(
    "sort-order",
    typeName,
    defaultSortOrder
  ), sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema2.get(typeName)) : sortOrderRaw, sortOrder = useUnique(sortWithOrderingFn), filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter2), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady,
    items,
    onListChange,
    onRetry
  } = useDocumentList({
    apiVersion,
    filter: filter2,
    params,
    searchQuery: searchQuery == null ? void 0 : searchQuery.trim(),
    sortOrder
  }), menuItemsWithSelectedState = (0, import_react2.useMemo)(
    () => addSelectedStateToMenuItems({
      menuItems,
      sortOrderRaw,
      layout
    }),
    [layout, menuItems, sortOrderRaw]
  ), handleQueryChange = useObservableCallback(
    (event$) => event$.pipe(
      map((event) => event.target.value),
      tap(setSearchInputValue),
      debounce((value) => value === "" ? of("") : timer(300)),
      tap(setSearchQuery)
    ),
    []
  ), handleClearSearch = (0, import_react2.useCallback)(() => {
    setSearchQuery(""), setSearchInputValue("");
  }, []), handleSearchKeyDown = (0, import_react2.useCallback)(
    (event) => {
      event.key === "Escape" && handleClearSearch();
    },
    [handleClearSearch]
  );
  (0, import_react2.useEffect)(() => (showSearchLoadingRef.current === false && !isLoading && (showSearchLoadingRef.current = true), () => {
    showSearchLoadingRef.current = false;
  }), [isLoading]), (0, import_react2.useEffect)(() => {
    handleClearSearch(), showSearchLoadingRef.current = false;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = (0, import_react2.useMemo)(() => isLoading && items.length === 0 && showSearchLoadingRef.current ? "spinner" : "initial", [isLoading, items.length]), searchInput = (0, import_jsx_runtime.jsx)(Box, { paddingX: 3, paddingBottom: 3, children: (0, import_jsx_runtime.jsx)(
    TextInput,
    {
      "aria-label": t("panes.document-list-pane.search-input.aria-label"),
      autoComplete: "off",
      border: false,
      clearButton: !!searchQuery,
      disabled: !isSearchReady,
      fontSize: [2, 2, 1],
      icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : SearchIcon,
      onChange: handleQueryChange,
      onClear: handleClearSearch,
      onKeyDown: handleSearchKeyDown,
      padding: 2,
      placeholder: t("panes.document-list-pane.search-input.placeholder"),
      radius: 2,
      ref: setSearchInputElement,
      spellCheck: false,
      value: searchInputValue
    }
  ) });
  return (0, import_jsx_runtime.jsx)(SourceProvider, { name: sourceName || parentSourceName, children: (0, import_jsx_runtime.jsxs)(
    Pane,
    {
      currentMaxWidth: 350,
      "data-ui": "DocumentListPane",
      id: paneKey,
      maxWidth: 640,
      minWidth: 320,
      selected: isSelected,
      children: [
        _DEBUG,
        (0, import_jsx_runtime.jsx)(
          DocumentListPaneHeader,
          {
            contentAfter: searchInput,
            index,
            initialValueTemplates,
            menuItemGroups,
            menuItems: menuItemsWithSelectedState,
            setLayout,
            setSortOrder,
            title
          }
        ),
        (0, import_jsx_runtime.jsx)(
          DocumentListPaneContent,
          {
            childItemId,
            error,
            filterIsSimpleTypeConstraint,
            hasMaxItems,
            hasSearchQuery: !!searchQuery,
            isActive,
            isLazyLoading,
            isLoading,
            items,
            layout,
            loadingVariant,
            onListChange,
            onRetry,
            paneTitle: title,
            searchInputElement,
            showIcons
          },
          paneKey
        )
      ]
    }
  ) });
});
var SerializeError = class extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    const segment = typeof pathSegment > "u" ? "<unknown>" : `${pathSegment}`;
    this.path = (parentPath || []).concat(hint ? `${segment} (${hint})` : segment);
  }
  withHelpUrl(id) {
    return this.helpId = id, this;
  }
};
var HELP_URL = ((HELP_URL2) => (HELP_URL2.ID_REQUIRED = "structure-node-id-required", HELP_URL2.TITLE_REQUIRED = "structure-title-required", HELP_URL2.FILTER_REQUIRED = "structure-filter-required", HELP_URL2.INVALID_LIST_ITEM = "structure-invalid-list-item", HELP_URL2.COMPONENT_REQUIRED = "structure-view-component-required", HELP_URL2.DOCUMENT_ID_REQUIRED = "structure-document-id-required", HELP_URL2.DOCUMENT_TYPE_REQUIRED = "structure-document-type-required", HELP_URL2.SCHEMA_TYPE_REQUIRED = "structure-schema-type-required", HELP_URL2.SCHEMA_TYPE_NOT_FOUND = "structure-schema-type-not-found", HELP_URL2.LIST_ITEMS_MUST_BE_ARRAY = "structure-list-items-must-be-array", HELP_URL2.QUERY_PROVIDED_FOR_FILTER = "structure-query-provided-for-filter", HELP_URL2.ACTION_OR_INTENT_REQUIRED = "structure-action-or-intent-required", HELP_URL2.LIST_ITEM_IDS_MUST_BE_UNIQUE = "structure-list-item-ids-must-be-unique", HELP_URL2.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE = "structure-action-and-intent-mutually-exclusive", HELP_URL2.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER = "structure-api-version-required-for-custom-filter", HELP_URL2))(HELP_URL || {});
var ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  i18n: {
    title: {
      key: "menu-items.sort-by.last-edited",
      ns: structureLocaleNamespace
    }
  },
  name: "lastEditedDesc",
  by: [{ field: "_updatedAt", direction: "desc" }]
};
var ORDER_BY_CREATED_AT = {
  title: "Created",
  i18n: {
    title: {
      key: "menu-items.sort-by.created",
      ns: structureLocaleNamespace
    }
  },
  name: "lastCreatedDesc",
  by: [{ field: "_createdAt", direction: "desc" }]
};
var DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
var DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemBuilder = class _MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({ action });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({ group });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({ params });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction = true) {
    return this.clone({ showAsAction: !!showAsAction });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options = { path: [] }) {
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action == "string" ? `action: "${action}"` : void 0;
      throw new SerializeError(
        "`title` is required for menu item",
        options.path,
        options.index,
        hint
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent)
      throw new SerializeError(
        `\`action\` or \`intent\` required for menu item with title ${this.spec.title}`,
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    if (intent && action)
      throw new SerializeError(
        "cannot set both `action` AND `intent`",
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    return { ...this.spec, title };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new _MenuItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
function getOrderingMenuItem(context, { by, title, i18n }, extendedProjection) {
  let builder = new MenuItemBuilder(context).group("sorting").title(
    context.i18n.t("default-menu-item.fallback-title", {
      // note this lives in the `studio` bundle because that one is loaded by default
      ns: "studio",
      replace: { title }
      // replaces the `{{title}}` option
    })
  ).icon(SortIcon).action("setSortOrder").params({ by, extendedProjection });
  return i18n && (builder = builder.i18n(i18n)), builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema: schema2 } = context, type = typeof typeName == "string" ? schema2.get(typeName) : typeName;
  return !type || !("orderings" in type) ? [] : (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(
    (ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by))
  );
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemGroupBuilder = class _MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context, this._id = spec ? spec.id : "", this._title = spec ? spec.title : "", this._i18n = spec ? spec.i18n : void 0;
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new _MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new _MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n) {
    return new _MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this._i18n;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options = { path: [] }) {
    const { _id, _title, _i18n } = this;
    if (!_id)
      throw new SerializeError(
        "`id` is required for a menu item group",
        options.path,
        options.index,
        _title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!_title)
      throw new SerializeError(
        "`title` is required for a menu item group",
        options.path,
        _id
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: _id,
      title: _title,
      i18n: _i18n
    };
  }
};
var disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id != "string")
    throw new SerializeError(
      `Structure node id must be of type string, got ${typeof id}`,
      parentPath,
      pathSegment
    );
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar)
    throw new SerializeError(
      `Structure node id cannot contain character "${disallowedChar}"`,
      parentPath,
      pathSegment
    );
  if (id.startsWith("__edit__"))
    throw new SerializeError(
      "Structure node id cannot start with __edit__",
      parentPath,
      pathSegment
    );
  return id;
}
function getStructureNodeId(title, id) {
  if (id)
    return id;
  const camelCased = (0, import_camelCase.default)(title);
  return disallowedPattern.test(camelCased) ? (0, import_camelCase.default)((0, import_speakingurl.default)(title)) : camelCased;
}
var ComponentBuilder = class _ComponentBuilder {
  constructor(spec) {
    this.spec = { options: {}, ...spec || {} };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options = { path: [] }) {
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!component2)
      throw new SerializeError(
        "`component` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, options.path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, options.path)
      )
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new _ComponentBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = getPublishedId(id), draftId = getDraftId(id);
  return (await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(
    query,
    { documentId, draftId },
    { tag: "structure.resolve-type" }
  ))[0];
}
var GenericViewBuilder = class {
  constructor() {
    this.spec = {};
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({ title, id: this.spec.id || (0, import_kebabCase.default)(title) });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options = { path: [] }) {
    const { id, title, icon } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!title)
      throw new SerializeError(
        "`title` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
};
function isSerializable(view) {
  return typeof view.serialize == "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
var isComponentSpec = (spec) => isRecord$4(spec) && spec.type === "component";
var ComponentViewBuilder = class _ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super(), this.spec = spec;
    const userComponent = typeof componentOrSpec == "function" ? componentOrSpec : this.spec.component;
    userComponent && (this.spec = this.component(userComponent).spec);
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options = { path: [] }) {
    const base = super.serialize(options), component2 = this.spec.component;
    if (typeof component2 != "function")
      throw new SerializeError(
        "`component` is required and must be a function for `component()` view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new _ComponentViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
var FormViewBuilder = class _FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super(), this.spec = { id: "editor", title: "Editor", ...spec || {} };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options = { path: [] }) {
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new _FormViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
var form = (spec) => new FormViewBuilder(spec);
var component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
});
var createDocumentChildResolver = ({ resolveDocumentNode, getClient }) => async (itemId, { params, path }) => {
  let type = params.type;
  const parentPath = path.slice(0, path.length - 1), currentSegment = path[path.length - 1];
  if (type || (type = await resolveTypeForDocument(getClient, itemId)), !type)
    throw new SerializeError(
      "Failed to resolve document, and no type provided in parameters.",
      parentPath,
      currentSegment
    );
  return resolveDocumentNode({ documentId: itemId, schemaType: type });
};
var DocumentBuilder = class _DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options || {},
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        type: typeof documentType == "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const urlId = path[index || path.length - 1], id = this.spec.id || urlId && `${urlId}` || "", options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for document nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options || !options.id)
      throw new SerializeError(
        "document id (`id`) is required for document nodes",
        path,
        id,
        hint
      ).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    if (!options || !options.type)
      throw new SerializeError(
        "document type (`schemaType`) is required for document nodes",
        path,
        id,
        hint
      );
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map(
      (item, i) => maybeSerializeView(item, i, path)
    ), viewIds = views2.map((view) => view.id), dupes = (0, import_uniq.default)(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0)
      throw new SerializeError(
        `document node has views with duplicate IDs: ${dupes.join(",  ")}`,
        path,
        id,
        hint
      );
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec = {}) {
    const builder = new _DocumentBuilder(this._context), options = { ...this.spec.options || {}, ...withSpec.options || {} };
    return builder.spec = { ...this.spec, ...withSpec, options }, builder;
  }
};
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  return spec.template && (opts.template = spec.template), spec.templateParameters && (opts.templateParameters = spec.templateParameters), opts;
}
function documentFromEditor(context, spec) {
  let doc = spec != null && spec.type ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const { id, type, template: template2, templateParameters } = spec.options;
  return doc = doc.id(spec.id).documentId(id), type && (doc = doc.schemaType(type)), template2 && (doc = doc.initialValueTemplate(template2, templateParameters)), spec.child && (doc = doc.child(spec.child)), doc;
}
function documentFromEditorWithInitialValue({ resolveDocumentNode, templates }, templateId, parameters) {
  const template2 = templates.find((t) => t.id === templateId);
  if (!template2)
    throw new Error(`Template with ID "${templateId}" not defined`);
  return resolveDocumentNode({ schemaType: template2.schemaType }).initialValueTemplate(
    templateId,
    parameters
  );
}
var InitialValueTemplateItemBuilder = class _InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const { spec, _context } = this, { templates } = _context;
    if (typeof spec.id != "string" || !spec.id)
      throw new SerializeError(
        "`id` is required for initial value template item nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!spec.templateId)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const template2 = templates.find((t) => t.id === spec.templateId);
    if (!template2)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template2.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template2.description,
      title: spec.title || template2.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template2.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec = {}) {
    const builder = new _InitialValueTemplateItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec }, builder;
  }
};
function defaultInitialValueTemplateItems(context) {
  const { schema: schema2, getStructureBuilder, templates } = context, typeNames = schema2.getTypeNames();
  return templates.filter((tpl) => {
    var _a;
    return !((_a = tpl.parameters) != null && _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)).map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema: schema2, templates } = context;
  return templateItems.map((item) => {
    const template2 = templates.find((t) => t.id === item.templateId), title = item.title || (template2 == null ? void 0 : template2.title) || "Create", params = {};
    template2 && template2.schemaType && (params.type = template2.schemaType), item.templateId && (params.template = item.templateId);
    const intentParams = item.parameters ? [params, item.parameters] : params, schemaType = template2 && schema2.get(template2.schemaType), i18n = item.i18n || (template2 == null ? void 0 : template2.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template2 && template2.icon || (schemaType == null ? void 0 : schemaType.icon) || AddIcon).intent({ type: "create", params: intentParams });
    return i18n && (builder = builder.i18n(i18n)), builder.serialize();
  });
}
var DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
var defaultIntentChecker = (intentName, params, { pane }) => {
  var _a, _b;
  const isEdit = intentName === "edit", isCreate = intentName === "create", typedSpec = pane, paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "", paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {}, typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams), initialValueTemplates = typedSpec.initialValueTemplates || [];
  return isCreate && params.template ? initialValueTemplates.some((tpl) => tpl.templateId === params.template) : isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var layoutOptions = ["default", "card", "media", "detail", "block"];
function noChildResolver() {
}
var shallowIntentChecker = (intentName, params, { pane, index }) => index <= 1 && defaultIntentChecker(intentName, params, { pane, index });
var GenericListBuilder = class {
  constructor() {
    this.initialValueTemplatesSpecified = false, this.spec = {};
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled = true) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    return this.initialValueTemplatesSpecified = true, this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id || "", path = options.path, defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout))
      throw new SerializeError(
        `\`layout\` must be one of ${layoutOptions.map((item) => `"${item}"`).join(", ")}`,
        path,
        id || options.index,
        this.spec.title
      );
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map(
      (item, i) => maybeSerializeInitialValueTemplateItem(item, i, path)
    );
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      i18n: this.spec.i18n,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, path)
      )
    };
  }
};
var validateFilter = (spec, options) => {
  var _a;
  const filter2 = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter2[0]))
    throw new SerializeError(
      `\`filter\` cannot start with \`${filter2[0]}\` - looks like you are providing a query, not a filter`,
      options.path,
      spec.id,
      spec.title
    ).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  return filter2;
};
var createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a;
  const parentItem = options.parent, template2 = (_a = options.params) != null && _a.template ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0, type = template2 ? template2.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(
    (schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType("")
  );
};
var DocumentListBuilder = class _DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec != null && spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter2) {
    return this.clone({ options: { ...this.spec.options || {}, filter: filter2 } });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type == "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, params }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering))
      throw new Error("`defaultOrdering` must be an array of order clauses");
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options = { path: [] }) {
    var _a;
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError(
        "`id` is required for document lists",
        options.path,
        options.index,
        this.spec.title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.options || !this.spec.options.filter)
      throw new SerializeError(
        "`filter` is required for document lists",
        options.path,
        this.spec.id,
        this.spec.title
      ).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    return ((_a = this.spec.options) == null ? void 0 : _a.filter) !== "_type == $type" && this.spec.options.filter && !this.spec.options.apiVersion && console.warn(
      `No apiVersion specified for document type list with custom filter: \`${this.spec.options.filter}\`. This will be required in the future. See %s for more info.`,
      generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER)
    ), {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, this.initialValueTemplatesSpecified || (builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec)), builder.spec.schemaTypeName || (builder.spec.schemaTypeName = inferTypeName(builder.spec)), builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
};
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context, { schemaTypeName, options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter2, params)));
  if (typeNames.length !== 0)
    return typeNames.flatMap(
      (schemaType) => document2.resolveNewDocumentOptions({
        type: "structure",
        schemaType
      })
    ).map((option) => ({ ...option, icon: AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = getTypeNamesFromFilter(filter2, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter2, params = {}) {
  let typeNames = getTypeNamesFromEqualityFilter(filter2, params);
  return typeNames.length === 0 && (typeNames = getTypeNamesFromInTypesFilter(filter2, params)), typeNames;
}
function getTypeNamesFromEqualityFilter(filter2, params = {}) {
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g, matches = [];
  let match;
  for (; (match = pattern.exec(filter2)) !== null; )
    matches.push(match[1] || match[2]);
  return matches.map((candidate) => ((candidate[0] === "$" ? params[candidate.slice(1)] : candidate) || "").trim().replace(/^["']|["']$/g, "")).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter2, params = {}) {
  const pattern = /\b_type\s+in\s+\[(.*?)\]/, matches = filter2.match(pattern);
  return matches ? matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean) : [];
}
var getArgType = (thing) => thing instanceof ListBuilder ? "ListBuilder" : isPromise(thing) ? "Promise" : Array.isArray(thing) ? "array" : typeof thing;
var isListItem = (item) => item.type === "listItem";
var defaultCanHandleIntent = (intentName, params, context) => (context.pane.items || []).filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
var resolveChildForItem = (itemId, options) => {
  const target = (options.parent.items.filter(isListItem).find((item) => item.id === itemId) || { child: void 0 }).child;
  return !target || typeof target != "function" ? target : typeof target == "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder)
    return item.serialize({ path, index });
  const listItem = item;
  if (listItem && listItem.type === "divider")
    return item;
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem), helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError(
      `List items must be of type "listItem", got "${gotWhat}"${helpText}`,
      path,
      index
    ).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord$4(thing) && typeof thing.then == "function";
}
var ListBuilder = class _ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for lists",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const items = typeof this.spec.items > "u" ? [] : this.spec.items;
    if (!Array.isArray(items))
      throw new SerializeError(
        "`items` must be an array of items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    const path = (options.path || []).concat(id), serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path)), dupes = serializedItems.filter((val, i) => (0, import_find.default)(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5), dupeDesc = dupes.length > 5 ? `${dupeIds.join(", ")}...` : dupeIds.join(", ");
      throw new SerializeError(
        `List items with same ID found (${dupeDesc})`,
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new _ListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
var ListItemBuilder = class _ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled = true) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    return typeof schemaType == "string" ? this._context.schema.get(schemaType) : this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options = { path: [] }) {
    const { id, title, child } = this.spec;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options.titleIsOptional && (typeof title != "string" || !title))
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(
        HELP_URL.TITLE_REQUIRED
      );
    let schemaType = this.spec.schemaType;
    if (typeof schemaType == "string") {
      const type = this._context.schema.get(schemaType);
      if (!type)
        throw new SerializeError(
          `Could not find type "${schemaType}" in schema`,
          options.path,
          id
        ).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild == "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => originalChild(itemId, { ...childOptions, serializeOptions });
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _ListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
var createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType == "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
var DocumentListItemBuilder = class _DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec), this._context = _context, this.spec = spec || {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options = { path: [] }) {
    const spec = super.serialize({ ...options, titleIsOptional: true });
    if (!spec.schemaType)
      throw new SerializeError(
        "`schemaType` is required for document list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
};
function isDocumentListItem(item) {
  return isRecord$4(item) && typeof item.schemaType < "u" && typeof item._id == "string";
}
var DocumentTypeListBuilder = class _DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context), this._context = _context, this.spec = spec || {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec), builder = new _DocumentTypeListBuilder(this._context);
    return builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} }, builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec), builder = new _DocumentTypeListBuilder(this._context), canHandleIntent = this.spec.canHandleIntent, override = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER ? { canHandleIntent: void 0 } : {};
    return builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec || {},
      ...override
    }, builder;
  }
};
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes({ schema: schema2 }) {
  return schema2.getTypeNames().filter((n) => {
    const schemaType = schema2.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  return getDocumentTypes(context).map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema: schema2 } = context, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || (0, import_startCase.default)(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent, parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    return parentItem && parentItem.title && (list = list.title(parentItem.title)), list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema: schema2, resolveDocumentNode } = context, schemaType = typeof typeNameOrSpec == "string" ? typeNameOrSpec : typeNameOrSpec.schemaType, typeName = typeof schemaType == "string" ? schemaType : schemaType.name, spec = typeof typeNameOrSpec == "string" ? { schemaType } : typeNameOrSpec, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || (0, import_startCase.default)(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(
    spec.menuItemGroups || [
      {
        id: "sorting",
        title: "Sort",
        i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } }
      },
      {
        id: "layout",
        title: "Layout",
        i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } }
      },
      {
        id: "actions",
        title: "Actions",
        i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } }
      }
    ]
  ).child(
    spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))
  ).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(
    spec.menuItems || [
      // Create new (from action button) will be added in serialization step of GenericList
      // Sort by <Y>
      ...getOrderingMenuItemsForSchemaType(context, type),
      // Display as <Z>
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({ layout: "default" }),
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(StackIcon).action("setLayout").params({ layout: "detail" })
      // Create new (from menu) will be added in serialization step of GenericList
    ]
  );
}
function hasIcon(schemaType) {
  return !schemaType || typeof schemaType == "string" ? false : !!schemaType.icon;
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder({
  defaultDocumentNode,
  source
}) {
  const configContext = getConfigContextFromSource(source), context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
      return builder.getId() || (builder = builder.id("documentEditor")), options.documentId && (builder = builder.documentId(getPublishedId(options.documentId))), builder.schemaType(options.schemaType);
    }
  }, structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: (...args) => getDocumentTypeList(context, ...args),
    documentTypeListItem: (...args) => getDocumentTypeListItem(context, ...args),
    documentTypeListItems: (...args) => getDocumentTypeListItems(context, ...args),
    document: (...args) => new DocumentBuilder(context, ...args),
    documentWithInitialValueTemplate: (...args) => documentFromEditorWithInitialValue(context, ...args),
    defaultDocument: context.resolveDocumentNode,
    list: (...args) => new ListBuilder(context, ...args),
    listItem: (...args) => new ListItemBuilder(context, ...args),
    menuItem: (...args) => new MenuItemBuilder(context, ...args),
    menuItemGroup: (...args) => new MenuItemGroupBuilder(context, ...args),
    menuItemsFromInitialValueTemplateItems: (...args) => menuItemsFromInitialValueTemplateItems(context, ...args),
    documentList: (...args) => new DocumentListBuilder(context, ...args),
    documentListItem: (...args) => new DocumentListItemBuilder(context, ...args),
    orderingMenuItem: (...args) => getOrderingMenuItem(context, ...args),
    orderingMenuItemsForType: (...args) => getOrderingMenuItemsForSchemaType(context, ...args),
    editor: (...args) => documentFromEditor(context, ...args),
    defaultInitialValueTemplateItems: (...args) => defaultInitialValueTemplateItems(context, ...args),
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => (0, import_react_is.isValidElementType)(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec),
    divider: () => ({ id: (0, import_uniqueId.default)("__divider__"), type: "divider" }),
    view: views,
    context
  };
  return structureBuilder;
}
var tasksLocaleNamespace = "tasks";
var tasksUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: tasksLocaleNamespace,
  resources: () => import("./resources3-EXUAOMJQ.js")
});
function getTargetValue({
  documentId,
  documentType,
  dataset,
  projectId
}) {
  return {
    documentType,
    document: {
      _ref: getPublishedId(documentId),
      _type: "crossDatasetReference",
      _dataset: dataset,
      _projectId: projectId,
      _weak: true
    }
  };
}
function getMentionedUsers(description) {
  if (!description)
    return [];
  const subscribers = [];
  return description == null || description.forEach((block) => {
    isPortableTextTextBlock(block) && block.children.forEach((child) => {
      child._type === "mention" && typeof child.userId == "string" && !subscribers.includes(child.userId) && subscribers.push(child.userId);
    });
  }), subscribers;
}
var TASK_STATUS = [
  { value: "open", title: "To Do", icon: (0, import_jsx_runtime.jsx)(CircleIcon, {}) },
  { value: "closed", title: "Done", icon: (0, import_jsx_runtime.jsx)(CheckmarkCircleIcon, {}) }
];
function useDocumentPreviewValues(options) {
  var _a;
  const { documentId, documentType } = options || {}, schemaType = useSchema().get(documentType), documentPreviewStore = useDocumentPreviewStore(), previewState = useMemoObservable(() => !documentId || !schemaType ? of(null) : getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), isLoading = (_a = previewState == null ? void 0 : previewState.isLoading) != null ? _a : true, { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title), subtitle = (draft == null ? void 0 : draft.subtitle) || (published == null ? void 0 : published.subtitle), description = (draft == null ? void 0 : draft.description) || (published == null ? void 0 : published.description), media = (draft == null ? void 0 : draft.media) || (published == null ? void 0 : published.media);
  return {
    isLoading,
    value: {
      title: documentTitle,
      subtitle,
      media,
      description
    }
  };
}
var DATE_FORMAT_OPTIONS = {
  month: "long",
  day: "2-digit",
  minute: "2-digit",
  hour: "2-digit",
  second: "2-digit"
};
var RELATIVE_TIME_OPTIONS = {
  minimal: true,
  useTemporalPhrase: true
};
var Strong = ut.strong`
  font-weight: 600;
`;
function UpdatedTimeAgo(timestamp) {
  const date = new Date(timestamp), formattedDate = useDateTimeFormat(DATE_FORMAT_OPTIONS).format(date);
  return { timeAgo: useRelativeTime(date || "", RELATIVE_TIME_OPTIONS), formattedDate };
}
function UserName({ userId }) {
  const [user, isLoading] = useUser(userId);
  return isLoading ? (0, import_jsx_runtime.jsx)(TextSkeleton, { style: { width: "15ch" } }) : (0, import_jsx_runtime.jsx)(Strong, { children: user == null ? void 0 : user.displayName });
}
var DUE_BY_DATE_OPTIONS = {
  month: "short",
  day: "numeric"
};
function DueByChange({ date }) {
  const dueBy = new Date(date), formattedDate = useDateTimeFormat(DUE_BY_DATE_OPTIONS).format(dueBy);
  return (0, import_jsx_runtime.jsx)(Strong, { children: formattedDate });
}
var LinkWrapper = ut.span`
  > a {
    color: var(--card-fg-muted-color);
    text-decoration: underline;
    text-underline-offset: 1px;
    font-weight: 600;
  }
`;
function TargetContentChange({ target }) {
  const schema2 = useSchema(), documentId = target.document._ref, documentType = target.documentType, documentSchema = schema2.get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  });
  return isLoading ? (0, import_jsx_runtime.jsx)(TextSkeleton, { style: { width: "15ch" } }) : documentSchema ? (0, import_jsx_runtime.jsx)(LinkWrapper, { children: (0, import_jsx_runtime.jsx)(IntentLink, { intent: "edit", params: { id: documentId, type: documentType }, children: value == null ? void 0 : value.title }) }) : null;
}
function getChangeDetails(activity) {
  var _a, _b;
  switch (activity.field) {
    case "status": {
      const statusTitle = (_a = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _a.title;
      return {
        text: "changed status to",
        icon: ((_b = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _b.icon) || (0, import_jsx_runtime.jsx)(CircleIcon, {}),
        changeTo: (0, import_jsx_runtime.jsx)(Strong, { children: statusTitle })
      };
    }
    case "target":
      return activity.to ? {
        text: "set target content to",
        icon: (0, import_jsx_runtime.jsx)(LinkIcon, {}),
        changeTo: (0, import_jsx_runtime.jsx)(TargetContentChange, { target: activity.to })
      } : {
        text: "removed target content",
        icon: (0, import_jsx_runtime.jsx)(LinkIcon, {}),
        changeTo: void 0
      };
    case "dueBy":
      return activity.from ? activity.to ? {
        text: "changed the due date to",
        icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}),
        changeTo: (0, import_jsx_runtime.jsx)(DueByChange, { date: activity.to })
      } : {
        text: "removed the due date",
        icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}),
        changeTo: void 0
      } : {
        text: "set the due date to",
        icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}),
        changeTo: (0, import_jsx_runtime.jsx)(DueByChange, { date: activity.to })
      };
    case "assignedTo":
      return activity.to ? {
        text: "assigned to",
        icon: (0, import_jsx_runtime.jsx)(UserIcon, {}),
        changeTo: (0, import_jsx_runtime.jsx)(UserName, { userId: activity.to })
      } : {
        text: "unassigned this task",
        icon: (0, import_jsx_runtime.jsx)(UserIcon, {}),
        changeTo: void 0
      };
    case "description":
      return {
        text: "updated the task description",
        icon: (0, import_jsx_runtime.jsx)(EditIcon, {}),
        changeTo: void 0
      };
    case "title":
      return {
        text: "updated the task title",
        icon: (0, import_jsx_runtime.jsx)(EditIcon, {}),
        changeTo: void 0
      };
    default:
      return {
        text: "",
        icon: (0, import_jsx_runtime.jsx)(CircleIcon, {})
      };
  }
}
var EditedAt = (0, import_react2.memo)(
  function(props) {
    const { activity } = props, { formattedDate, timeAgo } = UpdatedTimeAgo(activity.timestamp), { icon, text, changeTo } = getChangeDetails(activity);
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [
      (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, marginLeft: 1, marginRight: 3, children: (0, import_jsx_runtime.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime.jsx)(Text, { children: icon }) }) }),
      (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [
        (0, import_jsx_runtime.jsx)(UserName, { userId: activity.author }),
        " ",
        text,
        " ",
        changeTo,
        " â€¢",
        " ",
        (0, import_jsx_runtime.jsx)(Tooltip, { content: formattedDate, placement: "top-end", children: (0, import_jsx_runtime.jsx)("time", { dateTime: formattedDate, children: timeAgo }) })
      ] })
    ] });
  },
  (prevProps, nextProps) => prevProps.activity.timestamp === nextProps.activity.timestamp
);
var AvatarRoot = ut.div(
  (props) => {
    var _a, _b;
    const theme = getTheme_v2(props.theme);
    return at`
      min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
      min-width: ${(_b = theme.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      ${props.$border ? "box-shadow: inset 0 0 0 1px var(--card-border-color);" : ""};
      ${props.$removeBg ? "--card-avatar-gray-bg-color: transparent;" : ""}
    `;
  }
);
var AvatarSkeleton = ut(Skeleton)((props) => {
  var _a, _b;
  const theme = getTheme_v2(props.theme);
  return at`
    height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
    width: ${(_b = theme.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
    border-radius: 50%;
  `;
});
function TasksUserAvatar(props) {
  const { user, size = 0, border = true } = props, [loadedUser, loading] = useUser((user == null ? void 0 : user.id) || "");
  return loading ? (0, import_jsx_runtime.jsx)(AvatarSkeleton, { $size: size, animated: true }) : !user || !loadedUser ? (0, import_jsx_runtime.jsx)(AvatarRoot, { $size: size, $border: border, children: (0, import_jsx_runtime.jsx)(Text, { size, children: (0, import_jsx_runtime.jsx)(UserIcon, {}) }) }) : (0, import_jsx_runtime.jsx)(AvatarRoot, { $size: size, $removeBg: !!(loadedUser != null && loadedUser.imageUrl), children: (0, import_jsx_runtime.jsx)(
    UserAvatar,
    {
      user: loadedUser,
      size,
      ...loadedUser != null && loadedUser.imageUrl ? { color: void 0 } : {}
    }
  ) });
}
var ActivityItemChildrenContainer = ut.div`
  width: 100%;
`;
function ActivityItem({ userId, children }) {
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [
    (0, import_jsx_runtime.jsx)(Box, { marginRight: 3, paddingTop: 1, children: (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: { id: userId }, size: 0 }) }),
    (0, import_jsx_runtime.jsx)(ActivityItemChildrenContainer, { children })
  ] });
}
function TasksActivityCommentInput(props) {
  const { mentionOptions, currentUser, onSubmit } = props, [value, setValue] = (0, import_react2.useState)(null), editorRef = (0, import_react2.useRef)(null), hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]), handleChange = (0, import_react2.useCallback)((nextValue) => {
    setValue(nextValue);
  }, []), handleSubmit = (0, import_react2.useCallback)(() => {
    hasValue && (onSubmit(value), setValue(null));
  }, [hasValue, onSubmit, value]), handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close(), setValue(null);
  }, []), handleKeyDown = (0, import_react2.useCallback)(
    (e2) => {
      var _a, _b;
      e2.key === "Escape" && (e2.preventDefault(), e2.stopPropagation(), hasValue ? (_a = editorRef.current) == null || _a.discardDialogController.open() : ((_b = editorRef.current) == null || _b.discardDialogController.close(), setValue(null)));
    },
    [hasValue]
  ), { t } = useTranslation2(tasksLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: currentUser.id, children: (0, import_jsx_runtime.jsx)(Card, { tone: "transparent", radius: 3, padding: 2, children: (0, import_jsx_runtime.jsx)(
    CommentInput,
    {
      withAvatar: false,
      currentUser,
      expandOnFocus: true,
      mentionOptions,
      onChange: handleChange,
      onDiscardConfirm: handleDiscardConfirm,
      onDiscardCancel: handleDiscardCancel,
      onKeyDown: handleKeyDown,
      onSubmit: handleSubmit,
      placeholder: t("panel.comment.placeholder"),
      ref: editorRef,
      value
    }
  ) }) });
}
var COMMENTS_LIST_ITEM_AVATAR_CONFIG = {
  parentCommentAvatar: false,
  threadCommentsAvatar: true,
  replyAvatar: true,
  avatarSize: 0
};
function TasksActivityCommentItem(props) {
  const { parentComment } = props;
  return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: parentComment.authorId, children: (0, import_jsx_runtime.jsx)(
    CommentsListItem,
    {
      ...props,
      avatarConfig: COMMENTS_LIST_ITEM_AVATAR_CONFIG,
      canReply: true,
      innerPadding: 1,
      isSelected: false,
      mode: "default"
    }
  ) });
}
var UserSkeleton = ut(TextSkeleton)`
  max-width: 15ch;
  width: '100%';
`;
var TasksActivityCreatedAt = (0, import_react2.memo)(
  function(props) {
    var _a;
    const { createdAt, authorId } = props, [user, loading] = useUser(authorId), { timeAgo, formattedDate } = UpdatedTimeAgo(createdAt), { t } = useTranslation2(tasksLocaleNamespace);
    return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: authorId, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", paddingTop: 1, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, muted: true, children: [
      (0, import_jsx_runtime.jsxs)("strong", { style: { fontWeight: 600 }, children: [
        loading ? (0, import_jsx_runtime.jsx)(UserSkeleton, {}) : (_a = user == null ? void 0 : user.displayName) != null ? _a : t("panel.activity.unknown-user"),
        " "
      ] }),
      t("panel.activity.created-fragment"),
      " â€¢",
      " ",
      (0, import_jsx_runtime.jsx)(Tooltip, { content: formattedDate, placement: "top-end", children: (0, import_jsx_runtime.jsx)("time", { dateTime: createdAt, children: timeAgo }) })
    ] }) }) });
  },
  (prevProps, nextProps) => prevProps.createdAt === nextProps.createdAt
);
function TasksSubscribers(props) {
  var _a, _b;
  const { value, onChange, path, currentUserId } = props, buttonText = (_a = value.subscribers) != null && _a.includes(currentUserId) ? "Unsubscribe" : "Subscribe", handleToggleSubscribe = (0, import_react2.useCallback)(() => {
    const subscribers = value.subscribers || [];
    subscribers.includes(currentUserId) || onChange(set(subscribers.concat(currentUserId), path)), subscribers.includes(currentUserId) && onChange(
      set(
        subscribers.filter((subscriberId) => subscriberId !== currentUserId),
        path
      )
    );
  }, [value.subscribers, currentUserId, onChange, path]);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", children: [
    (0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", text: buttonText, onClick: handleToggleSubscribe }),
    value.subscribers && ((_b = value.subscribers) == null ? void 0 : _b.length) > 0 && (0, import_jsx_runtime.jsx)(TasksSubscriberAvatars, { subscriberIds: value.subscribers })
  ] });
}
var EMPTY_ARRAY$4 = [];
function TasksSubscriberAvatars(props) {
  const { subscriberIds: subscriberIdsProp } = props, subscriberIds = (0, import_react2.useMemo)(() => (subscriberIdsProp == null ? void 0 : subscriberIdsProp.filter(Boolean)) || EMPTY_ARRAY$4, [subscriberIdsProp]);
  return (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength: 3, size: 0, children: subscriberIds.map((subscriberId) => (0, import_jsx_runtime.jsx)(
    motion.div,
    {
      exit: { opacity: 0, translateX: "2px", scale: 0.9 },
      animate: {
        opacity: 1,
        translateX: 0,
        scale: 1,
        transition: { type: "just", duration: 0.2 }
      },
      initial: { opacity: 0, translateX: "2px", scale: 0.9 },
      children: (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: { id: subscriberId }, size: 0 })
    },
    subscriberId
  )) }) });
}
var EMPTY_ARRAY$3 = [];
var VARIANTS$2 = {
  hidden: { opacity: 0, x: 0 },
  visible: { opacity: 1, x: 0 }
};
var MotionStack = ut(motion(Stack))``;
function TasksActivityLog(props) {
  const { value, onChange, path, activityData = [] } = props, currentUser = useCurrentUser(), { title: workspaceTitle, basePath } = useWorkspace(), { comments: comments2, mentionOptions, operation, getComment } = useComments(), [commentToDeleteId, setCommentToDeleteId] = (0, import_react2.useState)(null), [commentDeleteError, setCommentDeleteError] = (0, import_react2.useState)(null), [commentDeleteLoading, setCommentDeleteLoading] = (0, import_react2.useState)(false), loading = comments2.loading, taskComments = comments2.data.open, handleGetNotificationValue = (0, import_react2.useCallback)(
    (message, commentId) => {
      const studioUrl = new URL(`${window.location.origin}${basePath ? `${basePath}/` : ""}`);
      studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", value == null ? void 0 : value._id), studioUrl.searchParams.set("viewMode", "edit"), studioUrl.searchParams.set("commentId", commentId);
      const mentionedUsers = getMentionedUsers(message), subscribers = Array.from(/* @__PURE__ */ new Set([...value.subscribers || [], ...mentionedUsers]));
      return {
        documentTitle: value.title || "Sanity task",
        url: studioUrl.toString(),
        workspaceTitle,
        subscribers
      };
    },
    [basePath, value == null ? void 0 : value._id, value.title, workspaceTitle, value.subscribers]
  ), handleCommentCreate = (0, import_react2.useCallback)(
    (message) => {
      const commentId = v4_default(), notification = handleGetNotificationValue(message, commentId), nextComment = {
        id: commentId,
        type: "task",
        message,
        parentCommentId: void 0,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: v4_default(),
        context: {
          notification
        }
      };
      onChange(set(notification.subscribers, ["subscribers"])), operation.create(nextComment);
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentReply = (0, import_react2.useCallback)(
    (nextComment) => {
      const commentId = v4_default(), notification = handleGetNotificationValue(nextComment.message, commentId);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        id: commentId,
        type: "task",
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: nextComment.threadId,
        context: {
          notification
        }
      });
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentCreateRetry = (0, import_react2.useCallback)(
    (id) => {
      const comment = getComment(id);
      if (!comment)
        return;
      const notification = handleGetNotificationValue(comment.message, comment._id);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        type: "task",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || EMPTY_ARRAY$3,
        status: comment.status,
        threadId: comment.threadId,
        context: {
          notification
        }
      });
    },
    [getComment, operation, handleGetNotificationValue, onChange]
  ), handleCommentReact = (0, import_react2.useCallback)(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeleteCommentStart = (0, import_react2.useCallback)((id) => setCommentToDeleteId(id), []), handleDeleteCommentCancel = (0, import_react2.useCallback)(() => setCommentToDeleteId(null), []), handleDeleteCommentConfirm = (0, import_react2.useCallback)(
    async (id) => {
      try {
        setCommentDeleteLoading(true), setCommentDeleteError(null), await operation.remove(id), setCommentToDeleteId(null);
      } catch (err) {
        setCommentDeleteError(err);
      } finally {
        setCommentDeleteLoading(false);
      }
    },
    [operation]
  ), handleCommentEdit = (0, import_react2.useCallback)(
    (id, next) => {
      operation.update(id, next);
    },
    [operation]
  ), activity = (0, import_react2.useMemo)(() => {
    const taskActivity = activityData.map((item) => ({
      _type: "activity",
      payload: item,
      timestamp: item.timestamp
    })), commentsActivity = taskComments.map((comment) => ({
      _type: "comment",
      payload: comment,
      timestamp: comment.parentComment._createdAt
    }));
    return taskActivity.concat(commentsActivity).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  }, [activityData, taskComments]), { t } = useTranslation2(tasksLocaleNamespace), commentToDeleteIsParent = (0, import_react2.useMemo)(() => {
    var _a;
    const parent = taskComments.find((c) => {
      var _a2;
      return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === commentToDeleteId;
    });
    return !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
  }, [commentToDeleteId, taskComments]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    commentToDeleteId && (0, import_jsx_runtime.jsx)(
      CommentDeleteDialog,
      {
        commentId: commentToDeleteId,
        error: commentDeleteError,
        isParent: commentToDeleteIsParent,
        loading: commentDeleteLoading,
        onClose: handleDeleteCommentCancel,
        onConfirm: handleDeleteCommentConfirm
      }
    ),
    (0, import_jsx_runtime.jsxs)(Stack, { space: 5, children: [
      (0, import_jsx_runtime.jsxs)(Flex, { align: "center", children: [
        (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, weight: "semibold", children: t("panel.activity.title") }) }),
        (currentUser == null ? void 0 : currentUser.id) && (0, import_jsx_runtime.jsx)(
          TasksSubscribers,
          {
            currentUserId: currentUser.id,
            value,
            onChange,
            path
          }
        )
      ] }),
      loading && (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: "Loading activity" }),
      (0, import_jsx_runtime.jsx)(AnimatePresence, { children: !loading && (0, import_jsx_runtime.jsxs)(MotionStack, { animate: "visible", initial: "hidden", space: 4, variants: VARIANTS$2, children: [
        value.createdByUser && (0, import_jsx_runtime.jsx)(Stack, { paddingBottom: 1, children: (0, import_jsx_runtime.jsx)(
          TasksActivityCreatedAt,
          {
            createdAt: value.createdByUser,
            authorId: value.authorId
          }
        ) }),
        currentUser && (0, import_jsx_runtime.jsxs)(Stack, { space: 4, marginTop: 1, children: [
          activity.map((item) => item._type === "activity" ? (0, import_jsx_runtime.jsx)(EditedAt, { activity: item.payload }, item.timestamp) : (0, import_jsx_runtime.jsx)(
            TasksActivityCommentItem,
            {
              currentUser,
              mentionOptions,
              onCreateRetry: handleCommentCreateRetry,
              onDelete: handleDeleteCommentStart,
              onEdit: handleCommentEdit,
              onReactionSelect: handleCommentReact,
              onReply: handleCommentReply,
              parentComment: item.payload.parentComment,
              replies: item.payload.replies
            },
            item.payload.parentComment._id
          )),
          (0, import_jsx_runtime.jsx)(
            TasksActivityCommentInput,
            {
              currentUser,
              mentionOptions,
              onSubmit: handleCommentCreate
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
var TasksEnabledContext = (0, import_react2.createContext)(null);
function TasksEnabledProvider({ children }) {
  var _a;
  const { enabled, isLoading } = useFeatureEnabled("sanityTasks"), { enabled: stagingIsEnabled, isLoading: stagingIsLoading } = useFeatureEnabled("studioTasks"), isWorkspaceEnabled = (_a = useWorkspace().tasks) == null ? void 0 : _a.enabled, value = (0, import_react2.useMemo)(() => !isWorkspaceEnabled || isLoading || stagingIsLoading ? {
    enabled: false,
    mode: null
  } : stagingIsEnabled || enabled ? {
    enabled: true,
    mode: "default"
  } : {
    enabled: false,
    mode: null
  }, [enabled, isLoading, isWorkspaceEnabled, stagingIsEnabled, stagingIsLoading]);
  return (0, import_jsx_runtime.jsx)(TasksEnabledContext.Provider, { value, children });
}
function useTasksEnabled() {
  const context = (0, import_react2.useContext)(TasksEnabledContext);
  if (!context)
    throw new Error("useTasks must be used within a TasksEnabledProvider");
  return context;
}
var MentionUserContext = (0, import_react2.createContext)(null);
function MentionUserProvider(props) {
  const [selectedDocument, setSelectedDocument] = (0, import_react2.useState)(null), mentionOptions = useUserListWithPermissions({
    documentValue: selectedDocument,
    permission: "read"
  }), value = (0, import_react2.useMemo)(
    () => ({
      mentionOptions,
      selectedDocument,
      setSelectedDocument
    }),
    [mentionOptions, selectedDocument, setSelectedDocument]
  );
  return (0, import_jsx_runtime.jsx)(MentionUserContext.Provider, { value, children: props.children });
}
function useMentionUser() {
  const context = (0, import_react2.useContext)(MentionUserContext);
  if (!context)
    throw new Error("useMentionUser must be used within a MentionUserProvider");
  return context;
}
var TasksNavigationContext = (0, import_react2.createContext)(null);
var initialState = {
  viewMode: "list",
  selectedTask: null,
  activeTabId: "assigned",
  duplicateTaskValues: null,
  isOpen: false
};
function reducer(state2, action) {
  switch (action.type) {
    case "TOGGLE_TASKS_VIEW":
      return action.payload === false ? {
        ...initialState,
        isOpen: action.payload
      } : {
        ...state2,
        isOpen: action.payload
      };
    case "CREATE_TASK":
      return {
        ...state2,
        viewMode: "create",
        selectedTask: v4_default()
      };
    case "EDIT_TASK":
      return {
        ...state2,
        viewMode: "edit",
        selectedTask: action.payload.id
      };
    case "EDIT_DRAFT":
      return {
        ...state2,
        viewMode: "draft",
        selectedTask: action.payload.id
      };
    case "DUPLICATE_TASK":
      return {
        ...state2,
        viewMode: "duplicate",
        selectedTask: v4_default(),
        duplicateTaskValues: action.payload.duplicateTaskValues
      };
    case "SET_ACTIVE_TAB":
      return {
        ...state2,
        viewMode: "list",
        activeTabId: action.payload
      };
    case "NAVIGATE_TO_LIST":
      return {
        ...state2,
        viewMode: "list"
      };
    default:
      return state2;
  }
}
var TasksNavigationProvider = ({ children }) => {
  const [state2, dispatch] = (0, import_react2.useReducer)(reducer, initialState), router2 = useRouter(), toast = useToast(), setViewMode = (0, import_react2.useCallback)((viewMode) => {
    switch (viewMode.type) {
      case "list":
        dispatch({ type: "NAVIGATE_TO_LIST" });
        break;
      case "create":
        dispatch({ type: "CREATE_TASK" });
        break;
      case "edit":
        dispatch({ type: "EDIT_TASK", payload: { id: viewMode.id } });
        break;
      case "duplicate":
        dispatch({
          type: "DUPLICATE_TASK",
          payload: { duplicateTaskValues: viewMode.duplicateTaskValues }
        });
        break;
      case "draft":
        dispatch({ type: "EDIT_DRAFT", payload: { id: viewMode.id } });
        break;
    }
  }, []), setActiveTab = (0, import_react2.useCallback)((tabId) => {
    dispatch({ type: "SET_ACTIVE_TAB", payload: tabId });
  }, []), handleCloseTasks = (0, import_react2.useCallback)(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: false });
  }, []), handleOpenTasks = (0, import_react2.useCallback)(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: true });
  }, []), handleCopyLinkToTask = (0, import_react2.useCallback)(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("sidebar", "tasks"), url.searchParams.set("viewMode", state2.viewMode), state2.selectedTask && url.searchParams.set("selectedTask", state2.selectedTask), navigator.clipboard.writeText(url.toString()).then(() => {
      toast.push({
        closable: true,
        status: "info",
        title: "Copied link to clipboard"
      });
    }).catch(() => {
      toast.push({
        closable: true,
        status: "error",
        title: "Failed to copy link to clipboard"
      });
    });
  }, [state2.selectedTask, state2.viewMode, toast]), searchParamsAsString = new URLSearchParams(router2.state._searchParams).toString();
  return (0, import_react2.useEffect)(() => {
    if (searchParamsAsString) {
      const searchParams = new URLSearchParams(searchParamsAsString);
      if (searchParams.get("sidebar") !== "tasks")
        return;
      dispatch({ type: "TOGGLE_TASKS_VIEW", payload: true });
      const viewMode = searchParams.get("viewMode"), selectedTask = searchParams.get("selectedTask");
      viewMode === "edit" && selectedTask && dispatch({ type: "EDIT_TASK", payload: { id: selectedTask } });
    }
  }, [searchParamsAsString]), (0, import_jsx_runtime.jsx)(
    TasksNavigationContext.Provider,
    {
      value: {
        state: state2,
        setViewMode,
        setActiveTab,
        handleCloseTasks,
        handleOpenTasks,
        handleCopyLinkToTask
      },
      children
    }
  );
};
function useTasksNavigation() {
  return (0, import_react2.useContext)(TasksNavigationContext) || {
    state: {
      activeTabId: "assigned",
      viewMode: "list",
      selectedTask: null,
      isOpen: false,
      duplicateTaskValues: null
    },
    setActiveTab: () => null,
    setViewMode: () => null,
    handleCloseTasks: () => null,
    handleCopyLinkToTask: () => null,
    handleOpenTasks: () => null
  };
}
var TasksContext = (0, import_react2.createContext)(null);
function createTasksSet(tasks2) {
  return tasks2.reduce((acc, task) => ({ ...acc, [task._id]: task }), {});
}
function tasksReducer(state2, action) {
  switch (action.type) {
    case "TASKS_SET": {
      const tasksById = createTasksSet(action.tasks);
      return {
        ...state2,
        tasks: tasksById
      };
    }
    case "TASK_ADDED": {
      const nextTaskResult = action.payload, nextTaskValue = nextTaskResult, nextTask = {
        [nextTaskResult._id]: {
          ...state2.tasks[nextTaskResult._id],
          ...nextTaskValue,
          _state: nextTaskResult._state || void 0,
          // If the task is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the tasks correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the task.
          // Once the task is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextTaskResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          ...nextTask
        }
      };
    }
    case "TASK_RECEIVED": {
      const nextTaskResult = action.payload;
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [nextTaskResult._id]: nextTaskResult
        }
      };
    }
    case "TASK_DELETED": {
      const { [action.id]: _, ...restTasks } = state2.tasks;
      return {
        ...state2,
        tasks: restTasks
      };
    }
    case "TASK_UPDATED": {
      const updatedTask = action.payload, id = updatedTask._id, nextTask = {
        // Add existing task data
        ...state2.tasks[id],
        // Add incoming task data
        ...updatedTask
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [id]: nextTask
        }
      };
    }
    default:
      return state2;
  }
}
var INITIAL_STATE = {
  tasks: {}
};
var LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: true,
  visibility: "query"
};
var SORT_FIELD = "_createdAt";
var SORT_ORDER = "desc";
var QUERY_FILTERS = ['_type == "tasks.task"'];
var QUERY_PROJECTION = `{
  ...,
}`;
var QUERY_SORT_ORDER = `order(${SORT_FIELD} ${SORT_ORDER})`;
var QUERY = `*[${QUERY_FILTERS.join(" && ")}] ${QUERY_PROJECTION} | ${QUERY_SORT_ORDER}`;
function useTasksStore(opts) {
  const { client } = useAddonDataset(), { documentId } = opts, [state2, dispatch] = (0, import_react2.useReducer)(tasksReducer, INITIAL_STATE), [isLoading, setIsLoading] = (0, import_react2.useState)(client !== null), [error, setError] = (0, import_react2.useState)(null), params = (0, import_react2.useMemo)(
    () => ({ documentId: documentId ? getPublishedId(documentId) : null }),
    [documentId]
  ), initialFetch = (0, import_react2.useCallback)(async () => {
    if (!client) {
      setIsLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "TASKS_SET", tasks: res }), setIsLoading(false);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = (0, import_react2.useCallback)(
    async (event) => {
      if (event.type === "welcome" && (setIsLoading(true), await initialFetch(), setIsLoading(false)), event.type === "reconnect" && setIsLoading(true), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextTask = event.result;
          nextTask && dispatch({
            type: "TASK_RECEIVED",
            payload: nextTask
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "TASK_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedTask = event.result;
          updatedTask && dispatch({
            type: "TASK_UPDATED",
            payload: updatedTask
          });
        }
      }
    },
    [initialFetch]
  ), listener$ = (0, import_react2.useMemo)(() => client ? client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(
    catchError((err) => (setError(err), of(err)))
  ) : of(), [client, params]);
  return (0, import_react2.useEffect)(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: (0, import_react2.useMemo)(() => Object.values(state2.tasks), [state2.tasks]),
    dispatch,
    error,
    isLoading
  };
}
var EMPTY_ARRAY$2 = [];
function TasksProvider(props) {
  const { children } = props, [activeDocument, setActiveDocument] = (0, import_react2.useState)(null), { data = EMPTY_ARRAY$2, isLoading } = useTasksStore({}), value = (0, import_react2.useMemo)(
    () => ({
      activeDocument,
      setActiveDocument,
      isLoading,
      data: data != null ? data : []
    }),
    [activeDocument, data, isLoading]
  );
  return (0, import_jsx_runtime.jsx)(TasksContext.Provider, { value, children });
}
function useTasks() {
  return (0, import_react2.useContext)(TasksContext) || {
    activeDocument: null,
    setActiveDocument: () => null,
    data: [],
    isLoading: false
  };
}
var API_VERSION = "2024-03-05";
function MentionUserMenuItem(props) {
  const { user, onSelect, pressed } = props, { t } = useTranslation2(tasksLocaleNamespace), handleSelect = (0, import_react2.useCallback)(() => onSelect(user.id), [user, onSelect]);
  return (0, import_jsx_runtime.jsx)(MenuItem, { onClick: handleSelect, padding: 1, disabled: !user.granted, pressed, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, flex: 1, children: [
      (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: user.id ? user : void 0, size: 1 }),
      (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", title: user.displayName, children: user.displayName })
    ] }),
    !user.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
  ] }) });
}
var StyledMenu$1 = ut(Menu)`
  width: 308px;
  border-radius: 3px;
`;
var IGNORED_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
];
var NO_ASSIGNEE_OPTION = {
  id: "",
  displayName: "No assignee",
  granted: true
};
function MentionsMenu({ onSelect, value = "" }) {
  const [searchTerm, setSearchTerm] = (0, import_react2.useState)(""), { mentionOptions } = useMentionUser(), inputRef = (0, import_react2.useRef)(null), options = [NO_ASSIGNEE_OPTION].concat(mentionOptions.data || []), handleSearchChange = (0, import_react2.useCallback)((event) => {
    setSearchTerm(event.currentTarget.value);
  }, []), filteredOptions = (0, import_react2.useMemo)(() => {
    var _a;
    if (!searchTerm)
      return options || [];
    const deburredSearchTerm = (0, import_deburr.default)(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      searchName: (0, import_deburr.default)(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => option == null ? void 0 : option.searchName.includes(deburredSearchTerm))) == null ? void 0 : _a.sort((a, b) => {
      const matchA = a.searchName.startsWith(deburredSearchTerm), matchB = b.searchName.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || [];
  }, [options, searchTerm]), renderItem2 = (0, import_react2.useCallback)(
    (user) => (0, import_jsx_runtime.jsx)(
      MentionUserMenuItem,
      {
        user,
        onSelect,
        pressed: user.id === value
      },
      user.id
    ),
    [onSelect, value]
  ), handleKeyDown = (0, import_react2.useCallback)((event) => {
    var _a;
    event.target !== inputRef.current && (IGNORED_KEYS.includes(event.key) || (_a = inputRef.current) == null || _a.focus());
  }, []), { t } = useTranslation2(tasksLocaleNamespace);
  return mentionOptions.loading ? (0, import_jsx_runtime.jsx)(Container, { width: 0, children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) }) : (0, import_jsx_runtime.jsxs)("div", { onKeyDown: handleKeyDown, children: [
    (0, import_jsx_runtime.jsx)(
      TextInput,
      {
        placeholder: t("form.input.assignee.search.placeholder"),
        autoFocus: true,
        border: false,
        onChange: handleSearchChange,
        value: searchTerm,
        fontSize: 1,
        icon: UserIcon,
        ref: inputRef
      }
    ),
    (0, import_jsx_runtime.jsx)("div", { style: { maxHeight: "320px", overflowY: "scroll", paddingTop: "8px" }, children: filteredOptions.length === 0 ? (0, import_jsx_runtime.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: t("form.input.assignee.search.no-users.text") }) }) : filteredOptions.map(renderItem2) })
  ] });
}
function AssigneeSelectionMenu(props) {
  const { onSelect, menuButton, value } = props;
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: menuButton,
      id: "assign-user-menu",
      menu: (0, import_jsx_runtime.jsx)(StyledMenu$1, { children: (0, import_jsx_runtime.jsx)(MentionsMenu, { onSelect, value }) }),
      popover: {
        placement: "bottom",
        portal: true
      }
    }
  );
}
var FocusableCard = ut(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return at`
    &[data-as='button'] {
      border: 1px solid var(--card-border-color);
      &:focus-within {
        border: 1px solid var(--card-focus-ring-color);
      }
      --card-muted-fg-color: ${theme.color.input.default.enabled.placeholder};
    }
  `;
});
function AssigneeCreateFormField(props) {
  const { value, onChange } = props, { mentionOptions } = useMentionUser(), mentionedUser = (0, import_react2.useMemo)(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), onSelect = (0, import_react2.useCallback)((userId) => onChange(set(userId)), [onChange]), { t } = useTranslation2(tasksLocaleNamespace), displayText = (0, import_react2.useMemo)(() => {
    if (value) {
      if (mentionOptions.loading)
        return (0, import_jsx_runtime.jsx)(TextSkeleton, { animated: true, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.search.placeholder");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return (0, import_jsx_runtime.jsx)(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: (0, import_jsx_runtime.jsx)(FocusableCard, { "data-as": "button", padding: 1, radius: 2, tabIndex: 0, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
        (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, flex: 1, children: [
          (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: mentionedUser, size: 1, border: false }),
          (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", muted: !mentionedUser, children: displayText })
        ] }),
        value && mentionedUser && !mentionedUser.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
var StyledButton = ut(Button)`
  padding: 3px 6px;
`;
function AssigneeEditFormField(props) {
  const { value, onChange, path } = props, subscribers = useFormValue(["subscribers"]), { mentionOptions } = useMentionUser(), mentionedUser = (0, import_react2.useMemo)(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), { t } = useTranslation2(tasksLocaleNamespace), onSelect = (0, import_react2.useCallback)(
    (userId) => {
      onChange(set(userId, path)), subscribers && !subscribers.includes(userId) && userId && onChange(set([...subscribers, userId], ["subscribers"]));
    },
    [onChange, path, subscribers]
  ), displayText = (0, import_react2.useMemo)(() => {
    if (value) {
      if (mentionOptions.loading)
        return (0, import_jsx_runtime.jsx)(TextSkeleton, { animated: true, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.no-user-assigned.text");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return (0, import_jsx_runtime.jsx)(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: (0, import_jsx_runtime.jsx)(StyledButton, { mode: "ghost", padding: 0, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [
        (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, flex: 1, children: [
          (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: mentionedUser, size: 0 }),
          (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: displayText }) })
        ] }),
        value && mentionedUser && !mentionedUser.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
var serialize = (date) => format(date, DEFAULT_DATE_FORMAT);
var deserialize = (value) => parse(value, DEFAULT_DATE_FORMAT);
function DateEditFormField(props) {
  var _a;
  const { value, onChange, path } = props, { t: coreT } = useTranslation2(), { t } = useTranslation2(tasksLocaleNamespace), [pickerOpen, setPickerOpen] = (0, import_react2.useState)(false), [popoverRef, setPopoverRef] = (0, import_react2.useState)(null), buttonRef = (0, import_react2.useRef)(null), dateFormatter = useDateTimeFormat({ dateStyle: "long" }), dueByeDisplayValue = (0, import_react2.useMemo)(() => {
    if (!value)
      return { short: "----", full: "----" };
    const dueFormated = dateFormatter.format(new Date(value)), [monthAndDay] = dueFormated.split(",");
    return { short: monthAndDay, full: dueFormated };
  }, [dateFormatter, value]);
  useClickOutside(() => setPickerOpen(false), [popoverRef]);
  const handleKeyUp = (0, import_react2.useCallback)((e2) => {
    e2.key === "Escape" && setPickerOpen(false);
  }, []), handleClick = (0, import_react2.useCallback)(() => setPickerOpen((p) => !p), []), calendarLabels = (0, import_react2.useMemo)(() => getCalendarLabels(coreT), [coreT]), handleChange = (0, import_react2.useCallback)(
    (nextDate) => {
      onChange(nextDate ? set(serialize(nextDate), path) : unset(path)), setPickerOpen(false);
    },
    [onChange, path]
  ), deserializedValue = deserialize(value), handleDeactivation = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = buttonRef.current) == null || _a2.focus();
  }, [buttonRef]), dueDateIsThisYear = ((_a = deserializedValue == null ? void 0 : deserializedValue.date) == null ? void 0 : _a.getFullYear()) === (/* @__PURE__ */ new Date()).getFullYear();
  return (0, import_jsx_runtime.jsx)(
    Popover2,
    {
      constrainSize: true,
      "data-testid": "date-input-dialog",
      portal: true,
      ref: setPopoverRef,
      content: (0, import_jsx_runtime.jsx)(Box, { overflow: "auto", children: (0, import_jsx_runtime.jsxs)(es2015_default, { onDeactivation: handleDeactivation, children: [
        (0, import_jsx_runtime.jsx)(
          DatePicker,
          {
            calendarLabels,
            selectTime: false,
            timeStep: 1,
            onKeyUp: handleKeyUp,
            value: deserializedValue.date,
            onChange: handleChange
          }
        ),
        value && (0, import_jsx_runtime.jsx)(Flex, { justify: "flex-start", padding: 3, paddingTop: 0, children: (0, import_jsx_runtime.jsx)(
          Button2,
          {
            mode: "bleed",
            text: t("form.input.date.buttons.remove.text"),
            onClick: () => handleChange(null),
            tone: "critical"
          }
        ) })
      ] }) }),
      open: pickerOpen,
      placement: "bottom",
      fallbackPlacements: ["bottom-start", "bottom-end"],
      children: (0, import_jsx_runtime.jsx)(
        Button2,
        {
          icon: CalendarIcon,
          mode: "ghost",
          text: dueDateIsThisYear ? dueByeDisplayValue.short : dueByeDisplayValue.full,
          onClick: handleClick,
          ref: buttonRef
        }
      )
    }
  );
}
var NormalText = ut(Text)`
  word-break: break-word;
`;
function DescriptionInputBlock(props) {
  const { children } = props;
  return (0, import_jsx_runtime.jsx)(Box, { paddingTop: 2, paddingBottom: 3, children: (0, import_jsx_runtime.jsx)(NormalText, { size: 1, children }) });
}
var renderBlock = (blockProps) => {
  const { children } = blockProps;
  return (0, import_jsx_runtime.jsx)(DescriptionInputBlock, { children });
};
var DescriptionInputRoot = ut.div((props) => {
  const theme = getTheme_v2(props.theme), verticalPadding = props.$mode === "edit" ? theme.space[1] : theme.space[3];
  return at`
    /* select editable-wrap and change the padding */
    [data-ui='editable-wrap'] {
      overflow: hidden;
      padding: ${props.$mode === "edit" ? `${verticalPadding}px 0px` : `${verticalPadding}px ${theme.space[2]}px`};
      min-height: ${Math.max(props.$minHeight + verticalPadding, 200)}px !important;
    }
    #comment-input-root {
      box-shadow: ${props.$mode === "edit" ? "none" : ""};
    }
    [data-ui='CommentInputActions'] {
      display: none !important;
    }
  `;
});
function DescriptionInput(props) {
  const {
    value: _propValue,
    mode,
    inputProps: { onChange }
  } = props, value = _propValue, currentUser = useCurrentUser(), { mentionOptions } = useMentionUser(), handleChange = (0, import_react2.useCallback)((next) => onChange(set(next)), [onChange]), [rootRef, setRootRef] = (0, import_react2.useState)(null), [textBoxScrollHeight, setTextBoxScrollHeight] = (0, import_react2.useState)(200), setTextboxHeight = (0, import_react2.useCallback)((ref) => {
    const textBox = ref.querySelector('[role="textbox"]');
    if (!textBox)
      return;
    const height = textBox.scrollHeight;
    setTextBoxScrollHeight(height);
  }, []), handleSetRootRef = (0, import_react2.useCallback)((ref) => {
    ref && (0, import_react2.startTransition)(() => {
      setRootRef(ref);
    });
  }, []), { t } = useTranslation2(tasksLocaleNamespace);
  return (0, import_react2.useEffect)(() => {
    rootRef && setTextboxHeight(rootRef);
  }, [value, setTextboxHeight, rootRef]), currentUser ? (0, import_jsx_runtime.jsx)(
    DescriptionInputRoot,
    {
      $mode: mode,
      ref: handleSetRootRef,
      $minHeight: textBoxScrollHeight || 200,
      children: (0, import_jsx_runtime.jsx)(
        CommentInput,
        {
          expandOnFocus: false,
          currentUser,
          mentionOptions,
          onChange: handleChange,
          value: value != null ? value : [],
          withAvatar: false,
          placeholder: t("form.input.description.placeholder"),
          onDiscardConfirm: () => null,
          renderBlock
        }
      )
    }
  ) : null;
}
var FieldWrapperRoot = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  return at`
    // Reset the padding of the field header content box
    [data-ui='fieldHeaderContentBox'] {
      padding: 0;
      label {
        font-weight: ${theme.font.text.weights.regular};
      }
    }
  `;
});
function FieldWrapper(props) {
  return (0, import_jsx_runtime.jsx)(FieldWrapperRoot, { children: props.renderDefault(props) });
}
var StatusMenuButton = (0, import_react2.forwardRef)(function(props, ref) {
  var _a;
  const { value, options, ...rest } = props, selectedOption = options.find((option) => option.value === value), icon = (_a = TASK_STATUS.find((status) => status.value === value)) == null ? void 0 : _a.icon;
  return (0, import_jsx_runtime.jsx)(
    Button2,
    {
      ...rest,
      ref,
      tooltipProps: null,
      icon,
      text: (selectedOption == null ? void 0 : selectedOption.title) || value,
      tone: "default",
      mode: "ghost"
    }
  );
});
function StatusSelector(props) {
  const { value, onChange, options, path } = props;
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(StatusMenuButton, { value, options }),
      id: "reference-menuButton",
      menu: (0, import_jsx_runtime.jsx)(Menu, { children: options.map((option) => {
        var _a;
        const isSelected = value === option.value, icon = (_a = TASK_STATUS.find((status) => status.value === option.value)) == null ? void 0 : _a.icon;
        return (0, import_jsx_runtime.jsx)(
          MenuItem2,
          {
            icon: isString(option.value) ? icon || CircleIcon : CircleIcon,
            text: option.title || option.value,
            pressed: isSelected,
            iconRight: isSelected && (0, import_jsx_runtime.jsx)(CheckmarkIcon, {}),
            onClick: () => onChange(set(option.value, path))
          },
          option.title
        );
      }) })
    }
  );
}
function ConfigErrorsScreen() {
  return (0, import_jsx_runtime.jsx)("div", { children: "Config errors" });
}
function CurrentWorkspaceProvider({ children }) {
  return (0, import_jsx_runtime.jsx)(WorkspaceLoaderBoundary, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children });
}
var EmptyReferenceRoot = ut(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return at`
    &:focus {
      border: 1px solid var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      border: 1px solid var(--card-focus-ring-color);
    }
    &:hover {
      border-color: ${theme.color.input.default.hovered.border};
    }
  `;
});
var Placeholder = ut(Text)((props) => `
      color: ${getTheme_v2(props.theme).color.input.default.enabled.placeholder};
      margin-left: 3px;
  `);
var TargetRoot = ut(Card)`
  position: relative;
  [data-ui='show-on-hover'] {
    opacity: 0;
    position: absolute;
    right: 6px;
    top: 4px;
    display: flex;
  }
  &:focus-within,
  &:hover {
    padding-right: 36px;
    /* Hides the preview status dot, the button will take it's position. */
    [data-testid='compact-preview__status'] {
      opacity: 0;
    }
    [data-ui='show-on-hover'] {
      transition: opacity 200ms;
      opacity: 1;
    }
  }
`;
var StyledIntentLink$1 = ut(IntentLink)(() => at`
    text-decoration: none;
    width: 100%;
    overflow: hidden;
    cursor: pointer;
    &:focus {
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
  `);
function Preview(props) {
  const { value, handleRemove } = props, documentId = value.document._ref, documentType = value.documentType, schemaType = useSchema().get(value.documentType), documentPresence = useDocumentPresence(documentId), { t } = useTranslation2(tasksLocaleNamespace), CardLink = (0, import_react2.useMemo)(
    () => (0, import_react2.forwardRef)(function(linkProps, ref) {
      return (0, import_jsx_runtime.jsx)(
        StyledIntentLink$1,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return schemaType ? (0, import_jsx_runtime.jsx)(TargetRoot, { border: true, radius: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", justify: "space-between", children: [
    (0, import_jsx_runtime.jsx)(Card, { as: CardLink, radius: 2, "data-as": "button", children: (0, import_jsx_runtime.jsx)(
      SearchResultItemPreview,
      {
        documentId: value.document._ref,
        layout: "compact",
        presence: documentPresence,
        schemaType,
        showBadge: false
      }
    ) }),
    (0, import_jsx_runtime.jsx)("div", { "data-ui": "show-on-hover", children: (0, import_jsx_runtime.jsx)(
      Button2,
      {
        icon: CloseIcon,
        mode: "bleed",
        onClick: handleRemove,
        tooltipProps: { content: t("form.input.target.buttons.remove.text") }
      }
    ) })
  ] }) }) : (0, import_jsx_runtime.jsx)(Text, { children: t("form.input.target.error.schema-not-found") });
}
function TargetField(props) {
  const [open, setOpen] = (0, import_react2.useState)(false), { dataset, projectId } = useWorkspace(), {
    mode,
    inputProps: { onChange },
    value: _propValue
  } = props, value = _propValue, handleItemSelect = (0, import_react2.useCallback)(
    (item) => {
      onChange(
        set(
          getTargetValue({
            documentId: item._id,
            documentType: item._type,
            dataset,
            projectId
          })
        )
      );
    },
    [dataset, projectId, onChange]
  ), handleRemove = (0, import_react2.useCallback)(() => {
    onChange(unset());
  }, [onChange]), handleOpenSearch = (0, import_react2.useCallback)(() => {
    setOpen(true);
  }, [setOpen]), handleCloseSearch = (0, import_react2.useCallback)(() => {
    setOpen(false);
  }, [setOpen]), handleKeyDown = (0, import_react2.useCallback)((event) => {
    (event.key === "Enter" || event.key === " ") && setOpen(true);
  }, []), { t } = useTranslation2(tasksLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(Card, { borderBottom: mode === "edit", paddingBottom: mode === "edit" ? 4 : 0, children: (0, import_jsx_runtime.jsx)(FieldWrapperRoot, { children: (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime.jsxs)(CurrentWorkspaceProvider, { children: [
    (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
      mode === "create" && (0, import_jsx_runtime.jsx)(Box, { "data-ui": "fieldHeaderContentBox", children: (0, import_jsx_runtime.jsx)(
        FormFieldHeaderText,
        {
          description: props.description,
          inputId: props.inputId,
          title: props.title,
          validation: props.validation,
          deprecated: void 0
        }
      ) }),
      value ? (0, import_jsx_runtime.jsx)(Preview, { value, handleRemove }) : (0, import_jsx_runtime.jsx)(
        EmptyReferenceRoot,
        {
          border: true,
          radius: 2,
          paddingX: 2,
          paddingY: 3,
          onClick: handleOpenSearch,
          onKeyDown: handleKeyDown,
          tabIndex: 0,
          children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, justify: "flex-start", align: "center", children: [
            (0, import_jsx_runtime.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentIcon, {}) }) }),
            (0, import_jsx_runtime.jsx)(Placeholder, { size: 1, children: t("form.input.target.search.placeholder") })
          ] })
        }
      )
    ] }),
    (0, import_jsx_runtime.jsx)(SearchProvider, { children: (0, import_jsx_runtime.jsx)(
      SearchPopover,
      {
        open,
        onClose: handleCloseSearch,
        onOpen: handleOpenSearch,
        onItemSelect: handleItemSelect,
        disableIntentLink: true
      }
    ) })
  ] }) }) }) });
}
var Root$1 = ut.div((props) => `
      display: grid;
      grid-template-columns: 1fr;
      padding-top: ${getTheme_v2(props.theme).space[3]}px;
    `);
var TitleInput = ut.textarea((props) => {
  const { color, font } = getTheme_v2(props.theme);
  return at`
    resize: none;
    overflow: hidden;
    appearance: none;
    background: none;
    border: 0;
    padding: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${font.text.weights.semibold};
    font-size: ${font.text.sizes[3].fontSize}px;
    line-height: ${font.text.sizes[3].lineHeight}px;
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;
    transition: height 500ms;
    /* NOTE: This is a hack to disable Chromeâ€™s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    color: ${color.input.default.enabled.fg};

    &::placeholder {
      color: ${color.input.default.enabled.placeholder};
    }
  `;
});
function Title(props) {
  const { value, onChange, placeholder, path } = props, ref = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    ref.current && (ref.current.style.height = "auto", ref.current.style.height = `${ref.current.scrollHeight}px`);
  }, [value]);
  const handleChange = (0, import_react2.useCallback)(
    (event) => {
      const inputValue = event.currentTarget.value;
      return inputValue || onChange(unset(path)), onChange(set(inputValue.replace(/\n/g, ""), path));
    },
    [onChange, path]
  );
  return (0, import_jsx_runtime.jsx)(Root$1, { children: (0, import_jsx_runtime.jsx)(
    TitleInput,
    {
      ref,
      autoFocus: !value,
      value,
      placeholder,
      onChange: handleChange,
      rows: 1
    }
  ) });
}
function TitleField(props) {
  const { value, inputProps } = props, { onChange, schemaType } = inputProps;
  return (0, import_jsx_runtime.jsx)(Title, { value, onChange, placeholder: schemaType.placeholder });
}
function useTaskOperations() {
  const { client, createAddonDataset } = useAddonDataset(), currentUser = useCurrentUser(), handleCreate = (0, import_react2.useCallback)(
    async (payload) => {
      if (!currentUser)
        throw new Error("No current user found. Unable to create task.");
      const task = {
        ...payload,
        authorId: currentUser.id,
        _type: "tasks.task"
      };
      if (!client)
        try {
          const newCreatedClient = await createAddonDataset();
          if (!newCreatedClient)
            throw new Error("No addon client found. Unable to create task.");
          return await newCreatedClient.create(task);
        } catch (err) {
          throw err;
        }
      try {
        return await client.create(task);
      } catch (err) {
        throw err;
      }
    },
    [client, createAddonDataset, currentUser]
  ), handleEdit = (0, import_react2.useCallback)(
    async (id, set2) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        return await client.patch(id).set(set2).commit();
      } catch (e2) {
        throw e2;
      }
    },
    [client]
  ), handleRemove = (0, import_react2.useCallback)(
    async (id) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        await client.delete(id);
      } catch (e2) {
        throw e2;
      }
    },
    [client]
  );
  return (0, import_react2.useMemo)(
    () => ({
      create: handleCreate,
      edit: handleEdit,
      remove: handleRemove
    }),
    [handleCreate, handleEdit, handleRemove]
  );
}
function useRemoveTask({ id, onError, onRemoved }) {
  const [removeStatus, setRemoveStatus] = (0, import_react2.useState)("idle"), [showDialog, setShowDialog] = (0, import_react2.useState)(false), [error, setError] = (0, import_react2.useState)(null), operations = useTaskOperations(), handleRemove = (0, import_react2.useCallback)(async () => {
    try {
      setRemoveStatus("loading"), await operations.remove(id), onRemoved == null || onRemoved(), setRemoveStatus("idle"), await new Promise((resolve) => setTimeout(resolve, 300)), setShowDialog(false);
    } catch (e2) {
      onError == null || onError(e2.message), setError(e2.message), setRemoveStatus("error");
    } finally {
      setRemoveStatus("idle");
    }
  }, [id, operations, onError, onRemoved]), handleOpenDialog = (0, import_react2.useCallback)(() => {
    setShowDialog(true);
  }, [setShowDialog]), handleCloseDialog = (0, import_react2.useCallback)(() => {
    setShowDialog(false);
  }, [setShowDialog]);
  return {
    removeStatus,
    showDialog,
    error,
    handleRemove,
    handleOpenDialog,
    handleCloseDialog
  };
}
var getTaskSubscribers = (task) => {
  const subscribers = task.subscribers || [];
  return getMentionedUsers(task.description).forEach((user) => {
    subscribers.includes(user) || subscribers.push(user);
  }), task.assignedTo && (subscribers.includes(task.assignedTo) || subscribers.push(task.assignedTo)), subscribers;
};
function FormCreate(props) {
  const [createMore, setCreateMore] = (0, import_react2.useState)(false), {
    setViewMode,
    setActiveTab,
    state: { viewMode }
  } = useTasksNavigation(), toast = useToast(), handleCreateMore = (0, import_react2.useCallback)(() => setCreateMore((p) => !p), []), { onChange } = props, value = props.value, onRemove = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { handleRemove, removeStatus } = useRemoveTask({ id: value._id, onRemoved: onRemove }), { t } = useTranslation2(tasksLocaleNamespace), handleCreate = (0, import_react2.useCallback)(() => {
    if (!(value != null && value.title)) {
      toast.push({
        closable: true,
        status: "error",
        title: t("form.status.error.title-required")
      });
      return;
    }
    onChange([
      set(getTaskSubscribers(value), ["subscribers"]),
      set((/* @__PURE__ */ new Date()).toISOString(), ["createdByUser"])
    ]), createMore ? setViewMode({ type: "create" }) : setActiveTab("subscribed"), toast.push({
      closable: true,
      status: "success",
      title: t("form.status.success")
    });
  }, [setViewMode, setActiveTab, onChange, createMore, toast, value, t]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    props.renderDefault(props),
    (0, import_jsx_runtime.jsx)(Box, { paddingY: 5, children: (0, import_jsx_runtime.jsxs)(Flex, { justify: "flex-end", paddingTop: 1, gap: 3, children: [
      (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, style: { flexGrow: viewMode === "draft" ? 1 : 0 }, children: [
        (0, import_jsx_runtime.jsx)(Switch, { onChange: handleCreateMore, checked: createMore }),
        (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("form.input.create-more.text") })
      ] }),
      viewMode === "draft" && (0, import_jsx_runtime.jsx)(
        Button2,
        {
          text: t("buttons.discard.text"),
          onClick: handleRemove,
          mode: "bleed",
          disabled: removeStatus === "loading",
          loading: removeStatus === "loading"
        }
      ),
      (0, import_jsx_runtime.jsx)(Button2, { text: t("buttons.create.text"), onClick: handleCreate })
    ] }) })
  ] });
}
var FIELDS_TO_GROUP = [
  "title",
  "status",
  "assignedTo",
  "dueBy",
  "target",
  "description"
];
var GROUP_TIME = 2 * 60 * 1e3;
function groupChanges(changes) {
  const groupedChanges = [];
  for (const change of changes) {
    const lastChangeProcessed = groupedChanges[groupedChanges.length - 1];
    if (!lastChangeProcessed) {
      groupedChanges.push(change);
      continue;
    }
    if (!FIELDS_TO_GROUP.includes(change.field)) {
      groupedChanges.push(change);
      continue;
    }
    if (lastChangeProcessed.author === change.author && lastChangeProcessed.field === change.field) {
      const lastChangeDate = new Date(lastChangeProcessed.timestamp), changeDate = new Date(change.timestamp);
      if (Math.abs(lastChangeDate.getTime() - changeDate.getTime()) <= GROUP_TIME) {
        lastChangeProcessed.to = change.to, lastChangeProcessed.timestamp = change.timestamp;
        continue;
      }
    }
    groupedChanges.push(change);
  }
  return groupedChanges;
}
function omitRev(document2) {
  const { _rev, ...doc } = document2;
  return doc;
}
function trackFieldChanges(newestDocument, transactions, fieldsToTrack) {
  let currentDocument = omitRev(newestDocument);
  const changes = [];
  let previousDocument = currentDocument;
  for (const transaction of transactions) {
    const { timestamp, effects } = transaction, documentId = transaction.documentIDs[0], effect = effects[documentId];
    !effect || !effect.revert || (previousDocument = applyPatch(currentDocument, effect.revert), fieldsToTrack.forEach((field) => {
      (previousDocument == null ? void 0 : previousDocument[field]) !== (currentDocument == null ? void 0 : currentDocument[field]) && changes.push({
        field,
        from: previousDocument == null ? void 0 : previousDocument[field],
        to: currentDocument == null ? void 0 : currentDocument[field],
        timestamp,
        author: transaction.author
      });
    }), currentDocument = previousDocument);
  }
  const changesSortedByTimestamp = changes.sort((a, b) => a.timestamp.localeCompare(b.timestamp)), createdByUserIndex = changesSortedByTimestamp.findIndex(
    (change) => change.field === "createdByUser"
  );
  return groupChanges(changesSortedByTimestamp.slice(createdByUserIndex + 1));
}
function useActivityLog(task) {
  var _a;
  const [changes, setChanges] = (0, import_react2.useState)([]), client = useClient({ apiVersion: API_VERSION }), { dataset, token } = client.config(), queryParams = "tag=sanity.studio.tasks.history&effectFormat=mendoza&excludeContent=true&includeIdentifiedDocumentsOnly=true&reverse=true", publishedId = getPublishedId((_a = task == null ? void 0 : task._id) != null ? _a : ""), transactionsUrl = client.getUrl(
    `/data/history/${dataset}/transactions/${publishedId}?${queryParams}`
  ), fetchAndParse = (0, import_react2.useCallback)(
    async (newestTaskDocument) => {
      try {
        if (!publishedId)
          return;
        const transactions = [], reader = (await getJsonStream(transactionsUrl, token)).getReader();
        let result;
        for (; result = await reader.read(), !result.done; ) {
          if ("error" in result.value)
            throw new Error(result.value.error.description || result.value.error.type);
          transactions.push(result.value);
        }
        const fieldsToTrack = [
          "createdByUser",
          "title",
          "description",
          "dueBy",
          "assignedTo",
          "status",
          "target"
        ], parsedChanges = await trackFieldChanges(
          newestTaskDocument,
          [...transactions],
          fieldsToTrack
        );
        setChanges(parsedChanges);
      } catch (error) {
        console.error("Failed to fetch and parse activity log", error);
      }
    },
    [transactionsUrl, token, publishedId]
  );
  return (0, import_react2.useEffect)(() => {
    fetchAndParse(task);
  }, [fetchAndParse, task._rev]), { changes };
}
function RemoveTaskDialog(props) {
  const { handleCloseDialog, handleRemove, removeStatus, showDialog } = props, { t } = useTranslation2(tasksLocaleNamespace);
  return showDialog ? (0, import_jsx_runtime.jsx)(
    Dialog2,
    {
      id: "remove-task",
      header: t("dialog.remove-task.title"),
      onClose: handleCloseDialog,
      footer: {
        cancelButton: {
          text: t("dialog.remove-task.buttons.cancel.text"),
          onClick: handleCloseDialog
        },
        confirmButton: {
          text: t("dialog.remove-task.buttons.confirm.text"),
          tone: "critical",
          onClick: handleRemove,
          loading: removeStatus === "loading"
        }
      },
      children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
        (0, import_jsx_runtime.jsx)(Text, { as: "p", children: t("dialog.remove-task.body") }),
        (0, import_jsx_runtime.jsx)(Text, { as: "p", children: t("dialog.remove-task.body2") })
      ] })
    }
  ) : null;
}
var FirstRow = ut(Flex)((props) => {
  const theme = getTheme_v2(props.theme);
  return at`
    column-gap: ${theme.space[2]}px;
    row-gap: ${theme.space[3]}px;
  `;
});
function FormActionsMenu({ id, value }) {
  const { setViewMode, handleCopyLinkToTask } = useTasksNavigation(), onTaskRemoved = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), removeTask = useRemoveTask({ id, onRemoved: onTaskRemoved }), duplicateTask = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "duplicate", duplicateTaskValues: value });
  }, [setViewMode, value]), { t } = useTranslation2(tasksLocaleNamespace);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(Box, { paddingTop: 3, children: (0, import_jsx_runtime.jsx)(
      MenuButton,
      {
        id: "edit-task-menu",
        button: (0, import_jsx_runtime.jsx)(ContextMenuButton, {}),
        popover: {
          placement: "bottom",
          fallbackPlacements: ["bottom-end", "bottom-start"]
        },
        menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              text: t("menuitem.duplicate.text"),
              icon: CopyIcon,
              onClick: duplicateTask
            }
          ),
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              text: t("menuitem.copylink.text"),
              icon: LinkIcon,
              onClick: handleCopyLinkToTask
            }
          ),
          (0, import_jsx_runtime.jsx)(MenuDivider, {}),
          (0, import_jsx_runtime.jsx)(
            MenuItem2,
            {
              text: t("menuitem.delete.text"),
              icon: TrashIcon,
              onClick: removeTask.handleOpenDialog,
              tone: "critical"
            }
          )
        ] })
      }
    ) }),
    (0, import_jsx_runtime.jsx)(RemoveTaskDialog, { ...removeTask })
  ] });
}
function FormEditInner(props) {
  var _a, _b, _c, _d, _e, _f;
  const statusField = props.schemaType.fields.find((f) => f.name === "status"), value = props.value, currentUser = useCurrentUser(), { t } = useTranslation2(tasksLocaleNamespace), activityData = useActivityLog(value).changes, handleChangeAndSubscribe = (0, import_react2.useCallback)(
    (patch) => {
      const subscribers = value.subscribers || [];
      props.onChange(patch), currentUser && (subscribers.includes(currentUser.id) || props.onChange(set([...subscribers, currentUser.id], ["subscribers"])));
    },
    [currentUser, props, value.subscribers]
  );
  if (!statusField)
    throw new Error("Status field not found");
  return (_a = props.value) != null && _a._id ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, children: [
      (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(
        Title,
        {
          onChange: handleChangeAndSubscribe,
          value: (_b = props.value) == null ? void 0 : _b.title,
          path: ["title"],
          placeholder: t("form.input.title.placeholder")
        }
      ) }),
      (0, import_jsx_runtime.jsx)(FormActionsMenu, { id: (_c = props.value) == null ? void 0 : _c._id, value })
    ] }),
    (0, import_jsx_runtime.jsx)(Card, { borderTop: true, marginTop: 3, children: (0, import_jsx_runtime.jsxs)(
      FirstRow,
      {
        paddingBottom: 3,
        paddingTop: 4,
        align: "flex-start",
        justify: "flex-start",
        wrap: "wrap",
        children: [
          (0, import_jsx_runtime.jsx)(
            StatusSelector,
            {
              value: (_d = props.value) == null ? void 0 : _d.status,
              path: ["status"],
              onChange: handleChangeAndSubscribe,
              options: statusField.type.options.list
            }
          ),
          (0, import_jsx_runtime.jsx)(
            AssigneeEditFormField,
            {
              value: (_e = props.value) == null ? void 0 : _e.assignedTo,
              onChange: handleChangeAndSubscribe,
              path: ["assignedTo"]
            }
          ),
          (0, import_jsx_runtime.jsx)(
            DateEditFormField,
            {
              value: (_f = props.value) == null ? void 0 : _f.dueBy,
              onChange: handleChangeAndSubscribe,
              path: ["dueBy"]
            }
          )
        ]
      }
    ) }),
    props.renderDefault(props),
    (0, import_jsx_runtime.jsx)(
      CommentsProvider,
      {
        documentId: value._id,
        documentType: "tasks.task",
        sortOrder: "asc",
        type: "task",
        children: (0, import_jsx_runtime.jsx)(CurrentWorkspaceProvider, { children: (0, import_jsx_runtime.jsx)(Card, { borderTop: true, paddingTop: 4, marginTop: 4, paddingBottom: 6, children: (0, import_jsx_runtime.jsx)(
          TasksActivityLog,
          {
            value,
            onChange: props.onChange,
            path: ["subscribers"],
            activityData
          }
        ) }) })
      }
    )
  ] }) : (0, import_jsx_runtime.jsx)(LoadingBlock, {});
}
function FormEdit(props) {
  const value = props.value, currentUser = useCurrentUser(), transformPatches = (0, import_react2.useCallback)(
    (patches) => {
      if (!currentUser || patches.some((patch) => patch.path[0] === "subscribers"))
        return patches;
      const subscribers = value.subscribers || [], newSubscribers = [...subscribers], changeAssigneePatch = patches.find((patch) => patch.path[0] === "assignedTo");
      changeAssigneePatch && changeAssigneePatch.type === "set" && typeof changeAssigneePatch.value == "string" && !newSubscribers.includes(changeAssigneePatch.value) && newSubscribers.push(changeAssigneePatch.value), newSubscribers.includes(currentUser.id) || newSubscribers.push(currentUser.id);
      const changedDescriptionPatch = patches.find(
        (patch) => patch.path[0] === "description" && patch.type === "set"
      );
      if (changedDescriptionPatch) {
        const prevMentionedUser = getMentionedUsers(value.description), newDescription = changedDescriptionPatch.type === "set" ? changedDescriptionPatch.value : void 0;
        getMentionedUsers(newDescription).filter((user) => !prevMentionedUser.includes(user)).forEach((user) => {
          newSubscribers.includes(user) || newSubscribers.push(user);
        });
      }
      return newSubscribers.length !== subscribers.length && patches.push(set(newSubscribers, ["subscribers"])), patches;
    },
    [currentUser, value.subscribers, value.description]
  );
  return (0, import_jsx_runtime.jsx)(TransformPatches, { transform: transformPatches, children: (0, import_jsx_runtime.jsx)(FormEditInner, { ...props }) });
}
function TasksNotificationTargetInner(props) {
  var _a, _b, _c;
  const { inputProps } = props, { onChange } = inputProps, { target, _id, context } = useFormValue([]), { title: workspaceTitle, basePath } = useWorkspace(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = (0, import_react2.useMemo)(() => (0, import_image_url.default)(client), [client]), documentId = (_b = (_a = target == null ? void 0 : target.document) == null ? void 0 : _a._ref) != null ? _b : "", documentType = (_c = target == null ? void 0 : target.documentType) != null ? _c : "", { isLoading: previewValuesLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), targetContentTitle = (value == null ? void 0 : value.title) || null, imageUrl = isImageSource(value == null ? void 0 : value.media) ? imageBuilder.image(value.media).width(96).height(96).url() : null;
  return (0, import_react2.useEffect)(() => {
    if (documentId && documentType && previewValuesLoading)
      return;
    const studioUrl = new URL(`${window.location.origin}${basePath}/`);
    studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", _id), studioUrl.searchParams.set("viewMode", "edit");
    const notificationTarget = {
      url: studioUrl.toString(),
      workspaceTitle,
      targetContentImageUrl: imageUrl,
      targetContentTitle
    };
    (0, import_react_fast_compare.default)(notificationTarget, context == null ? void 0 : context.notification) || onChange(set(notificationTarget, ["notification"]));
  }, [
    _id,
    basePath,
    workspaceTitle,
    documentId,
    documentType,
    previewValuesLoading,
    targetContentTitle,
    imageUrl,
    onChange,
    context
  ]), null;
}
function TasksNotificationTarget(props) {
  return (0, import_jsx_runtime.jsx)(CurrentWorkspaceProvider, { children: (0, import_jsx_runtime.jsx)(TasksNotificationTargetInner, { ...props }) });
}
var targetContentField = (mode) => defineField({
  type: "object",
  name: "target",
  title: "Target",
  components: {
    field: (props) => (0, import_jsx_runtime.jsx)(TargetField, { ...props, mode })
  },
  fields: [
    {
      name: "document",
      type: "crossDatasetReference",
      dataset: "playground",
      weak: true,
      studioUrl: ({ id, type }) => `intent/edit/id=${id};type=${type}/`,
      to: [
        {
          type: "any_document",
          preview: {
            select: { title: "title" }
          }
        }
      ]
    },
    {
      name: "documentType",
      type: "string",
      title: "Document type"
    }
  ]
});
var descriptionInputField = (mode) => defineField({
  type: "array",
  name: "description",
  title: "Description",
  components: {
    field: (props) => (0, import_jsx_runtime.jsx)(DescriptionInput, { ...props, mode })
  },
  of: [
    {
      type: "block",
      name: "block",
      of: [
        {
          name: "mention",
          type: "object",
          fields: [
            {
              name: "userId",
              type: "string"
            }
          ]
        }
      ],
      marks: {
        annotations: []
      },
      styles: [{ title: "Normal", value: "normal" }],
      lists: []
    }
  ]
});
var taskSchema = (mode) => defineType({
  type: "document",
  name: "tasks.task",
  liveEdit: true,
  components: {
    input: mode === "edit" ? FormEdit : FormCreate
  },
  fields: [
    {
      type: "string",
      title: "Title",
      name: "title",
      placeholder: "Task title",
      components: {
        field: TitleField
      },
      hidden: mode === "edit"
    },
    ...mode === "edit" ? [targetContentField(mode), descriptionInputField(mode)] : [descriptionInputField(mode), targetContentField(mode)],
    {
      type: "string",
      name: "assignedTo",
      title: "Assign to",
      placeholder: "Select username",
      components: {
        field: FieldWrapper,
        input: AssigneeCreateFormField
      },
      hidden: mode === "edit"
    },
    {
      type: "date",
      name: "dueBy",
      title: "Deadline",
      placeholder: "Select date",
      components: {
        field: FieldWrapper
      },
      hidden: mode === "edit"
    },
    {
      type: "string",
      name: "authorId",
      hidden: true
    },
    {
      type: "string",
      name: "createdByUser",
      hidden: true
    },
    {
      type: "array",
      of: [{ type: "string" }],
      name: "subscribers",
      hidden: true
    },
    {
      type: "string",
      name: "status",
      title: "Status",
      options: {
        list: TASK_STATUS.map((s) => ({ value: s.value, title: s.title }))
      },
      hidden: true
    },
    {
      type: "object",
      name: "context",
      components: {
        field: TasksNotificationTarget
      },
      fields: [
        {
          type: "object",
          name: "notification",
          fields: [
            {
              type: "string",
              name: "url"
            },
            {
              type: "string",
              name: "workspaceTitle"
            },
            {
              type: "string",
              name: "targetContentImageUrl"
            },
            {
              type: "string",
              name: "targetContentTitle"
            }
          ]
        }
      ]
    }
  ]
});
function TasksAddonWorkspaceProviderInner({
  children,
  mode,
  addonDataset
}) {
  const apiHost = useClient({ apiVersion: API_VERSION }).config().apiHost, basePath = "", source = useSource(), addonDatasetConfig = (0, import_react2.useMemo)(
    () => ({
      basePath,
      dataset: addonDataset,
      name: `addon-dataset-${addonDataset}`,
      projectId: source.projectId,
      apiHost,
      schema: {
        types: [taskSchema(mode)]
      }
    }),
    [source.projectId, mode, apiHost, addonDataset, basePath]
  ), { workspaces } = (0, import_react2.useMemo)(
    () => prepareConfig(addonDatasetConfig, { basePath }),
    [addonDatasetConfig, basePath]
  ), addonWorkspace = useWorkspaceLoader(workspaces[0]);
  return addonWorkspace ? (0, import_jsx_runtime.jsx)(WorkspaceProvider, { workspace: addonWorkspace, children: (0, import_jsx_runtime.jsx)(SourceProvider, { source: addonWorkspace.unstable_sources[0], children: (0, import_jsx_runtime.jsx)(ResourceCacheProvider, { children }) }) }) : null;
}
function TasksAddonWorkspaceProvider(props) {
  const { client: addonDatasetClient, ready, createAddonDataset } = useAddonDataset(), addonDataset = addonDatasetClient == null ? void 0 : addonDatasetClient.config().dataset;
  return (0, import_react2.useEffect)(() => {
    !addonDataset && ready && createAddonDataset();
  }, [addonDataset, ready, createAddonDataset]), addonDataset ? (0, import_jsx_runtime.jsx)(TasksAddonWorkspaceProviderInner, { ...props, addonDataset }) : (0, import_jsx_runtime.jsx)(LoadingBlock, {});
}
function useTasksFormBuilder(options) {
  const { documentType = "tasks.task", documentId, initialValue = {} } = options, tasksSchemaType = useSchema().get(documentType);
  if (!tasksSchemaType)
    throw new Error(`Schema type for '${documentType}' not found`);
  const { validation: validationRaw } = useValidationStatus(documentId, documentType), validation = useUnique(validationRaw), [focusPath, setFocusPath] = (0, import_react2.useState)([]), [openPath, setOpenPath] = (0, import_react2.useState)([]), [collapsedPaths, onSetCollapsedPath] = (0, import_react2.useState)(), [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react2.useState)(), [fieldGroupState, onSetFieldGroupState] = (0, import_react2.useState)(), [presence] = (0, import_react2.useState)([]), handleFocus = (0, import_react2.useCallback)(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath);
    },
    [setFocusPath]
  ), handleBlur = (0, import_react2.useCallback)(() => {
    setFocusPath([]);
  }, []), handleOnSetCollapsedPath = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = (0, import_react2.useCallback)(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), { patch } = useDocumentOperation(documentId, documentType), patchRef = (0, import_react2.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue);
  };
  const handleChange = (0, import_react2.useCallback)((event) => patchRef.current(event), []), connectionState = useConnectionState(documentId, documentType), editState = useEditState(documentId, documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue, formState = useFormState(tasksSchemaType, {
    value,
    comparisonValue: value,
    readOnly: false,
    changesOpen: false,
    presence,
    focusPath,
    openPath,
    collapsedPaths,
    collapsedFieldSets,
    fieldGroupState,
    validation
  }), ready = editState.ready && connectionState === "connected", patchChannel = (0, import_react2.useMemo)(() => createPatchChannel(), []);
  return formState === null || !ready ? { loading: true } : {
    id: "root",
    onChange: handleChange,
    // eslint-disable-next-line camelcase
    __internal_patchChannel: patchChannel,
    // eslint-disable-next-line camelcase
    __internal_fieldActions: void 0,
    onPathFocus: handleFocus,
    onPathOpen: setOpenPath,
    onPathBlur: handleBlur,
    onFieldGroupSelect: handleSetActiveFieldGroup,
    onSetFieldSetCollapsed: handleOnSetCollapsedFieldSet,
    onSetPathCollapsed: handleOnSetCollapsedPath,
    collapsedPaths,
    collapsedFieldSets,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    validation: formState.validation,
    members: formState.members,
    presence: formState.presence,
    schemaType: tasksSchemaType,
    value: formState.value
  };
}
var VARIANTS$1 = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.2, delay: 0.2 }
  }
};
var FormBuilderRoot = ut(motion.div)((props) => {
  const theme = getTheme_v2(props.theme);
  return `
    // Update spacing for the form builder
    & > [data-ui='Stack'] {
      grid-gap: ${rem(theme.space[4])};
    }
`;
});
var TasksFormBuilderInner = ({
  documentId,
  initialValue
}) => {
  var _a, _b;
  const formBuilderProps = useTasksFormBuilder({
    documentType: "tasks.task",
    documentId,
    initialValue
  }), { setSelectedDocument } = useMentionUser(), target = formBuilderProps.loading || (_a = formBuilderProps.value) == null ? void 0 : _a.target, targetId = (_b = target == null ? void 0 : target.document) == null ? void 0 : _b._ref, targetType = target == null ? void 0 : target.documentType;
  return (0, import_react2.useEffect)(() => {
    setSelectedDocument(targetId && targetType ? { _id: targetId, _type: targetType } : null);
  }, [targetId, targetType, setSelectedDocument]), (0, import_jsx_runtime.jsx)(CommentsEnabledProvider, { documentId: "", documentType: "", children: (0, import_jsx_runtime.jsx)(Box, { children: formBuilderProps.loading ? (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) : (0, import_jsx_runtime.jsx)(FormBuilderRoot, { id: "wrapper", initial: "hidden", animate: "visible", variants: VARIANTS$1, children: (0, import_jsx_runtime.jsx)(FormBuilder, { ...formBuilderProps }) }) }) });
};
function TasksFormBuilder() {
  const currentUser = useCurrentUser(), { activeDocument } = useTasks(), { dataset, projectId } = useWorkspace(), {
    state: { selectedTask, viewMode, duplicateTaskValues }
  } = useTasksNavigation(), initialValue = (0, import_react2.useMemo)(() => {
    if (currentUser && selectedTask) {
      if (viewMode === "duplicate")
        return {
          ...duplicateTaskValues,
          title: `${duplicateTaskValues == null ? void 0 : duplicateTaskValues.title} (copy)`,
          // Set the new task title
          createdByUser: void 0,
          // Remove the createdByUser field
          _id: selectedTask,
          // Set the new task ID
          _type: "tasks.task",
          authorId: currentUser.id,
          // Set the author ID
          status: "open"
        };
      if (viewMode === "create")
        return {
          _id: selectedTask,
          _type: "tasks.task",
          authorId: currentUser.id,
          status: "open",
          subscribers: [currentUser.id],
          target: activeDocument ? getTargetValue({
            documentId: activeDocument.documentId,
            documentType: activeDocument.documentType,
            dataset,
            projectId
          }) : void 0
        };
    }
  }, [activeDocument, currentUser, dataset, duplicateTaskValues, projectId, selectedTask, viewMode]);
  return currentUser ? selectedTask ? (
    // This provider needs to be mounted before the TasksAddonWorkspaceProvider.
    (0, import_jsx_runtime.jsx)(MentionUserProvider, { children: (0, import_jsx_runtime.jsx)(TasksAddonWorkspaceProvider, { mode: viewMode === "edit" ? "edit" : "create", children: (0, import_jsx_runtime.jsx)(
      TasksFormBuilderInner,
      {
        documentId: selectedTask,
        currentUser,
        initialValue
      }
    ) }) })
  ) : null : (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: "Loading current user" });
}
var HEADING_BY_STATUS = {
  open: {
    assigned: {
      heading: "empty-state.status.list.open.assigned.heading",
      text: "empty-state.status.list.open.assigned.text"
    },
    document: { heading: "empty-state.status.list.open.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.open.subscribed.heading",
      text: "empty-state.status.list.open.subscribed.text"
    }
  },
  closed: {
    assigned: {
      heading: "empty-state.status.list.closed.assigned.heading",
      text: "empty-state.status.list.closed.assigned.text"
    },
    document: { heading: "empty-state.status.list.closed.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.closed.subscribed.heading",
      text: "empty-state.status.list.closed.subscribed.text"
    }
  }
};
function EmptyStatusListState({ status }) {
  const {
    state: { activeTabId }
  } = useTasksNavigation(), { t } = useTranslation(tasksLocaleNamespace), { heading, text } = HEADING_BY_STATUS[status][activeTabId];
  return (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: t(heading) }),
    (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t(text) })
  ] });
}
var EMPTY_TASK_LIST = {
  assigned: {
    heading: "empty-state.list.assigned.heading",
    text: "empty-state.list.assigned.text"
  },
  subscribed: {
    heading: "empty-state.list.subscribed.heading",
    text: "empty-state.list.subscribed.text"
  },
  document: {
    heading: "empty-state.list.document.heading",
    text: "empty-state.list.document.text"
  }
};
var Root = ut.div`
  max-width: 268px;
  margin: 0 auto;
  height: 100%;
  margin-top: 40%;
`;
function EmptyTasksListState() {
  const {
    state: { activeTabId },
    setViewMode
  } = useTasksNavigation(), { heading, text } = EMPTY_TASK_LIST[activeTabId], { t } = useTranslation(tasksLocaleNamespace), handleTaskCreate = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]);
  return (0, import_jsx_runtime.jsx)(Root, { children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 3, align: "center", flex: 1, justify: "center", children: [
    (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: t(heading) }),
    (0, import_jsx_runtime.jsx)(Box, { paddingBottom: 6, paddingTop: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, align: "center", children: t(text) }) }),
    (0, import_jsx_runtime.jsx)(Button2, { icon: AddIcon, text: t("empty-state.list.create-new"), onClick: handleTaskCreate })
  ] }) });
}
var StyledIntentLink = ut(IntentLink)((props) => `
  text-decoration: underline;
  text-decoration-color: ${getTheme_v2(props.theme).color.input.default.enabled.border};
  text-underline-offset: 2px;
`);
function DocumentPreview({
  documentId,
  documentType
}) {
  const documentSchema = useSchema().get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), Link2 = (0, import_react2.useMemo)(
    () => (0, import_react2.forwardRef)(function(linkProps, ref) {
      return (0, import_jsx_runtime.jsx)(
        StyledIntentLink,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return documentSchema ? (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [
    (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentIcon, {}) }),
    isLoading ? (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, muted: true }) : (0, import_jsx_runtime.jsx)(Text, { size: 1, as: Link2, weight: "medium", style: { maxWidth: "20ch" }, textOverflow: "ellipsis", children: (value == null ? void 0 : value.title) || "Untitled" })
  ] }) : null;
}
function TasksStatus(props) {
  const operations = useTaskOperations(), { documentId, status } = props, [checkboxValue, setCheckboxValue] = (0, import_react2.useState)(status === "closed"), [isLoading, setIsLoading] = (0, import_react2.useState)(false), handleCheckboxChange = (0, import_react2.useCallback)(
    async (event) => {
      const isChecked = event.target.checked;
      setCheckboxValue(isChecked), setIsLoading(true);
      try {
        isChecked ? await operations.edit(documentId, { status: "closed" }) : isChecked || await operations.edit(documentId, { status: "open" });
      } catch (error) {
        console.error("An error occurred while updating the task status", error);
      } finally {
        setIsLoading(false);
      }
    },
    [documentId, operations]
  );
  return (0, import_jsx_runtime.jsx)(Flex, { children: isLoading ? (0, import_jsx_runtime.jsx)("div", { style: { height: "17px", width: "17px" }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { marginLeft: "3.5px", marginRight: "3.5px", marginTop: "3.5px" } }) }) : (0, import_jsx_runtime.jsx)(Checkbox, { onChange: handleCheckboxChange, checked: checkboxValue, disabled: isLoading }) });
}
var TitleButton = ut(Button)`
  width: 100%;
  max-width: 100%;
`;
var TaskDetailsRoot = ut(Flex)`
  /* Checkbox width is 17px and first row gap is 12px. */
  margin-left: 29px;
`;
function getTargetDocumentMeta(target) {
  var _a;
  if ((_a = target == null ? void 0 : target.document) != null && _a._ref)
    return {
      _ref: target == null ? void 0 : target.document._ref,
      _type: target == null ? void 0 : target.documentType
    };
}
function TaskDueDate({ dueBy }) {
  const fullDateFormatter = useDateTimeFormat({ dateStyle: "medium" }), monthAndDayFormatter = useDateTimeFormat({ month: "short", day: "numeric" }), dayFormatter = useDateTimeFormat({ weekday: "long" }), dateOptions = (0, import_react2.useMemo)(() => {
    const date = new Date(dueBy);
    return {
      fullDate: fullDateFormatter.format(date),
      monthAndDay: monthAndDayFormatter.format(date),
      day: dayFormatter.format(date),
      isDueByToday: isToday(date),
      isDueThisWeek: isThisISOWeek(date)
    };
  }, [dayFormatter, dueBy, fullDateFormatter, monthAndDayFormatter]), { fullDate, monthAndDay, day, isDueByToday, isDueThisWeek } = dateOptions;
  return (0, import_jsx_runtime.jsx)(Tooltip, { content: fullDate, children: (0, import_jsx_runtime.jsx)(Card, { tone: isDueByToday ? "critical" : "transparent", padding: 1, radius: 2, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", gap: 2, children: (0, import_jsx_runtime.jsx)(Text, {
    as: "time",
    size: 1,
    dateTime: dueBy,
    muted: true,
    // eslint-disable-next-line no-nested-ternary
    children: isDueByToday ? "Today" : isDueThisWeek ? day : monthAndDay
  }) }) }) });
}
function TasksListItem(props) {
  const { assignedTo, title, dueBy, target, onSelect, documentId, status } = props, targetDocument = (0, import_react2.useMemo)(() => getTargetDocumentMeta(target), [target]);
  return (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
      (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(TasksStatus, { documentId, status }) }),
      (0, import_jsx_runtime.jsx)(Flex, { flex: 1, children: (0, import_jsx_runtime.jsx)(TitleButton, { onClick: onSelect, mode: "bleed", padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title || "Untitled" }) }) }),
      (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: assignedTo ? { id: assignedTo } : void 0 })
    ] }),
    (dueBy || targetDocument) && (0, import_jsx_runtime.jsxs)(TaskDetailsRoot, { align: "center", gap: 2, paddingX: 0, children: [
      dueBy && (0, import_jsx_runtime.jsx)(TaskDueDate, { dueBy }),
      targetDocument && (0, import_jsx_runtime.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime.jsx)(
        DocumentPreview,
        {
          documentId: targetDocument._ref,
          documentType: targetDocument._type
        }
      ) })
    ] })
  ] });
}
var EMPTY_ARRAY$1 = [];
var getLabelForStatus = (status) => {
  const statusConfig = TASK_STATUS.find((item) => item.value === status);
  return statusConfig == null ? void 0 : statusConfig.title;
};
var DetailsFlex = ut(Flex)`
  [data-ui='summary-icon'] {
    transition: transform 0.2s;
    transform: rotate(-90deg);
  }
  &[open] [data-ui='summary-icon'] {
    transform: rotate(0);
  }
  > summary::-webkit-details-marker {
    display: none;
  }
`;
var SummaryBox = ut(Box)`
  list-style: none;
`;
function TaskList(props) {
  const { status, tasks: tasks2, onTaskSelect } = props;
  return (0, import_jsx_runtime.jsxs)(DetailsFlex, { forwardedAs: "details", direction: "column", open: status === "open", children: [
    (0, import_jsx_runtime.jsx)(SummaryBox, { forwardedAs: "summary", children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, paddingY: 1, children: [
      (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", muted: true, children: getLabelForStatus(status) }),
      (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronDownIcon, { "data-ui": "summary-icon" }) })
    ] }) }),
    (0, import_jsx_runtime.jsx)(Stack, { space: 4, marginTop: 4, paddingBottom: 5, children: (tasks2 == null ? void 0 : tasks2.length) > 0 ? tasks2.map((task, index) => {
      const showDivider = index < tasks2.length - 1;
      return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(
          TasksListItem,
          {
            documentId: task._id,
            title: task.title,
            dueBy: task.dueBy,
            assignedTo: task.assignedTo,
            target: task.target,
            onSelect: () => onTaskSelect(task._id),
            status: task.status
          }
        ),
        showDivider && (0, import_jsx_runtime.jsx)(MenuDivider, {})
      ] }, task._id);
    }) : (0, import_jsx_runtime.jsx)(EmptyStatusListState, { status }) })
  ] });
}
function TasksList(props) {
  var _a, _b;
  const { items = EMPTY_ARRAY$1, onTaskSelect } = props, tasksByStatus = (0, import_react2.useMemo)(
    () => items.reduce((acc, task) => (acc[task.status] || (acc[task.status] = []), acc[task.status].push(task), acc), {}),
    [items]
  ), hasOpenTasks = ((_a = tasksByStatus.open) == null ? void 0 : _a.length) > 0, hasClosedTasks = ((_b = tasksByStatus.closed) == null ? void 0 : _b.length) > 0;
  return (0, import_jsx_runtime.jsx)(Stack, { space: 4, flex: 1, children: !hasOpenTasks && !hasClosedTasks ? (0, import_jsx_runtime.jsx)(EmptyTasksListState, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(TaskList, { status: "open", tasks: tasksByStatus.open, onTaskSelect }),
    (0, import_jsx_runtime.jsx)(TaskList, { status: "closed", tasks: tasksByStatus.closed, onTaskSelect })
  ] }) });
}
var LIST_STYLES = {
  marginLeft: "-0.5em",
  justifyContent: "space-between",
  display: "flex"
};
function TasksListTabs({ activeTabId, onChange }) {
  const { activeDocument } = useTasks(), activeDocumentId = activeDocument == null ? void 0 : activeDocument.documentId, [documentTabIsDisabled, setDocumentTabIsDisabled] = (0, import_react2.useState)(!activeDocumentId);
  (0, import_react2.useEffect)(() => {
    let timeoutId = null;
    return !activeDocumentId && !documentTabIsDisabled && (timeoutId = setTimeout(() => {
      setDocumentTabIsDisabled(true), onChange("assigned");
    }, 1e3)), documentTabIsDisabled && activeDocumentId && setDocumentTabIsDisabled(false), () => {
      timeoutId && clearTimeout(timeoutId);
    };
  }, [activeDocumentId, documentTabIsDisabled, onChange]);
  const { t } = useTranslation2(tasksLocaleNamespace), tabs = (0, import_react2.useMemo)(
    () => [
      {
        id: "assigned",
        label: t("tab.assigned.label")
      },
      {
        id: "subscribed",
        label: t("tab.subscribed.label")
      },
      {
        id: "document",
        label: t("tab.document.label"),
        isDisabled: documentTabIsDisabled
      }
    ],
    [documentTabIsDisabled, t]
  ), handleTabChange = (0, import_react2.useCallback)(
    (tab) => {
      tab.isDisabled || onChange(tab.id);
    },
    [onChange]
  );
  return (0, import_jsx_runtime.jsx)(TabList, { space: 2, style: LIST_STYLES, children: tabs.map((tab) => (0, import_jsx_runtime.jsx)(
    Tab,
    {
      "aria-controls": `${tab.id}-panel`,
      id: `${tab.id}-tab`,
      onClick: () => handleTabChange(tab),
      disabled: tab == null ? void 0 : tab.isDisabled,
      selected: tab.id === activeTabId,
      children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: tab.label })
    },
    `${tab.id}-tab`
  )) });
}
var Divider = ut.div((props) => `
    height: 25px;
    width: 1px;
    background-color: ${getTheme_v2(props.theme).color.input.default.enabled.border};
  `);
function TasksActiveTabNavigation(props) {
  const { items: allItems } = props, { state: state2, setViewMode } = useTasksNavigation(), { selectedTask } = state2, items = allItems.filter((t2) => t2.status === "open"), currentItemIndex = items.findIndex((item) => item._id === selectedTask), goToPreviousTask = (0, import_react2.useCallback)(() => {
    const prevTaskId = currentItemIndex > 0 ? items[currentItemIndex - 1]._id : items[items.length - 1]._id;
    setViewMode({ type: "edit", id: prevTaskId });
  }, [currentItemIndex, items, setViewMode]), goToNextTask = (0, import_react2.useCallback)(() => {
    const nextTaskId = currentItemIndex < items.length - 1 ? items[currentItemIndex + 1]._id : items[0]._id;
    setViewMode({ type: "edit", id: nextTaskId });
  }, [currentItemIndex, items, setViewMode]), { t } = useTranslation2(tasksLocaleNamespace);
  return items.length ? (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", children: [
    (0, import_jsx_runtime.jsx)(
      Button2,
      {
        tooltipProps: { content: t("buttons.previous.tooltip") },
        mode: "bleed",
        icon: ChevronLeftIcon,
        onClick: goToPreviousTask
      }
    ),
    (0, import_jsx_runtime.jsx)(Tooltip, { content: t("panel.navigation.tooltip"), children: (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, children: [
      currentItemIndex + 1,
      " / ",
      items.length
    ] }) }) }),
    (0, import_jsx_runtime.jsx)(
      Button2,
      {
        tooltipProps: { content: t("buttons.next.tooltip") },
        mode: "bleed",
        icon: ChevronRightIcon,
        onClick: goToNextTask
      }
    ),
    (0, import_jsx_runtime.jsx)(Divider, {})
  ] }) }) : null;
}
var MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: true,
  fallbackPlacements: ["bottom-end"],
  placement: "bottom-end",
  portal: true
};
var StyledMenu = ut(Menu)`
  width: 220px;
`;
function TasksDraftsMenuItem(props) {
  const { isSelected, item, onSelect } = props, handleClick = (0, import_react2.useCallback)(() => {
    onSelect(item._id);
  }, [item._id, onSelect]), iconRight = isSelected ? CheckmarkIcon : void 0, text = item.title || "Untitled";
  return (0, import_jsx_runtime.jsx)(
    MenuItem2,
    {
      iconRight,
      onClick: handleClick,
      pressed: isSelected,
      selected: isSelected,
      text
    }
  );
}
function TasksHeaderDraftsMenu() {
  const { data } = useTasks(), { state: state2, setViewMode } = useTasksNavigation(), { viewMode, selectedTask } = state2, currentUser = useCurrentUser(), draftTasks = (0, import_react2.useMemo)(() => currentUser != null && currentUser.id ? data.filter((task) => {
    const isAuthoredByUser = task.authorId === currentUser.id, isDraft = !task.createdByUser, hasEdits = task._updatedAt !== task._createdAt, isNotTheTaskBeingCreated = viewMode === "create" ? task._id !== selectedTask : true;
    return isAuthoredByUser && isDraft && isNotTheTaskBeingCreated && hasEdits;
  }) : [], [data, selectedTask, currentUser == null ? void 0 : currentUser.id, viewMode]), handleSelectTask = (0, import_react2.useCallback)(
    (id) => {
      setViewMode({ type: "draft", id });
    },
    [setViewMode]
  ), { t } = useTranslation2(tasksLocaleNamespace);
  return draftTasks.length ? (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(Button2, { text: t("buttons.draft.text"), mode: "ghost", iconRight: ChevronDownIcon }),
      id: "edit-task-menu",
      menu: (0, import_jsx_runtime.jsxs)(StyledMenu, { children: [
        (0, import_jsx_runtime.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: t("panel.drafts.title") }) }),
        (0, import_jsx_runtime.jsx)(MenuDivider, {}),
        draftTasks == null ? void 0 : draftTasks.map((task) => (0, import_jsx_runtime.jsx)(
          TasksDraftsMenuItem,
          {
            isSelected: selectedTask === task._id,
            item: task,
            onSelect: handleSelectTask
          },
          task._id
        ))
      ] }),
      popover: MENU_BUTTON_POPOVER_PROPS
    }
  ) : null;
}
function TasksSidebarHeader(props) {
  const { items: allItems } = props, { state: state2, setViewMode, handleCloseTasks } = useTasksNavigation(), { viewMode, activeTabId } = state2, handleTaskCreate = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]), handleGoBack = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { t } = useTranslation2(tasksLocaleNamespace);
  return (0, import_jsx_runtime.jsxs)(Flex, { justify: "space-between", align: "center", gap: 1, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, children: [
      viewMode === "list" ? (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, weight: "semibold", children: t("panel.title") }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(Button, { mode: "bleed", space: 2, padding: 2, onClick: handleGoBack, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("panel.title") }) }),
        (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}),
        (0, import_jsx_runtime.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", style: { textTransform: "capitalize" }, children: viewMode === "create" || viewMode === "draft" ? t("panel.create.title") : activeTabId }) })
      ] }),
      (0, import_jsx_runtime.jsx)(BetaBadge, { marginLeft: 2 })
    ] }),
    (viewMode === "create" || viewMode === "draft") && (0, import_jsx_runtime.jsx)(TasksHeaderDraftsMenu, {}),
    viewMode === "edit" && (0, import_jsx_runtime.jsx)(TasksActiveTabNavigation, { items: allItems }),
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [
      viewMode === "list" && (0, import_jsx_runtime.jsx)(
        Button2,
        {
          icon: AddIcon,
          onClick: handleTaskCreate,
          mode: "bleed",
          text: t("buttons.new.text")
        }
      ),
      (0, import_jsx_runtime.jsx)(
        Button2,
        {
          tooltipProps: {
            content: t("panel.close.tooltip")
          },
          iconRight: CloseIcon,
          mode: "bleed",
          onClick: handleCloseTasks
        }
      )
    ] })
  ] });
}
var RootCard = ut(Card)`
  flex: 1;
  flex-direction: column;
`;
var HeaderStack = ut(Stack)`
  border-bottom: 1px solid var(--card-border-color);
`;
var ContentFlex = ut(Flex)`
  overflow-y: scroll;
  overflow-x: hidden;
`;
function TasksStudioSidebarInner() {
  const { activeDocument, data, isLoading } = useTasks(), { state: state2, setActiveTab, setViewMode } = useTasksNavigation(), { activeTabId, viewMode, selectedTask } = state2, currentUser = useCurrentUser(), onTaskSelect = (0, import_react2.useCallback)((id) => setViewMode({ type: "edit", id }), [setViewMode]), filteredList = (0, import_react2.useMemo)(() => data.filter((item) => {
    var _a, _b;
    return item.createdByUser ? activeTabId === "assigned" ? item.assignedTo === (currentUser == null ? void 0 : currentUser.id) : activeTabId === "subscribed" ? (currentUser == null ? void 0 : currentUser.id) && ((_a = item.subscribers) == null ? void 0 : _a.includes(currentUser.id)) : activeTabId === "document" ? (activeDocument == null ? void 0 : activeDocument.documentId) && ((_b = item.target) == null ? void 0 : _b.document._ref) === activeDocument.documentId : false : false;
  }), [activeDocument == null ? void 0 : activeDocument.documentId, activeTabId, data, currentUser]), content = (0, import_react2.useMemo)(() => viewMode !== "list" ? (0, import_jsx_runtime.jsx)(TasksFormBuilder, {}, selectedTask) : isLoading ? (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", children: (0, import_jsx_runtime.jsx)(Spinner, {}) }) : (0, import_jsx_runtime.jsx)(TasksList, { items: filteredList, onTaskSelect }), [filteredList, isLoading, onTaskSelect, selectedTask, viewMode]);
  return (0, import_jsx_runtime.jsxs)(RootCard, { display: "flex", height: "fill", flex: 1, overflow: "hidden", children: [
    (0, import_jsx_runtime.jsxs)(HeaderStack, { space: 3, padding: 3, sizing: "border", children: [
      (0, import_jsx_runtime.jsx)(TasksSidebarHeader, { items: filteredList }),
      viewMode === "list" && !isLoading && (0, import_jsx_runtime.jsx)(TasksListTabs, { activeTabId, onChange: setActiveTab })
    ] }),
    (0, import_jsx_runtime.jsx)(
      ContentFlex,
      {
        direction: "column",
        flex: 1,
        overflow: "auto",
        padding: 3,
        paddingTop: 4,
        paddingX: 4,
        sizing: "border",
        children: content
      }
    )
  ] });
}
function TasksStudioSidebar() {
  const { enabled } = useTasksEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(TasksStudioSidebarInner, {}) : null;
}
function TaskCreateAction() {
  const { handleOpenTasks, setViewMode } = useTasksNavigation(), { enabled } = useTasksEnabled(), handleCreateTaskFromDocument = (0, import_react2.useCallback)(() => {
    handleOpenTasks(), setViewMode({ type: "create" });
  }, [handleOpenTasks, setViewMode]), { t } = useTranslation2(tasksLocaleNamespace);
  return enabled ? {
    icon: TaskIcon,
    label: t("actions.create.text"),
    title: t("actions.create.text"),
    group: ["paneActions"],
    onHandle: handleCreateTaskFromDocument
  } : null;
}
function SetActiveDocumentInner(document2) {
  const { documentId, documentType } = document2, { isLast } = usePane(), { setActiveDocument } = useTasks();
  return (0, import_react2.useEffect)(() => (documentId && isLast && documentType && (setActiveDocument == null || setActiveDocument({
    documentId: getPublishedId(documentId),
    documentType
  })), () => {
    isLast && (setActiveDocument == null || setActiveDocument(null));
  }), [documentId, documentType, isLast, setActiveDocument]), null;
}
function SetActiveDocument(document2) {
  const { enabled } = useTasksEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(SetActiveDocumentInner, { ...document2 }) : null;
}
function TasksDocumentInputLayout(props) {
  var _a, _b;
  const documentId = (_a = props.value) == null ? void 0 : _a._id, documentType = (_b = props.value) == null ? void 0 : _b._type;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(SetActiveDocument, { documentId, documentType }),
    props.renderDefault(props)
  ] });
}
var ButtonContainer = ut.div`
  position: relative;
  [data-ui='Badge'] {
    position: absolute;
    top: -2px;
    right: -2px;
  }
`;
function TasksFooterOpenTasks() {
  const { data, activeDocument } = useTasks(), { handleOpenTasks, setActiveTab } = useTasksNavigation(), { enabled } = useTasksEnabled(), mediaIndex = useMediaIndex(), pendingTasks = (0, import_react2.useMemo)(
    () => data.filter((item) => {
      var _a;
      return ((_a = item.target) == null ? void 0 : _a.document._ref) === (activeDocument == null ? void 0 : activeDocument.documentId) && item.status === "open" && item.createdByUser;
    }),
    [activeDocument, data]
  ), handleOnClick = (0, import_react2.useCallback)(() => {
    handleOpenTasks(), setActiveTab("document");
  }, [handleOpenTasks, setActiveTab]), { t } = useTranslation2(tasksLocaleNamespace);
  return pendingTasks.length === 0 || !enabled ? null : mediaIndex < 3 ? (0, import_jsx_runtime.jsxs)(ButtonContainer, { children: [
    (0, import_jsx_runtime.jsx)(
      Button2,
      {
        mode: "bleed",
        icon: TaskIcon,
        size: "large",
        onClick: handleOnClick,
        tooltipProps: {
          content: t("document.footer.open-tasks.placeholder", {
            count: pendingTasks.length
          })
        }
      }
    ),
    (0, import_jsx_runtime.jsx)(Badge, { tone: "primary", fontSize: 0, children: pendingTasks.length })
  ] }) : (0, import_jsx_runtime.jsx)(
    Button2,
    {
      mode: "bleed",
      tooltipProps: {
        content: t("document.footer.open-tasks.placeholder", {
          count: pendingTasks.length
        })
      },
      text: t("document.footer.open-tasks.text", { count: pendingTasks.length }),
      onClick: handleOnClick
    }
  );
}
var VARIANTS = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};
var TRANSITION = { duration: 0.2 };
var FULLSCREEN_MEDIA_INDEX = 1;
var POSITION_ABSOLUTE_MEDIA_INDEX = 2;
var RootFlex = ut(Flex)(({ theme }) => {
  const media = theme.sanity.media;
  return at`
    min-height: 100%;

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      position: relative;
    }
  `;
});
var SidebarMotionLayer = ut(motion(Layer))(({ theme }) => {
  const media = theme.sanity.media;
  return at`
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 360px;
    border-left: 1px solid var(--card-border-color);
    box-sizing: border-box;
    overflow: hidden;

    box-shadow:
      0px 6px 8px -4px var(--card-shadow-umbra-color),
      0px 12px 17px -1px var(--card-shadow-penumbra-color);

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      bottom: 0;
      position: absolute;
      right: 0;
      top: 0;
    }

    @media (max-width: ${media[FULLSCREEN_MEDIA_INDEX]}px) {
      border-left: 0;
      min-width: 100%;
      left: 0;
    }
  `;
});
function TasksStudioActiveToolLayoutInner(props) {
  const mediaIndex = useMediaIndex(), {
    state: { isOpen }
  } = useTasksNavigation(), scrollLock = mediaIndex <= FULLSCREEN_MEDIA_INDEX && isOpen;
  return (0, import_jsx_runtime.jsxs)(RootFlex, { sizing: "border", height: "fill", children: [
    (0, import_jsx_runtime.jsx)(Box, { flex: 1, height: "fill", overflow: scrollLock ? "hidden" : "auto", children: props.renderDefault(props) }),
    (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: isOpen && (0, import_jsx_runtime.jsx)(
      SidebarMotionLayer,
      {
        animate: "visible",
        height: "fill",
        initial: "hidden",
        transition: TRANSITION,
        variants: VARIANTS,
        children: (0, import_jsx_runtime.jsx)(TasksStudioSidebar, {})
      }
    ) })
  ] });
}
function TasksStudioActiveToolLayout(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(TasksStudioActiveToolLayoutInner, { ...props }) : props.renderDefault(props);
}
var TasksStudioLayoutInner = (props) => {
  const { enabled } = useTasksEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(AddonDatasetProvider, { children: (0, import_jsx_runtime.jsx)(TasksProvider, { children: (0, import_jsx_runtime.jsx)(TasksNavigationProvider, { children: props.renderDefault(props) }) }) }) : props.renderDefault(props);
};
function TasksStudioLayout(props) {
  return (0, import_jsx_runtime.jsx)(TasksEnabledProvider, { children: (0, import_jsx_runtime.jsx)(TasksStudioLayoutInner, { ...props }) });
}
var EMPTY_ARRAY = [];
function TasksStudioNavbarInner(props) {
  const {
    handleOpenTasks,
    state: { isOpen }
  } = useTasksNavigation(), { t } = useTranslation2(tasksLocaleNamespace), actions = (0, import_react2.useMemo)(() => [
    ...(props == null ? void 0 : props.__internal_actions) || EMPTY_ARRAY,
    {
      icon: PanelRightIcon,
      location: "topbar",
      name: "tasks-topbar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    },
    {
      icon: TaskIcon,
      location: "sidebar",
      name: "tasks-sidebar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    }
  ], [handleOpenTasks, isOpen, props == null ? void 0 : props.__internal_actions, t]);
  return props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_actions: actions
  });
}
function TasksStudioNavbar(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? (0, import_jsx_runtime.jsx)(TasksStudioNavbarInner, { ...props }) : props.renderDefault(props);
}
var tasks = definePlugin({
  name: "sanity/tasks",
  // eslint-disable-next-line camelcase
  __internal_tasks: {
    footerAction: (0, import_jsx_runtime.jsx)(TasksFooterOpenTasks, {})
  },
  document: {
    actions: (prev) => [...prev, TaskCreateAction].filter(Boolean)
  },
  studio: {
    components: {
      layout: TasksStudioLayout,
      navbar: TasksStudioNavbar,
      activeToolLayout: TasksStudioActiveToolLayout
    }
  },
  form: {
    components: {
      input: (props) => {
        var _a;
        return props.id === "root" && ((_a = props.schemaType.type) == null ? void 0 : _a.name) === "document" ? (0, import_jsx_runtime.jsx)(TasksDocumentInputLayout, { ...props }) : props.renderDefault(props);
      }
    }
  },
  i18n: {
    bundles: [tasksUsEnglishLocaleBundle]
  }
});
var LiveEditBadge = (props) => {
  const { liveEdit } = props;
  return liveEdit ? {
    label: "Live",
    color: "danger"
  } : null;
};
var state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [], activePanes = state.activePanes || [], editDocumentId = params.id || v4_default(), isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane == "object" && ((_a = pane.canHandleIntent) != null && _a.call(pane, intent, params, {
      pane,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type")) {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$1;
      return {
        panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]])
      };
    }
  }
  return { intent, params, payload };
}
function collectLatestAuthorAnnotations(diff2) {
  const authorMap = /* @__PURE__ */ new Map();
  return visitDiff(diff2, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation)
      return true;
    const { author, timestamp } = child.annotation, previous = authorMap.get(author);
    return (!previous || previous.timestamp < timestamp) && authorMap.set(author, child.annotation), true;
  }), Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
var Scroller = ut(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function ChangesInspector(props) {
  const { onClose } = props, { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane(), scrollRef = (0, import_react2.useRef)(null), diff2 = useTimelineSelector(timelineStore, (state2) => state2.diff), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, { t } = useTranslation2("studio"), documentContext = (0, import_react2.useMemo)(
    () => ({
      documentId,
      schemaType,
      FieldWrapper: ChangeFieldWrapper,
      rootDiff: diff2,
      isComparingCurrent,
      value
    }),
    [documentId, diff2, isComparingCurrent, schemaType, value]
  ), changeAnnotations = (0, import_react2.useMemo)(
    () => diff2 ? collectLatestAuthorAnnotations(diff2) : [],
    [diff2]
  );
  return (0, import_jsx_runtime.jsxs)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    (0, import_jsx_runtime.jsx)(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("changes.action.close-label"),
        flex: "none",
        onClose,
        title: t("changes.title"),
        children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [
          (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }),
          (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(
            DiffTooltip,
            {
              annotations: changeAnnotations,
              description: t("changes.changes-by-author"),
              portal: true,
              children: (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map(({ author }) => (0, import_jsx_runtime.jsx)(UserAvatar, { user: author }, author)) })
            }
          ) })
        ] })
      }
    ),
    (0, import_jsx_runtime.jsx)(Card, { flex: 1, children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: scrollRef.current, children: (0, import_jsx_runtime.jsx)(Scroller, { "data-ui": "Scroller", ref: scrollRef, children: (0, import_jsx_runtime.jsx)(Box, { flex: 1, padding: 4, children: (0, import_jsx_runtime.jsx)(
      Content,
      {
        diff: diff2,
        documentContext,
        error: timelineError,
        loading,
        schemaType
      }
    ) }) }) }) })
  ] });
}
function Content({
  error,
  diff: diff2,
  documentContext,
  loading,
  schemaType
}) {
  return error ? (0, import_jsx_runtime.jsx)(NoChanges, {}) : loading ? (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) : diff2 ? (0, import_jsx_runtime.jsx)(DocumentChangeContext.Provider, { value: documentContext, children: (0, import_jsx_runtime.jsx)(ChangeList, { diff: diff2, schemaType }) }) : (0, import_jsx_runtime.jsx)(NoChanges, {});
}
var changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const { features } = useStructureTool(), { t } = useTranslation2();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: t("changes.title")
    };
  },
  component: ChangesInspector,
  onClose: ({ params }) => ({ params: { ...params, since: void 0 } }),
  onOpen: ({ params }) => ({ params: { ...params, since: "@lastPublished" } })
};
function getPathTitles(options) {
  const { path, schemaType, value } = options, result = [];
  let s = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!isRecord$4(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s.jsonType !== "object")
        throw new Error(
          `Parent type is not an object schema type, cannot get path segment: .${segment}`
        );
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({ name: segment }), result;
      s = field.type, result.push(s);
      continue;
    }
    if (typeof segment == "number") {
      if (!isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: [${segment}]`
        );
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : isRecord$4(v) ? ofType.name === (v == null ? void 0 : v._type) : false);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s = itemType, result.push(s);
      continue;
    }
    if (isRecord$4(segment) && segment._key) {
      if (!isArray(v))
        throw new Error(
          `Parent value is not an array, cannot get path segment: [_key == ${segment}]`
        );
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: .${segment}`
        );
      if (v = (v != null ? v : []).find((i) => isRecord$4(i) && i._key === segment._key), !isRecord$4(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      const ofType = s.of.find((i) => isRecord$4(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType)
        throw new Error(`Array item type not found: .${v == null ? void 0 : v._type}`);
      s = ofType, result.push(s);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
var MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
};
var MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const { onClose } = props, { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane(), { t } = useTranslation2("validation"), handleOpen = (0, import_react2.useCallback)(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onFocus, onPathOpen]
  );
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    (0, import_jsx_runtime.jsx)(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("panel.close-button-aria-label"),
        flex: "none",
        onClose,
        title: t("panel.title")
      }
    ),
    (0, import_jsx_runtime.jsxs)(Card, { flex: 1, overflow: "auto", padding: 3, children: [
      validation.length === 0 && (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t("panel.no-errors-message") }) }),
      validation.length > 0 && (0, import_jsx_runtime.jsx)(Stack, { space: 2, children: validation.map((marker, i) => (0, import_jsx_runtime.jsx)(
        ValidationCard,
        {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        },
        i
      )) })
    ] })
  ] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props, handleOpen = (0, import_react2.useCallback)(() => onOpen(marker.path), [marker, onOpen]), [errorInfo, setErrorInfo] = (0, import_react2.useState)(null);
  return (0, import_jsx_runtime.jsxs)(ErrorBoundary, { onCatch: setErrorInfo, children: [
    errorInfo && (0, import_jsx_runtime.jsx)(Card, { padding: 3, radius: 2, tone: "critical", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: errorInfo.error.message }) }),
    !errorInfo && (0, import_jsx_runtime.jsx)(
      Card,
      {
        __unstable_focusRing: true,
        as: "button",
        onClick: handleOpen,
        padding: 3,
        radius: 2,
        tone: MARKER_TONE[marker.level],
        children: (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, children: [
          (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_react2.createElement)(MARKER_ICON[marker.level]) }) }),
          (0, import_jsx_runtime.jsxs)(Stack, { flex: 1, space: 2, children: [
            (0, import_jsx_runtime.jsx)(
              DocumentNodePathBreadcrumbs,
              {
                path: marker.path,
                schemaType,
                value
              }
            ),
            (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: marker.message })
          ] })
        ] })
      }
    )
  ] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props, pathTitles = (0, import_react2.useMemo)(
    () => getPathTitles({ path, schemaType, value }),
    [path, schemaType, value]
  );
  return pathTitles.length ? (0, import_jsx_runtime.jsx)(Text, { size: 1, children: pathTitles.map((t, i) => (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [
    i > 0 && (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }),
    (0, import_jsx_runtime.jsx)("span", { style: { fontWeight: 500 }, children: t.title || t.name })
  ] }, i)) }) : null;
}
function useMenuItem(props) {
  const { documentId, documentType } = props, { t } = useTranslation2("validation"), { validation: validationMarkers } = useValidationStatus(documentId, documentType), validation = (0, import_react2.useMemo)(
    () => validationMarkers.map((item) => ({
      level: item.level,
      message: item.message,
      path: item.path
    })),
    [validationMarkers]
  ), hasErrors = validation.some(isValidationError), hasWarnings = validation.some(isValidationWarning), icon = (0, import_react2.useMemo)(() => hasErrors ? ErrorOutlineIcon : hasWarnings ? WarningOutlineIcon : CheckmarkCircleIcon, [hasErrors, hasWarnings]), tone = (0, import_react2.useMemo)(() => hasErrors ? "critical" : hasWarnings ? "caution" : "positive", [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: t("panel.title"),
    tone,
    showAsAction: true
  };
}
var validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
};
var EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
var router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [
    route.create({
      path: "/:params",
      transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } }
    })
  ]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: { toState, toPath }
    }
  })
]);
var panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
var isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str);
var isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str);
var exclusiveParams = ["view", "since", "rev", "inspect", "comment"];
var isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS, payload: void 0 };
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else
      isPayloadLike(chunk) ? pane.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane;
  }, sibling);
}
function encodeChunks(pane, index, group) {
  const { payload, params = {}, id } = pane, [firstSibling] = group, paneIsFirstSibling = pane === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    var _a;
    const [key, value] = entry;
    if (!value)
      return false;
    if (paneIsFirstSibling)
      return true;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [
      firstSibling,
      ...restOfSiblings.map((sibling) => ({
        ...firstSibling,
        ...sibling,
        id: sibling.id || firstSibling.id,
        params: { ...(0, import_omit.default)(firstSibling.params, exclusiveParams), ...sibling.params },
        payload: sibling.payload || firstSibling.payload
      }))
    ];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
var documentActions = [
  PublishAction,
  UnpublishAction,
  DiscardChangesAction,
  DuplicateAction,
  DeleteAction,
  HistoryRestoreAction
];
var documentBadges = [LiveEditBadge];
var inspectors = [validationInspector, changesInspector];
var structureTool = definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions) => Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])),
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    plugins: [comments(), tasks()],
    tools: [
      {
        name: (options == null ? void 0 : options.name) || "structure",
        title: (options == null ? void 0 : options.title) || "Structure",
        icon,
        component: (0, import_react2.lazy)(() => import("./index3-OWQCJXMF.js")),
        canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : false,
        getIntentState,
        // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
        controlsDocumentTitle: true,
        options,
        router
      }
    ],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  return "type" in params ? "template" in params ? { template: true } : true : false;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? { mode: params.mode === "structure" } : true : false;
}
function StructureToolProvider({
  defaultDocumentNode,
  structure: resolveStructure,
  children
}) {
  const [layoutCollapsed, setLayoutCollapsed] = (0, import_react2.useState)(false), source = useSource(), configContext = useConfigContextFromSource(source), documentStore = useDocumentStore(), S = (0, import_react2.useMemo)(() => createStructureBuilder({
    defaultDocumentNode,
    source
  }), [defaultDocumentNode, source]), rootPaneNode = (0, import_react2.useMemo)(() => resolveStructure ? resolveStructure(S, {
    ...configContext,
    documentStore
  }) : S.defaults(), [S, resolveStructure, configContext, documentStore]), features = (0, import_react2.useMemo)(
    () => ({
      backButton: layoutCollapsed,
      resizablePanes: !layoutCollapsed,
      reviewChanges: !layoutCollapsed,
      splitPanes: !layoutCollapsed,
      splitViews: !layoutCollapsed
    }),
    [layoutCollapsed]
  ), structureTool2 = (0, import_react2.useMemo)(() => ({
    features,
    layoutCollapsed,
    setLayoutCollapsed,
    rootPaneNode,
    structureContext: S.context
  }), [features, layoutCollapsed, rootPaneNode, S.context]);
  return (0, import_jsx_runtime.jsx)(StructureToolContext.Provider, { value: structureTool2, children });
}

export {
  require_template,
  require_isNumber,
  require_camelCase,
  require_kebabCase,
  CommentsIntentProvider,
  structureLocaleNamespace,
  PaneRouterContext,
  BackLink,
  usePaneLayout,
  ChildLink,
  ParameterizedLink,
  ReferenceChildLink,
  usePaneRouter,
  ConfirmDeleteDialogContainer,
  Pane,
  usePane,
  PaneContent,
  PaneHeader,
  PaneLayout,
  PaneHeaderActions,
  PaneItem,
  _DEBUG,
  LOADING_PANE,
  useDocumentPane,
  LoadingPane,
  useStructureTool,
  useDocumentTitle,
  DocumentInspectorHeader,
  DocumentPaneProvider,
  DocumentPane,
  DocumentListPane,
  SerializeError,
  HELP_URL,
  maybeSerializeMenuItem,
  MenuItemBuilder,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  maybeSerializeMenuItemGroup,
  MenuItemGroupBuilder,
  ComponentBuilder,
  GenericViewBuilder,
  maybeSerializeView,
  ComponentViewBuilder,
  FormViewBuilder,
  form,
  component,
  DocumentBuilder,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  InitialValueTemplateItemBuilder,
  defaultInitialValueTemplateItems,
  maybeSerializeInitialValueTemplateItem,
  menuItemsFromInitialValueTemplateItems,
  DEFAULT_INTENT_HANDLER,
  defaultIntentChecker,
  shallowIntentChecker,
  GenericListBuilder,
  DocumentListBuilder,
  getTypeNamesFromFilter,
  ListBuilder,
  ListItemBuilder,
  DocumentListItemBuilder,
  isDocumentListItem,
  DocumentTypeListBuilder,
  createStructureBuilder,
  setActivePanes,
  structureTool,
  StructureToolProvider
};
//# sourceMappingURL=chunk-7Q5FFO5Q.js.map
