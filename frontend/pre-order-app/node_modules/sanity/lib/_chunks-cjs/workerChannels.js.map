{"version":3,"file":"workerChannels.js","sources":["../../src/_internal/cli/util/workerChannels.ts"],"sourcesContent":["import {type MessagePort, type Worker} from 'worker_threads'\n\ntype StreamReporter<TPayload = unknown> = {emit: (payload: TPayload) => void; end: () => void}\ntype EventReporter<TPayload = unknown> = (payload: TPayload) => void\ntype EventReceiver<TPayload = unknown> = () => Promise<TPayload>\ntype StreamReceiver<TPayload = unknown> = () => AsyncIterable<TPayload>\n\ntype EventKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelEvent<any> ? K : never\n}[keyof TWorkerChannel]\ntype StreamKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelStream<any> ? K : never\n}[keyof TWorkerChannel]\n\ntype EventMessage<TPayload = unknown> = {type: 'event'; name: string; payload: TPayload}\ntype StreamEmissionMessage<TPayload = unknown> = {type: 'emission'; name: string; payload: TPayload}\ntype StreamEndMessage = {type: 'end'; name: string}\ntype WorkerChannelMessage = EventMessage | StreamEmissionMessage | StreamEndMessage\n\n/**\n * Represents the definition of a \"worker channel\" to report progress from the\n * worker to the parent. Worker channels can define named events or streams and\n * the worker will report events and streams while the parent will await them.\n * This allows the control flow of the parent to follow the control flow of the\n * worker 1-to-1.\n */\nexport type WorkerChannel<\n  TWorkerChannel extends Record<\n    string,\n    WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>\n  > = Record<string, WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>>,\n> = TWorkerChannel\n\nexport type WorkerChannelEvent<TPayload = void> = {type: 'event'; payload: TPayload}\nexport type WorkerChannelStream<TPayload = void> = {type: 'stream'; payload: TPayload}\n\nexport interface WorkerChannelReporter<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReporter<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReporter<TPayload>\n      : void\n  }\n}\n\nexport interface WorkerChannelReceiver<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReceiver<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReceiver<TPayload>\n      : void\n  }\n  // TODO: good candidate for [Symbol.asyncDispose] when our tooling better supports it\n  dispose: () => Promise<number>\n}\n\n/**\n * A simple queue that has two primary methods: `push(message)` and\n * `await next()`. This message queue is used by the \"receiver\" of the worker\n * channel and this class handles buffering incoming messages if the worker is\n * producing faster than the parent as well as returning a promise if there is\n * no message yet in the queue when the parent awaits `next()`.\n */\nclass MessageQueue<T> {\n  resolver: ((result: IteratorResult<T>) => void) | null = null\n  queue: T[] = []\n\n  push(message: T) {\n    if (this.resolver) {\n      this.resolver({value: message, done: false})\n      this.resolver = null\n    } else {\n      this.queue.push(message)\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    if (this.queue.length) {\n      return Promise.resolve({value: this.queue.shift()!, done: false})\n    }\n\n    return new Promise((resolve) => (this.resolver = resolve))\n  }\n\n  end() {\n    if (this.resolver) {\n      this.resolver({value: undefined, done: true})\n    }\n  }\n}\n\nfunction isWorkerChannelMessage(message: unknown): message is WorkerChannelMessage {\n  if (typeof message !== 'object') return false\n  if (!message) return false\n  if (!('type' in message)) return false\n  if (typeof message.type !== 'string') return false\n  const types: string[] = ['event', 'emission', 'end'] satisfies WorkerChannelMessage['type'][]\n  return types.includes(message.type)\n}\n\n/**\n * Creates a \"worker channel receiver\" that subscribes to incoming messages\n * from the given worker and returns promises for worker channel events and\n * async iterators for worker channel streams.\n */\nexport function createReceiver<TWorkerChannel extends WorkerChannel>(\n  worker: Worker,\n): WorkerChannelReceiver<TWorkerChannel> {\n  const _events = new Map<string, MessageQueue<EventMessage>>()\n  const _streams = new Map<string, MessageQueue<StreamEmissionMessage>>()\n  const errors = new MessageQueue<{type: 'error'; error: unknown}>()\n\n  const eventQueue = (name: string) => {\n    const queue = _events.get(name) ?? new MessageQueue()\n    if (!_events.has(name)) _events.set(name, queue)\n    return queue\n  }\n\n  const streamQueue = (name: string) => {\n    const queue = _streams.get(name) ?? new MessageQueue()\n    if (!_streams.has(name)) _streams.set(name, queue)\n    return queue\n  }\n\n  const handleMessage = (message: unknown) => {\n    if (!isWorkerChannelMessage(message)) return\n    if (message.type === 'event') eventQueue(message.name).push(message)\n    if (message.type === 'emission') streamQueue(message.name).push(message)\n    if (message.type === 'end') streamQueue(message.name).end()\n  }\n\n  const handleError = (error: unknown) => {\n    errors.push({type: 'error', error})\n  }\n\n  worker.addListener('message', handleMessage)\n  worker.addListener('error', handleError)\n\n  return {\n    event: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReceiver: EventReceiver = async () => {\n          const {value} = await Promise.race([eventQueue(name).next(), errors.next()])\n          if (value.type === 'error') throw value.error\n          return value.payload\n        }\n\n        return eventReceiver\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['stream'], {\n      get: (target, prop) => {\n        if (typeof prop !== 'string') return target[prop as keyof typeof target]\n        const name = prop // alias for better typescript narrowing\n\n        async function* streamReceiver() {\n          while (true) {\n            const {value, done} = await Promise.race([streamQueue(name).next(), errors.next()])\n            if (done) return\n            if (value.type === 'error') throw value.error\n            yield value.payload\n          }\n        }\n\n        return streamReceiver satisfies StreamReceiver\n      },\n    }),\n    dispose: () => {\n      worker.removeListener('message', handleMessage)\n      worker.removeListener('error', handleError)\n      return worker.terminate()\n    },\n  }\n}\n\n/**\n * Creates a \"worker channel reporter\" that sends messages to the given\n * `parentPort` to be received by a worker channel receiver.\n */\nexport function createReporter<TWorkerChannel extends WorkerChannel>(\n  parentPort: MessagePort | null,\n): WorkerChannelReporter<TWorkerChannel> {\n  if (!parentPort) {\n    throw new Error('parentPart was falsy')\n  }\n\n  return {\n    event: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReporter: EventReporter = (payload) => {\n          const message: EventMessage = {type: 'event', name, payload}\n          parentPort.postMessage(message)\n        }\n\n        return eventReporter\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['stream'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const streamReporter: StreamReporter = {\n          emit: (payload) => {\n            const message: StreamEmissionMessage = {type: 'emission', name, payload}\n            parentPort.postMessage(message)\n          },\n          end: () => {\n            const message: StreamEndMessage = {type: 'end', name}\n            parentPort.postMessage(message)\n          },\n        }\n\n        return streamReporter\n      },\n    }),\n  }\n}\n"],"names":[],"mappings":";AAuEA,MAAM,aAAgB;AAAA,EAAtB,cAAA;AAC2D,SAAA,WAAA,MACzD,KAAA,QAAa;EAAC;AAAA,EAEd,KAAK,SAAY;AACX,SAAK,YACP,KAAK,SAAS,EAAC,OAAO,SAAS,MAAM,GAAM,CAAA,GAC3C,KAAK,WAAW,QAEhB,KAAK,MAAM,KAAK,OAAO;AAAA,EAE3B;AAAA,EAEA,OAAmC;AAC7B,WAAA,KAAK,MAAM,SACN,QAAQ,QAAQ,EAAC,OAAO,KAAK,MAAM,MAAA,GAAU,MAAM,IAAM,IAG3D,IAAI,QAAQ,CAAC,YAAa,KAAK,WAAW,OAAQ;AAAA,EAC3D;AAAA,EAEA,MAAM;AACA,SAAK,YACP,KAAK,SAAS,EAAC,OAAO,QAAW,MAAM,GAAA,CAAK;AAAA,EAEhD;AACF;AAEA,SAAS,uBAAuB,SAAmD;AAC7E,SAAA,OAAO,WAAY,YACnB,CAAC,WACD,EAAE,UAAU,YACZ,OAAO,QAAQ,QAAS,WAAiB,KACrB,CAAC,SAAS,YAAY,KAAK,EACtC,SAAS,QAAQ,IAAI;AACpC;AAOO,SAAS,eACd,QACuC;AACvC,QAAM,UAAU,oBAAI,IAAwC,GACtD,WAAe,oBAAA,OACf,SAAS,IAAI,aAAA,GAEb,aAAa,CAAC,SAAiB;AAxHvC,QAAA;AAyHI,UAAM,SAAQ,KAAQ,QAAA,IAAI,IAAI,MAAhB,OAAA,KAAqB,IAAI;AAClC,WAAA,QAAQ,IAAI,IAAI,KAAG,QAAQ,IAAI,MAAM,KAAK,GACxC;AAAA,EAAA,GAGH,cAAc,CAAC,SAAiB;AA9HxC,QAAA;AA+HI,UAAM,SAAQ,KAAS,SAAA,IAAI,IAAI,MAAjB,OAAA,KAAsB,IAAI;AACnC,WAAA,SAAS,IAAI,IAAI,KAAG,SAAS,IAAI,MAAM,KAAK,GAC1C;AAAA,EAAA,GAGH,gBAAgB,CAAC,YAAqB;AACrC,2BAAuB,OAAO,MAC/B,QAAQ,SAAS,WAAS,WAAW,QAAQ,IAAI,EAAE,KAAK,OAAO,GAC/D,QAAQ,SAAS,cAAY,YAAY,QAAQ,IAAI,EAAE,KAAK,OAAO,GACnE,QAAQ,SAAS,SAAO,YAAY,QAAQ,IAAI,EAAE,IAAI;AAAA,EAAA,GAGtD,cAAc,CAAC,UAAmB;AACtC,WAAO,KAAK,EAAC,MAAM,SAAS,MAAM,CAAA;AAAA,EAAA;AAG7B,SAAA,OAAA,YAAY,WAAW,aAAa,GAC3C,OAAO,YAAY,SAAS,WAAW,GAEhC;AAAA,IACL,OAAO,IAAI,MAAM,IAAsD;AAAA,MACrE,KAAK,CAAC,QAAQ,SACR,OAAO,QAAS,WAAiB,OAAO,IAA2B,IAElC,YAAY;AAC/C,cAAM,EAAC,MAAS,IAAA,MAAM,QAAQ,KAAK,CAAC,WAAW,IAAI,EAAE,KAAK,GAAG,OAAO,KAAA,CAAM,CAAC;AAC3E,YAAI,MAAM,SAAS;AAAS,gBAAM,MAAM;AACxC,eAAO,MAAM;AAAA,MACf;AAAA,IAAA,CAIH;AAAA,IACD,QAAQ,IAAI,MAAM,IAAuD;AAAA,MACvE,KAAK,CAAC,QAAQ,SAAS;AACrB,YAAI,OAAO,QAAS;AAAU,iBAAO,OAAO,IAA2B;AACvE,cAAM,OAAO;AAEb,wBAAgB,iBAAiB;AAClB,qBAAA;AACX,kBAAM,EAAC,OAAO,KAAQ,IAAA,MAAM,QAAQ,KAAK,CAAC,YAAY,IAAI,EAAE,KAAK,GAAG,OAAO,KAAA,CAAM,CAAC;AAC9E,gBAAA;AAAM;AACV,gBAAI,MAAM,SAAS;AAAS,oBAAM,MAAM;AACxC,kBAAM,MAAM;AAAA,UACd;AAAA,QACF;AAEO,eAAA;AAAA,MACT;AAAA,IAAA,CACD;AAAA,IACD,SAAS,OACP,OAAO,eAAe,WAAW,aAAa,GAC9C,OAAO,eAAe,SAAS,WAAW,GACnC,OAAO,UAAU;AAAA,EAAA;AAG9B;AAMO,SAAS,eACd,YACuC;AACvC,MAAI,CAAC;AACG,UAAA,IAAI,MAAM,sBAAsB;AAGjC,SAAA;AAAA,IACL,OAAO,IAAI,MAAM,IAAsD;AAAA,MACrE,KAAK,CAAC,QAAQ,SACR,OAAO,QAAS,WAAiB,OAAO,IAA2B,IAElC,CAAC,YAAY;AAChD,cAAM,UAAwB,EAAC,MAAM,SAAS,MAAM,QAAO;AAC3D,mBAAW,YAAY,OAAO;AAAA,MAChC;AAAA,IAAA,CAIH;AAAA,IACD,QAAQ,IAAI,MAAM,IAAuD;AAAA,MACvE,KAAK,CAAC,QAAQ,SACR,OAAO,QAAS,WAAiB,OAAO,IAA2B,IAEhC;AAAA,QACrC,MAAM,CAAC,YAAY;AACjB,gBAAM,UAAiC,EAAC,MAAM,YAAY,MAAM,QAAO;AACvE,qBAAW,YAAY,OAAO;AAAA,QAChC;AAAA,QACA,KAAK,MAAM;AACT,gBAAM,UAA4B,EAAC,MAAM,OAAO,KAAI;AACpD,qBAAW,YAAY,OAAO;AAAA,QAChC;AAAA,MACF;AAAA,IAAA,CAIH;AAAA,EAAA;AAEL;;;"}