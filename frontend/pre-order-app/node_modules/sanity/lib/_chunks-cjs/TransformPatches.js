"use strict";
var jsxRuntime = require("react/jsx-runtime"), React = require("react"), flatten$1 = require("lodash/flatten.js"), reactRx = require("react-rx"), rxjs = require("rxjs"), operators = require("rxjs/operators"), isEqual$1 = require("lodash/isEqual.js"), resizeObserver$1 = require("@juggle/resize-observer"), createPubSub = require("nano-pubsub");
require("lodash/throttle.js");
var isString$1 = require("lodash/isString.js"), bifurClient = require("@sanity/bifur-client"), client = require("@sanity/client"), ui = require("@sanity/ui"), startCase = require("lodash/startCase.js"), reactIs = require("react-is"), icons = require("@sanity/icons"), uniqueId = require("lodash/uniqueId.js"), styled = require("styled-components"), getJsonStream = require("./getJsonStream.js"), history$1 = require("history"), i18next = require("i18next"), reactI18next = require("react-i18next"), isPlainObject = require("lodash/isPlainObject.js"), schema = require("@sanity/schema"), _internal = require("@sanity/schema/_internal"), cloneDeep = require("lodash/cloneDeep.js"), get = require("lodash/get.js"), types = require("@sanity/types"), legacyDateFormat = require("@sanity/util/legacyDateFormat"), memoize$1 = require("lodash/memoize.js"), client$1 = require("@sanity/util/client"), concurrencyLimiter = require("@sanity/util/concurrency-limiter"), uniqBy = require("lodash/uniqBy.js"), DataLoader = require("dataloader"), PathUtils = require("@sanity/util/paths"), deepCompare = require("react-fast-compare"), debounce = require("lodash/debounce.js"), theme = require("@sanity/ui/theme"), sortBy = require("lodash/sortBy.js"), reactVirtual = require("@tanstack/react-virtual"), throttle = require("lodash/throttle"), observableCallback = require("observable-callback"), portableTextEditor = require("@sanity/portable-text-editor"), color = require("@sanity/color"), dateFns = require("date-fns"), omit = require("lodash/omit.js"), diffMatchPatch$1 = require("@sanity/diff-match-patch"), orderBy = require("lodash/orderBy.js"), assetUtils = require("@sanity/asset-utils"), imageUrlBuilder = require("@sanity/image-url"), withSelector = require("use-sync-external-store/with-selector"), escapeRegExp$1 = require("lodash/escapeRegExp.js"), framerMotion = require("framer-motion"), FocusLock = require("react-focus-lock"), uniq = require("lodash/uniq.js"), xor = require("lodash/xor.js"), sanityDiffPatch = require("sanity-diff-patch"), shallowEquals = require("shallow-equals"), router = require("sanity/router"), useDevicePixelRatio = require("use-device-pixel-ratio"), classNames = require("classnames"), groupBy = require("lodash/groupBy.js"), scrollIntoView = require("scroll-into-view-if-needed"), compact = require("lodash/compact.js"), intersection = require("lodash/intersection.js"), keyBy = require("lodash/keyBy.js"), partition = require("lodash/partition.js"), toLower = require("lodash/toLower.js"), union = require("lodash/union.js"), words = require("lodash/words.js"), flow = require("lodash/flow.js"), trim = require("lodash/trim.js"), isFinite = require("lodash/isFinite.js"), uuid = require("@sanity/uuid"), mutator = require("@sanity/mutator"), jsonReduce = require("json-reduce"), rxjsExhaustmapWithTrailing = require("rxjs-exhaustmap-with-trailing"), content = require("@sanity/util/content"), isEqual$2 = require("lodash/isEqual"), startCase$1 = require("lodash/startCase"), server = require("react-dom/server"), intersection$1 = require("lodash/intersection"), isEmpty$1 = require("lodash/isEmpty"), debug$3 = require("debug"), getRandomValues = require("get-random-values-esm"), capitalize = require("lodash/capitalize.js"), core = require("@dnd-kit/core"), modifiers = require("@dnd-kit/modifiers"), sortable = require("@dnd-kit/sortable"), utilities = require("@dnd-kit/utilities"), speakingurl = require("speakingurl"), difference = require("lodash/difference.js"), react = require("@sanity/telemetry/react"), telemetry = require("@sanity/telemetry"), blockTools = require("@sanity/block-tools"), find = require("lodash/find.js");
require("lodash/castArray.js");
var pick = require("lodash/pick.js"), identity = require("lodash/identity.js"), values = require("lodash/values.js"), assignWith = require("lodash/assignWith.js");
require("polished");
var exif = require("exif-component"), groqJs = require("groq-js"), operators$1 = require("rxjs-etc/operators"), mendoza = require("mendoza"), diff = require("@sanity/diff"), nanoid = require("nanoid"), sample = require("lodash/sample.js"), raf = require("raf"), color2k = require("color2k");
require("react-dom/client");
var Refractor = require("react-refractor"), bash = require("refractor/lang/bash"), javascript = require("refractor/lang/javascript"), json = require("refractor/lang/json"), jsx2 = require("refractor/lang/jsx"), typescript = require("refractor/lang/typescript"), react$1 = require("@portabletext/react"), logos = require("@sanity/logos"), generateHelpUrl = require("@sanity/generate-help-url"), useHotModuleReload = require("use-hot-module-reload"), arrify = require("arrify"), isHotkey = require("is-hotkey"), upperFirst = require("lodash/upperFirst.js"), isValidDate = require("date-fns/isValid"), range = require("lodash/range.js"), isObject = require("lodash/isObject.js"), findIndex$1 = require("lodash/findIndex.js"), clone = require("lodash/clone.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e)
    return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
var flatten__default = /* @__PURE__ */ _interopDefaultCompat(flatten$1), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual$1), createPubSub__default = /* @__PURE__ */ _interopDefaultCompat(createPubSub), isString__default = /* @__PURE__ */ _interopDefaultCompat(isString$1), startCase__default = /* @__PURE__ */ _interopDefaultCompat(startCase), uniqueId__default = /* @__PURE__ */ _interopDefaultCompat(uniqueId), styled__default = /* @__PURE__ */ _interopDefaultCompat(styled), isPlainObject__default = /* @__PURE__ */ _interopDefaultCompat(isPlainObject), cloneDeep__default = /* @__PURE__ */ _interopDefaultCompat(cloneDeep), get__default = /* @__PURE__ */ _interopDefaultCompat(get), legacyDateFormat__namespace = /* @__PURE__ */ _interopNamespaceCompat(legacyDateFormat), memoize__default = /* @__PURE__ */ _interopDefaultCompat(memoize$1), uniqBy__default = /* @__PURE__ */ _interopDefaultCompat(uniqBy), DataLoader__default = /* @__PURE__ */ _interopDefaultCompat(DataLoader), PathUtils__namespace = /* @__PURE__ */ _interopNamespaceCompat(PathUtils), deepCompare__default = /* @__PURE__ */ _interopDefaultCompat(deepCompare), debounce__default = /* @__PURE__ */ _interopDefaultCompat(debounce), sortBy__default = /* @__PURE__ */ _interopDefaultCompat(sortBy), throttle__default = /* @__PURE__ */ _interopDefaultCompat(throttle), omit__default = /* @__PURE__ */ _interopDefaultCompat(omit), orderBy__default = /* @__PURE__ */ _interopDefaultCompat(orderBy), imageUrlBuilder__default = /* @__PURE__ */ _interopDefaultCompat(imageUrlBuilder), escapeRegExp__default = /* @__PURE__ */ _interopDefaultCompat(escapeRegExp$1), FocusLock__default = /* @__PURE__ */ _interopDefaultCompat(FocusLock), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq), xor__default = /* @__PURE__ */ _interopDefaultCompat(xor), shallowEquals__default = /* @__PURE__ */ _interopDefaultCompat(shallowEquals), classNames__default = /* @__PURE__ */ _interopDefaultCompat(classNames), groupBy__default = /* @__PURE__ */ _interopDefaultCompat(groupBy), scrollIntoView__default = /* @__PURE__ */ _interopDefaultCompat(scrollIntoView), compact__default = /* @__PURE__ */ _interopDefaultCompat(compact), intersection__default = /* @__PURE__ */ _interopDefaultCompat(intersection), keyBy__default = /* @__PURE__ */ _interopDefaultCompat(keyBy), partition__default = /* @__PURE__ */ _interopDefaultCompat(partition), toLower__default = /* @__PURE__ */ _interopDefaultCompat(toLower), union__default = /* @__PURE__ */ _interopDefaultCompat(union), words__default = /* @__PURE__ */ _interopDefaultCompat(words), flow__default = /* @__PURE__ */ _interopDefaultCompat(flow), trim__default = /* @__PURE__ */ _interopDefaultCompat(trim), isFinite__default = /* @__PURE__ */ _interopDefaultCompat(isFinite), isEqual__default$1 = /* @__PURE__ */ _interopDefaultCompat(isEqual$2), startCase__default$1 = /* @__PURE__ */ _interopDefaultCompat(startCase$1), intersection__default$1 = /* @__PURE__ */ _interopDefaultCompat(intersection$1), isEmpty__default = /* @__PURE__ */ _interopDefaultCompat(isEmpty$1), debug__default = /* @__PURE__ */ _interopDefaultCompat(debug$3), getRandomValues__default = /* @__PURE__ */ _interopDefaultCompat(getRandomValues), capitalize__default = /* @__PURE__ */ _interopDefaultCompat(capitalize), speakingurl__default = /* @__PURE__ */ _interopDefaultCompat(speakingurl), difference__default = /* @__PURE__ */ _interopDefaultCompat(difference), find__default = /* @__PURE__ */ _interopDefaultCompat(find), pick__default = /* @__PURE__ */ _interopDefaultCompat(pick), identity__default = /* @__PURE__ */ _interopDefaultCompat(identity), values__default = /* @__PURE__ */ _interopDefaultCompat(values), assignWith__default = /* @__PURE__ */ _interopDefaultCompat(assignWith), exif__default = /* @__PURE__ */ _interopDefaultCompat(exif), sample__default = /* @__PURE__ */ _interopDefaultCompat(sample), raf__default = /* @__PURE__ */ _interopDefaultCompat(raf), Refractor__default = /* @__PURE__ */ _interopDefaultCompat(Refractor), bash__default = /* @__PURE__ */ _interopDefaultCompat(bash), javascript__default = /* @__PURE__ */ _interopDefaultCompat(javascript), json__default = /* @__PURE__ */ _interopDefaultCompat(json), jsx2__default = /* @__PURE__ */ _interopDefaultCompat(jsx2), typescript__default = /* @__PURE__ */ _interopDefaultCompat(typescript), arrify__default = /* @__PURE__ */ _interopDefaultCompat(arrify), isHotkey__default = /* @__PURE__ */ _interopDefaultCompat(isHotkey), upperFirst__default = /* @__PURE__ */ _interopDefaultCompat(upperFirst), isValidDate__default = /* @__PURE__ */ _interopDefaultCompat(isValidDate), range__default = /* @__PURE__ */ _interopDefaultCompat(range), isObject__default = /* @__PURE__ */ _interopDefaultCompat(isObject), findIndex__default = /* @__PURE__ */ _interopDefaultCompat(findIndex$1), clone__default = /* @__PURE__ */ _interopDefaultCompat(clone);
const ConnectorContext = React.createContext({
  isReviewChangesOpen: !1,
  onOpenReviewChanges: () => {
  },
  onSetFocus: () => {
  }
});
function createStore() {
  const reportedValues = /* @__PURE__ */ new Map(), { publish: publish2, subscribe } = createPubSub__default.default(), debouncedPublish = debounce__default.default(publish2, 10, { trailing: !0 }), read2 = () => Array.from(reportedValues.entries());
  function add(id2, value) {
    reportedValues.has(id2), reportedValues.set(id2, value), debouncedPublish(read2());
  }
  function update(id2, value) {
    reportedValues.has(id2), reportedValues.set(id2, value), debouncedPublish(read2());
  }
  function remove2(id2) {
    reportedValues.has(id2), reportedValues.delete(id2), debouncedPublish(read2());
  }
  return {
    add,
    remove: remove2,
    update,
    read: read2,
    subscribe
  };
}
function isFunc(value) {
  return typeof value == "function";
}
function read(value) {
  return isFunc(value) ? value() : value;
}
const noop$4 = () => {
};
function createUseReporter(Context2) {
  return function(id2, value, isEqual2 = Object.is) {
    const { add, update, remove: remove2 } = React.useContext(Context2), previous = React.useRef();
    React.useLayoutEffect(() => {
      if (id2 === null)
        return noop$4;
      const current = read(value);
      return add(id2, current), previous.current = current, () => {
        remove2(id2);
      };
    }, [add, id2, remove2, value]), React.useLayoutEffect(() => {
      const current = read(value);
      typeof previous.current < "u" && !isEqual2(previous.current, current) && id2 !== null && update(id2, current), previous.current = current;
    });
  };
}
let didWarn = !1;
const useReporterGuard = (id2) => {
  didWarn || console.warn(
    new Error(
      `No context provided for reporter. Make sure that the component calling "useReporter(${id2}, ...)", is wrapped in a <Tracker> element`
    )
  ), didWarn = !0;
};
function useReportedValueGuard() {
  return didWarn || console.warn(
    new Error(
      'No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'
    )
  ), didWarn = !0, [];
}
const useSubscribeGuard = () => (didWarn || console.warn(
  new Error(
    'No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'
  )
), didWarn = !0, () => {
}), DEFAULT_CONTEXT = {
  add: useReporterGuard,
  update: useReporterGuard,
  remove: useReporterGuard,
  subscribe: useSubscribeGuard,
  read: useReportedValueGuard
};
let id$1 = 0;
const getNextId = () => ++id$1;
function createTrackerScope() {
  const Context2 = React.createContext(DEFAULT_CONTEXT);
  function useReportedValues2() {
    const context = React.useContext(Context2), [values2, setValues] = React.useState(context.read());
    return React.useLayoutEffect(() => (setValues(context.read()), context.subscribe(setValues)), [context]), values2;
  }
  function Tracker2(props2) {
    const store = React.useMemo(() => createStore(), []);
    return /* @__PURE__ */ jsxRuntime.jsx(Context2.Provider, { value: store, children: props2.children });
  }
  const useReporter2 = createUseReporter(Context2);
  return {
    Tracker: Tracker2,
    useReportedValues: useReportedValues2,
    useReporter: useReporter2,
    useAutoIdReporter: (value, isEqual2 = Object.is) => useReporter2(`element-${React.useRef(getNextId()).current}`, value, isEqual2)
  };
}
const CORNER_RADIUS = 4, INTERACTIVE_STROKE_WIDTH = 16, CONNECTOR_MARGIN = 8, ARROW_MARGIN_X = 8, ARROW_MARGIN_Y = 2, ARROW_SIZE = 4, ARROW_THRESHOLD = 12, STROKE_WIDTH$2 = 1, DEBUG$1 = !1, DEBUG_LAYER_BOUNDS = !1, trackerScope = createTrackerScope(), Tracker$1 = trackerScope.Tracker, useReportedValues$1 = trackerScope.useReportedValues, useReporter$1 = trackerScope.useReporter;
function useUnique(value) {
  const valueRef = React.useRef(value);
  return isEqual__default.default(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
function createHookFromObservableFactory(observableFactory, initialValue) {
  const initialLoadingTuple = [initialValue, !0], initialResult = { type: "tuple", tuple: initialLoadingTuple };
  return function(_arg) {
    const memoArg = useUnique(_arg), result = reactRx.useMemoObservable(
      () => rxjs.of(memoArg).pipe(
        operators.switchMap(
          (arg) => rxjs.concat(
            rxjs.of({ type: "loading" }),
            observableFactory(arg).pipe(operators.map((value) => ({ type: "value", value })))
          )
        ),
        operators.scan(([prevValue], next) => next.type === "loading" ? [prevValue, !0] : [next.value, !1], initialLoadingTuple),
        operators.distinctUntilChanged(([prevValue, prevIsLoading], [nextValue, nextIsLoading]) => !(prevValue !== nextValue || prevIsLoading !== nextIsLoading)),
        operators.map((tuple) => ({ type: "tuple", tuple })),
        operators.catchError((error) => rxjs.of({ type: "error", error }))
      ),
      [memoArg],
      initialResult
    );
    if (result.type === "error")
      throw result.error;
    return result.tuple;
  };
}
function isNonNullable$2(value) {
  return value != null;
}
const DRAFTS_FOLDER = "drafts", DRAFTS_PREFIX = `${DRAFTS_FOLDER}.`;
function documentIdEquals(documentId, equalsDocumentId) {
  return getPublishedId(documentId) === getPublishedId(equalsDocumentId);
}
function isDraft(document2) {
  return isDraftId(document2._id);
}
function isDraftId(id2) {
  return id2.startsWith(DRAFTS_PREFIX);
}
function getIdPair(id2) {
  return {
    draftId: getDraftId(id2),
    publishedId: getPublishedId(id2)
  };
}
function isPublishedId(id2) {
  return !isDraftId(id2);
}
function getDraftId(id2) {
  return isDraftId(id2) ? id2 : DRAFTS_PREFIX + id2;
}
function getPublishedId(id2) {
  return isDraftId(id2) ? id2.slice(DRAFTS_PREFIX.length) : id2;
}
function createDraftFrom(document2) {
  return {
    ...document2,
    _id: getDraftId(document2._id)
  };
}
function newDraftFrom(document2) {
  return {
    ...document2,
    _id: DRAFTS_PREFIX
  };
}
function createPublishedFrom(document2) {
  return {
    ...document2,
    _id: getPublishedId(document2._id)
  };
}
function collate(documents) {
  const byId = documents.reduce((res, doc) => {
    const publishedId = getPublishedId(doc._id);
    let entry = res.get(publishedId);
    return entry || (entry = { id: publishedId, type: doc._type, published: void 0, draft: void 0 }, res.set(publishedId, entry)), entry[publishedId === doc._id ? "published" : "draft"] = doc, res;
  }, /* @__PURE__ */ new Map());
  return Array.from(byId.values());
}
function removeDupes(documents) {
  return collate(documents).map((entry) => entry.draft || entry.published).filter(isNonNullable$2);
}
const EMPTY_OBJECT = Object.freeze({}), EMPTY_ARRAY$b = Object.freeze([]);
function getGlobalScope() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof window < "u")
    return window;
  if (typeof self < "u")
    return self;
  if (typeof global < "u")
    return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
function isRecord$4(value) {
  return !!value && typeof value == "object" && !Array.isArray(value);
}
function isString(value) {
  return typeof value == "string";
}
const ResizeObserver = typeof document == "object" && typeof window == "object" && window.ResizeObserver ? window.ResizeObserver : resizeObserver$1.ResizeObserver, createSharedResizeObserver = () => {
  const event = createPubSub__default.default(), resizeObserver2 = new ResizeObserver(
    (entries) => event.publish(entries)
  );
  return {
    observe: (element, observer, options) => {
      const unsubscribe = event.subscribe((entries) => {
        const entry = entries.find((e) => e.target === element);
        entry && observer(entry);
      });
      return resizeObserver2.observe(element, options), () => {
        unsubscribe(), resizeObserver2.unobserve(element);
      };
    },
    unobserve: (element) => resizeObserver2.unobserve(element)
  };
}, resizeObserver = createSharedResizeObserver(), GROQ_KEYWORDS = ["match", "in", "asc", "desc", "true", "false", "null"], VALID_FIELD = /^[a-zA-Z_][a-zA-Z0-9_]*$/, fieldNeedsEscape = (fieldName) => !VALID_FIELD.test(fieldName) || GROQ_KEYWORDS.includes(fieldName), escapeField = (fieldName) => `["${fieldName}"]`, escapeFirst = (fieldName) => `@${escapeField(fieldName)}`, isEmptyArray = (value) => Array.isArray(value) && value.length === 0, joinPath = (pathArray) => {
  let path = "";
  for (let i = 0; i < pathArray.length; i++) {
    const pathSegment = pathArray[i];
    if (isEmptyArray(pathSegment)) {
      path += "[]";
      continue;
    }
    if (typeof pathSegment == "number") {
      path += `[${pathSegment}]`;
      continue;
    }
    const isFirst = i === 0;
    fieldNeedsEscape(pathSegment) ? path = isFirst ? escapeFirst(pathSegment) : `${path}${escapeField(pathSegment)}` : path = isFirst ? pathSegment : `${path}.${pathSegment}`;
  }
  return path;
}, supportsTouch = isTouchDevice$1();
function isTouchDevice$1() {
  return typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
const segmenter = typeof Intl == "object" && "Segmenter" in Intl ? new Intl.Segmenter() : void 0;
function sliceString(str, start, end) {
  if (end < start)
    throw new Error(
      "End must be greater than start, use `String.prototype.slice()` for negative values"
    );
  if (!segmenter)
    return str.slice(start, end);
  let i = 0, sliced = "";
  for (const value of segmenter.segment(str)) {
    if (i === end)
      return sliced;
    sliced += value.segment, i++;
  }
  return sliced;
}
function truncateString(str, maxLength) {
  const truncated = sliceString(str, 0, maxLength);
  return truncated === str ? truncated : `${truncated}\u2026`;
}
const LOADING_STATE = {
  isLoading: !0,
  value: void 0,
  error: null
};
function useLoadable(value$, initialValue) {
  return reactRx.useMemoObservable(() => value$.pipe(asLoadable()), [value$], typeof initialValue > "u" ? LOADING_STATE : { isLoading: !1, value: initialValue, error: null });
}
function asLoadable() {
  return (value$) => value$.pipe(
    operators.map((value) => ({ isLoading: !1, value, error: null })),
    operators.catchError(
      (error) => rxjs.of({ isLoading: !1, value: void 0, error })
    )
  );
}
function userHasRole(user, roleId) {
  return user !== null && user.roles.some((role) => role.name === roleId);
}
var _a$1;
const DEBUG_MODE$2 = typeof process > "u" ? !1 : (_a$1 = process == null ? void 0 : process.env) == null ? void 0 : _a$1.SANITY_STUDIO_DEBUG_I18N, DEBUG_I18N = !!DEBUG_MODE$2, debugWrappers = {
  reverse: (str) => `\u202E${str}`,
  triangles: (str) => `\u25E4 ${str} \u25E2`
};
function maybeWrapT(t2) {
  const wrapper = DEBUG_MODE$2 === "reverse" || DEBUG_MODE$2 === "triangles" ? debugWrappers[DEBUG_MODE$2] : null;
  return wrapper ? (...args) => wrapper(t2(...args)) : t2;
}
const translationOptionOverrides = {
  // We're manually forcing a re-render with the locale key in the LocaleProvider,
  // so we don't need to bind to the i18n instance for language change events.
  bindI18n: !1
};
function useTranslation(ns, options) {
  const { t: t2 } = reactI18next.useTranslation(
    ns,
    options ? { keyPrefix: options.keyPrefix, lng: options.lng, ...translationOptionOverrides } : translationOptionOverrides
  );
  return { t: maybeWrapT(t2) };
}
const animationSpeed = 250, ChangeBarWrapper$1 = styled__default.default.div(
  ({ $changed, $disabled, $hasFocus, $isReviewChangeOpen }) => $disabled ? styled.css`
        ${ChangeBarMarker}:after {
          display: none;
        }
      ` : styled.css`
      --change-bar-offset: 4px;

      display: flex;
      position: relative;

      ${ChangeBarMarker}:after {
        opacity: 0.5;
      }

      @media (hover: hover) {
        &:hover {
          z-index: 10;
          ${ChangeBarMarker}:after {
            opacity: 1;
          }
        }
      }

      /* hide when field is not changed */
      ${$hasFocus && styled.css`
        ${ChangeBarMarker}:after {
          opacity: 1;
        }
      `}

      /* hide when field is not changed */
      ${!$changed && styled.css`
        ${ChangeBarMarker}:after {
          opacity: 0;
          pointer-events: none;
        }
      `}

      /* hide hover effect when review changes is open */
      ${$isReviewChangeOpen && styled.css`
        ${ChangeBarButton} {
          opacity: 0;
        }
      `}
    `
), FieldWrapper = styled__default.default.div`
  flex-grow: 1;
  min-width: 0;
`, ChangeBar = styled__default.default.div`
  position: relative;
  opacity: 1;
  transition: opacity 100ms;
  z-index: ${({ $zIndex }) => $zIndex};
`, ChangeBarMarker = styled__default.default.div((props2) => {
  const { media } = theme.getTheme_v2(props2.theme);
  return styled.css`
    position: absolute;
    top: -1px;
    left: var(--change-bar-offset);
    width: 1px;
    bottom: -1px;
    background-color: var(--card-bg-color);

    @media (min-width: ${media[0]}px) {
      display: unset;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 1px;
      left: 0;
      width: 1px;
      bottom: 1px;
      background-color: var(--card-badge-caution-dot-color);
      border-radius: 0.5px;
    }
  `;
}), ChangeBarButton = styled__default.default.button((props2) => {
  const { $withHoverEffect } = props2;
  return styled.css`
    appearance: none;
    border: 0;
    outline: 0;
    display: block;
    padding: 0;
    background: transparent;
    opacity: 0;
    position: absolute;
    height: 100%;
    cursor: pointer;
    pointer-events: all;
    left: calc(-0.25rem + var(--change-bar-offset));
    width: calc(1rem - 1px);
    transition: opacity ${animationSpeed}ms;

    &:focus {
      border: 0;
      outline: 0;
    }

    &:focus {
      border: 0;
      outline: 0;
    }

    ${$withHoverEffect && styled.css`
      @media (hover: hover) {
        &:hover {
          opacity: 0.2;
        }
      }
    `}
  `;
});
function ElementWithChangeBar(props2) {
  const { children, disabled, hasFocus, isChanged, withHoverEffect = !0 } = props2, { onOpenReviewChanges, isReviewChangesOpen } = React.useContext(ConnectorContext), { zIndex } = ui.useLayer(), { t: t2 } = useTranslation(), changeBar = React.useMemo(
    () => disabled || !isChanged ? null : /* @__PURE__ */ jsxRuntime.jsxs(ChangeBar, { "data-testid": "change-bar", $zIndex: zIndex, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ChangeBarMarker, { "data-testid": "change-bar__marker" }),
      /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: t2("changes.change-bar.aria-label"), portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
        ChangeBarButton,
        {
          "aria-label": t2("changes.change-bar.aria-label"),
          "data-testid": "change-bar__button",
          onClick: isReviewChangesOpen ? void 0 : onOpenReviewChanges,
          tabIndex: -1,
          type: "button",
          $withHoverEffect: withHoverEffect
        }
      ) })
    ] }),
    [disabled, isChanged, isReviewChangesOpen, onOpenReviewChanges, t2, withHoverEffect, zIndex]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ChangeBarWrapper$1,
    {
      "data-testid": "change-bar-wrapper",
      $changed: isChanged,
      $disabled: disabled,
      $hasFocus: hasFocus,
      $isReviewChangeOpen: isReviewChangesOpen,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper, { "data-testid": "change-bar__field-wrapper", children }),
        changeBar
      ]
    }
  );
}
const ChangeBarWrapper = React.memo(function(props2) {
  const {
    children,
    disabled,
    hasFocus,
    isChanged,
    onMouseEnter: onMouseEnterProp,
    onMouseLeave: onMouseLeaveProp,
    path = EMPTY_ARRAY$b,
    withHoverEffect,
    ...restProps
  } = props2, layer = ui.useLayer(), [hasHover, setHover] = React.useState(!1), onMouseEnter = React.useCallback(
    (event) => {
      onMouseEnterProp == null || onMouseEnterProp(event), setHover(!0);
    },
    [onMouseEnterProp]
  ), onMouseLeave = React.useCallback(
    (event) => {
      onMouseLeaveProp == null || onMouseLeaveProp(event), setHover(!1);
    },
    [onMouseLeaveProp]
  ), ref = React.useRef(null);
  return useReporter$1(
    disabled ? null : `field-${PathUtils__namespace.toString(path)}`,
    () => ({
      element: ref.current,
      path,
      isChanged,
      hasFocus,
      hasHover,
      zIndex: layer.zIndex
    }),
    deepCompare__default.default
    // note: deepCompare should be ok here since we're not comparing deep values
  ), /* @__PURE__ */ jsxRuntime.jsx("div", { ...restProps, ref, onMouseEnter, onMouseLeave, children: /* @__PURE__ */ jsxRuntime.jsx(
    ElementWithChangeBar,
    {
      hasFocus,
      isChanged,
      disabled,
      withHoverEffect,
      children
    }
  ) });
});
function ChangeIndicator(props2) {
  const { children, hasFocus, isChanged, path, withHoverEffect, ...restProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ChangeBarWrapper,
    {
      ...restProps,
      path,
      hasFocus,
      isChanged,
      withHoverEffect,
      children
    }
  );
}
const ChangeIndicatorContext = React.createContext({
  path: [],
  fullPath: [],
  focusPath: [],
  isChanged: !1
}), ScrollContext = React.createContext(null), noop$3 = () => {
}, ScrollContainer = React.forwardRef(function(props2, ref) {
  const { as = "div", onScroll, ...rest } = props2, forwardedRef = ui.useForwardedRef(ref), parentContext = React.useContext(ScrollContext), childContext = React.useMemo(() => createPubSub__default.default(), []);
  return React.useEffect(() => onScroll ? childContext.subscribe(onScroll) : noop$3, [childContext, onScroll]), React.useEffect(() => parentContext ? childContext.subscribe(parentContext.publish) : noop$3, [parentContext, childContext]), React.useEffect(() => {
    const handleScroll = (event) => {
      childContext.publish(event);
    }, el = forwardedRef.current;
    if (el)
      return el.addEventListener("scroll", handleScroll, {
        passive: !0,
        capture: !0
      }), () => {
        el.removeEventListener("scroll", handleScroll);
      };
  }, [childContext, forwardedRef]), /* @__PURE__ */ jsxRuntime.jsx(ScrollContext.Provider, { value: childContext, children: React.createElement(as, { ref: forwardedRef, "data-testid": "scroll-container", ...rest }) });
});
function ClampedRect(props2) {
  const { bounds, ...rest } = props2, x = Math.max(bounds.left, props2.left), y = Math.max(props2.top, bounds.top), height = Math.max(0, props2.height - (y - props2.top)), width = Math.max(0, props2.width - (x - props2.left));
  return /* @__PURE__ */ jsxRuntime.jsx("rect", { ...rest, x, y, height, width });
}
styled__default.default.rect`
  stroke: #ccc;
  fill: none;
  pointer-events: none;
  stroke-linecap: round;
`;
const ConnectorPath = styled__default.default.path`
  fill: none;
  pointer-events: none;
  stroke-linejoin: round;
  stroke: var(--card-badge-caution-dot-color);
`, InteractivePath = styled__default.default.path`
  fill: none;
  pointer-events: stroke;
  stroke: transparent;
  cursor: pointer;
  stroke-linecap: round;
  stroke-linejoin: round;
  opacity: 0;

  &:hover {
    opacity: 0.2;
  }
`, RightBarWrapper = styled__default.default(ClampedRect)`
  stroke: none;
  pointer-events: none;
  fill: var(--card-badge-caution-dot-color);
`;
function arrowPath(x, y, dir) {
  return [
    `M ${x - ARROW_SIZE} ${y - ARROW_SIZE * dir} `,
    `L ${x} ${y}`,
    `L ${x + ARROW_SIZE} ${y - ARROW_SIZE * dir}`
  ].join("");
}
function moveTo(x, y) {
  return `M${x} ${y}`;
}
function lineTo(x, y) {
  return `L${x} ${y}`;
}
function join(strings, delim = "") {
  return strings.join(delim);
}
function quadCurve(x1, y1, x, y) {
  return `Q${x1} ${y1} ${x} ${y}`;
}
function generateConnectorPath(line) {
  const { from, to } = line, { left: fromX, top: fromY } = from, { left: toX, top: toY } = to, cmds = [], r1 = Math.min(CORNER_RADIUS, Math.abs(fromY - toY) / 2);
  return from.isAbove ? cmds.push(
    moveTo(fromX + ARROW_MARGIN_X, fromY - ARROW_THRESHOLD + ARROW_MARGIN_Y),
    lineTo(fromX + ARROW_MARGIN_X, fromY - CORNER_RADIUS),
    quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY)
  ) : from.isBelow ? cmds.push(
    moveTo(fromX + ARROW_MARGIN_X, fromY + ARROW_THRESHOLD - ARROW_MARGIN_Y),
    lineTo(fromX + ARROW_MARGIN_X, fromY + CORNER_RADIUS),
    quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY)
  ) : cmds.push(moveTo(fromX, fromY)), to.isAbove ? fromY < to.bounds.top ? cmds.push(
    lineTo(to.bounds.left - 8 - r1, fromY),
    quadCurve(to.bounds.left - 8, fromY, to.bounds.left - 8, fromY + r1),
    lineTo(to.bounds.left - 8, toY - r1),
    quadCurve(to.bounds.left - 8, toY, to.bounds.left - 8 + r1, toY),
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      toY,
      to.bounds.left + ARROW_MARGIN_X,
      toY - CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY - CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y)
  ) : to.isBelow ? fromY > to.bounds.top + to.bounds.height ? cmds.push(
    lineTo(to.bounds.left - ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left - ARROW_MARGIN_X,
      fromY,
      to.bounds.left - ARROW_MARGIN_X,
      fromY - r1
    ),
    lineTo(to.bounds.left - ARROW_MARGIN_X, toY + r1),
    quadCurve(to.bounds.left - ARROW_MARGIN_X, toY, to.bounds.left - ARROW_MARGIN_X + r1, toY),
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      toY,
      to.bounds.left + ARROW_MARGIN_X,
      toY + CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY + CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y)
  ) : fromY < toY ? cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY + r1
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - r1),
    quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY),
    lineTo(toX, toY)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY - r1
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + r1),
    quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY),
    lineTo(toX, toY)
  ), join(cmds);
}
function getConnectorLinePoint(rect, bounds) {
  const centerY = rect.top + rect.height / 2, isAbove = rect.top + rect.height < bounds.top + ARROW_MARGIN_Y, isBelow = rect.top > bounds.top + bounds.height - ARROW_MARGIN_Y;
  return {
    bounds,
    left: rect.left,
    top: centerY,
    centerY,
    startY: rect.top + CONNECTOR_MARGIN,
    endY: rect.top + rect.height - CONNECTOR_MARGIN,
    isAbove,
    isBelow,
    outOfBounds: isAbove || isBelow
  };
}
function mapConnectorToLine(connector) {
  const fromBounds = {
    top: connector.from.bounds.top + ARROW_THRESHOLD,
    bottom: connector.from.bounds.top + connector.from.bounds.height - ARROW_THRESHOLD,
    left: connector.from.bounds.left,
    right: connector.from.bounds.left + connector.from.bounds.width,
    width: connector.from.bounds.width,
    height: connector.from.bounds.height - ARROW_THRESHOLD * 2
  }, from = getConnectorLinePoint(connector.from.rect, fromBounds);
  from.left = connector.from.rect.left + connector.from.rect.width + 1;
  const toBounds = {
    top: connector.to.bounds.top + ARROW_THRESHOLD,
    bottom: connector.to.bounds.top + connector.to.bounds.height - ARROW_THRESHOLD,
    left: connector.to.bounds.left,
    right: connector.to.bounds.left + connector.to.bounds.width,
    width: connector.to.bounds.width,
    height: connector.to.bounds.height - ARROW_THRESHOLD * 2
  }, to = getConnectorLinePoint(connector.to.rect, toBounds), maxStartY = Math.max(to.startY, from.startY);
  return from.top = Math.min(maxStartY, from.endY), from.top < toBounds.top ? from.top = Math.min(toBounds.top, from.endY) : from.top > toBounds.bottom && (from.top = Math.max(toBounds.bottom, from.startY)), to.top = Math.min(maxStartY, to.endY), to.top < fromBounds.top ? to.top = Math.min(fromBounds.top, to.endY) : to.top > fromBounds.bottom && (to.top = Math.max(fromBounds.bottom, to.startY)), from.top = Math.min(Math.max(from.top, fromBounds.top), fromBounds.bottom), to.top = Math.min(Math.max(to.top, toBounds.top), toBounds.bottom), { from, to };
}
const Connector = React.memo(function({ from, to }) {
  const line = mapConnectorToLine({ from, to });
  if (line.from.outOfBounds && line.to.outOfBounds)
    return null;
  const linePathDescription = generateConnectorPath(line);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(InteractivePath, { d: linePathDescription, strokeWidth: INTERACTIVE_STROKE_WIDTH }),
    /* @__PURE__ */ jsxRuntime.jsx(ConnectorPath, { d: linePathDescription, strokeWidth: STROKE_WIDTH$2 }),
    /* @__PURE__ */ jsxRuntime.jsx(
      RightBarWrapper,
      {
        top: to.rect.top,
        left: to.rect.left - 0.5,
        height: to.rect.height,
        width: STROKE_WIDTH$2,
        bounds: to.bounds
      }
    ),
    line.from.isAbove && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.from.left + ARROW_MARGIN_X,
          line.from.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y,
          -1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.from.isBelow && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.from.left + ARROW_MARGIN_X,
          line.from.bounds.top + line.from.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y,
          1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.to.isAbove && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.to.bounds.left + ARROW_MARGIN_X,
          line.to.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y,
          -1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.to.isBelow && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.to.bounds.left + ARROW_MARGIN_X,
          line.to.bounds.top + line.to.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y,
          1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    DEBUG$1
  ] });
}), SvgWrapper = styled__default.default.svg`
  pointer-events: none;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
`;
function focusRingBorderStyle$2(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
const AlignedBottomGrid$1 = styled__default.default(ui.Grid)`
  align-items: flex-end;
`;
function focusRingStyle$2(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle$2(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const LIST_ITEM_DATA_ATTR_ACTIVE = "data-active", LIST_ITEM_INTERACTIVE_SELECTOR = "a,button", FocusOverlayDiv = styled__default.default.div(({ theme: theme2, offset }) => styled.css`
    bottom: ${-offset}px;
    border-radius: ${ui.rem(theme2.sanity.radius[1])};
    left: ${-offset}px;
    pointer-events: none;
    position: absolute;
    right: ${-offset}px;
    top: ${-offset}px;
    z-index: 2;

    ${VirtualListBox}:focus-visible & {
      box-shadow: ${focusRingStyle$2({
  base: theme2.sanity.color.base,
  focusRing: theme2.sanity.focusRing
})};
    }
  `), PointerOverlayDiv = styled__default.default.div`
  bottom: 0;
  display: none;
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
  z-index: 1;

  @media (hover: hover) {
    &[data-enabled='true'] {
      display: block;
    }
  }
`, VirtualListBox = styled__default.default(ui.Box)`
  height: 100%;
  outline: none;
  overflow-x: hidden;
  overflow-y: auto;
  overscroll-behavior: contain;
  width: 100%;
`, VirtualListChildBox = styled__default.default(ui.Box).attrs(({ $height }) => ({
  style: { height: `${$height}px` }
}))`
  position: relative;
  width: 100%;
`, CommandList = React.forwardRef(function({
  activeItemDataAttr = LIST_ITEM_DATA_ATTR_ACTIVE,
  ariaLabel,
  ariaMultiselectable = !1,
  autoFocus,
  canReceiveFocus,
  fixedHeight,
  focusRingOffset = 0,
  getItemDisabled,
  getItemKey: getItemKey2,
  getItemSelected,
  initialIndex,
  initialScrollAlign = "start",
  inputElement,
  itemHeight,
  items,
  onEndReached,
  onEndReachedIndexOffset = 0,
  onlyShowSelectionWhenActive,
  overscan,
  renderItem,
  wrapAround = !0,
  ...responsivePaddingProps
}, ref) {
  const isMountedRef = React.useRef(!1), commandListId = React.useRef(React.useId()), activeIndexRef = React.useRef(initialIndex != null ? initialIndex : 0), [childContainerElement, setChildContainerElement] = React.useState(null), [hovered, setHovered] = React.useState(!1), [pointerOverlayElement, setPointerOverlayElement] = React.useState(null), [virtualListElement, setVirtualListElement] = React.useState(null), handleChange = React.useCallback(
    (v) => {
      if (!onEndReached)
        return;
      const [lastItem] = [...v.getVirtualItems()].reverse();
      lastItem && lastItem.index >= items.length - onEndReachedIndexOffset - 1 && isMountedRef.current && onEndReached();
    },
    [onEndReached, items.length, onEndReachedIndexOffset]
  ), virtualizer = reactVirtual.useVirtualizer({
    count: items.length,
    getItemKey: getItemKey2,
    getScrollElement: () => virtualListElement,
    estimateSize: () => itemHeight,
    onChange: handleChange,
    overscan
  }), itemIndices = React.useMemo(() => {
    let i = -1;
    return items.reduce((acc, _, index) => {
      var _a2, _b;
      const disabled = (_a2 = getItemDisabled == null ? void 0 : getItemDisabled(index)) != null ? _a2 : !1, selected = (_b = getItemSelected == null ? void 0 : getItemSelected(index)) != null ? _b : !1;
      return disabled || (i += 1), acc[index] = {
        activeIndex: disabled ? null : i,
        disabled,
        selected
      }, acc;
    }, []);
  }, [getItemDisabled, getItemSelected, items]), activeItemCount = React.useMemo(
    () => itemIndices.filter((v) => !v.disabled).length,
    [itemIndices]
  ), enableChildContainerPointerEvents = React.useCallback(
    (enabled) => pointerOverlayElement == null ? void 0 : pointerOverlayElement.setAttribute("data-enabled", (!enabled).toString()),
    [pointerOverlayElement]
  ), getChildDescendantId = React.useCallback(
    (index) => `${commandListId.current}-item-${index}`,
    []
  ), getCommandListChildrenId = React.useCallback(() => `${commandListId.current}-children`, []), showChildrenActiveState = React.useCallback(() => {
    const hasFocus = [inputElement, virtualListElement].some((el) => document.activeElement === el);
    if (onlyShowSelectionWhenActive && !hasFocus && !hovered)
      return;
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null || childElements.forEach((child) => {
      var _a2, _b, _c;
      const virtualIndex = Number((_a2 = child.dataset) == null ? void 0 : _a2.index), targetIndex = (_b = itemIndices[virtualIndex]) == null ? void 0 : _b.activeIndex;
      (_c = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null || _c.toggleAttribute(activeItemDataAttr, targetIndex === activeIndexRef.current);
    });
  }, [
    activeItemDataAttr,
    childContainerElement == null ? void 0 : childContainerElement.children,
    hovered,
    inputElement,
    itemIndices,
    onlyShowSelectionWhenActive,
    virtualListElement
  ]), hideChildrenActiveState = React.useCallback(() => {
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null || childElements.forEach((child) => {
      var _a2;
      (_a2 = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null || _a2.toggleAttribute(activeItemDataAttr, !1);
    });
  }, [activeItemDataAttr, childContainerElement == null ? void 0 : childContainerElement.children]), refreshChildrenActiveStateThrottled = React.useMemo(() => throttle__default.default(showChildrenActiveState, 200), [showChildrenActiveState]), handleUpdateActiveDescendant = React.useCallback(() => {
    const activeIndex = activeIndexRef == null ? void 0 : activeIndexRef.current;
    items.length > 0 ? (inputElement == null || inputElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex)), virtualListElement == null || virtualListElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex))) : (inputElement == null || inputElement.removeAttribute("aria-activedescendant"), virtualListElement == null || virtualListElement.removeAttribute("aria-activedescendant"));
  }, [getChildDescendantId, inputElement, items.length, virtualListElement]), handleGetTopIndex = React.useCallback(() => {
    var _a2, _b;
    const childContainerParentElement = childContainerElement == null ? void 0 : childContainerElement.parentElement;
    if (childContainerElement && childContainerParentElement) {
      const offset = childContainerParentElement.getBoundingClientRect().top - childContainerElement.getBoundingClientRect().top;
      return (_b = (_a2 = virtualizer.getVirtualItemForOffset(offset)) == null ? void 0 : _a2.index) != null ? _b : -1;
    }
    return -1;
  }, [childContainerElement, virtualizer]), setActiveIndex = React.useCallback(
    ({
      index,
      scrollAlign,
      scrollIntoView: scrollIntoView2 = !0
    }) => {
      if (activeIndexRef.current = index, handleUpdateActiveDescendant(), showChildrenActiveState(), scrollIntoView2) {
        const virtualListIndex = itemIndices.findIndex((i) => i.activeIndex === index);
        virtualListIndex > -1 && virtualizer.scrollToIndex(virtualListIndex, scrollAlign ? { align: scrollAlign } : {});
      }
    },
    [handleUpdateActiveDescendant, itemIndices, showChildrenActiveState, virtualizer]
  ), selectAdjacentItemIndex = React.useCallback(
    (direction) => {
      let nextIndex = -1;
      const lastIndex = activeItemCount - 1;
      if (direction === "next") {
        const wrapAroundIndex = wrapAround ? 0 : lastIndex;
        nextIndex = activeIndexRef.current < activeItemCount - 1 ? activeIndexRef.current + 1 : wrapAroundIndex;
      }
      if (direction === "previous") {
        const wrapAroundIndex = wrapAround ? lastIndex : 0;
        nextIndex = activeIndexRef.current > 0 ? activeIndexRef.current - 1 : wrapAroundIndex;
      }
      setActiveIndex({ index: nextIndex, scrollIntoView: !0 }), enableChildContainerPointerEvents(!1);
    },
    [activeItemCount, enableChildContainerPointerEvents, setActiveIndex, wrapAround]
  ), focusElement = React.useCallback(
    (type) => {
      switch (type) {
        case "input":
          inputElement == null || inputElement.focus();
          break;
        case "list":
          virtualListElement == null || virtualListElement.focus();
          break;
      }
    },
    [inputElement, virtualListElement]
  ), focusInputElement = React.useCallback(() => {
    inputElement == null || inputElement.focus();
  }, [inputElement]), focusListElement = React.useCallback(() => {
    virtualListElement == null || virtualListElement.focus();
  }, [virtualListElement]), handleChildMouseEnter = React.useCallback(
    (index) => () => {
      setActiveIndex({ index, scrollIntoView: !1 });
    },
    [setActiveIndex]
  ), handleFocus = React.useCallback(() => {
    showChildrenActiveState();
  }, [showChildrenActiveState]), handleKeyDown = React.useCallback(
    (type) => (event) => {
      const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
      if (childElements.length && (event.key === "ArrowDown" && (event.preventDefault(), focusElement(type), selectAdjacentItemIndex("next")), event.key === "ArrowUp" && (event.preventDefault(), focusElement(type), selectAdjacentItemIndex("previous")), event.key === "Enter")) {
        event.preventDefault(), focusElement(type);
        const currentElement = childElements.find(
          (el) => Number(el.dataset.index) === itemIndices.findIndex((i) => i.activeIndex === activeIndexRef.current)
        );
        if (currentElement) {
          const clickableElement = currentElement == null ? void 0 : currentElement.querySelector(
            LIST_ITEM_INTERACTIVE_SELECTOR
          );
          clickableElement == null || clickableElement.click();
        }
      }
    },
    [childContainerElement == null ? void 0 : childContainerElement.children, focusElement, itemIndices, selectAdjacentItemIndex]
  ), handleKeyDownInput = React.useCallback(
    (event) => handleKeyDown("input")(event),
    [handleKeyDown]
  ), handleKeyDownList = React.useCallback(
    (event) => handleKeyDown("list")(event),
    [handleKeyDown]
  ), handleVirtualListMouseEnter = React.useCallback(() => {
    onlyShowSelectionWhenActive && (showChildrenActiveState(), setHovered(!0));
  }, [onlyShowSelectionWhenActive, showChildrenActiveState]), handleVirtualListMouseLeave = React.useCallback(() => {
    onlyShowSelectionWhenActive && (hideChildrenActiveState(), setHovered(!1));
  }, [hideChildrenActiveState, onlyShowSelectionWhenActive]);
  React.useImperativeHandle(
    ref,
    () => ({
      focusInputElement() {
        focusInputElement();
      },
      focusListElement() {
        focusListElement();
      },
      getTopIndex() {
        return handleGetTopIndex();
      },
      scrollToIndex(index) {
        setActiveIndex({ index }), enableChildContainerPointerEvents(!0);
      }
    }),
    [
      enableChildContainerPointerEvents,
      focusInputElement,
      focusListElement,
      handleGetTopIndex,
      setActiveIndex
    ]
  ), React.useEffect(() => {
    typeof initialIndex < "u" && !isMountedRef.current && setActiveIndex({
      index: initialIndex,
      scrollAlign: initialScrollAlign,
      scrollIntoView: !0
    }), isMountedRef.current = !0;
  }, [initialIndex, initialScrollAlign, onlyShowSelectionWhenActive, setActiveIndex]), React.useEffect(() => {
    function handleMouseEvent() {
      enableChildContainerPointerEvents(!0);
    }
    return virtualListElement == null || virtualListElement.addEventListener("mousemove", handleMouseEvent), virtualListElement == null || virtualListElement.addEventListener("wheel", handleMouseEvent, { passive: !0 }), () => {
      virtualListElement == null || virtualListElement.removeEventListener("mousemove", handleMouseEvent), virtualListElement == null || virtualListElement.removeEventListener("wheel", handleMouseEvent);
    };
  }, [enableChildContainerPointerEvents, virtualListElement]), React.useEffect(() => (inputElement == null || inputElement.addEventListener("focus", handleFocus), inputElement == null || inputElement.addEventListener("keydown", handleKeyDownInput), virtualListElement == null || virtualListElement.addEventListener("focus", handleFocus), virtualListElement == null || virtualListElement.addEventListener("keydown", handleKeyDownList), () => {
    inputElement == null || inputElement.removeEventListener("focus", handleFocus), inputElement == null || inputElement.removeEventListener("keydown", handleKeyDownInput), virtualListElement == null || virtualListElement.removeEventListener("focus", handleFocus), virtualListElement == null || virtualListElement.removeEventListener("keydown", handleKeyDownList);
  }), [
    canReceiveFocus,
    handleFocus,
    handleKeyDown,
    handleKeyDownInput,
    handleKeyDownList,
    hideChildrenActiveState,
    inputElement,
    showChildrenActiveState,
    virtualListElement
  ]), React.useEffect(() => {
    handleUpdateActiveDescendant();
  }, [handleUpdateActiveDescendant, items]), React.useEffect(() => {
    const mutationObserver = new MutationObserver(refreshChildrenActiveStateThrottled);
    return childContainerElement && mutationObserver.observe(childContainerElement, {
      childList: !0,
      subtree: !0
    }), () => {
      mutationObserver.disconnect();
    };
  }, [childContainerElement, refreshChildrenActiveStateThrottled]), React.useEffect(() => {
    inputElement == null || inputElement.setAttribute("aria-autocomplete", "list"), inputElement == null || inputElement.setAttribute("aria-expanded", "true"), inputElement == null || inputElement.setAttribute("aria-controls", getCommandListChildrenId()), inputElement == null || inputElement.setAttribute("role", "combobox");
  }, [getCommandListChildrenId, inputElement]), React.useEffect(() => {
    autoFocus && focusElement(autoFocus);
  }, [autoFocus, canReceiveFocus, focusListElement, focusInputElement, focusElement]);
  const rootTabIndex = canReceiveFocus ? 0 : -1;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    VirtualListBox,
    {
      id: getCommandListChildrenId(),
      onMouseEnter: handleVirtualListMouseEnter,
      onMouseLeave: handleVirtualListMouseLeave,
      ref: setVirtualListElement,
      sizing: "border",
      tabIndex: rootTabIndex,
      ...responsivePaddingProps,
      children: [
        canReceiveFocus && /* @__PURE__ */ jsxRuntime.jsx(FocusOverlayDiv, { offset: focusRingOffset }),
        /* @__PURE__ */ jsxRuntime.jsx(PointerOverlayDiv, { "aria-hidden": "true", "data-enabled": !0, ref: setPointerOverlayElement }),
        virtualizer && /* @__PURE__ */ jsxRuntime.jsx(
          VirtualListChildBox,
          {
            forwardedAs: "ul",
            $height: virtualizer.getTotalSize(),
            "aria-label": ariaLabel,
            "aria-multiselectable": ariaMultiselectable,
            flex: 1,
            ref: setChildContainerElement,
            role: "listbox",
            children: virtualizer.getVirtualItems().map((virtualRow) => {
              const virtualIndex = virtualRow.index, { activeIndex, disabled, selected } = itemIndices[virtualIndex], itemToRender = renderItem(items[virtualIndex], {
                activeIndex,
                disabled,
                selected,
                virtualIndex
              }), clonedItem = React.cloneElement(itemToRender, {
                tabIndex: -1
              }), activeAriaAttributes = typeof activeIndex == "number" && !disabled ? {
                "aria-posinset": activeIndex + 1,
                ...ariaMultiselectable ? { "aria-selected": selected.toString() } : {},
                "aria-setsize": activeItemCount,
                id: getChildDescendantId(activeIndex),
                role: "option",
                onMouseEnter: handleChildMouseEnter(activeIndex)
              } : {};
              return /* @__PURE__ */ jsxRuntime.jsx(
                ui.Stack,
                {
                  as: "li",
                  "data-index": virtualIndex,
                  ref: fixedHeight ? void 0 : virtualizer.measureElement,
                  style: {
                    flex: 1,
                    ...fixedHeight ? { height: `${virtualRow.size}px` } : {},
                    left: 0,
                    position: "absolute",
                    top: 0,
                    transform: `translateY(${virtualRow.start}px)`,
                    width: "100%"
                  },
                  tabIndex: -1,
                  ...activeAriaAttributes,
                  children: clonedItem
                },
                virtualRow.key
              );
            })
          }
        )
      ]
    }
  );
}), ContextMenuButton = React.forwardRef(function(props2, ref) {
  const { mode = "bleed", tooltipProps, tone, ...rest } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ...rest,
      icon: icons.EllipsisHorizontalIcon,
      mode,
      ref,
      tone,
      tooltipProps: {
        ...tooltipProps,
        content: (tooltipProps == null ? void 0 : tooltipProps.content) || t2("common.context-menu-button.tooltip")
      }
    }
  );
});
function getWorkspaceIdentifier({ name, title }, index) {
  return typeof name == "string" && name.trim().length > 0 ? name : getNamelessWorkspaceIdentifier(title, index);
}
function getNamelessWorkspaceIdentifier(title, index) {
  const withTitle = typeof title == "string" && title.trim().length > 0 ? ` (titled "${title}")` : "";
  return `at index ${index}${withTitle}`;
}
const WorkspacesContext = React.createContext(null);
function useWorkspaces() {
  const workspaces = React.useContext(WorkspacesContext);
  if (!workspaces)
    throw new Error("Could not find `workspaces` context");
  return workspaces;
}
class WorkspaceValidationError extends Error {
  constructor(message, options) {
    super(message), this.index = options == null ? void 0 : options.index, this.identifier = (options == null ? void 0 : options.workspace) && getWorkspaceIdentifier(options.workspace, options.index);
  }
}
function validateWorkspaces({ workspaces }) {
  if (workspaces.length === 0)
    throw new WorkspaceValidationError("At least one workspace is required.");
  validateNames(workspaces), validateBasePaths(workspaces);
}
function validateNames(workspaces) {
  const isSingleWorkspace = workspaces.length === 1, names = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const { name: rawName, title } = workspace, thisIdentifier = getNamelessWorkspaceIdentifier(title, index);
    if (!rawName && !isSingleWorkspace)
      throw new WorkspaceValidationError(
        `All workspaces must have a \`name\`, unless only a single workspace is defined. Workspace ${thisIdentifier} did not define a \`name\`.`,
        { workspace, index }
      );
    const name = isSingleWorkspace && typeof rawName > "u" ? "default" : rawName;
    if (typeof name != "string")
      throw new WorkspaceValidationError(
        `Workspace at index ${index} defined an invalid \`name\` - must be a string.`,
        { workspace, index }
      );
    const normalized = name.toLowerCase(), existingWorkspace = names.get(normalized);
    if (existingWorkspace) {
      const prevIdentifier = getNamelessWorkspaceIdentifier(
        existingWorkspace.workspace.title,
        existingWorkspace.index
      );
      throw new WorkspaceValidationError(
        `\`name\`s must be unique. Workspace ${prevIdentifier} and workspace ${thisIdentifier} both have the \`name\` \`${name}\``,
        { workspace, index }
      );
    }
    if (names.set(normalized, { index, workspace }), !/^[a-z0-9][a-z0-9_-]*$/i.test(name))
      throw new WorkspaceValidationError(
        `All workspace \`name\`s must consist of only a-z, 0-9, underscore and dashes, and cannot begin with an underscore or dash. Workspace ${thisIdentifier} has the invalid name \`${name}\``,
        { workspace, index }
      );
  });
}
function validateBasePaths(workspaces) {
  workspaces.length > 1 && workspaces.every(hasBasePath), workspaces.every(validateBasePath);
  const [firstWorkspace, ...restOfWorkspaces] = workspaces, firstWorkspaceSegmentCount = (firstWorkspace.basePath || "/").substring(1).split("/").filter(Boolean).length;
  restOfWorkspaces.forEach((workspace, index) => {
    const workspaceSegmentCount = (workspace.basePath || "/").substring(1).split("/").length;
    if (firstWorkspaceSegmentCount !== workspaceSegmentCount)
      throw new WorkspaceValidationError(
        `All workspace \`basePath\`s must have the same amount of segments. Workspace \`${getWorkspaceIdentifier(
          firstWorkspace,
          index
        )}\` had ${firstWorkspaceSegmentCount} segment${firstWorkspaceSegmentCount === 1 ? "" : "s"} \`${firstWorkspace.basePath}\` but workspace \`${getWorkspaceIdentifier(
          workspace,
          index
        )}\` had ${workspaceSegmentCount} segment${workspaceSegmentCount === 1 ? "" : "s"} \`${workspace.basePath}\``,
        { workspace, index }
      );
  });
  const basePaths = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const basePath = (workspace.basePath || "").toLowerCase(), existingWorkspace = basePaths.get(basePath);
    if (existingWorkspace)
      throw new WorkspaceValidationError(
        `\`basePath\`s must be unique. Workspaces \`${existingWorkspace}\` and \`${getWorkspaceIdentifier(
          workspace,
          index
        )}\` both have the \`basePath\` \`${basePath}\``,
        { workspace, index }
      );
    basePaths.set(basePath, getWorkspaceIdentifier(workspace, index));
  });
}
function hasBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (basePath && typeof basePath == "string")
    return !0;
  throw typeof basePath > "u" ? new WorkspaceValidationError(
    `If more than one workspace is defined, every workspace must have a \`basePath\` defined. Workspace \`${name}\` is missing a \`basePath\``,
    { workspace, index }
  ) : new WorkspaceValidationError(
    `If more than one workspace is defined, every workspace must have a \`basePath\` defined. Workspace \`${name}\` has an invalid \`basePath\` (must be a non-empty string)`,
    { workspace, index }
  );
}
function validateBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (!(!basePath || basePath === "/") && !/^\/[a-z0-9/_-]*[a-z0-9_-]+$/i.test(basePath))
    throw new WorkspaceValidationError(
      `All workspace \`basePath\`s must start with a leading \`/\`, consist of only URL safe characters, and cannot end with a trailing \`/\`. Workspace \`${name}\`'s basePath is \`${basePath}\``,
      { workspace, index }
    );
}
const emptyRender = () => React.createElement(React.Fragment);
function _createMiddlewareComponent(defaultComponent, middlewareComponents) {
  return (outerProps) => {
    let next = (props2) => React.createElement(defaultComponent, props2);
    for (const middleware of middlewareComponents) {
      const renderDefault = next;
      next = (props2) => React.createElement(middleware, { ...props2, renderDefault });
    }
    return next({
      ...outerProps,
      // NOTE: it's safe to pass the empty render function, since it'll be overwritten in the next step (above).
      // NOTE: it's important that the default component does not use `renderDefault`, since it will
      // get the `emptyRender` callback will be passed when the middleware stack is empty.
      renderDefault: emptyRender
    });
  };
}
function useMiddlewareComponents(props2) {
  const { options } = useSource().__internal, { defaultComponent, pick: pick2 } = props2;
  return React.useMemo(() => {
    const flattened = [...flattenConfig(options, [])];
    flattened.reverse();
    const result = flattened.map(({ config }) => pick2(config)).filter(Boolean);
    return _createMiddlewareComponent(defaultComponent, result);
  }, [defaultComponent, options, pick2]);
}
class ConfigPropertyError extends Error {
  constructor({ propertyName, path, cause }) {
    const message = isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) == "string" ? `: ${cause.message}` : "";
    super(
      `An error occurred while resolving \`${propertyName}\` from ${path.join(" > ")}${message}`
    ), this.propertyName = propertyName, this.cause = cause, this.path = path;
  }
}
class ConfigResolutionError extends Error {
  constructor({ causes, name, type }) {
    const messages = causes.filter(Boolean).map(
      (cause) => isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) == "string" ? cause.message : String(cause)
    );
    super(
      `Could not resolve ${type}${name ? ` \`${name}\`` : ""}:
${messages.map((message) => `	- ${message}`).join(`
`)}

`
    ), this.name = name, this.causes = causes, this.type = type;
  }
}
const documentFieldActionsReducer = (prev, { document: document2 }, context) => {
  const documentFieldActions = document2 == null ? void 0 : document2.unstable_fieldActions;
  if (!documentFieldActions)
    return prev;
  if (typeof documentFieldActions == "function")
    return documentFieldActions(prev, context);
  if (Array.isArray(documentFieldActions))
    return [...prev, ...documentFieldActions];
  throw new Error(
    `Expected \`document.unstable_fieldActions\` to be an array or a function, but received ${typeof documentFieldActions}`
  );
}, initialDocumentFieldActions = [], flattenConfig = ({ plugins = [], ...currentConfig }, path) => {
  const rootConfig = { config: currentConfig, path: [...path, currentConfig.name] }, allPlugins = plugins.flatMap(
    (plugin) => flattenConfig(plugin, [...path, currentConfig.name])
  ), tasksPlugin = allPlugins.find((plugin) => plugin.config.name === "sanity/tasks"), resolved = [
    ...allPlugins.filter((plugin) => plugin.config.name !== "sanity/tasks"),
    rootConfig
  ];
  return tasksPlugin && resolved.push(tasksPlugin), resolved;
}, DEBUG_MODE$1 = !1, SPINNER_DELAY = 750, TEXT_DELAY = 2e3, StyledCard$4 = styled__default.default(ui.Card)(({ $fill }) => styled.css`
    align-items: center;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;

    ${$fill ? styled.css`
          bottom: 0;
          height: 100%;
          left: 0;
          position: absolute;
          right: 0;
          top: 0;
          width: 100%;
        ` : styled.css`
          min-height: 75px;
          height: stretch;
          height: -webkit-fill-available;
          width: stretch;
          width: -webkit-fill-available;
        `}

    ${DEBUG_MODE$1}

    > * {
      position: absolute;
    }
  `), StyledSpinner = styled__default.default(ui.Spinner)(({ $animatePosition = !0 }) => styled.css`
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    @keyframes slideUp {
      from {
        transform: translateY(0);
      }
      to {
        transform: translateY(-15px);
      }
    }
    animation: ${$animatePosition ? `500ms ease-out ${SPINNER_DELAY}ms 1 normal both running fadeIn, 750ms ease-out ${TEXT_DELAY}ms 1 normal both running slideUp` : `500ms ease-out ${SPINNER_DELAY}ms 1 normal both running fadeIn`};
  `), StyledText$5 = styled__default.default(ui.Text)`
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  @keyframes slideDown {
    from {
      transform: translateY(0);
    }
    to {
      transform: translateY(15px);
    }
  }
  animation:
    1500ms ease-out ${TEXT_DELAY}ms 1 normal both running fadeIn,
    750ms ease-out ${TEXT_DELAY}ms 1 normal both running slideDown;
`;
function LoadingBlock({ fill, showText, title }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledCard$4, { $fill: fill, as: fill ? ui.Layer : "div", children: [
    /* @__PURE__ */ jsxRuntime.jsx(StyledSpinner, { $animatePosition: !!showText, muted: !0 }),
    showText && /* @__PURE__ */ jsxRuntime.jsx(LoadingText, { title })
  ] });
}
function LoadingText({ title }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(StyledText$5, { muted: !0, size: 1, children: title || t2("common.loading") });
}
function defineLocaleResourceBundle(bundle) {
  return bundle;
}
function defineLocale(locale) {
  return locale;
}
function isStaticResourceBundle(bundle) {
  return !("then" in bundle.resources && typeof bundle.resources.then == "function");
}
function defineLocalesResources(namespace, resources) {
  return resources;
}
function removeUndefinedLocaleResources(resources) {
  const result = {};
  for (const key in resources)
    typeof resources[key] < "u" && (result[key] = resources[key]);
  return result;
}
const studioLocaleNamespace = "studio", validationLocaleNamespace = "validation", studioLocaleStrings = defineLocalesResources("studio", {
  /** Menu item for deleting the asset */
  "asset-source.asset-list.menu.delete": "Delete",
  /** Menu item for showing where a particular asset is used */
  "asset-source.asset-list.menu.show-usage": "Show usage",
  /** Header in usage dialog for file assets */
  "asset-source.asset-usage-dialog.header_file": "Documents using file",
  /** Header in usage dialog for image assets */
  "asset-source.asset-usage-dialog.header_image": "Documents using image",
  /** Text shown in usage dialog when loading documents using the selected asset */
  "asset-source.asset-usage-dialog.loading": "Loading\u2026",
  /** Text for cancel action in delete-asset dialog */
  "asset-source.delete-dialog.action.cancel": "Cancel",
  /** Text for "confirm delete" action in delete-asset dialog */
  "asset-source.delete-dialog.action.delete": "Delete",
  /** Dialog header for delete-asset dialog when deleting a file */
  "asset-source.delete-dialog.header_file": "Delete file",
  /** Dialog header for delete-asset dialog when deleting an image */
  "asset-source.delete-dialog.header_image": "Delete image",
  /** Text shown in delete dialog when loading documents using the selected asset */
  "asset-source.delete-dialog.loading": "Loading\u2026",
  /** Message confirming to delete *named* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_named": "You are about to delete the file <strong>{{filename}}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_unnamed": "You are about to delete the file and its metadata. Are you sure?",
  /** Message confirming to delete *named* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_named": "You are about to delete the image <strong>{{filename}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_unnamed": "You are about to delete the image and its metadata. Are you sure?",
  /** Alt text showing on image preview in delete asset dialog  */
  "asset-source.delete-dialog.usage-list.image-preview-alt": "Preview of image",
  /** Warning message showing when *named* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this file, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_unnamed": "This file cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Warning message showing when *named* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this image, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_unnamed": "This image cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Text shown when the list of assets only include a specific set of types */
  "asset-source.dialog.accept-message": "Only showing assets of accepted types: <strong>{{acceptTypes}}</strong>",
  /** Keys shared between both image asset source and file asset source */
  /** Select asset dialog title for files */
  "asset-source.dialog.default-title_file": "Select file",
  /** Select asset dialog title for images */
  "asset-source.dialog.default-title_image": "Select image",
  /** Select asset dialog load more items */
  "asset-source.dialog.load-more": "Load more",
  /** Text shown when selecting a file but there's no files to select from */
  "asset-source.dialog.no-assets_file": "No files",
  /** Text shown when selecting an image but there's no images to select from */
  "asset-source.dialog.no-assets_image": "No images",
  "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file": "Cannot delete currently selected file",
  "asset-source.file.asset-list.action.delete.text": "Delete",
  "asset-source.file.asset-list.action.delete.title": "Delete file",
  "asset-source.file.asset-list.action.select-file.title": "Select the file {{filename}}",
  "asset-source.file.asset-list.action.show-usage.title": "Show usage",
  "asset-source.file.asset-list.delete-failed": "File could not be deleted",
  "asset-source.file.asset-list.delete-successful": "File was deleted",
  "asset-source.file.asset-list.header.date-added": "Date added",
  /** File asset source */
  "asset-source.file.asset-list.header.filename": "Filename",
  "asset-source.file.asset-list.header.size": "Size",
  "asset-source.file.asset-list.header.type": "Type",
  /** Text displayed on button or menu invoking the file asset source */
  "asset-source.file.title": "Uploaded files",
  "asset-source.image.asset-list.delete-failed": "Image could not be deleted",
  /** Image asset source */
  "asset-source.image.asset-list.delete-successful": "Image was deleted",
  /** Text displayed on button or menu invoking the image asset source */
  "asset-source.image.title": "Uploaded images",
  "asset-source.usage-list.documents-using-file_named_one": "One document is using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_named_other": "{{count}} documents are using file <code>{{filename}}</code>",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *named* file **/
  "asset-source.usage-list.documents-using-file_named_zero": "No documents are using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_unnamed_one": "One document is using this file",
  "asset-source.usage-list.documents-using-file_unnamed_other": "{{count}} documents are using this file",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *unnamed* file **/
  "asset-source.usage-list.documents-using-file_unnamed_zero": "No documents are using this file",
  "asset-source.usage-list.documents-using-image_named_one": "One document is using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_named_other": "{{count}} documents are using image <code>{{filename}}</code>",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *named* image **/
  "asset-source.usage-list.documents-using-image_named_zero": "No documents are using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_unnamed_one": "One document is using this image",
  "asset-source.usage-list.documents-using-image_unnamed_other": "{{count}} documents are using this image",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *unnamed* image **/
  "asset-source.usage-list.documents-using-image_unnamed_zero": "No documents are using this image",
  /** Action message for navigating to next month */
  "calendar.action.go-to-next-month": "Go to next month",
  /** Action message for navigating to next year */
  "calendar.action.go-to-next-year": "Go to next year",
  /** Action message for navigating to previous month */
  "calendar.action.go-to-previous-month": "Go to previous month",
  /** Action message for navigating to previous year */
  "calendar.action.go-to-previous-year": "Go to previous year",
  /* Label for navigating the calendar to "today", without _selecting_ today. Short form, eg `Today`, not `Go to today` */
  "calendar.action.go-to-today": "Today",
  /* Accessibility label for navigating the calendar to "today", without _selecting_ today */
  "calendar.action.go-to-today-aria-label": "Go to today",
  /* Label for navigating the calendar to "tomorrow", without _selecting_ tomorrow. Short form, eg `Tomorrow`, not `Go to tomorrow` */
  "calendar.action.go-to-tomorrow": "Tomorrow",
  /* Label for navigating the calendar to "yesterday", without _selecting_ yesterday. Short form, eg `Yesterday`, not `Go to yesterday` */
  "calendar.action.go-to-yesterday": "Yesterday",
  /** Label for switch that controls whether or not to include time in given timestamp */
  "calendar.action.include-time-label": "Include time",
  /** Action message for selecting the hour */
  "calendar.action.select-hour": "Select hour",
  /** Action message for selecting the minute */
  "calendar.action.select-minute": "Select minute",
  /** Action message for setting to the current time */
  "calendar.action.set-to-current-time": "Set to current time",
  /** Label for selecting an hour preset. Receives a `time` param as a string on hh:mm format and a `date` param as a Date instance denoting the preset date */
  "calendar.action.set-to-time-preset": "{{time}} on {{date, datetime}}",
  /** Error message displayed in calendar when entered date is not the correct format */
  "calendar.error.must-be-in-format": "Must be in the format: {{exampleDate}}",
  /** Month name for April */
  "calendar.month-names.april": "April",
  /** Month name for August */
  "calendar.month-names.august": "August",
  /** Month name for December */
  "calendar.month-names.december": "December",
  /** Month name for February */
  "calendar.month-names.february": "February",
  /** Month name for January */
  "calendar.month-names.january": "January",
  /** Month name for July */
  "calendar.month-names.july": "July",
  /** Month name for June */
  "calendar.month-names.june": "June",
  /** Month name for March */
  "calendar.month-names.march": "March",
  /** Month name for May */
  "calendar.month-names.may": "May",
  /** Month name for November */
  "calendar.month-names.november": "November",
  /** Month name for October */
  "calendar.month-names.october": "October",
  /** Month name for September */
  "calendar.month-names.september": "September",
  /** Short weekday name for Friday */
  "calendar.weekday-names.short.friday": "Fri",
  /** Short weekday name for Monday */
  "calendar.weekday-names.short.monday": "Mon",
  /** Short weekday name for Saturdayday */
  "calendar.weekday-names.short.saturday": "Sat",
  /** Short weekday name for Sunday */
  "calendar.weekday-names.short.sunday": "Sun",
  /** Short weekday name for Thursday */
  "calendar.weekday-names.short.thursday": "Thu",
  /** Short weekday name for Tuesday */
  "calendar.weekday-names.short.tuesday": "Tue",
  /** Short weekday name for Wednesday */
  "calendar.weekday-names.short.wednesday": "Wed",
  /** Label for the close button label in Review Changes pane */
  "changes.action.close-label": "Close review changes",
  /** Cancel label for revert button prompt action */
  "changes.action.revert-all-cancel": "Cancel",
  /** Revert all confirm label for revert button action - used on prompt button + review changes pane */
  "changes.action.revert-all-confirm": "Revert all",
  /** Prompt for reverting all changes in document in Review Changes pane. Includes a count of changes. */
  "changes.action.revert-all-description": "Are you sure you want to revert all {{count}} changes?",
  /** Prompt for confirming revert change (singular) label for field change action */
  "changes.action.revert-changes-confirm-change_one": "Revert change",
  /** Revert for confirming revert (plural) label for field change action */
  "changes.action.revert-changes-confirm-change_other": "Revert changes",
  /** Prompt for reverting changes for a field change */
  "changes.action.revert-changes-description": "Are you sure you want to revert the changes?",
  /** Prompt for reverting changes for a group change, eg multiple changes */
  "changes.action.revert-changes-description_one": "Are you sure you want to revert the change?",
  /** Label for when the action of the change was to set something that was previously empty, eg a field was given a value, an array item was added, an asset was selected or similar */
  "changes.added-label": "Added",
  /** Array diff: An item was added in a given position (`{{position}}`) */
  "changes.array.item-added-in-position": "Added in position {{position}}",
  "changes.array.item-moved_down_one": "Moved {{count}} position down",
  "changes.array.item-moved_down_other": "Moved {{count}} positions down",
  /**
   * Array diff: An item was moved within the array.
   * Receives `{{count}}` representing number of positions it moved.
   * Context is the direction of the move, either `up` or `down`.
   */
  "changes.array.item-moved_up_one": "Moved {{count}} position up",
  "changes.array.item-moved_up_other": "Moved {{count}} positions up",
  /** Array diff: An item was removed from a given position (`{{position}}`) */
  "changes.array.item-removed-from-position": "Removed from position {{position}}",
  /** Accessibility label for the "change bar" shown when there are edits on a field-level */
  "changes.change-bar.aria-label": "Review changes",
  /** Label for when the action of the change was _not_ an add/remove, eg a text field changed value, an image was changed from one asset to another or similar */
  "changes.changed-label": "Changed",
  /** Label and text for tooltip that indicates the authors of the changes */
  "changes.changes-by-author": "Changes by",
  /** Additional text shown in development mode when a diff component crashes during rendering */
  "changes.error-boundary.developer-info": "Check the developer console for more information",
  /** Text shown when a diff component crashes during rendering, triggering the error boundary */
  "changes.error-boundary.title": "Rendering the changes to this field caused an error",
  /** Error message shown when the value of a field is not the expected one */
  "changes.error.incorrect-type-message": 'Value error: Value is of type "<code>{{actualType}}</code>", expected "<code>{{expectedType}}</code>"',
  /** File diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.file.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.crop-changed": "Crop changed",
  /** Image diff: Text shown if the previous image asset was deleted (shouldn't theoretically happen) */
  "changes.image.deleted": "Image deleted",
  /** Image diff: Text shown if the image failed to be loaded when previewing it */
  "changes.image.error-loading-image": "Error loading image",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.hotspot-changed": "Hotspot changed",
  /** Image diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.image.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown if no asset has been set for the field (but has metadata changes) */
  "changes.image.no-asset-set": "Image not set",
  /** Image diff: Text shown when the from/to state has/had no image */
  "changes.image.no-image-placeholder": "(no image)",
  /** Label for the "from" value in the change inspector */
  "changes.inspector.from-label": "From",
  /** Label for the "meta" (field path, action etc) information in the change inspector */
  "changes.inspector.meta-label": "Meta",
  /** Label for the "to" value in the change inspector */
  "changes.inspector.to-label": "To",
  /** Loading author of change in the differences tooltip in the review changes pane */
  "changes.loading-author": "Loading\u2026",
  /** Loading changes in Review Changes Pane */
  "changes.loading-changes": "Loading changes\u2026",
  /** No Changes description in the Review Changes pane */
  "changes.no-changes-description": "Edit the document or select an older version in the timeline to see a list of changes appear in this panel.",
  /** No Changes title in the Review Changes pane */
  "changes.no-changes-title": "There are no changes",
  /** Portable Text diff: An annotation was added */
  "changes.portable-text.annotation_added": "Added annotation",
  /** Portable Text diff: An annotation was changed */
  "changes.portable-text.annotation_changed": "Changed annotation",
  /** Portable Text diff: An annotation was removed */
  "changes.portable-text.annotation_removed": "Removed annotation",
  /** Portable Text diff: An annotation was left unchanged */
  "changes.portable-text.annotation_unchanged": "Unchanged annotation",
  /** Portable Text diff: A block changed from one style to another (eg `normal` to `h1` or similar) */
  "changes.portable-text.block-style-changed": 'Changed block style from "{{fromStyle}}" to "{{toStyle}}"',
  /** Portable Text diff: Change formatting of text (setting/unsetting marks, eg bold/italic etc) */
  "changes.portable-text.changed-formatting": "Changed formatting",
  /** Portable Text diff: An empty inline object is part of a change */
  "changes.portable-text.empty-inline-object": "Empty {{inlineObjectType}}",
  /** Portable Text diff: An empty object is the result of adding/removing an annotation */
  "changes.portable-text.empty-object-annotation": "Empty {{annotationType}}",
  /** Portable Text diff: Added a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_added": "Added empty text",
  /** Portable Text diff: Changed a block that contained no text (eg empty block) */
  "changes.portable-text.empty-text_changed": "Changed empty text",
  /** Portable Text diff: Removed a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_removed": "Removed empty text",
  /** Portable Text diff: An inline object was added */
  "changes.portable-text.inline-object_added": "Added inline object",
  /** Portable Text diff: An inline object was changed */
  "changes.portable-text.inline-object_changed": "Changed inline object",
  /** Portable Text diff: An inline object was removed */
  "changes.portable-text.inline-object_removed": "Removed inline object",
  /** Portable Text diff: An inline object was left unchanged */
  "changes.portable-text.inline-object_unchanged": "Unchanged inline object",
  /** Portable Text diff: Added a chunk of text */
  "changes.portable-text.text_added": "Added text",
  /** Portable Text diff: Removed a chunk of text */
  "changes.portable-text.text_removed": "Removed text",
  /** Portable Text diff: Annotation has an unknown schema type */
  "changes.portable-text.unknown-annotation-schema-type": "Unknown schema type",
  /** Portable Text diff: Inline object has an unknown schema type */
  "changes.portable-text.unknown-inline-object-schema-type": "Unknown schema type",
  /** Label for when the action of the change was a removal, eg a field was cleared, an array item was removed, an asset was deselected or similar */
  "changes.removed-label": "Removed",
  /** Title for the Review Changes pane */
  "changes.title": "Review changes",
  /** --- Common components --- */
  /** Tooltip text for context menu buttons */
  "common.context-menu-button.tooltip": "Show more",
  /** Default text for dialog cancel button */
  "common.dialog.cancel-button.text": "Cancel",
  /** Default text for dialog confirm button */
  "common.dialog.confirm-button.text": "Confirm",
  /** Default text in shared loader text / spinner lockup */
  "common.loading": "Loading",
  /** --- Configuration issues --- */
  /** Tooltip displayed on configuration issues button */
  "configuration-issues.button.tooltip": "Found configuration issues",
  /** The fallback title for an ordering menu item if no localized titles are provided. */
  "default-menu-item.fallback-title": "Sort by {{title}}",
  /** Title for the default ordering/SortOrder if no orderings are provided and the caption field is found */
  "default-orderings.caption": "Sort by Caption",
  /** Title for the default ordering/SortOrder if no orderings are provided and the description field is found */
  "default-orderings.description": "Sort by Description",
  /** Title for the default ordering/SortOrder if no orderings are provided and the header field is found */
  "default-orderings.header": "Sort by Header",
  /** Title for the default ordering/SortOrder if no orderings are provided and the heading field is found */
  "default-orderings.heading": "Sort by Heading",
  /** Title for the default ordering/SortOrder if no orderings are provided and the label field is found */
  "default-orderings.label": "Sort by Label",
  /** Title for the default ordering/SortOrder if no orderings are provided and the name field is found */
  "default-orderings.name": "Sort by Name",
  /** Title for the default ordering/SortOrder if no orderings are provided and the title field is found */
  "default-orderings.title": "Sort by Title",
  /** Label to show in the document footer indicating the last edited date of the document */
  "document-status.edited": "Edited {{date}}",
  /** Label to show in the document footer indicating the document is not published*/
  "document-status.not-published": "Not published",
  /** Label to show in the document footer indicating the published date of the document */
  "document-status.published": "Published {{date}}",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.duplicate-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely. */
  "form.error.duplicate-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely.",
  /** Developer info */
  "form.error.duplicate-keys-alert.details.title": "Developer info",
  /** Generate unique keys */
  "form.error.duplicate-keys-alert.generate-button.text": "Generate unique keys",
  /** Several items in this list share the same identifier (key). Every item must have an unique identifier. */
  "form.error.duplicate-keys-alert.summary": "Several items in this list share the same identifier (key). Every item must have an unique identifier.",
  /** Non-unique keys */
  "form.error.duplicate-keys-alert.title": "Non-unique keys",
  /** Error text shown when a field with a given name cannot be found in the schema or is conditionally hidden but explicitly told to render  */
  "form.error.field-not-found": 'Field "{{fieldName}}" not found among members \u2013 verify that it is defined in the schema and that it has not been conditionally hidden.',
  /** Add missing keys */
  "form.error.missing-keys-alert.add-button.text": "Add missing keys",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.missing-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property has not been included. */
  "form.error.missing-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property has not been included.",
  /** Developer info */
  "form.error.missing-keys-alert.details.title": "Developer info",
  /** Some items in the list are missing their keys. This must be fixed in order to edit the list. */
  "form.error.missing-keys-alert.summary": "Some items in the list are missing their keys. This must be fixed in order to edit the list.",
  /** Missing keys */
  "form.error.missing-keys-alert.title": "Missing keys",
  /** This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list. */
  "form.error.mixed-array-alert.details.description": "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list.",
  /** Developer info */
  "form.error.mixed-array-alert.details.title": "Developer info",
  /**  Remove non-object values */
  "form.error.mixed-array-alert.remove-button.text": "Remove non-object values",
  /** Some items in this list are not objects. This must be fixed in order to edit the list. */
  "form.error.mixed-array-alert.summary": "Some items in this list are not objects. This must be fixed in order to edit the list.",
  /** Invalid list values */
  "form.error.mixed-array-alert.title": "Invalid list values",
  /** Error text shown when form is unable to find an array item at a given indexed path */
  "form.error.no-array-item-at-index": "No array item at index <code>{{index}}</code> found at path <code>{{path}}</code>",
  /** Error text shown when form is unable to find an array item at a given keyed path */
  "form.error.no-array-item-at-key": 'No array item with `_key` <code>"{{key}}"</code> found at path <code>{{path}}</code>',
  /** Form field deprecated label */
  "form.field.deprecated-label": "deprecated",
  /** Fallback title shown above field if it has no defined title */
  "form.field.untitled-field-label": "Untitled",
  /** Fallback title shown above fieldset if it has no defined title */
  "form.field.untitled-fieldset-label": "Untitled",
  /** Accessibility label for the icon that indicates the field has a validation error */
  "form.validation.has-error-aria-label": "Has error",
  /** Accessibility label for the icon that indicates the field has validation information */
  "form.validation.has-info-aria-label": "Has information",
  /** Accessibility label for the icon that indicates the field has a validation warning */
  "form.validation.has-warning-aria-label": "Has warning",
  /** Text shown when summarizing validation information, when the field has one or more errors */
  "form.validation.summary.errors-count_one": "{{count}} error",
  "form.validation.summary.errors-count_other": "{{count}} errors",
  /** Text shown when summarizing validation information, when the field has one or more warnings */
  "form.validation.summary.warnings-count_one": "{{count}} warning",
  "form.validation.summary.warnings-count_other": "{{count}} warnings",
  /** Tooltip for free trial navbar button indicating remaining days */
  "free-trial.tooltip.days-count_one": "{{count}} day left in trial",
  "free-trial.tooltip.days-count_other": "{{count}} days left in trial",
  /** Tooltip for free trial navbar button, once trial has ended */
  "free-trial.tooltip.trial-finished": "Upgrade your project",
  /**
   * Label for "contact sales" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.contact-sales": "Contact sales",
  /**
   * Label for "help and support" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.help-and-support": "Help and support",
  /**
   * Label for "join our community" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.join-our-community": "Join our community",
  /** Information for what the latest sanity version is */
  "help-resources.latest-sanity-version": "Latest version is {{latestVersion}}",
  /** Information for what studio version the current studio is running */
  "help-resources.studio-version": "Sanity Studio version {{studioVersion}}",
  /** Title for help and resources menus */
  "help-resources.title": "Help and resources",
  /** Text for button to cancel an ongoing upload */
  "input.files.common.cancel-upload": "Cancel",
  /** Text for file input button in upload placeholder */
  "input.files.common.upload-placeholder.file-input-button.text": "Upload",
  /** Uploading <FileName/> */
  "input.files.common.upload-progress": "Uploading <FileName/>",
  /** The referenced document cannot be opened, because the URL failed to be resolved */
  "input.reference.document-cannot-be-opened.failed-to-resolve-url": "This document cannot be opened (unable to resolve URL to Studio)",
  /** Label for adding item after a specific array item */
  "inputs.array.action.add-after": "Add item after",
  /** Label for adding item before a specific array item */
  "inputs.array.action.add-before": "Add item before",
  /** Label for adding array item action when the schema allows for only one schema type */
  "inputs.array.action.add-item": "Add item",
  /**
   * Label for adding one array item action when the schema allows for multiple schema types,
   * eg. will prompt the user to select a type once triggered
   */
  "inputs.array.action.add-item-select-type": "Add item...",
  /** Array drag handle button tooltip */
  "inputs.array.action.drag.tooltip": "Drag to re-order",
  /** Label for duplicating an array item  */
  "inputs.array.action.duplicate": "Duplicate",
  /** Label for editing the item of a specific type, eg "Edit Person" */
  "inputs.array.action.edit": "Edit {{itemTypeTitle}}",
  /** Label for removing an array item action  */
  "inputs.array.action.remove": "Remove",
  /** Label for removing action when an array item has an error  */
  "inputs.array.action.remove-invalid-item": "Remove",
  /** Label for viewing the item of a specific type, eg "View Person" */
  "inputs.array.action.view": "View {{itemTypeTitle}}",
  /** Error description for the array item tooltip that explains that the current item can still be moved or deleted but not edited since the schema definition is not found */
  "inputs.array.error.can-delete-but-no-edit-description": "You can still move or delete this item, but it cannot be edited since the schema definition for its type is nowhere to be found.",
  /** Error label for toast when array could not resolve the initial value */
  "inputs.array.error.cannot-resolve-initial-value-title": "Unable to resolve initial value for type: {{schemaTypeTitle}}: {{errorMessage}}.",
  /** Error label for toast when trying to upload one array item of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_one": "The following item can't be uploaded because there's no known conversion from content type to array item:",
  /** Error label for toast when trying to upload multiple array items of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_other": "The following items can't be uploaded because there's no known conversion from content types to array item:",
  /** Error description for the array item tooltip that explains that the current type item is not valid for the list  */
  "inputs.array.error.current-schema-not-declare-description": "The current schema does not declare items of type <code>{{typeName}}</code> as valid for this list. This could mean that the type has been removed as a valid item type, or that someone else has added it to their own local schema that is not yet deployed.",
  /** Error description to show how the item is being represented in the json format */
  "inputs.array.error.json-representation-description": "JSON representation of this item:",
  /** Error description for the array item tooltip that explains what the error means with more context */
  "inputs.array.error.type-is-incompatible-prompt": "Item of type <code>{{typeName}}</code> not valid for this list",
  /** Error title for when an item type within an array input is incompatible, used in the tooltip */
  "inputs.array.error.type-is-incompatible-title": "Why is this happening?",
  /** Error label for unexpected errors in the Array Input */
  "inputs.array.error.unexpected-error": "Unexpected Error: {{error}}",
  /** Label for when the array input doesn't have any items */
  "inputs.array.no-items-label": "No items",
  /** Label for read only array fields */
  "inputs.array.read-only-label": "This field is read-only",
  /** Label for when the array input is resolving the initial value for the item */
  "inputs.array.resolving-initial-value": "Resolving initial value\u2026",
  /** Placeholder value for datetime input */
  "inputs.datetime.placeholder": "e.g. {{example}}",
  /** Acessibility label for button to open file options menu */
  "inputs.file.actions-menu.file-options.aria-label": "Open file options menu",
  /** Browse */
  "inputs.file.browse-button.text": "Browse",
  /** Select file */
  "inputs.file.dialog.title": "Select file",
  /** Unknown member kind: `{{kind}}` */
  "inputs.file.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** The value of this field is not a valid file. Resetting this field will let you choose a new file. */
  "inputs.file.invalid-file-warning.description": "The value of this field is not a valid file. Resetting this field will let you choose a new file.",
  /** Reset value */
  "inputs.file.invalid-file-warning.reset-button.text": "Reset value",
  /** Invalid file value */
  "inputs.file.invalid-file-warning.title": "Invalid file value",
  /** Select */
  "inputs.file.multi-browse-button.text": "Select",
  /** The upload could not be completed at this time. */
  "inputs.file.upload-failed.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.file.upload-failed.title": "Upload failed",
  /** Clear field */
  "inputs.files.common.actions-menu.clear-field.label": "Clear field",
  /** Copy URL */
  "inputs.files.common.actions-menu.copy-url.label": "Copy URL",
  /** Download */
  "inputs.files.common.actions-menu.download.label": "Download",
  /** The URL is copied to the clipboard */
  "inputs.files.common.actions-menu.notification.url-copied": "The URL is copied to the clipboard",
  /** Replace */
  "inputs.files.common.actions-menu.replace.label": "Replace",
  /** Upload */
  "inputs.files.common.actions-menu.upload.label": "Upload",
  /** Drop to upload */
  "inputs.files.common.drop-message.drop-to-upload": "Drop to upload",
  /** Drop to upload `{{count}}` file */
  "inputs.files.common.drop-message.drop-to-upload-multi_one": "Drop to upload {{count}} file",
  /** Drop to upload `{{count}}` files */
  "inputs.files.common.drop-message.drop-to-upload-multi_other": "Drop to upload {{count}} files",
  /** Can't upload this file here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_one": "Can't upload this file here",
  /** Can't upload any of these files here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_other": "Can't upload any of these files here",
  /** `{{count}}` file can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_one": "{{count}} file can't be uploaded here",
  /** `{{count}}` files can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_other": "{{count}} files can't be uploaded here",
  /** Cannot upload `{{count}}` files */
  "inputs.files.common.placeholder.cannot-upload-some-files_one": "Cannot upload file",
  "inputs.files.common.placeholder.cannot-upload-some-files_other": "Cannot upload {{count}} files",
  /** Drag or paste type here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_file": "Drag or paste file here",
  /** Drag or paste image here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_image": "Drag or paste image here",
  /** Drop to upload file */
  "inputs.files.common.placeholder.drop-to-upload_file": "Drop to upload file",
  /** Drop to upload image */
  "inputs.files.common.placeholder.drop-to-upload_image": "Drop to upload image",
  /** Read only */
  "inputs.files.common.placeholder.read-only": "Read only",
  /** Can't upload files here */
  "inputs.files.common.placeholder.upload-not-supported": "Can't upload files here",
  /** Clear upload */
  "inputs.files.common.stale-upload-warning.clear": "Clear upload",
  /** An upload has made no progress for at least `{{staleThresholdMinutes}}` minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again. */
  "inputs.files.common.stale-upload-warning.description": "An upload has made no progress for at least {{staleThresholdMinutes}} minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again.",
  /** Incomplete upload */
  "inputs.files.common.stale-upload-warning.title": "Incomplete upload",
  /** Tooltip text for action to crop image */
  "inputs.image.actions-menu.crop-image-tooltip": "Crop image",
  /** Accessibility label for button to open image edit dialog */
  "inputs.image.actions-menu.edit-details.aria-label": "Open image edit dialog",
  /** Accessibility label for button to open image options menu */
  "inputs.image.actions-menu.options.aria-label": "Open image options menu",
  /** Select */
  "inputs.image.browse-menu.text": "Select",
  /** Cannot upload this file here */
  "inputs.image.drag-overlay.cannot-upload-here": "Cannot upload this file here",
  /** Drop image to upload */
  "inputs.image.drag-overlay.drop-to-upload-image": "Drop image to upload",
  /** This field is read only */
  "inputs.image.drag-overlay.this-field-is-read-only": "This field is read only",
  /** Unknown member kind: `{{kind}}` */
  "inputs.image.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** Edit hotspot and crop */
  "inputs.image.hotspot-dialog.title": "Edit hotspot and crop",
  /** The value of this field is not a valid image. Resetting this field will let you choose a new image. */
  "inputs.image.invalid-image-warning.description": "The value of this field is not a valid image. Resetting this field will let you choose a new image.",
  /** Reset value */
  "inputs.image.invalid-image-warning.reset-button.text": "Reset value",
  /** Invalid image value */
  "inputs.image.invalid-image-warning.title": "Invalid image value",
  /** Preview of uploaded image */
  "inputs.image.preview-uploaded-image": "Preview of uploaded image",
  /** The upload could not be completed at this time. */
  "inputs.image.upload-error.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.image.upload-error.title": "Upload failed",
  /** Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible. */
  "inputs.imagetool.description": "Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible.",
  /** Error: `{{errorMessage}}` */
  "inputs.imagetool.load-error": "Error: {{errorMessage}}",
  /** Hotspot & Crop */
  "inputs.imagetool.title": "Hotspot & Crop",
  /** Convert to `{{targetType}}` */
  "inputs.invalid-value.convert-button.text": "Convert to {{targetType}}",
  /** The current value (<code>`{{actualType}}`</code>) */
  "inputs.invalid-value.current-type": "The current value (<code>{{actualType}}</code>)",
  /** The property value is stored as a value type that does not match the expected type. */
  "inputs.invalid-value.description": "The property value is stored as a value type that does not match the expected type.",
  /** The value of this property must be of type <code>`{{validType}}`</code> according to the schema. */
  "inputs.invalid-value.details.description": "The value of this property must be of type <code>{{validType}}</code> according to the schema.",
  /** Only the following types are valid here according to schema: */
  "inputs.invalid-value.details.multi-type-description": "Only the following types are valid here according to schema:",
  /** Mismatching value types typically occur when the schema has recently been changed. */
  "inputs.invalid-value.details.possible-reason": "Mismatching value types typically occur when the schema has recently been changed.",
  /** Developer info */
  "inputs.invalid-value.details.title": "Developer info",
  /** -- Invalid Value Input -- */
  /** Reset value */
  "inputs.invalid-value.reset-button.text": "Reset value",
  /** Invalid property value */
  "inputs.invalid-value.title": "Invalid property value",
  /** Field groups */
  "inputs.object.field-group-tabs.aria-label": "Field groups",
  /** Read-only field description */
  "inputs.object.unknown-fields.read-only.description": "This field is <strong>read only</strong> according to the document\u2019s schema and cannot be unset. If you want to be able to unset this in Studio, make sure you remove the <code>readOnly</code> field from the enclosing type in the schema.",
  /** Remove field */
  "inputs.object.unknown-fields.remove-field-button.text": "Remove field",
  /** Encountered `{{count}}` fields that are not defined in the schema. */
  "inputs.object.unknown-fields.warning.description_one": "Encountered a field that is not defined in the schema.",
  "inputs.object.unknown-fields.warning.description_other": "Encountered {{count}} fields that are not defined in the schema.",
  /** Detailed description of unknown field warning */
  "inputs.object.unknown-fields.warning.details.description_one": "This field is not defined in the schema, which could mean that the field definition has been removed or that someone else has added it to their own local project and have not deployed their changes yet.",
  "inputs.object.unknown-fields.warning.details.description_other": "These fields are not defined in the document\u2019s schema, which could mean that the field definitions have been removed or that someone else has added them to their own local project and have not deployed their changes yet.",
  /** Developer info */
  "inputs.object.unknown-fields.warning.details.title": "Developer info",
  /** Unknown field found */
  "inputs.object.unknown-fields.warning.title_one": "Unknown field found",
  "inputs.object.unknown-fields.warning.title_other": "Unknown fields found",
  /** Collapse the editor to save screen space  */
  "inputs.portable-text.action.collapse-editor": "Collapse editor",
  /** Aria label for action to edit an existing annotation */
  "inputs.portable-text.action.edit-annotation-aria-label": "Edit annotation",
  /** Expand the editor to give more editing space */
  "inputs.portable-text.action.expand-editor": "Expand editor",
  /** Label label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block": "Insert {{typeName}}",
  /** Accessibility label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block-aria-label": "Insert {{typeName}} (block)",
  /** Label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object": "Insert {{typeName}}",
  /** Accessibility label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object-aria-label": "Insert {{typeName}} (inline)",
  /** Aria label for action to remove an annotation */
  "inputs.portable-text.action.remove-annotation-aria-label": "Remove annotation",
  /** Label for activate on focus with context of click and not focused */
  "inputs.portable-text.activate-on-focus-message_click": "Click to activate",
  /** Label for activate on focus with context of click and focused */
  "inputs.portable-text.activate-on-focus-message_click-focused": "Click or press space to activate",
  /** Label for activate on focus with context of tap and not focused */
  "inputs.portable-text.activate-on-focus-message_tap": "Tap to activate",
  /**Aria label for the annotation object */
  "inputs.portable-text.annotation-aria-label": "Annotation object",
  /** Title for dialog that allows editing an annotation */
  "inputs.portable-text.annotation-editor.title": "Edit {{schemaType}}",
  /** Title of the default "link" annotation */
  "inputs.portable-text.annotation.link": "Link",
  /**Aria label for the block object */
  "inputs.portable-text.block.aria-label": "Block object",
  /** Label for action to edit a block item, in the case where it is editable */
  "inputs.portable-text.block.edit": "Edit",
  /** Accessibility label for the button that opens the actions menu on blocks */
  "inputs.portable-text.block.open-menu-aria-label": "Open menu",
  /** Label for action to open a reference, in the case of block-level reference types */
  "inputs.portable-text.block.open-reference": "Open reference",
  /** Label for action to remove a block item */
  "inputs.portable-text.block.remove": "Remove",
  /** Label for action to view a block item, in the case where it is read-only and thus cannot be edited */
  "inputs.portable-text.block.view": "View",
  /** Title of the "code" decorator */
  "inputs.portable-text.decorator.code": "Code",
  /** Title of the "em" (emphasis) decorator */
  "inputs.portable-text.decorator.emphasis": "Italic",
  /** Title of the "strike-through" decorator */
  "inputs.portable-text.decorator.strike-through": "Strike",
  /** Title of the "strong" decorator */
  "inputs.portable-text.decorator.strong": "Strong",
  /** Title of the "underline" decorator */
  "inputs.portable-text.decorator.underline": "Underline",
  /** Placeholder text for when the editor is empty */
  "inputs.portable-text.empty-placeholder": "Empty",
  /**Aria label for the block object */
  "inputs.portable-text.inline-block.aria-label": "Inline object",
  /** Label for action to edit an inline object item */
  "inputs.portable-text.inline-object.edit": "Edit object",
  /** Aria label for icon for action to edit an inline object item */
  "inputs.portable-text.inline-object.edit-aria-label": "Edit object",
  /** Label for action to remove an inline object item */
  "inputs.portable-text.inline-object.remove": "Remove object",
  /** Aria label for icon for action to remove an inline object item */
  "inputs.portable-text.inline-object.remove-aria-label": "Remove object",
  /** Disclaimer text shown on invalid Portable Text value, when an action is available to unblock the user, but it is not guaranteed to be safe */
  "inputs.portable-text.invalid-value.action-disclaimer": "NOTE: It\u2019s generally safe to perform the action above, but if you are in doubt, get in touch with those responsible for configuring your studio.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is of type <code>{{childType}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.description": "Block with key <code>{{key}}</code> is of type <code>{{typeName}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.action": "Insert empty text span",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.description": "Text block with key <code>{{key}}</code> has no text spans.",
  /** Label for the button to ignore invalid values in the Portable Text editor */
  "inputs.portable-text.invalid-value.ignore-button.text": "Ignore",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.description": "Block with key <code>{{key}}</code> has an invalid type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.action": "Set empty text value",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.description": "Span with key {{childKey}} of block with key <code>{{key}}</code> has a missing or invalid <code>text</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.description": "Block with key <code>{{key}}</code> is missing a type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is missing <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is missing <code>_type</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.description": "Block at index <code>{{index}}</code> is missing required <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.description": "Text block with key <code>{{key}}</code> has an invalid or missing `children` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action": "Add property",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description": "Text block with key <code>{{key}}</code> has an invalid or missing `markDefs` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.description": "Block with key <code>{{key}}</code> is missing a type name.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.action": "Remove the item",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is not an object.",
  /** Action presented when the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.action": "Unset the value",
  /** Text explaining that the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.description": "Value must be an array of Portable Text blocks, or undefined.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.action": "Remove item",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.description": "Item at <code>{{index}}</code> is not an object,.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.action": "Remove disallowed marks",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.description": "Text block with key <code>{{key}}</code> contains marks <code>({{orphanedMarks, list}})</code> that are not allowed by the schema.",
  /** Title for the alert indicating that the Portable Text field has an invalid value */
  "inputs.portable-text.invalid-value.title": "Invalid Portable Text value",
  /** Title of "bulleted" list type */
  "inputs.portable-text.list-type.bullet": "Bulleted list",
  /** Title of numbered list type */
  "inputs.portable-text.list-type.number": "Numbered list",
  /** Title of the "h1" block style */
  "inputs.portable-text.style.h1": "Heading 1",
  /** Title of the "h2" block style */
  "inputs.portable-text.style.h2": "Heading 2",
  /** Title of the "h3" block style */
  "inputs.portable-text.style.h3": "Heading 3",
  /** Title of the "h4" block style */
  "inputs.portable-text.style.h4": "Heading 4",
  /** Title of the "h5" block style */
  "inputs.portable-text.style.h5": "Heading 5",
  /** Title of the "h6" block style */
  "inputs.portable-text.style.h6": "Heading 6",
  /** Title shown when multiple blocks of varying styles is selected */
  "inputs.portable-text.style.multiple": "Multiple",
  /** Title of fallback when no style is given for a block */
  "inputs.portable-text.style.none": "No style",
  /** Title of the "normal" block style */
  "inputs.portable-text.style.normal": "Normal",
  /** Title of the "quote" block style */
  "inputs.portable-text.style.quote": "Quote",
  /** Label for action to clear the current value of the reference field */
  "inputs.reference.action.clear": "Clear",
  /** Label for action to create a new document from the reference input */
  "inputs.reference.action.create-new-document": "Create",
  /** Label for action to create a new document from the reference input, when there are multiple templates or document types to choose from */
  "inputs.reference.action.create-new-document-select": "Create\u2026",
  /** Label for action to duplicate the current item to a new item (used within arrays) */
  "inputs.reference.action.duplicate": "Duplicate",
  /** Label for action that opens the referenced document in a new tab */
  "inputs.reference.action.open-in-new-tab": "Open in new tab",
  /** Label for action to remove the reference from an array */
  "inputs.reference.action.remove": "Remove",
  /** Label for action to replace the current value of the field */
  "inputs.reference.action.replace": "Replace",
  /** Label for action to cancel a previously initiated replace action  */
  "inputs.reference.action.replace-cancel": "Cancel replace",
  /** The cross-dataset reference field currently has a reference, but the feature has been disabled since it was created. This explains what can/cannot be done in its current state. */
  "inputs.reference.cross-dataset.feature-disabled-actions": "You can still clear this field's existing reference, but it cannot be changed to a different document as long as the feature is disabled.",
  /** A cross-dataset reference field exists but the feature has been disabled. A <DocumentationLink> component is available. */
  "inputs.reference.cross-dataset.feature-disabled-description": "This feature has been disabled. Read how to enable it in <DocumentationLink>the documentation</DocumentationLink>.",
  /** Title for a warning telling the user that the current project does not have the "cross dataset references" feature */
  "inputs.reference.cross-dataset.feature-unavailable-title": "Unavailable feature: Cross dataset reference",
  /** The cross-dataset reference points to a document with an invalid type  */
  "inputs.reference.cross-dataset.invalid-type": "The referenced document is of invalid type ({{typeName}}) <JsonValue/>",
  /** The referenced document will open in a new tab (due to external studio) */
  "inputs.reference.document-opens-in-new-tab": "This document opens in a new tab",
  /** Error title for when the document is unavailable (for any possible reason) */
  "inputs.reference.error.document-unavailable-title": "Document unavailable",
  /** Error title for when the referenced document failed to be loaded */
  "inputs.reference.error.failed-to-load-document-title": "Failed to load referenced document",
  /** Error title for when the reference search returned a document that is not an allowed type for the field */
  "inputs.reference.error.invalid-search-result-type-title": `Search returned a type that's not valid for this reference: "{{returnedType}}"`,
  /** Error description for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-description": "Referenced document (<code>{{documentId}}</code>) is of type <code>{{actualType}}</code>. According to the schema, referenced documents can only be of type <AllowedTypes />.",
  /** Error title for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-title": "Document of invalid type",
  /** Error description for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-description": "The referenced document could not be accessed due to insufficient permissions",
  /** Error title for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-title": "Insufficient permissions",
  /** Error description for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-description": "The referenced document does not exist (ID: <code>{{documentId}}</code>). You can either remove the reference or replace it with another document.",
  /** Error title for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-title": "Not found",
  /** Label for button that clears the reference when it points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document.clear-button-label": "Clear",
  /** Error title for when the search for a reference failed. Note that the message sent by the backend may not be localized. */
  "inputs.reference.error.search-failed-title": "Reference search failed",
  /** Alternative text for the image shown in cross-dataset reference input */
  "inputs.reference.image-preview-alt-text": "Image preview of referenced document",
  /** Description for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be finalized.",
  /** Title for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-title": "Finalize reference",
  /** Description for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be converted to a strong reference.",
  /** Title for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-title": "Convert to strong reference",
  /** Label for button that triggers the action that strengthen a reference */
  "inputs.reference.incomplete-reference.strengthen-button-label": "Convert to strong reference",
  /** Label for button that triggers a retry attempt for reference metadata  */
  "inputs.reference.metadata-error.retry-button-label": "Retry",
  /** Title for alert shown when reference metadata fails to be loaded */
  "inputs.reference.metadata-error.title": "Unable to load reference metadata",
  /** Message shown when no documents were found that matched the given search string */
  "inputs.reference.no-results-for-query": "No results for <strong>\u201C{{searchTerm}}\u201D</strong>",
  /** Text for tooltip showing when a document was edited, using relative time (eg "how long ago was it edited?") */
  "inputs.reference.preview.edited-at-time": "Edited <RelativeTime/>",
  /** Accessibility label for icon indicating that document does _not_ have any unpublished changes */
  "inputs.reference.preview.has-no-unpublished-changes-aria-label": "No unpublished edits",
  /** Accessibility label for icon indicating that document has unpublished changes */
  "inputs.reference.preview.has-unpublished-changes-aria-label": "Edited",
  /** Accessibility label for icon indicating that document does _not_ have a published version */
  "inputs.reference.preview.is-not-published-aria-label": "Not published",
  /** Accessibility label for icon indicating that document has a published version */
  "inputs.reference.preview.is-published-aria-label": "Published",
  /** Text for tooltip indicating that a document has no unpublished edits */
  "inputs.reference.preview.no-unpublished-edits": "No unpublished edits",
  /** Text for tooltip indicating that a document has not yet been published */
  "inputs.reference.preview.not-published": "Not published",
  /** Text for tooltip showing when a document was published, using relative time (eg "how long ago was it published?") */
  "inputs.reference.preview.published-at-time": "Published <RelativeTime/>",
  /** The referenced document no longer exist and might have been deleted (for weak references) */
  "inputs.reference.referenced-document-does-not-exist": "The referenced document no longer exist and might have been deleted (document ID: <code>{{documentId}}</code>).",
  /** The referenced document could not be displayed to the user because of insufficient permissions */
  "inputs.reference.referenced-document-insufficient-permissions": "The referenced document could not be accessed due to insufficient permissions",
  /** Label for when the reference input is resolving the initial value for an item */
  "inputs.reference.resolving-initial-value": "Resolving initial value\u2026",
  /** Placeholder shown in a reference input with no current value */
  "inputs.reference.search-placeholder": "Type to search",
  /** Explanation of the consequences of leaving the reference as strong instead of weak */
  "inputs.reference.strength-mismatch.is-strong-consquences": "It will not be possible to delete the reference document without first removing this reference or converting it to weak.",
  /** Description for alert shown when a reference is supposed to be weak, but the actual value is strong */
  "inputs.reference.strength-mismatch.is-strong-description": "This reference is <em>strong</em>, but according to the current schema it should be <em>weak</em>.",
  /** Explanation of the consequences of leaving the reference as weak instead of strong */
  "inputs.reference.strength-mismatch.is-weak-consquences": "This makes it possible to delete the referenced document without first deleting this reference, leaving this field referencing a nonexisting document.",
  /** Description for alert shown when a reference is supposed to be strong, but the actual value is weak */
  "inputs.reference.strength-mismatch.is-weak-description": "This reference is <em>weak</em>, but according to the current schema it should be <em>strong</em>.",
  /** Label for button that triggers the action that strengthens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.strengthen-button-label": "Convert to strong reference",
  /** Title for alert shown when a reference is supposed to be weak/strong, but the actual value is the opposite of what it is supposed to be */
  "inputs.reference.strength-mismatch.title": "Reference strength mismatch",
  /** Label for button that triggers the action that weakens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.weaken-button-label": "Convert to weak reference",
  /** Action message for generating the slug */
  "inputs.slug.action.generate": "Generate",
  /** Loading message for when the input is actively generating a slug */
  "inputs.slug.action.generating": "Generating\u2026",
  /** Error message for when the source to generate a slug from is missing */
  "inputs.slug.error.missing-source": "Source is missing. Check source on type {{schemaType}} in schema",
  /** Placeholder for an empty tag input */
  "inputs.tags.placeholder": "Enter tag and press ENTER\u2026",
  /** Placeholder for an empty tag input on touch devices */
  "inputs.tags.placeholder_touch": "Enter tag\u2026",
  /** Convert to `{{targetType}}` */
  "inputs.untyped-value.convert-button.text": "Convert to {{targetType}}",
  /** Encountered an object value without a <code>_type</code> property. */
  "inputs.untyped-value.description": "Encountered an object value without a <code>_type</code> property.",
  /** Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items. */
  "inputs.untyped-value.details.description": "Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items.",
  /** Current value (<code>object</code>): */
  "inputs.untyped-value.details.json-dump-prefix": "Current value (<code>object</code>):",
  /** The following types are valid here according to schema: */
  "inputs.untyped-value.details.multi-type-description": "The following types are valid here according to schema:",
  /** Developer info */
  "inputs.untyped-value.details.title": "Developer info",
  /** Property value missing <code>_type</code> */
  "inputs.untyped-value.title": "Property value missing <code>_type</code>",
  /** Unset value */
  "inputs.untyped-value.unset-item-button.text": "Unset value",
  /** The fallback explanation if no context is provided */
  "insufficient-permissions-message.not-authorized-explanation": "You do not have permission to access this feature.",
  /** The explanation when unable to create any document at all */
  "insufficient-permissions-message.not-authorized-explanation_create-any-document": "You do not have permission to create a document.",
  /** The explanation when unable to create a particular document */
  "insufficient-permissions-message.not-authorized-explanation_create-document": "You do not have permission to create this document.",
  /** The explanation when unable to create a particular type of document */
  "insufficient-permissions-message.not-authorized-explanation_create-document-type": "You do not have permission to create this kind of document.",
  /** The explanation when unable to create a new reference in a document */
  "insufficient-permissions-message.not-authorized-explanation_create-new-reference": "You do not have permission to create a new reference.",
  /** The explanation when unable to delete a particular document */
  "insufficient-permissions-message.not-authorized-explanation_delete-document": "You do not have permission to delete this document.",
  /** The explanation when unable to discard changes in a particular document */
  "insufficient-permissions-message.not-authorized-explanation_discard-changes": "You do not have permission to discard changes in this document.",
  /** The explanation when unable to duplicate a particular document */
  "insufficient-permissions-message.not-authorized-explanation_duplicate-document": "You do not have permission to duplicate this document.",
  /** The explanation when unable to publish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_publish-document": "You do not have permission to publish this document.",
  /** The explanation when unable to unpublish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_unpublish-document": "You do not have permission to unpublish this document.",
  /** Appears after the not-authorized message. Lists the current roles. */
  "insufficient-permissions-message.roles": "Your roles: <Roles/>",
  /** The title for the insufficient permissions message component */
  "insufficient-permissions-message.title": "Insufficient permissions",
  /** Unexpected error: `{{error}}` */
  "member-field-error.unexpected-error": "Unexpected error: {{error}}",
  /** Button label for "Create new document" button */
  "new-document.button": "Create",
  /**
   * Tooltip message displayed when hovering/activating the "Create new document" action,
   * when there are templates/types available for creation
   */
  "new-document.create-new-document-label": "New document\u2026",
  /** Placeholder for the "filter" input within the new document menu */
  "new-document.filter-placeholder": "Search document types",
  /** Loading indicator text within the new document menu */
  "new-document.loading": "Loading\u2026",
  /** Accessibility label for the list displaying options in the new document menu */
  "new-document.new-document-aria-label": "New document",
  /** Message for when there are no document type options in the new document menu */
  "new-document.no-document-types-found": "No document types found",
  /**
   * Tooltip message displayed when hovering/activating the "Create new document" action,
   * when there are no templates/types to create from
   */
  "new-document.no-document-types-label": "No document types",
  /** Message for when no results are found for a specific search query in the new document menu */
  "new-document.no-results": "No results for <strong>{{searchQuery}}</strong>",
  /** Aria label for the button that opens the "Create new document" popover/dialog */
  "new-document.open-dialog-aria-label": "Create new document",
  /** Title for "Create new document" dialog */
  "new-document.title": "Create new document",
  /** Label for action to manage members of the current studio project */
  "presence.action.manage-members": "Manage members",
  /** Accessibility label for presence menu button */
  "presence.aria-label": "Global presence",
  /** Message description for when no one else is currently present */
  "presence.no-one-else-description": "Invite people to the project to see their online status.",
  /** Message title for when no one else is currently present */
  "presence.no-one-else-title": "No one else is here",
  /** Message for when a user is not in a document (displayed in the global presence menu) */
  "presence.not-in-a-document": "Not in a document",
  /** Tooltip content text for presence menu button */
  "presence.tooltip-content": "Who is here",
  /** Fallback title shown when a preview does not provide a title */
  "preview.default.title-fallback": "Untitled",
  /** Fallback preview value for types that have "no value" (eg null, undefined) */
  "preview.fallback.no-value": "(no value)",
  /** Alternative text for image being shown while image is being uploaded, in previews */
  "preview.image.file-is-being-uploaded.alt-text": "The image currently being uploaded",
  /* Relative time, just now */
  "relative-time.just-now": "just now",
  /** Accessibility label to open search action when the search would go fullscreen (eg on narrower screens) */
  "search.action-open-aria-label": "Open search",
  /** Action label for adding a search filter */
  "search.action.add-filter": "Add filter",
  /** Action label for clearing search filters */
  "search.action.clear-filters": "Clear filters",
  /** Label for action to clear recent searches */
  "search.action.clear-recent-searches": "Clear recent searches",
  /** Accessibility label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-aria-label": "Clear checked filters",
  /** Label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-label": "Clear",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to close the search */
  "search.action.close-search-aria-label": "Close search",
  /** Accessibility label for filtering by document type */
  "search.action.filter-by-document-type-aria-label": "Filter by document type",
  /** Accessibility action label for removing an already applied search filter */
  "search.action.remove-filter-aria-label": "Remove filter",
  /**
   * Text displayed when either no document type(s) have been selected, or we need a fallback,
   * eg "Search for all types".
   */
  "search.action.search-all-types": "Search all documents",
  /**
   * Text displayed when we are able to determine one or more document types that will be used for
   * searching, and can fit within the space assigned by the design.
   */
  "search.action.search-specific-types": "Search for {{types, list}}",
  /**
   * Text displayed when we are able to determine one or more document types that will be used for
   * searching, but cannot list them all within the space assigned by the design, so we need an
   * additional "and X more" suffix. Allows using pluralization suffixes, eg `_one`, `_other` etc.
   */
  "search.action.search-specific-types-truncated": "Search for {{types, list}} +{{count}} more",
  /** Dialog title for action to select an asset of unknown type */
  "search.action.select-asset": "Select asset",
  /** Dialog title for action to select a file asset */
  "search.action.select-asset_file": "Select file",
  /** Dialog title for action to select an image asset */
  "search.action.select-asset_image": "Select image",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to hide filters */
  "search.action.toggle-filters-aria-label_hide": "Hide filters",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to show filters */
  "search.action.toggle-filters-aria-label_show": "Show filters",
  /** Label for when the search is full screen (on narrow screens) and you want to hide filters */
  "search.action.toggle-filters-label_hide": "Hide filters",
  /** Label for when the search is full screen (on narrow screens) and you want to show filters */
  "search.action.toggle-filters-label_show": "Show filters",
  /** Tooltip text for the global search button */
  "search.button.tooltip": "Search",
  /**
   * A list of provided types (use `list` formatter preferably).
   */
  "search.document-type-list": "{{types, list}}",
  /**
   * In the context of a list of document types - no filtering selection has been done,
   * thus the default is "all types".
   */
  "search.document-type-list-all-types": "All types",
  /**
   * A list of provided types that has been truncated - more types are included but not displayed,
   * thus we need to indicate that there are more. Allows using pluralization suffixes,
   * eg `_one`, `_other` etc.
   */
  "search.document-type-list-truncated": "{{types, list}} +{{count}} more",
  /** Accessibility label for list displaying the available document types */
  "search.document-types-aria-label": "Document types",
  /** Label for when no document types matching the filter are found */
  "search.document-types-no-matches-found": "No matches for {{filter}}",
  /** Description for error when a filter cannot be displayed, describes that you should check the schema */
  "search.error.display-filter-description": "This may indicate invalid options defined in your schema.",
  /** Title for error when a filter cannot be displayed (mainly a developer-oriented error) */
  "search.error.display-filter-title": "An error occurred whilst displaying this filter.",
  /** Description for error when no valid asset source is found, describes that you should check the the current studio config */
  "search.error.no-valid-asset-source-check-config-description": "Please ensure it's enabled in your studio configuration file.",
  /** Description for error when no valid asset source is found, describes that only the default asset is supported */
  "search.error.no-valid-asset-source-only-default-description": "Currently, only the default asset source is supported.",
  /** Title for error when no valid asset sources found */
  "search.error.no-valid-asset-source-title": "No valid asset sources found.",
  /** Helpful description for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-help-description": "Please try again or check your connection",
  /** Title label for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-title": "Something went wrong while searching",
  /**
   * Label for "All fields", a label that appears above the list of available fields when filtering.
   * If one or more document type has been chosen as filter, this label is replaced with a group of
   * fields per selected document type
   */
  "search.filter-all-fields-header": "All fields",
  /** Label for the action of changing from one file to a different file in asset search filter */
  "search.filter-asset-change_file": "Change file",
  /** Label for the action of changing from one image to a different image in asset search filter */
  "search.filter-asset-change_image": "Change image",
  /** Label for the action of clearing the currently selected asset in an image/file filter */
  "search.filter-asset-clear": "Clear",
  /** Label for the action of selecting a file in asset search filter */
  "search.filter-asset-select_file": "Select file",
  /** Label for the action of selecting an image in asset search filter */
  "search.filter-asset-select_image": "Select image",
  /** Label for boolean filter - false */
  "search.filter-boolean-false": "False",
  /** Label for boolean filter - true */
  "search.filter-boolean-true": "True",
  /** Accessibility label for list that lets you filter fields by title, when adding a new filter in search */
  "search.filter-by-title-aria-label": "Filter by title",
  /** Accessibility label for date filter input */
  "search.filter-date-aria-label": "Date",
  /** Accessibility label for selecting end date on the date range search filter */
  "search.filter-date-range-end-date-aria-label": "End date",
  /** Accessibility label for selecting start date on the date range search filter */
  "search.filter-date-range-start-date-aria-label": "Start date",
  /** Accessibility label for selecting the unit (day/month/year) when adding "X days ago" search filter */
  "search.filter-date-unit-aria-label": "Select unit",
  /**
   * Label for "Days"/"Months"/"Years" when selecting it as unit in "X days ago" search filter.
   * Capitalized, as it would be listed in a dropdown.
   */
  "search.filter-date-unit_days": "Days",
  "search.filter-date-unit_months": "Months",
  "search.filter-date-unit_years": "Years",
  /** Accessibility label for the input value (days/months/years) when adding "X days ago" search filter */
  "search.filter-date-value-aria-label": "Unit value",
  /** Label for "field description" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-description": "Field description",
  /** Label for "field name" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-name": "Field name",
  /** Label for "Used in document types", a list of the document types a field appears in. Shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-used-in-document-types": "Used in document types",
  /** Label for when no fields/filters are found for the given term */
  "search.filter-no-matches-found": "No matches for {{filter}}",
  /** Placeholder value for maximum numeric value filter */
  "search.filter-number-max-value-placeholder": "Max value",
  /** Placeholder value for minimum numeric value filter */
  "search.filter-number-min-value-placeholder": "Min value",
  /** Placeholder value for the number filter */
  "search.filter-number-value-placeholder": "Value",
  /** Placeholder for the "Filter" input, when narrowing possible fields/filters */
  "search.filter-placeholder": "Filter",
  /** Label for the action of clearing the currently selected document in a reference filter */
  "search.filter-reference-clear": "Clear",
  /**
   * Label for "shared fields", a label that appears above a list of fields that all filtered types
   * have in common, when adding a new filter. For instance, if "book" and "employee" both have a
   * "title" field, this field would be listed under "shared fields".
   * */
  "search.filter-shared-fields-header": "Shared fields",
  /** Placeholder value for the string filter */
  "search.filter-string-value-placeholder": "Value",
  /** Label/placeholder prompting user to select one of the predefined, allowed values for a string field */
  "search.filter-string-value-select-predefined-value": "Select\u2026",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (singular) */
  "search.filters-aria-label_one": "Filter",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (plural) */
  "search.filters-aria-label_other": "Filters",
  /** Label for instructions on how to use the search - displayed when no recent searches are available */
  "search.instructions": "Use <ControlsIcon/> to refine your search",
  /** Helpful description for when no search results are found */
  "search.no-results-help-description": "Try another keyword or adjust your filters",
  /** Title label for when no search results are found */
  "search.no-results-title": "No results found",
  /**
   * Individual search operators.
   *
   * The `name` variant is the form we use when the user is building a query, and selecting from a
   * list of available operators for a field. Keep in mind that since the user knows what the field
   * represents, we do not need to contextualize too much, and that the user may not be a developer
   * eg prefer "quantity is" over "array has length". Additionally, (if applicable in language) use
   * lowercased names.
   *
   * The `description` variant is the form shown once the filter has enough information to apply,
   * and is shown in the list of applied filters. It is passed components that _should_ be used to
   * compose the filter string, and to format them correctly:
   *
   * `<Field/>` - eg "Bird species", "Category", "Date of birth"
   * `<Operator>operator text</Operator>` - eg "has ≤", "includes", "is"
   * `<Value>{{value}}</Value>` - eg "Hawk", "Sparrow", "Eagle"
   *
   * Where applicable, a `count` is passed, allowing you to pluralize where needed, by using
   * suffixes such as `_zero`, `_one`, `_other` etc.
   *
   * Prefer (reasonable) brevity since many filters may be applied. For instance:
   * `<Field/> has ≤ <Value/>` may be better than
   * `<Field/> has less than or equal to <Value/>`
   **/
  /* Array should have a count the given filter value */
  "search.operator.array-count-equal.description_one": "<Field/> <Operator>has</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-equal.description_other": "<Field/> <Operator>has</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-equal.name": "quantity is",
  /* Array should have a count greater than given filter value */
  "search.operator.array-count-gt.description_one": "<Field/> <Operator>has ></Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gt.description_other": "<Field/> <Operator>has ></Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gt.name": "quantity greater than",
  /* Array should have a count greater than or equal to the given filter value */
  "search.operator.array-count-gte.description_one": "<Field/> <Operator>has \u2265</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gte.description_other": "<Field/> <Operator>has \u2265</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gte.name": "quantity greater than or equal to",
  /* Array should have a count less than given filter value */
  "search.operator.array-count-lt.description_one": "<Field/> <Operator>has <</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lt.description_other": "<Field/> <Operator>has <</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lt.name": "quantity less than",
  /* Array should have a count less than or equal to the given filter value */
  "search.operator.array-count-lte.description_one": "<Field/> <Operator>has \u2264</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lte.description_other": "<Field/> <Operator>has \u2264</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lte.name": "quantity less than or equal to",
  /* Array should have a count that is not equal to the given filter value */
  "search.operator.array-count-not-equal.description_one": "<Field/> <Operator>does not have</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-not-equal.description_other": "<Field/> <Operator>does not have</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-not-equal.name": "quantity is not",
  /**
   * Array should have a count within the range of given filter values.
   * Gets passed `{{from}}` and `{{to}}` values.
   **/
  "search.operator.array-count-range.description": "<Field/> <Operator>has between</Operator> <Value>{{from}} \u2192 {{to}} items</Value>",
  "search.operator.array-count-range.name": "quantity is between",
  /* Array should include the given value */
  "search.operator.array-list-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-includes.name": "includes",
  /* Array should not include the given value */
  "search.operator.array-list-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-not-includes.name": "does not include",
  /* Array should include the given reference */
  "search.operator.array-reference-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-includes.name": "includes",
  /* Array should not include the given reference */
  "search.operator.array-reference-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-not-includes.name": "does not include",
  /* Asset (file) should be the selected asset */
  "search.operator.asset-file-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-equal.name": "is",
  /* Asset (file) should not be the selected asset */
  "search.operator.asset-file-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-not-equal.name": "is not",
  /* Asset (image) should be the selected asset */
  "search.operator.asset-image-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-equal.name": "is",
  /* Asset (image) should not be the selected asset */
  "search.operator.asset-image-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-not-equal.name": "is not",
  /**
   * Boolean value should be the given filter value (true/false).
   * Context passed is `true` and `false`, allowing for more specific translations:
   * - `search.operator.boolean-equal.description_true`
   * - `search.operator.boolean-equal.description_false`
   */
  "search.operator.boolean-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.boolean-equal.name": "is",
  /* Date should be after (later than) given filter value */
  "search.operator.date-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-after.name": "after",
  /* Date should be before (earlier than) given filter value */
  "search.operator.date-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-before.name": "before",
  /* Date should be the given filter value */
  "search.operator.date-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-equal.name": "is",
  /* Date should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-last.name": "last",
  /* Date should not be the given filter value */
  "search.operator.date-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-not-equal.name": "is not",
  /* Date should be within the range of given filter values */
  "search.operator.date-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-range.name": "is between",
  /* Date and time should be after (later than) given filter value */
  "search.operator.date-time-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-after.name": "after",
  /* Date and time should be before (earlier than) given filter value */
  "search.operator.date-time-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-before.name": "before",
  /* Date and time should be the given filter value */
  "search.operator.date-time-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-equal.name": "is",
  /* Date and time should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-time-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-last.name": "last",
  /* Date and time should not be the given filter value */
  "search.operator.date-time-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-not-equal.name": "is not",
  /* Date and time should be within the range of given filter values */
  "search.operator.date-time-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-time-range.name": "is between",
  /* Value should be defined */
  "search.operator.defined.description": "<Field/> <Operator>is</Operator> <Value>not empty</Value>",
  "search.operator.defined.name": "not empty",
  /* Value should not be defined */
  "search.operator.not-defined.description": "<Field/> <Operator>is</Operator> <Value>empty</Value>",
  "search.operator.not-defined.name": "empty",
  /* Number should be the given filter value */
  "search.operator.number-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.number-equal.name": "is",
  /* Number should be greater than given filter value */
  "search.operator.number-gt.description": "<Field/> <Operator>></Operator> <Value>{{value}}</Value>",
  "search.operator.number-gt.name": "greater than",
  /* Number should be greater than or the given filter value */
  "search.operator.number-gte.description": "<Field/> <Operator>\u2265</Operator> <Value>{{value}}</Value>",
  "search.operator.number-gte.name": "greater than or equal to",
  /* Number should be less than given filter value */
  "search.operator.number-lt.description": "<Field/> <Operator><</Operator> <Value>{{value}}</Value>",
  "search.operator.number-lt.name": "less than",
  /* Number should be less than or the given filter value */
  "search.operator.number-lte.description": "<Field/> <Operator>\u2264</Operator> <Value>{{value}}</Value>",
  "search.operator.number-lte.name": "less than or equal to",
  /* Number should not be the given filter value */
  "search.operator.number-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.number-not-equal.name": "is not",
  /* Number should be within the range of given filter values */
  "search.operator.number-range.description": "<Field/> <Operator>is between</Operator> <Value>{{from}} \u2192 {{to}}</Value>",
  "search.operator.number-range.name": "is between",
  /* Portable Text should contain the given filter value */
  "search.operator.portable-text-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-contains.name": "contains",
  /* Portable Text should be the given filter value */
  "search.operator.portable-text-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-equal.name": "is",
  /* Portable Text should not contain the given filter value */
  "search.operator.portable-text-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-contains.name": "does not contain",
  /* Portable Text should not be the given filter value */
  "search.operator.portable-text-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-equal.name": "is not",
  /* References the given asset (file) */
  "search.operator.reference-asset-file.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-file.name": "file",
  /* References the given asset (image) */
  "search.operator.reference-asset-image.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-image.name": "image",
  /* References the given document */
  "search.operator.reference-document.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-document.name": "document",
  /* Reference should be the given document */
  "search.operator.reference-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-equal.name": "is",
  /* Reference should not be the given document */
  "search.operator.reference-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-not-equal.name": "is not",
  /* Slug contains the given value */
  "search.operator.slug-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-contains.name": "contains",
  /* Slug equals the given filter value */
  "search.operator.slug-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-equal.name": "is",
  /* Slug does not contain the given value */
  "search.operator.slug-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-contains.name": "does not contain",
  /* Slug does not equal the given filter value */
  "search.operator.slug-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-equal.name": "is not",
  /* String contains the given filter value */
  "search.operator.string-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.string-contains.name": "contains",
  /* String equals the given filter value */
  "search.operator.string-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-equal.name": "is",
  /* String equals one of the predefined allowed values */
  "search.operator.string-list-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-equal.name": "is",
  /* String does not equal one of the predefined allowed values */
  "search.operator.string-list-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-not-equal.name": "is not",
  /* String does not contain the given filter value */
  "search.operator.string-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-contains.name": "does not contain",
  /* String does not equal the given filter value */
  "search.operator.string-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-equal.name": "is not",
  /** Label for the "Best match" search ordering type */
  "search.ordering.best-match-label": "Best match",
  /** Label for the "Created: Oldest first" search ordering type */
  "search.ordering.created-ascending-label": "Created: Oldest first",
  /** Label for the "Created: Newest first" search ordering type */
  "search.ordering.created-descending-label": "Created: Newest first",
  /** Label for the "Updated: Oldest first" search ordering type */
  "search.ordering.updated-ascending-label": "Updated: Oldest first",
  /** Label for the "Updated: Newest first" search ordering type */
  "search.ordering.updated-descending-label": "Updated: Newest first",
  /** Placeholder text for the global search input field */
  "search.placeholder": "Search",
  /** Accessibility label for the recent searches section, shown when no valid search terms has been given */
  "search.recent-searches-aria-label": "Recent searches",
  /** Label/heading shown for the recent searches section */
  "search.recent-searches-label": "Recent searches",
  /** Accessibility label for the search results section, shown when the user has typed valid terms */
  "search.search-results-aria-label": "Search results",
  /** Accessibility label for the navbar status button */
  "status-button.aria-label": "Configuration status",
  /** Description for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-description": "Document history transactions have not been affected.",
  /** Title for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-title": "An error occurred whilst retrieving document changes.",
  /** Error description for when the document doesn't have history */
  "timeline.error.no-document-history-description": "When changing the content of the document, the document versions will appear in this menu.",
  /** Error title for when the document doesn't have history */
  "timeline.error.no-document-history-title": "No document history",
  /** Error prompt when revision cannot be loaded */
  "timeline.error.unable-to-load-revision": "Unable to load revision",
  /** Label for when the timeline item is the latest in the history */
  "timeline.latest": "Latest",
  /** Label for latest version for timeline menu dropdown */
  "timeline.latest-version": "Latest version",
  /** The aria-label for the list of revisions in the timeline */
  "timeline.list.aria-label": "Document revisions",
  /** Label for loading history */
  "timeline.loading-history": "Loading history\u2026",
  /** Label shown in review changes timeline when a document has been created */
  "timeline.operation.created": "Created",
  /** Label shown in review changes timeline when a document was initially created */
  "timeline.operation.created-initial": "Created",
  /** Label shown in review changes timeline when a document was initially created, with a timestamp */
  "timeline.operation.created-initial_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been created, with a timestamp */
  "timeline.operation.created_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been deleted */
  "timeline.operation.deleted": "Deleted",
  /** Label shown in review changes timeline when a document has been deleted, with a timestamp */
  "timeline.operation.deleted_timestamp": "Deleted: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been discarded */
  "timeline.operation.draft-discarded": "Discarded draft",
  /** Label shown in review changes timeline when a draft has been discarded, with a timestamp */
  "timeline.operation.draft-discarded_timestamp": "Discarded draft: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been edited */
  "timeline.operation.edited-draft": "Edited",
  /** Label shown in review changes timeline when a draft has been edited, with a timestamp */
  "timeline.operation.edited-draft_timestamp": "Edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been edited live */
  "timeline.operation.edited-live": "Live edited",
  /** Label shown in review changes timeline when a document has been edited live, with a timestamp */
  "timeline.operation.edited-live_timestamp": "Live edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was published */
  "timeline.operation.published": "Published",
  /** Label shown in review changes timeline when a document was published, with a timestamp */
  "timeline.operation.published_timestamp": "Published: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was unpublished */
  "timeline.operation.unpublished": "Unpublished",
  /** Label shown in review changes timeline when a document was unpublished, with a timestamp */
  "timeline.operation.unpublished_timestamp": "Unpublished: {{timestamp, datetime}}",
  /**
   * Label for determining since which version the changes for timeline menu dropdown are showing.
   * Receives the time label as a parameter (`timestamp`).
   */
  "timeline.since": "Since: {{timestamp, datetime}}",
  /** Label for missing change version for timeline menu dropdown are showing */
  "timeline.since-version-missing": "Since: unknown version",
  /**Aria label for the action buttons in the PTE toolbar */
  "toolbar.portable-text.action-button-aria-label": "{{action}}",
  /** Label for the button showed after trial ended */
  "user-menu.action.free-trial-finished": "Upgrade from free",
  /** Label for button showing the free trial days left */
  "user-menu.action.free-trial_one": "{{count}} day left in trial",
  "user-menu.action.free-trial_other": "{{count}} days left in trial",
  /** Label for action to invite members to the current sanity project */
  "user-menu.action.invite-members": "Invite members",
  /** Accessibility label for action to invite members to the current sanity project */
  "user-menu.action.invite-members-aria-label": "Invite members",
  /** Label for action to manage the current sanity project */
  "user-menu.action.manage-project": "Manage project",
  /** Accessibility label for the action to manage the current project */
  "user-menu.action.manage-project-aria-label": "Manage project",
  /** Tooltip helper text when portable text annotation is disabled for empty block*/
  "user-menu.action.portable-text.annotation-disabled_empty-block": "Cannot apply {{name}} to empty block",
  /** Tooltip helper text when portable text annotation is disabled for multiple blocks */
  "user-menu.action.portable-text.annotation-disabled_multiple-blocks": "Cannot apply {{name}} to multiple blocks",
  /** Label for action to sign out of the current sanity project */
  "user-menu.action.sign-out": "Sign out",
  /** Title for appearance section for the current studio (dark / light / system scheme) */
  "user-menu.appearance-title": "Appearance",
  /** Label for close menu button for user menu */
  "user-menu.close-menu": "Close menu",
  /** Description for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-description": "Use dark appearance",
  /** Title for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-title": "Dark",
  /** Description for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-description": "Use light appearance",
  /** Title for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-title": "Light",
  /** Description for using "system apparence" in the appearance user menu */
  "user-menu.color-scheme.system-description": "Use system appearance",
  /** Title for using system apparence in the appearance user menu */
  "user-menu.color-scheme.system-title": "System",
  /** Title for locale section for the current studio */
  "user-menu.locale-title": "Language",
  /** Label for tooltip to show which provider the currently logged in user is using */
  "user-menu.login-provider": "Signed in with {{providerTitle}}",
  /** Label for open menu button for user menu */
  "user-menu.open-menu": "Open menu",
  /**
   * Label for action to add a workspace (currently a developer-oriented action, as this will
   * lead to the documentation on workspace configuration)
   */
  "workspaces.action.add-workspace": "Add workspace",
  /**
   * Label for action to choose a different workspace, in the case where you are not logged in,
   * have selected a workspace, and are faced with the authentication options for the selected
   * workspace. In other words, label for the action shown when you have reconsidered which
   * workspace to authenticate in.
   */
  "workspaces.action.choose-another-workspace": "Choose another workspace",
  /** Label for heading that indicates that you can choose your workspace */
  "workspaces.choose-your-workspace-label": "Choose your workspace",
  /** Label for the workspace menu */
  "workspaces.select-workspace-aria-label": "Select workspace",
  /** Button label for opening the workspace switcher */
  "workspaces.select-workspace-label": "Select workspace",
  /** Tooltip for the workspace menu */
  "workspaces.select-workspace-tooltip": "Select workspace",
  /** Title for Workplaces dropdown menu */
  "workspaces.title": "Workspaces"
}), studioDefaultLocaleResources = {
  locale: "en-US",
  namespace: studioLocaleNamespace,
  resources: studioLocaleStrings
}, validationLocaleStrings = defineLocalesResources("validation", {
  /** Array must have exactly "$wantedLength" items, but has more/less */
  "array.exact-length": "Must have exactly {{wantedLength}} items",
  /** Portable Text array must have exactly "$wantedLength" blocks, but has more/less */
  "array.exact-length_blocks": "Must have exactly {{wantedLength}} blocks",
  /** Array item is a duplicate, but array wants only unique items */
  "array.item-duplicate": "Can't be a duplicate",
  /** Array has more than the maximum of "$maxLength" items */
  "array.maximum-length": "Must have at most {{maxLength}} items",
  /** Portable Text array has more than the maximum of "$maxLength" items */
  "array.maximum-length_blocks": "Must have at most {{maxLength}} blocks",
  /** Array has less than the minimum of "$minLength" items */
  "array.minimum-length": "Must have at least {{minLength}} items",
  /** Portable Text array has less than the minimum of "$minLength" blocks */
  "array.minimum-length_blocks": "Must have at least {{minLength}} blocks",
  /** Date is not valid or not in the correct format (ISO-8601) */
  "date.invalid-format": "Must be a valid ISO-8601 formatted date string",
  /** Date is later than the given maximum date "$maxDate" */
  "date.maximum": "Must be at or before {{maxDate}}",
  /** Date is earlier than the given minimum date "$minDate" */
  "date.minimum": "Must be at or after {{minDate}}",
  /** A value of incorrect type is found, eg found `number` instead of `string` */
  "generic.incorrect-type": 'Expected type "{{expectedType}}", got "{{actualType}}"',
  /** Value is not one of the values specifically allowed */
  "generic.not-allowed": "Value did not match any allowed values",
  /** Value "$givenValue" is not one of the values specifically allowed */
  "generic.not-allowed_hint": 'Value "{{hint}}" did not match any allowed values',
  /** A value is expected, but none is provided */
  "generic.required": "Required",
  /** Number is less than the given minimum threshold value "$threshold" */
  "number.greater-than": "Must be greater than {{threshold}}",
  /** Number is greater than the given maximum threshold value "$threshold" */
  "number.less-than": "Must be less than {{threshold}}",
  /** Number is higher than the given maximum value "$maxNumber" */
  "number.maximum": "Must be lower than or equal to {{maxNumber}}",
  /** Number has more precision (decimals) than the allowed "$limit" */
  "number.maximum-precision": "Max precision is {{limit}}",
  /** Number is lower than the given minimum value "$minNumber" */
  "number.minimum": "Must be greater than or equal to {{minNumber}}",
  /** Number is not an integer ("whole number") */
  "number.non-integer": "Must be an integer",
  /** Object is missing a reference to an asset document in its `asset` field */
  "object.asset-required": "Asset is required",
  /** Object is missing a reference to a file asset document in its `asset` field */
  "object.asset-required_file": "File is required",
  /** Object is missing a reference to an image asset document in its `asset` field */
  "object.asset-required_image": "Image is required",
  /** Object is not a reference to a document (eg `{_ref: 'documentId'}`) */
  "object.not-reference": "Must be a reference to a document",
  /** Object references a document which is not published */
  "object.reference-not-published": "Referenced document must be published",
  /** Accessibility label for closing the validation panel */
  "panel.close-button-aria-label": "Close validation",
  /** Message shown when the validation panel is opened but there are no errors/warnings */
  "panel.no-errors-message": "No validation errors",
  /** Title for the actual "Validation" panel/feature */
  "panel.title": "Validation",
  /** Slug is an object, but is missing a `current` string property */
  "slug.missing-current": "Slug must have a value",
  /** Slug is not an object (eg `{current: 'some-slug'}`) */
  "slug.not-object": "Slug must be an object",
  /** Slug is already in use somewhere else, but needs to be unique */
  "slug.not-unique": "Slug is already in use",
  /** String is not a valid email address */
  "string.email": "Must be a valid email address",
  /** String has a different character length than the exact number "$wantedLength" */
  "string.exact-length": "Must be exactly {{wantedLength}} characters long",
  /** String contains characters that are not in lowercase  */
  "string.lowercase": "Must be all lowercase characters",
  /** String is longer than the limit of "$maxLength" characters */
  "string.maximum-length": "Must be at most {{maxLength}} characters long",
  /** String is shorter than the limit of "$minLength" characters */
  "string.minimum-length": "Must be at least {{minLength}} characters long",
  /** String does not match the given regular expression, but should */
  "string.regex-does-not-match": 'Does not match "{{name}}"-pattern',
  /** String matches the given regular expression, but should not */
  "string.regex-match": 'Should not match "{{name}}"-pattern',
  /** String contains characters that are not in uppercase */
  "string.uppercase": "Must be all uppercase characters",
  /** String contains a protocol/scheme that is not allowed, eg (`ftp`, `mailto`…) */
  "string.url.disallowed-scheme": "Does not match allowed protocols/schemes",
  /** String contains a URL with a username or password specified before the host */
  "string.url.includes-credentials": "Username/password not allowed",
  /** String is not a valid URL */
  "string.url.invalid": "Not a valid URL",
  /** String is not an absolute URL (eg it is missing a protocol/host) */
  "string.url.not-absolute": "Relative URLs are not allowed",
  /** String is not a relative URL (eg it contains a protocol/host) */
  "string.url.not-relative": "Only relative URLs are allowed"
}), validationLocaleResources = {
  locale: "en-US",
  namespace: validationLocaleNamespace,
  resources: validationLocaleStrings
}, usEnglishLocale = {
  id: "en-US",
  title: "English (US)",
  bundles: [studioDefaultLocaleResources, validationLocaleResources],
  weekInfo: {
    firstDay: 7,
    // Sunday
    weekend: [6, 7],
    // Saturday, Sunday
    minimalDays: 1
  }
}, defaultLocale = usEnglishLocale, supportsLocalStorage = (() => {
  const key = "__tmp_supports_local_storage";
  try {
    return typeof localStorage > "u" ? !1 : (localStorage.setItem(key, "---"), localStorage.removeItem(key), !0);
  } catch {
    return !1;
  }
})(), LOCAL_STORAGE_PREFIX = "sanity-locale";
function getPreferredLocale(projectId, sourceId) {
  if (!supportsLocalStorage)
    return;
  const locale = localStorage.getItem(getItemKey$1(projectId, sourceId));
  return locale != null ? locale : void 0;
}
function storePreferredLocale(projectId, sourceId, locale) {
  supportsLocalStorage && localStorage.setItem(getItemKey$1(projectId, sourceId), locale);
}
function getItemKey$1(projectId, sourceId) {
  return [LOCAL_STORAGE_PREFIX, projectId, sourceId].join(":");
}
function LocaleProvider(props2) {
  const {
    projectId,
    name: sourceId,
    i18n: { locales },
    __internal: { i18next: i18next2 }
  } = useSource();
  return /* @__PURE__ */ jsxRuntime.jsx(
    LocaleProviderBase,
    {
      ...props2,
      projectId,
      sourceId,
      locales,
      i18next: i18next2
    }
  );
}
function LocaleProviderBase({
  projectId,
  sourceId,
  locales,
  i18next: i18next2,
  children
}) {
  const subscribe = React.useCallback(
    (callback) => (i18next2.on("languageChanged", callback), () => i18next2.off("languageChanged", callback)),
    [i18next2]
  ), currentLocale = React.useSyncExternalStore(
    subscribe,
    () => locales.find((candidate) => i18next2.language === candidate.id) || defaultLocale
  ), context = React.useMemo(
    () => ({
      locales,
      currentLocale,
      __internal: { i18next: i18next2 },
      changeLocale: async (newLocale) => {
        storePreferredLocale(projectId, sourceId, newLocale), await i18next2.changeLanguage(newLocale);
      }
    }),
    [currentLocale, i18next2, locales, projectId, sourceId]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {}), children: /* @__PURE__ */ jsxRuntime.jsx(reactI18next.I18nextProvider, { i18n: i18next2, children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.LocaleContext.Provider, { value: context, children }, currentLocale.id) }) });
}
function useGetI18nText(input) {
  const items = Array.isArray(input) ? input : [input], stableNamespaces = JSON.stringify(
    items.flatMap((item) => item != null && item.i18n ? Object.values(item.i18n).map(({ ns }) => ns) : []).filter(isNonNullable$2).sort()
  ), namespaces = React.useMemo(() => JSON.parse(stableNamespaces), [stableNamespaces]), { t: t2 } = useTranslation(namespaces);
  return React.useCallback(
    function(node) {
      const { i18n } = node;
      return i18n ? new Proxy(node, {
        get: (target, property) => {
          const defaultValue2 = target[property];
          if (typeof property == "string" && property in i18n) {
            const { key, ns } = i18n[property];
            return t2(key, {
              ns,
              // `defaultValue` is a special key in the i18next `t` API that
              // allows us to provide a fallback value if no translation is found
              // using the given key and namespace. if the value on the node
              // is a string, then we'll use that as the fallback value
              ...typeof defaultValue2 == "string" && { defaultValue: defaultValue2 }
            });
          }
          return defaultValue2;
        }
      }) : node;
    },
    [t2]
  );
}
function useI18nText(node) {
  const namespaces = React.useMemo(() => node.i18n ? Array.from(new Set(Object.values(node.i18n).map(({ ns }) => ns))).sort() : [], [node.i18n]), { t: t2 } = useTranslation(namespaces);
  return React.useMemo(() => {
    const { i18n } = node;
    return i18n ? new Proxy(node, {
      get: (target, property) => {
        const defaultValue2 = target[property];
        if (typeof property == "string" && property in i18n) {
          const { key, ns } = i18n[property];
          return t2(key, {
            ns,
            // `defaultValue` is a special key in the i18next `t` API that
            // allows us to provide a fallback value if no translation is found
            // using the given key and namespace. if the value on the node
            // is a string, then we'll use that as the fallback value
            ...typeof defaultValue2 == "string" && { defaultValue: defaultValue2 }
          });
        }
        return defaultValue2;
      }
    }) : node;
  }, [node, t2]);
}
const intlCache = (() => {
  const caches = {
    dateTimeFormat: createCache(),
    listFormat: createCache(),
    numberFormat: createCache(),
    relativeTimeFormat: createCache()
  };
  function dateTimeFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.dateTimeFormat[key];
    return instance || (instance = new Intl.DateTimeFormat(locale, options), caches.dateTimeFormat[key] = instance, instance);
  }
  function listFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.listFormat[key];
    return instance || (instance = new Intl.ListFormat(locale, options), caches.listFormat[key] = instance, instance);
  }
  function numberFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.numberFormat[key];
    return instance || (instance = new Intl.NumberFormat(locale, options), caches.numberFormat[key] = instance, instance);
  }
  function relativeTimeFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.relativeTimeFormat[key];
    return instance || (instance = new Intl.RelativeTimeFormat(locale, options), caches.relativeTimeFormat[key] = instance, instance);
  }
  return {
    dateTimeFormat,
    listFormat,
    numberFormat,
    relativeTimeFormat
  };
})();
function createCache() {
  return /* @__PURE__ */ Object.create(null);
}
function getCacheId(locale, options) {
  return `${locale}-${JSON.stringify(orderedProps(options))}`;
}
function orderedProps(obj) {
  const segments = [];
  for (const [key, value] of Object.entries(obj))
    segments.push(`${key}=${JSON.stringify(value)}`);
  return segments.sort().join(`
`);
}
function useListFormat(options = {}) {
  try {
    const currentLocale = getJsonStream.useCurrentLocale().id;
    return intlCache.listFormat(currentLocale, options);
  } catch {
    return intlCache.listFormat("en-US", { ...options, style: "narrow" });
  }
}
const OPEN_TAG_RE = /^<(?<tag>[^\s\d<][^/?><]+)\/?>/, CLOSE_TAG_RE = /<\/(?<tag>[^>]+)>/, SELF_CLOSING_RE = /<[^>]+\/>/, VALID_COMPONENT_NAME_RE = /^[A-Z][A-Za-z0-9]+$/, VALID_HTML_TAG_NAME_RE = /^[a-z]+$/, TEMPLATE_RE = /{{\s*?([^}]+)\s*?}}/g;
function simpleParser(input) {
  const tokens = [];
  let text = "", openTag = "", remainder = input;
  for (; remainder.length > 0; )
    if (!openTag && remainder[0] === "<") {
      const match = matchOpenTag(remainder);
      if (match) {
        const tagName = match.groups.tag;
        validateTagName(tagName), text && (tokens.push(...textTokenWithInterpolation(text)), text = ""), isSelfClosing(match[0]) ? tokens.push({ type: "tagOpen", selfClosing: !0, name: tagName }) : (tokens.push({ type: "tagOpen", name: tagName }), openTag = tagName), remainder = remainder.substring(match[0].length);
      } else
        text += remainder[0], remainder = remainder.substring(1);
    } else if (openTag && remainder[0] === "<" && remainder[1] !== "<") {
      const match = matchCloseTag(remainder);
      if (match) {
        const tagName = match.groups.tag;
        if (remainder[1] !== "/")
          throw new Error(
            `Expected closing tag for <${openTag}>, but found new opening tag <${tagName}>. Nested tags is not supported.`
          );
        if (tagName !== openTag)
          throw new Error(
            `Expected closing tag for <${openTag}>, but found closing tag </${tagName}> instead. Make sure each opening tag has a matching closing tag.`
          );
        text && (tokens.push(...textTokenWithInterpolation(text)), text = ""), tokens.push({ type: "tagClose", name: tagName }), openTag = "", remainder = remainder.substring(match[0].length);
      } else
        text += remainder[0], remainder = remainder.substring(1);
    } else
      text += remainder[0], remainder = remainder.substring(1);
  if (openTag)
    throw new Error(
      `No matching closing tag for <${openTag}> found. Either make it self closing (e.g. "<${openTag}/>") or close it (e.g "<${openTag}>...</${openTag}>").`
    );
  return text && tokens.push(...textTokenWithInterpolation(text)), tokens;
}
function textTokenWithInterpolation(text) {
  const tokens = [], interpolations = text.matchAll(TEMPLATE_RE);
  let lastIndex = 0;
  for (const match of interpolations) {
    if (typeof match.index > "u")
      continue;
    const pre = text.slice(lastIndex, match.index);
    pre.length > 0 && tokens.push({ type: "text", text: pre }), tokens.push(parseInterpolation(match[0])), lastIndex += pre.length + match[0].length;
  }
  return lastIndex < text.length && tokens.push({ type: "text", text: text.slice(lastIndex) }), tokens;
}
function parseInterpolation(interpolation) {
  const [variable, ...formatters] = interpolation.replace(/^\{\{|\}\}$/g, "").trim().split(/\s*,\s*/);
  if (formatters.length === 1 && formatters[0] === "list")
    return { type: "interpolation", variable, formatters };
  if (formatters.length > 0)
    throw new Error(
      `Interpolations with formatters are not supported when using <Translate>. Found "${interpolation}". Utilize "useTranslation" instead, or format the values passed to <Translate> ahead of time.`
    );
  return { type: "interpolation", variable };
}
function isSelfClosing(tag) {
  return SELF_CLOSING_RE.test(tag);
}
function matchOpenTag(input) {
  return input.match(OPEN_TAG_RE);
}
function matchCloseTag(input) {
  return input.match(CLOSE_TAG_RE);
}
function validateTagName(tagName) {
  if (!(VALID_COMPONENT_NAME_RE.test(tagName) || VALID_HTML_TAG_NAME_RE.test(tagName)))
    throw new Error(
      tagName.trim() === tagName ? `Invalid tag "<${tagName}>". Tag names must be lowercase HTML tags or start with an uppercase letter and can only include letters and numbers.` : `Invalid tag "<${tagName}>". No whitespace allowed in tags.`
    );
}
const COMPONENT_NAME_RE = /^[A-Z]/, RECOGNIZED_HTML_TAGS = [
  "abbr",
  "address",
  "cite",
  "code",
  "del",
  "em",
  "ins",
  "kbd",
  "q",
  "samp",
  "strong",
  "sub",
  "sup"
];
function Translate(props2) {
  const translated = props2.t(props2.i18nKey, {
    context: props2.context,
    skipInterpolation: !0,
    count: props2.values && "count" in props2.values && typeof props2.values.count == "number" ? props2.values.count : void 0
  }), tokens = React.useMemo(() => simpleParser(translated), [translated]), listFormat = useListFormat(), formatters = {
    list: (listValues) => listFormat.format(listValues)
  };
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: render(tokens, props2.values, props2.components || {}, formatters) });
}
function render(tokens, values2, componentMap, formatters) {
  const [head, ...tail] = tokens;
  if (!head)
    return null;
  if (head.type === "interpolation") {
    const value = values2 ? values2[head.variable] : void 0;
    if (typeof value > "u")
      return `{{${head.variable}}}`;
    const formattedValue = applyFormatters(value, head.formatters || [], formatters);
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      formattedValue,
      render(tail, values2, componentMap, formatters)
    ] });
  }
  if (head.type === "text")
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      head.text,
      render(tail, values2, componentMap, formatters)
    ] });
  if (head.type === "tagOpen" && head.selfClosing) {
    const Component = componentMap[head.name];
    if (!Component)
      throw new Error(`Component not found: ${head.name}`);
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(Component, {}),
      render(tail, values2, componentMap, formatters)
    ] });
  }
  if (head.type === "tagOpen" && !head.selfClosing) {
    const nextCloseIdx = tail.findIndex((token) => token.type === "tagClose"), nextClose = tail[nextCloseIdx];
    if (nextClose && head.name !== nextClose.name)
      throw new Error("Nested tags is not allowed");
    const Component = componentMap[head.name];
    if (!Component && COMPONENT_NAME_RE.test(head.name))
      throw new Error(`Component not defined: ${head.name}`);
    if (!Component && !RECOGNIZED_HTML_TAGS.includes(head.name))
      throw new Error(`HTML tag "${head.name}" is not allowed`);
    const children = tail.slice(0, nextCloseIdx), remaining = tail.slice(nextCloseIdx + 1);
    return Component ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(Component, { children: render(children, values2, componentMap, formatters) }),
      render(remaining, values2, componentMap, formatters)
    ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      React.createElement(head.name, {}, render(children, values2, componentMap, formatters)),
      render(remaining, values2, componentMap, formatters)
    ] });
  }
  return null;
}
function applyFormatters(value, formatters, formatterFns) {
  let formattedValue = value;
  for (const formatter of formatters)
    if (formatter === "list")
      if (Array.isArray(value))
        formattedValue = formatterFns.list(value);
      else
        throw new Error("List formatter used on non-array value");
  return `${formattedValue}`;
}
const DEFAULT_STUDIO_CLIENT_OPTIONS = {
  apiVersion: "2024-03-12"
};
function getSizeDiff(prev, next) {
  if (!prev || !next)
    return 0;
  const increase = next - prev;
  return Math.round(increase / prev * 100);
}
function getHumanFriendlyBytes(bytes, format) {
  return bytes < 1e3 ? format(bytes, "byte") : bytes < 1e3 * 1e3 ? format(bytes / 1e3, "kilobyte") : bytes < 1e3 * 1e3 * 1e3 ? format(bytes / (1e3 * 1e3), "megabyte") : bytes < 1e3 * 1e3 * 1e3 * 1e3 ? format(bytes / (1e3 * 1e3 * 1e3), "gigabyte") : format(bytes / (1e3 * 1e3 * 1e3 * 1e3), "terabyte");
}
function serverBackend({ client: _client }) {
  const client2 = _client.withConfig(DEFAULT_STUDIO_CLIENT_OPTIONS), keyValueLoader = new DataLoader__default.default(async (keys) => {
    const keyValuePairs = (await client2.request({
      uri: `/users/me/keyvalue/${keys.join(",")}`,
      withCredentials: !0
    }).catch((error) => (console.error("Error fetching data:", error), Array(keys.length).fill(null)))).reduce(
      (acc, next) => (next != null && next.key && (acc[next.key] = next.value), acc),
      {}
    );
    return keys.map((key) => keyValuePairs[key] || null);
  }), getKeys = (keys) => rxjs.from(keyValueLoader.loadMany(keys)), setKeys = (keyValuePairs) => rxjs.from(
    client2.request({
      method: "PUT",
      uri: "/users/me/keyvalue",
      body: keyValuePairs,
      withCredentials: !0
    })
  ).pipe(
    rxjs.map((response) => response.map((pair) => (keyValueLoader.clear(pair.key), keyValueLoader.prime(pair.key, pair.value), pair.value))),
    rxjs.catchError((error) => (console.error("Error setting data:", error), rxjs.of(Array(keyValuePairs.length).fill(null))))
  );
  return {
    getKey: (key) => getKeys([key]).pipe(rxjs.map((values2) => values2[0])),
    setKey: (key, nextValue) => setKeys([{ key, value: nextValue }]).pipe(rxjs.map((values2) => values2[0])),
    getKeys,
    setKeys
  };
}
function createKeyValueStore({ client: client2 }) {
  const storageBackend = serverBackend({ client: client2 }), setKey$ = new rxjs.Subject(), updates$ = setKey$.pipe(
    operators.switchMap((event) => storageBackend.setKey(event.key, event.value).pipe(
      operators.map((nextValue) => ({
        key: event.key,
        value: nextValue
      }))
    )),
    operators.shareReplay(1)
  );
  return { getKey: (key) => rxjs.merge(
    storageBackend.getKey(key),
    updates$.pipe(
      operators.filter((update) => update.key === key),
      operators.map((update) => update.value)
    )
  ), setKey: (key, value) => (setKey$.next({ key, value }), updates$.pipe(
    operators.filter((update) => update.key === key),
    operators.map((update) => update.value),
    operators.take(1)
  )) };
}
class CorsOriginError extends Error {
  constructor({ projectId }) {
    super("CorsOriginError"), this.projectId = projectId;
  }
}
const memStore = {};
function setItem(key, value) {
  supportsLocalStorage ? localStorage[key] = value : memStore[key] = value;
}
function getItem(key) {
  return supportsLocalStorage ? localStorage[key] : memStore[key];
}
function removeItem(key) {
  supportsLocalStorage ? localStorage.removeItem(key) : delete memStore[key];
}
function createBroadcastChannel(namespace) {
  const storageEvents$ = typeof window > "u" ? rxjs.of() : rxjs.fromEvent(window, "storage"), storageKey = `__studio_local_storage_messaging_${namespace}`, broadcastedMessages$ = new rxjs.Subject(), messages$ = rxjs.merge(
    broadcastedMessages$,
    storageEvents$.pipe(
      operators.filter((event) => event.key === storageKey),
      operators.map((event) => event.newValue),
      operators.filter(isNonNullable$2),
      operators.map((newValue) => JSON.parse(newValue))
    )
  ).pipe(
    // this is important to ensure all new subscribers get a message on subscribe
    operators.shareReplay(1)
  );
  function broadcast(message) {
    try {
      setItem(storageKey, JSON.stringify(message)), removeItem(storageKey), broadcastedMessages$.next(message);
    } catch {
    }
  }
  return { messages: messages$, broadcast };
}
const GithubRootSvg = styled__default.default.svg(({ theme: theme2 }) => {
  const { fg } = theme2.sanity.color.base;
  return styled.css`
    fill: ${fg};
  `;
}), CustomImage = styled__default.default.img`
  height: 19px;
  width: 19px;
  object-fit: contain;
`, GithubLogo = () => /* @__PURE__ */ jsxRuntime.jsx(
  GithubRootSvg,
  {
    width: "1em",
    height: "1em",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 438.55 438.55",
    children: /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M409.13 114.57a218.32 218.32 0 0 0-79.8-79.8Q278.94 5.36 219.27 5.36T109.21 34.77a218.29 218.29 0 0 0-79.8 79.8Q0 165 0 224.63q0 71.67 41.83 128.91t108.06 79.23q7.71 1.43 11.42-2a11.17 11.17 0 0 0 3.69-8.57q0-.86-.14-15.42t-.14-25.41l-6.57 1.14a83.77 83.77 0 0 1-15.85 1 120.73 120.73 0 0 1-19.84-2 44.34 44.34 0 0 1-19.11-8.51 36.23 36.23 0 0 1-12.56-17.6l-2.86-6.57a71.34 71.34 0 0 0-9-14.56q-6.14-8-12.42-10.85l-2-1.43a21 21 0 0 1-3.71-3.43 15.66 15.66 0 0 1-2.57-4q-.86-2 1.43-3.29C61.2 310.42 64 310 68 310l5.71.85q5.71 1.14 14.13 6.85a46.08 46.08 0 0 1 13.85 14.84q6.57 11.71 15.85 17.85t18.7 6.14a81.19 81.19 0 0 0 16.27-1.42 56.78 56.78 0 0 0 12.85-4.29q2.57-19.14 14-29.41a195.49 195.49 0 0 1-29.36-5.13 116.52 116.52 0 0 1-26.83-11.14 76.86 76.86 0 0 1-23-19.13q-9.14-11.42-15-30t-5.8-42.81q0-34.55 22.56-58.82-10.57-26 2-58.24 8.28-2.57 24.55 3.85t23.84 11q7.57 4.56 12.13 7.71a206.2 206.2 0 0 1 109.64 0l10.85-6.85a153.65 153.65 0 0 1 26.26-12.56q15.13-5.71 23.13-3.14 12.84 32.26 2.28 58.24 22.55 24.27 22.56 58.82 0 24.27-5.85 43t-15.12 30a79.82 79.82 0 0 1-23.13 19 116.74 116.74 0 0 1-26.84 11.14 195.29 195.29 0 0 1-29.23 5.07q14.8 12.84 14.81 40.58v60.2a11.37 11.37 0 0 0 3.57 8.56q3.57 3.42 11.28 2 66.24-22 108.07-79.23t41.83-128.91q-.03-59.62-29.43-110.05z" })
  }
), GoogleLogo = () => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    width: "1em",
    height: "1em",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 48 48",
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M11 24a13 13 0 0 1 .66-4.08l-7.4-5.66a22.18 22.18 0 0 0 0 19.49l7.4-5.67A13 13 0 0 1 11 24z",
          fill: "#fbbc05"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 11a12.72 12.72 0 0 1 8.1 2.9l6.4-6.4a22 22 0 0 0-34.24 6.75l7.4 5.66A13 13 0 0 1 24 11z",
          fill: "#ea4335"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 37a13 13 0 0 1-12.34-8.92l-7.4 5.66A21.93 21.93 0 0 0 24 46a21 21 0 0 0 14.33-5.48l-7-5.44A13.59 13.59 0 0 1 24 37zm-12.35-8.93l-7.4 5.67 7.4-5.66z",
          fill: "#34a853"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M44.5 20H24v8.5h11.8a9.91 9.91 0 0 1-4.49 6.58l7 5.44C42.37 36.76 45 31.17 45 24a18.25 18.25 0 0 0-.5-4z",
          fill: "#4285f4"
        }
      )
    ]
  }
);
function CustomLogo(props2) {
  const { provider } = props2;
  return provider.logo ? /* @__PURE__ */ jsxRuntime.jsx(CustomImage, { src: provider.logo, alt: `Logo for ${provider.name}` }) : void 0;
}
const providerLogos = {
  google: GoogleLogo,
  github: GithubLogo
  // sanity: () => <SanityMonogram data-sanity-icon="" />,
};
async function getProviders({
  client: client2,
  mode,
  providers: customProviders = []
}) {
  if (mode === "replace" && Array.isArray(customProviders))
    return customProviders;
  const { providers } = await client2.request({
    uri: "/auth/providers"
  });
  return typeof customProviders == "function" ? customProviders(providers) : customProviders.length === 0 ? providers : mode === "replace" ? customProviders : providers.filter((official) => customProviders.some((provider) => provider.url !== official.url)).concat(customProviders);
}
function createHrefForProvider({
  loginMethod = "dual",
  projectId,
  url,
  redirectPath
}) {
  const params = new URLSearchParams();
  return params.set("origin", `${window.location.origin}${redirectPath}`), params.set("projectId", projectId), loginMethod === "token" ? params.set("withSid", "true") : params.set("type", loginMethod), `${url}?${params}`;
}
function createLoginComponent({
  getClient,
  loginMethod,
  redirectOnSingle,
  ...providerOptions
}) {
  const useClient2 = createHookFromObservableFactory(getClient);
  function LoginComponent({ projectId, ...props2 }) {
    const redirectPath = props2.redirectPath || props2.basePath || "/", [providers, setProviders] = React.useState(null), [error, setError] = React.useState(null);
    if (error)
      throw error;
    const [client2] = useClient2();
    React.useEffect(() => {
      client2 && getProviders({ client: client2, ...providerOptions }).then(setProviders).catch(setError);
    }, [client2]);
    const redirectUrlForRedirectOnSingle = redirectOnSingle && (providers == null ? void 0 : providers.length) === 1 && (providers == null ? void 0 : providers[0]) && createHrefForProvider({
      loginMethod,
      projectId,
      url: providers[0].url,
      redirectPath
    }), loading = !providers || redirectUrlForRedirectOnSingle;
    return React.useEffect(() => {
      redirectUrlForRedirectOnSingle && (window.location.href = redirectUrlForRedirectOnSingle);
    }, [redirectUrlForRedirectOnSingle]), loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { align: "center", size: 1, children: "Choose login provider" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: providers.map((provider, index) => /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          as: "a",
          icon: providerLogos[provider.name] || /* @__PURE__ */ jsxRuntime.jsx(CustomLogo, { provider }),
          href: createHrefForProvider({
            loginMethod,
            projectId,
            url: provider.url,
            redirectPath
          }),
          mode: "ghost",
          size: "large",
          text: provider.title
        },
        `${provider.url}_${index}`
      )) })
    ] });
  }
  return LoginComponent;
}
const sidPattern = /sid=([^&]{20,})&?/;
function consumeSessionId() {
  if (typeof window > "u" || typeof window.location != "object")
    return null;
  const hash2 = window.location.hash, [, sidParam] = hash2.match(sidPattern) || [];
  if (!sidParam)
    return null;
  const newHash = hash2.replace(sidPattern, ""), newUrl = new URL(window.location.href);
  return newUrl.hash = newHash.length > 1 ? newHash : "", history.replaceState(null, "", newUrl), sidParam;
}
let sessionId$1 = consumeSessionId();
const getSessionId$1 = () => {
  const id2 = sessionId$1;
  return id2 && (sessionId$1 = null), id2;
};
function isAuthStore(maybeStore) {
  return isRecord$4(maybeStore) && "state" in maybeStore && isRecord$4(maybeStore.state) && "subscribe" in maybeStore.state && typeof maybeStore.state.subscribe == "function";
}
function isCookielessCompatibleLoginMethod(loginMethod) {
  return ["dual", "token"].includes(loginMethod);
}
const getStorageKey = (projectId) => {
  if (!projectId)
    throw new Error("Invalid project id");
  return `__studio_auth_token_${projectId}`;
}, getToken = (projectId) => {
  try {
    const item = getItem(getStorageKey(projectId));
    if (item) {
      const { token } = JSON.parse(item);
      if (token && typeof token == "string")
        return token;
    }
  } catch (err) {
    console.error(err);
  }
  return null;
}, clearToken = (projectId) => {
  try {
    removeItem(getStorageKey(projectId));
  } catch (err) {
    console.error(err);
  }
}, saveToken = ({ token, projectId }) => {
  try {
    setItem(
      getStorageKey(projectId),
      JSON.stringify({ token, time: (/* @__PURE__ */ new Date()).toISOString() })
    );
  } catch (err) {
    console.error(err);
  }
}, getCurrentUser = async (client2, broadcastToken) => {
  var _a2;
  try {
    const user = await client2.request({
      uri: "/users/me",
      withCredentials: !0,
      tag: "users.get-current"
    });
    return typeof (user == null ? void 0 : user.id) == "string" ? user : null;
  } catch (err) {
    if (err.statusCode === 401)
      return clearToken(client2.config().projectId || ""), broadcastToken(null), null;
    if (await client2.request({ uri: "/ping", withCredentials: !1, tag: "cors-check" }).then(
      () => !0,
      // Request succeeded, so likely the CORS origin is disallowed
      () => !1
      // Request failed, so likely a network error of some kind
    ))
      throw new CorsOriginError({ projectId: (_a2 = client2.config()) == null ? void 0 : _a2.projectId });
    if (err.isNetworkError && !err.message && err.request && err.request.url) {
      const host = new URL(err.request.url).host;
      throw new Error(`Unknown network error attempting to reach ${host}`);
    }
    throw err;
  }
};
function _createAuthStore({
  clientFactory: clientFactoryOption,
  projectId,
  dataset,
  apiHost,
  loginMethod = "dual",
  ...providerOptions
}) {
  const { broadcast, messages } = createBroadcastChannel(`dual_mode_auth_${projectId}`), clientFactory = clientFactoryOption != null ? clientFactoryOption : client.createClient, token$ = messages.pipe(
    operators.startWith(isCookielessCompatibleLoginMethod(loginMethod) ? getToken(projectId) : null)
  ), hostOptions = {};
  apiHost ? hostOptions.apiHost = apiHost : typeof __SANITY_STAGING__ < "u" && __SANITY_STAGING__ === !0 && (hostOptions.apiHost = "https://api.sanity.work");
  const state$ = token$.pipe(
    // // see above
    // debounce(() => firstMessage),
    operators.map(
      (token) => clientFactory({
        projectId,
        dataset,
        apiVersion: "2021-06-07",
        useCdn: !1,
        ...token && { token },
        withCredentials: !0,
        requestTagPrefix: "sanity.studio",
        ignoreBrowserTokenWarning: !0,
        allowReconfigure: !1,
        ...hostOptions
      })
    ),
    operators.switchMap(
      (client2) => rxjs.defer(async () => {
        const currentUser = await getCurrentUser(client2, broadcast);
        return {
          currentUser,
          client: client2,
          authenticated: !!currentUser
        };
      })
    ),
    operators.distinctUntilChanged(
      (prev, next) => (
        // Only notify subscribers if the the currentUser object has changed.
        // Using isEqual is OK since the currentUser object being a small data structure.
        isEqual__default.default(prev.currentUser, next.currentUser)
      )
    ),
    operators.shareReplay(1)
  );
  async function handleCallbackUrl() {
    const sessionId2 = getSessionId$1();
    if (!sessionId2) {
      broadcast(loginMethod === "cookie" ? null : getToken(projectId));
      return;
    }
    const requestClient = clientFactory({
      projectId,
      dataset,
      useCdn: !0,
      withCredentials: !0,
      apiVersion: "2021-06-07",
      requestTagPrefix: "sanity.studio",
      ...hostOptions
    });
    let currentUser;
    if ((loginMethod === "dual" || loginMethod === "cookie") && (currentUser = await getCurrentUser(requestClient, broadcast)), currentUser || loginMethod === "cookie") {
      broadcast(null);
      return;
    }
    const token = await tradeSessionForToken(requestClient, sessionId2);
    broadcast(token != null ? token : null);
  }
  async function tradeSessionForToken(client2, sessionId2) {
    const { token } = await client2.request({
      method: "GET",
      uri: "/auth/fetch",
      query: { sid: sessionId2 },
      tag: "auth.fetch-token"
    });
    return saveToken({ token, projectId }), token;
  }
  async function logout() {
    var _a2;
    const requestClient = clientFactory({
      projectId,
      dataset,
      useCdn: !0,
      withCredentials: !0,
      token: (_a2 = getToken(projectId)) != null ? _a2 : void 0,
      apiVersion: "2021-06-07",
      requestTagPrefix: "sanity.studio",
      ...hostOptions
    });
    clearToken(projectId), await requestClient.request({ uri: "/auth/logout", method: "POST" }), broadcast(null);
  }
  const LoginComponent = createLoginComponent({
    ...providerOptions,
    getClient: () => state$.pipe(operators.map((state) => state.client)),
    loginMethod
  });
  return {
    handleCallbackUrl,
    token: token$,
    state: state$,
    LoginComponent,
    logout
  };
}
function hash(value) {
  return typeof value != "object" || value === null ? `${value}` : JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a.localeCompare(b, "en")).map(([k, v]) => [k, hash(v)])
    )
  );
}
const createAuthStore = memoize__default.default(_createAuthStore, hash);
function getProviderTitle(provider) {
  if (provider === "google")
    return "Google";
  if (provider === "github")
    return "GitHub";
  if (provider === "sanity")
    return "Sanity";
  if (provider != null && provider.startsWith("saml-"))
    return "SAML/SSO";
}
function catchWithCount(selector) {
  return (input$) => {
    let errors = [];
    const errorOp = operators.catchError((err, caught) => (errors.push(err), selector(err, errors.length, caught).pipe(errorOp)));
    return input$.pipe(
      operators.tap(() => {
        errors = [];
      }),
      errorOp
    );
  };
}
const onOnline$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "online"), onOffline$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "offline"), expBackoff = (retryCount) => Math.pow(2, retryCount) * 100, CONNECTING = { type: "connecting" }, _callback = observableCallback.observableCallback(), onRetry$ = _callback[0], onRetry = _callback[1], createErrorStatus = ({
  error,
  isOffline,
  attemptNo,
  retryAt
}) => ({
  type: "error",
  error,
  attemptNo,
  isOffline,
  retryAt
});
function createConnectionStatusStore({
  bifur
}) {
  return { connectionStatus$: rxjs.merge(
    bifur.heartbeats,
    onOffline$.pipe(operators.mergeMapTo(rxjs.throwError(new Error("The browser went offline"))))
  ).pipe(
    operators.map((ts) => ({ type: "connected", lastHeartbeat: ts })),
    catchWithCount((error, successiveErrorsCount, caught) => {
      const timeUntilRetry = Math.min(24e4, expBackoff(successiveErrorsCount)), retryAt = new Date((/* @__PURE__ */ new Date()).getTime() + timeUntilRetry), expiry$ = rxjs.timer(retryAt), isOffline = !navigator.onLine, initialErrorStatus = createErrorStatus({
        error,
        retryAt,
        isOffline,
        attemptNo: successiveErrorsCount
      }), triggerRetry$ = rxjs.NEVER.pipe(
        operators.takeUntil(isOffline ? onOnline$ : rxjs.merge(expiry$, onOnline$, onRetry$))
      );
      return rxjs.concat(rxjs.of(initialErrorStatus), triggerRetry$.pipe(operators.take(1)), caught);
    }),
    operators.startWith(CONNECTING)
  ) };
}
function isBlockType(type) {
  return type.type ? isBlockType(type.type) : type.name === "block";
}
function isArrayOfObjectsFieldMember(member) {
  return member.kind === "field" && member.field.schemaType.jsonType === "array";
}
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/;
function pathToString$1(path) {
  if (!Array.isArray(path))
    throw new Error("Path is not an array");
  return path.reduce((target, segment, i) => {
    if (types.isIndexSegment(segment))
      return `${target}[${segment}]`;
    if (types.isKeySegment(segment) && segment._key)
      return `${target}[_key=="${segment._key}"]`;
    if (types.isIndexTuple(segment)) {
      const [from, to] = segment;
      return `${target}[${from}:${to}]`;
    }
    if (typeof segment == "string")
      return `${target}${i === 0 ? "" : "."}${segment}`;
    throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
  }, "");
}
function getValueAtPath(rootValue, path) {
  const segment = path[0];
  if (!segment)
    return rootValue;
  const tail = path.slice(1);
  if (types.isIndexSegment(segment))
    return getValueAtPath(Array.isArray(rootValue) ? rootValue[segment] : void 0, tail);
  if (types.isKeySegment(segment))
    return getValueAtPath(
      Array.isArray(rootValue) ? rootValue.find((item) => item._key === segment._key) : void 0,
      tail
    );
  if (typeof segment == "string")
    return getValueAtPath(isRecord$4(rootValue) ? rootValue[segment] : void 0, tail);
  throw new Error(`Unknown segment type ${JSON.stringify(segment)}`);
}
function findIndex(array, segment) {
  return typeof segment != "number" && !types.isKeySegment(segment) ? -1 : typeof segment == "number" ? segment : array.findIndex((item) => types.isKeyedObject(item) && item._key === segment._key);
}
function stringToPath(path) {
  const segments = path.match(rePropName);
  if (!segments)
    throw new Error("Invalid path string");
  return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
  return types.isIndexSegment(segment) ? normalizeIndexSegment(segment) : types.isKeySegment(segment) ? normalizeKeySegment(segment) : types.isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
  const segments = segment.match(reKeySegment);
  if (!segments)
    throw new Error("Invalid key segment");
  return { _key: segments[1] };
}
function normalizeIndexTupleSegment(segment) {
  const [from, to] = segment.split(":").map((seg) => seg === "" ? seg : Number(seg));
  return [from, to];
}
function pathsAreEqual(pathA, pathB) {
  return pathA.length !== pathB.length ? !1 : pathA.every((segmentA, index) => {
    const segmentB = pathB[index];
    return types.isKeySegment(segmentA) && types.isKeySegment(segmentB) ? segmentA._key === segmentB._key : types.isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : types.isIndexTuple(segmentA) && types.isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;
  });
}
function getItemKey(arrayItem) {
  return types.isKeyedObject(arrayItem) ? arrayItem._key : void 0;
}
function getItemKeySegment(arrayItem) {
  const key = getItemKey(arrayItem);
  return key ? { _key: key } : void 0;
}
function isEmptyObject$1(item) {
  return typeof item == "object" && item !== null && Object.keys(item).length <= 0;
}
function getAnnotationColor(colorManager, annotation) {
  return colorManager.get((annotation == null ? void 0 : annotation.author) || null);
}
function getAnnotationAtPath(diff2, diffPath) {
  const path = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getAnnotationAt(diff2, path);
}
function getDiffAtPath(diff2, diffPath) {
  const path = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getDiffAt(diff2, path);
}
function getAnnotationAt(diff2, path) {
  const diffAt = getDiffAt(diff2, path);
  if (diffAt && diffAt.action !== "unchanged")
    return diffAt.annotation || void 0;
}
function getDiffAt(diff2, path, parentPath = []) {
  if (path.length === 0)
    return diff2;
  const segment = path[0], tail = path.slice(1);
  if (types.isIndexTuple(segment))
    throw new Error("Index tuples are not supported in diff paths");
  if (types.isIndexSegment(segment) || types.isKeySegment(segment)) {
    const location = types.isIndexSegment(segment) ? `at index ${segment}` : `with key ${segment._key}`;
    if (diff2.type !== "array") {
      `${location}${pathToString$1(parentPath)}`;
      return;
    }
    const itemDiff = diff2.items.find(
      types.isIndexSegment(segment) ? (item) => item.toIndex === segment : (item) => itemMatchesKey(item, segment)
    );
    if (!itemDiff) {
      `${location}${pathToString$1(parentPath)}`;
      return;
    }
    return getDiffAt(itemDiff.diff, tail, parentPath.concat(segment));
  }
  if (diff2.type !== "object") {
    `${segment}${pathToString$1(parentPath)}`;
    return;
  }
  const fieldDiff = diff2.fields[segment];
  if (typeof fieldDiff > "u") {
    `${segment}${pathToString$1(parentPath)}`;
    return;
  }
  return getDiffAt(fieldDiff, tail, parentPath.concat(segment));
}
function itemMatchesKey(item, key) {
  const itemDiff = item.diff;
  return itemDiff.type !== "object" || !itemDiff.toValue ? !1 : itemDiff.toValue._key === key;
}
function visitDiff(diff2, visitor, path = []) {
  if (visitor(diff2, path)) {
    if (diff2.type === "array") {
      visitArrayDiff(diff2, visitor, path);
      return;
    }
    if (diff2.type === "object") {
      visitObjectDiff(diff2, visitor, path);
      return;
    }
    diff2.type === "string" && visitStringDiff(diff2, visitor, path);
  }
}
function visitArrayDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && diff2.items.forEach((itemDiff) => {
    var _a2;
    const _key = itemDiff.diff.type === "object" && ((_a2 = itemDiff.diff.toValue) == null ? void 0 : _a2._key), segment = _key ? { _key } : getItemDiffIndex(itemDiff);
    visitDiff(itemDiff.diff, visitor, path.concat(segment));
  });
}
function visitObjectDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && Object.keys(diff2.fields).forEach((fieldName) => {
    const fieldDiff = diff2.fields[fieldName];
    visitDiff(fieldDiff, visitor, path.concat(fieldName));
  });
}
function visitStringDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && diff2.segments.forEach((segment) => {
    visitDiff(segment, visitor, path);
  });
}
function getItemDiffIndex(itemDiff) {
  return typeof itemDiff.toIndex > "u" ? itemDiff.fromIndex || 0 : itemDiff.toIndex;
}
const UserColorManagerContext = React.createContext(null);
function useUserColorManager() {
  const userColorManager = React.useContext(UserColorManagerContext);
  if (!userColorManager)
    throw new Error("UserColorManager: missing context value");
  return userColorManager;
}
function useUserColor(userId) {
  const manager = useUserColorManager();
  return reactRx.useMemoObservable(userId ? manager.listen(userId) : rxjs.empty(), [userId], manager.get(null));
}
const DEFAULT_CURRENT_USER_HUE = "purple", USER_COLOR_EXCLUDE_HUES = ["green", "red", "gray"], defaultHues = color.COLOR_HUES.filter(
  (hue) => !USER_COLOR_EXCLUDE_HUES.includes(hue)
), getTints = (scheme) => {
  const isDarkScheme = scheme === "dark";
  return {
    background: isDarkScheme ? "900" : "100",
    border: isDarkScheme ? "700" : "300",
    text: isDarkScheme ? "200" : "700"
  };
}, getDefaultColors = (scheme) => {
  const { background, border, text } = getTints(scheme);
  return defaultHues.reduce(
    (colors, hue) => (colors[hue] = {
      name: hue,
      background: color.hues[hue][background].hex,
      border: color.hues[hue][border].hex,
      text: color.hues[hue][text].hex,
      tints: color.hues[hue]
    }, colors),
    {}
  );
}, getAnonymousColor = (scheme) => {
  const { background, border, text } = getTints(scheme);
  return {
    name: "gray",
    background: color.hues.gray[background].hex,
    border: color.hues.gray[border].hex,
    text: color.hues.gray[text].hex,
    tints: color.hues.gray
  };
};
function createUserColorManager(options) {
  const {
    anonymousColor: anonymousColorProp,
    colors,
    currentUserColor: currentUserColorProp,
    scheme
  } = options, userColors = colors || getDefaultColors(scheme), anonymousColor = anonymousColorProp || getAnonymousColor(scheme), currentUserColor = currentUserColorProp || DEFAULT_CURRENT_USER_HUE;
  if (!userColors.hasOwnProperty(currentUserColor))
    throw new Error(`'colors' must contain 'currentUserColor' (${currentUserColor})`);
  const userColorKeys = Object.keys(userColors), subscriptions = /* @__PURE__ */ new Map(), previouslyAssigned = /* @__PURE__ */ new Map(), assignedCounts = userColorKeys.reduce(
    (counts, color2) => (counts[color2] = 0, counts),
    {}
  ), assigned = /* @__PURE__ */ new Map();
  let currentUserId;
  return options != null && options.userStore && options.userStore.me.subscribe((user) => setCurrentUser(user ? user.id : null)), { get: get2, listen: listen2 };
  function get2(userId) {
    return userId ? userColors[getUserHue(userId)] : anonymousColor;
  }
  function getUserHue(userId) {
    if (userId === currentUserId)
      return currentUserColor;
    const assignedHue = assigned.get(userId);
    if (assignedHue)
      return assignedHue;
    const prevHue = previouslyAssigned.get(userId);
    if (prevHue && (assignedCounts[prevHue] === 0 || !hasUnusedColor()))
      return assignHue(userId, prevHue);
    const preferredHue = getPreferredHue(userId);
    return assignedCounts[preferredHue] === 0 ? assignHue(userId, preferredHue) : assignHue(userId, getLeastUsedHue(prevHue));
  }
  function listen2(userId) {
    let subscription = subscriptions.get(userId);
    if (subscription)
      return subscription;
    const hue = getUserHue(userId);
    return subscription = getObservableColor(userId, hue), subscriptions.set(userId, subscription), subscription;
  }
  function assignHue(userId, hue) {
    return assigned.set(userId, hue), previouslyAssigned.set(userId, hue), assignedCounts[hue]++, hue;
  }
  function unassignHue(userId, hue) {
    assigned.delete(userId), assignedCounts[hue]--;
  }
  function getUnusedColor() {
    return userColorKeys.find((colorHue) => assignedCounts[colorHue] === 0);
  }
  function hasUnusedColor() {
    return !!getUnusedColor();
  }
  function getLeastUsedHue(tieBreakerPreference) {
    let leastUses = 1 / 0, leastUsed = [];
    return userColorKeys.forEach((colorHue) => {
      const uses = assignedCounts[colorHue];
      uses === leastUses ? leastUsed.push(colorHue) : uses < leastUses && (leastUses = uses, leastUsed = [colorHue]);
    }), tieBreakerPreference && leastUsed.includes(tieBreakerPreference) ? tieBreakerPreference : leastUsed[0];
  }
  function getObservableColor(userId, hue) {
    return new rxjs.Observable((subscriber) => {
      const userColor = userColors[hue];
      return subscriber.next(userColor), () => {
        subscriptions.delete(userId), unassignHue(userId, hue);
      };
    }).pipe(operators.shareReplay({ refCount: !0 }));
  }
  function setCurrentUser(userId) {
    currentUserId = userId, assignedCounts[currentUserColor] += userId ? 1 : -1;
  }
  function getPreferredHue(userId) {
    let hash2 = 0;
    for (let i = 0; i < userId.length; i++)
      hash2 = (hash2 << 5) - hash2 + userId.charCodeAt(i) | 0;
    return userColorKeys[Math.abs(hash2) % userColorKeys.length];
  }
}
function UserColorManagerProvider({
  children,
  manager: managerFromProps
}) {
  const { scheme } = useColorScheme(), manager = React.useMemo(() => managerFromProps || createUserColorManager({ scheme }), [managerFromProps, scheme]);
  return /* @__PURE__ */ jsxRuntime.jsx(UserColorManagerContext.Provider, { value: manager, children });
}
function useAnnotationColor(annotation) {
  const userColorManager = useUserColorManager();
  return getAnnotationColor(userColorManager, annotation);
}
function useDiffAnnotationColor(diff2, path = []) {
  const userColorManager = useUserColorManager(), annotation = React.useMemo(() => getAnnotationAtPath(diff2, path), [diff2, path]);
  return React.useMemo(
    () => getAnnotationColor(userColorManager, annotation),
    [annotation, userColorManager]
  );
}
function DiffTooltip(props2) {
  if (!("diff" in props2))
    return /* @__PURE__ */ jsxRuntime.jsx(DiffTooltipWithAnnotation, { ...props2 });
  const { diff: diff2, path = [], ...restProps } = props2, annotation = getAnnotationAtPath(diff2, path);
  return /* @__PURE__ */ jsxRuntime.jsx(DiffTooltipWithAnnotation, { ...restProps, annotations: annotation ? [annotation] : [] });
}
function DiffTooltipWithAnnotation(props2) {
  const { annotations, children, description, ...restProps } = props2, { t: t2 } = useTranslation();
  if (!annotations)
    return children;
  const content2 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: description || t2("changes.changed-label") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: annotations.map((annotation, idx) => /* @__PURE__ */ jsxRuntime.jsx(AnnotationItem, { annotation }, idx)) })
  ] });
  return /* @__PURE__ */ jsxRuntime.jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: content2, portal: !0, ...restProps, children }) });
}
function AnnotationItem({ annotation }) {
  const { author, timestamp } = annotation, [user] = useUser(author), color2 = useAnnotationColor(annotation), timeAgo = useRelativeTime(timestamp, { minimal: !0 }), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        align: "center",
        paddingRight: 3,
        style: {
          backgroundColor: color2.background,
          color: color2.text,
          borderRadius: "calc(23px / 2)"
        },
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { user: author }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: { color: color2.text }, children: user ? user.displayName : t2("changes.loading-author") }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "time", muted: !0, size: 1, dateTime: timestamp, children: timeAgo })
  ] });
}
const StyledCard$3 = styled__default.default(ui.Card)`
  --diff-card-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  --diff-card-bg-color: ${({ theme: theme2 }) => theme2.sanity.color.card.enabled.bg};

  max-width: 100%;
  position: relative;
  border-radius: var(--diff-card-radius);

  &:not(del) {
    text-decoration: none;
  }

  &[data-hover] {
    &::after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
    }

    &:hover {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;

      &::after {
        bottom: -3px;
        border-top: 1px solid var(---diff-card-bg-color);
        border-bottom: 2px solid currentColor;
        border-bottom-left-radius: var(--diff-card-radius);
        border-bottom-right-radius: var(--diff-card-radius);
      }
    }

    [data-from-to-layout]:hover & {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;

      &::after {
        bottom: -3px;
        border-top: 1px solid var(---diff-card-bg-color);
        border-bottom: 2px solid currentColor;
        border-bottom-left-radius: var(--diff-card-radius);
        border-bottom-right-radius: var(--diff-card-radius);
      }
    }
  }
`, EMPTY_PATH$1 = [], DiffCard = React.forwardRef(function(props2, ref) {
  const {
    annotation: annotationProp,
    as = "div",
    children,
    className,
    diff: diff2,
    disableHoverEffect,
    path = EMPTY_PATH$1,
    style = {},
    tooltip,
    ...restProps
  } = props2, annotation = React.useMemo(
    () => annotationProp || getAnnotationAtPath(diff2, path),
    [annotationProp, diff2, path]
  ), color2 = useAnnotationColor(annotation), element = /* @__PURE__ */ jsxRuntime.jsx(
    StyledCard$3,
    {
      ...restProps,
      as,
      className,
      "data-hover": disableHoverEffect || !annotation ? void 0 : "",
      ref,
      radius: 1,
      style: {
        ...style,
        backgroundColor: color2.background,
        color: color2.text
      },
      children
    }
  );
  return tooltip && annotation ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffTooltip,
    {
      annotations: [annotation],
      description: tooltip && typeof tooltip == "object" && tooltip.description,
      children: element
    }
  ) : element;
}), RoundedCard$1 = styled__default.default.div`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  padding: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
`, AnnotationText = styled__default.default(ui.Text)`
  &:not([hidden]) {
    color: inherit;
  }
`;
function ChangeTitleSegment(props2) {
  const { change, segment } = props2;
  if (typeof segment == "string")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: segment, size: 1, weight: "medium", textOverflow: "ellipsis", children: segment }) });
  const { hasMoved, fromIndex, toIndex, annotation } = segment, created = typeof fromIndex > "u", deleted = typeof toIndex > "u";
  if (created)
    return /* @__PURE__ */ jsxRuntime.jsx(CreatedTitleSegment, { annotation, change, toIndex });
  if (deleted)
    return /* @__PURE__ */ jsxRuntime.jsx(DeletedTitleSegment, { annotation, fromIndex });
  if (hasMoved && typeof toIndex < "u" && typeof fromIndex < "u")
    return /* @__PURE__ */ jsxRuntime.jsx(MovedTitleSegment, { annotation, fromIndex, toIndex });
  const readableIndex = (toIndex || 0) + 1;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
    "#",
    readableIndex
  ] }) });
}
function CreatedTitleSegment(props2) {
  const { annotation: annotationProp, change, toIndex = 0 } = props2, { t: t2 } = useTranslation(), readableIndex = toIndex + 1, description = t2("changes.array.item-added-in-position", { position: readableIndex }), content2 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    "#",
    readableIndex
  ] }), annotation = (change != null && change.diff ? getAnnotationAtPath(change.diff, []) : void 0) || annotationProp;
  return annotation ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation, tooltip: { description }, as: RoundedCard$1, children: /* @__PURE__ */ jsxRuntime.jsx(AnnotationText, { size: 1, weight: "medium", forwardedAs: "ins", style: { textDecoration: "none" }, children: content2 }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: content2 });
}
function DeletedTitleSegment(props2) {
  const { annotation, fromIndex = 0 } = props2, { t: t2 } = useTranslation(), readableIndex = fromIndex + 1, description = t2("changes.array.item-removed-from-position", { position: readableIndex });
  return /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: annotation || null, as: RoundedCard$1, tooltip: { description }, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", forwardedAs: "del", children: [
    "#",
    readableIndex
  ] }) });
}
function MovedTitleSegment(props2) {
  const { annotation, fromIndex, toIndex } = props2, { t: t2 } = useTranslation(), indexDiff = toIndex - fromIndex, indexSymbol = indexDiff < 0 ? "\u2191" : "\u2193", positions = Math.abs(indexDiff), direction = indexDiff < 0 ? "up" : "down", description = t2("changes.array.item-moved", {
    count: positions,
    context: direction
  });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", children: [
      "#",
      toIndex + 1
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation, as: RoundedCard$1, tooltip: { description }, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", children: [
      indexSymbol,
      Math.abs(indexDiff)
    ] }) })
  ] });
}
function ChangeBreadcrumb(props2) {
  const { change, titlePath } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Breadcrumbs,
    {
      maxLength: 4,
      separator: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }),
      children: titlePath.map((titleSegment, idx) => typeof titleSegment == "string" || !change || change.showIndex ? /* @__PURE__ */ jsxRuntime.jsx(ChangeTitleSegment, { change, segment: titleSegment }, idx) : null)
    }
  );
}
function isThenable(value) {
  return isRecord$4(value) && typeof (value == null ? void 0 : value.then) == "function";
}
function useCheckCondition(checkProperty, checkPropertyName, context) {
  const { currentUser, document: document2, parent, value } = context, didWarn2 = React.useRef(!1);
  return React.useMemo(() => {
    let isTrueIsh = !1;
    if (typeof checkProperty == "boolean" || checkProperty === void 0)
      return checkProperty || !1;
    try {
      isTrueIsh = checkProperty({
        document: document2,
        parent,
        value,
        currentUser
      });
    } catch (err) {
      return console.error(
        `An error occurred while running the callback from \`${checkPropertyName}\`: ${err.message}`
      ), !1;
    }
    return isThenable(isTrueIsh) && !didWarn2.current ? (console.warn(
      `The \`${checkPropertyName}\` option is either a promise or a promise returning function. Async callbacks for \`${checkPropertyName}\` option is not currently supported.`
    ), !1) : (typeof isTrueIsh > "u" && console.warn(
      `The \`${checkPropertyName}\` option is or returned \`undefined\`. \`${checkPropertyName}\` should return a boolean.`
    ), isTrueIsh);
  }, [checkProperty, document2, parent, value, currentUser, checkPropertyName]);
}
const useConditionalProperty = (props2) => {
  const { checkProperty = !1, checkPropertyKey, document: document2, parent, value: valueProp } = props2, value = useUnique(valueProp), currentUser = useCurrentUser();
  return useCheckCondition(checkProperty, checkPropertyKey, {
    currentUser,
    document: document2,
    parent,
    value
  });
};
function resolveTypeName(value) {
  return types.isTypedObject(value) ? value._type : resolveJSType(value);
}
function getArrayDiffItemType(diff2, schemaType) {
  return diff2.action === "added" ? {
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  } : diff2.action === "changed" ? {
    fromType: resolveArrayMemberType(schemaType, diff2.fromValue),
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  } : diff2.action === "removed" ? {
    fromType: resolveArrayMemberType(schemaType, diff2.fromValue)
  } : {
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  };
}
function resolveArrayMemberType(schemaType, value) {
  const typeName = resolveTypeName(value);
  return schemaType.of.find((candidate) => candidate.name === typeName) || (schemaType.of.length === 1 ? schemaType.of[0] : void 0);
}
function resolveJSType(val) {
  return Array.isArray(val) ? "array" : val === null ? "null" : typeof val;
}
const ANNOTATION_SYMBOLS = [
  // [startTag, endTag]
  ["\uF050", "\uF051"],
  ["\uF052", "\uF053"],
  ["\uF054", "\uF055"],
  ["\uF056", "\uF057"],
  ["\uF058", "\uF059"],
  ["\uF05A", "\uF05B"],
  ["\uF05C", "\uF05D"],
  ["\uF05F", "\uF060"],
  ["\uF061", "\uF062"],
  ["\uF063", "\uF064"],
  ["\uF065", "\uF066"],
  ["\uF067", "\uF068"],
  ["\uF069", "\uF06A"],
  ["\uF06B", "\uF06C"],
  ["\uF06E", "\uF06F"],
  ["\uF070", "\uF071"],
  ["\uF072", "\uF073"],
  ["\uF074", "\uF075"],
  ["\uF076", "\uF077"],
  ["\uF078", "\uF079"],
  ["\uF07A", "\uF07B"],
  ["\uF07C", "\uF07D"],
  ["\uF07E", "\uF07F"],
  ["\uF080", "\uF081"],
  ["\uF082", "\uF083"],
  ["\uF084", "\uF085"],
  ["\uF086", "\uF087"],
  ["\uF088", "\uF089"],
  ["\uF08A", "\uF08B"],
  ["\uF08C", "\uF08D"],
  ["\uF08E", "\uF08F"]
], CHILD_SYMBOL = "\uF0D0", DECORATOR_SYMBOLS = [
  // [startTag, endTag]
  ["\uF000", "\uF001"],
  ["\uF002", "\uF003"],
  ["\uF004", "\uF005"],
  ["\uF006", "\uF007"],
  ["\uF008", "\uF009"],
  ["\uF00A", "\uF00B"],
  ["\uF00C", "\uF00D"],
  ["\uF00F", "\uF010"],
  ["\uF011", "\uF012"],
  ["\uF013", "\uF014"],
  ["\uF015", "\uF016"],
  ["\uF017", "\uF018"],
  ["\uF019", "\uF01A"],
  ["\uF01B", "\uF01C"],
  ["\uF01E", "\uF01F"],
  ["\uF020", "\uF021"]
], EMPTY_BLOCK_SYMBOL = "\u21B2", INLINE_SYMBOLS = [
  "\uF090",
  "\uF091",
  "\uF092",
  "\uF093",
  "\uF094",
  "\uF095",
  "\uF096",
  "\uF097",
  "\uF098",
  "\uF099",
  "\uF09A",
  "\uF09B",
  "\uF09C",
  "\uF09D",
  "\uF09E",
  "\uF09F",
  "\uF0A0",
  "\uF0A1",
  "\uF0A2",
  "\uF0A3",
  "\uF0A4",
  "\uF0A5",
  "\uF0A6",
  "\uF0A7",
  "\uF0A8",
  "\uF0A9",
  "\uF0AA",
  "\uF0AB",
  "\uF0AC",
  "\uF0AD",
  "\uF0AE",
  "\uF0AF",
  "\uF0B0",
  "\uF0B1",
  "\uF0B2",
  "\uF0B3",
  "\uF0B4",
  "\uF0B5",
  "\uF0B6",
  "\uF0B7",
  "\uF0B8",
  "\uF0B9",
  "\uF0BA",
  "\uF0BB",
  "\uF0BC",
  "\uF0BD",
  "\uF0BE",
  "\uF0BF"
], TRAILING_SPACE_SYMBOL = "\u205F", SEGMENT_START_SYMBOL = "\u2060";
function hasPTMemberType(schemaType) {
  return schemaType.of.some(isPTSchemaType);
}
const startMarkSymbols = DECORATOR_SYMBOLS.map((set2) => set2[0]).concat(
  ANNOTATION_SYMBOLS.map((set2) => set2[0])
), endMarkSymbols = DECORATOR_SYMBOLS.map((set2) => set2[1]).concat(
  ANNOTATION_SYMBOLS.map((set2) => set2[1])
), allSymbols = startMarkSymbols.concat(endMarkSymbols).concat(INLINE_SYMBOLS).concat(CHILD_SYMBOL).concat(SEGMENT_START_SYMBOL), symbolRegex = new RegExp(`${allSymbols.join("|")}`, "g"), segmentRegex = new RegExp(`${allSymbols.join("|")}|
`, "g");
function isPTSchemaType(schemaType) {
  return schemaType.jsonType === "object" && schemaType.name === "block";
}
function isHeader(node) {
  return types.isPortableTextTextBlock(node) && !!node.style && ["h1", "h2", "h3", "h4", "h5", "h6"].includes(node.style);
}
function findChildDiff(diff2, child) {
  return diff2.fields.children.items.filter(
    (item) => item.diff.isChanged && (item.diff.toValue === child || item.diff.fromValue === child)
  ).map((item) => item.diff).map((childDiff) => childDiff)[0];
}
function getChildSchemaType(fields, child) {
  const childrenField = fields.find((f) => f.name === "children");
  return childrenField && childrenField.type && childrenField.type.jsonType === "array" && childrenField.type.of.find((type) => type.name === child._type) || void 0;
}
function getDecorators(spanSchemaType) {
  return spanSchemaType.decorators ? orderBy__default.default(spanSchemaType.decorators, ["value"], ["asc"]) : [];
}
function isDecorator(name, schemaType) {
  return getDecorators(schemaType).some((dec2) => dec2.value === name);
}
function blockToSymbolizedText(diff2, block, decoratorMap, annotationMap, inlineMap) {
  return block ? block.children.map((child) => {
    var _a2;
    let returned = types.isPortableTextSpan(child) ? (_a2 = child.text) == null ? void 0 : _a2.replace(symbolRegex, "") : "";
    if (types.isPortableTextSpan(child)) {
      const spanDiff = findSpanDiffFromChild(diff2, child), textDiff = spanDiff == null ? void 0 : spanDiff.fields.text;
      textDiff && textDiff.toValue === child.text && textDiff.type === "string" && textDiff.action !== "unchanged" && (returned = textDiff.segments.filter((seg) => seg.action !== "removed").map((seg) => seg.text.replace(symbolRegex, "")).join(SEGMENT_START_SYMBOL)), child.marks && child.marks.forEach((mark) => {
        decoratorMap[mark] ? returned = `${decoratorMap[mark][0]}${returned}${decoratorMap[mark][1]}` : annotationMap[mark] && (returned = `${annotationMap[mark][0]}${returned}${annotationMap[mark][1]}`);
      });
    } else
      returned = inlineMap[child._key];
    return `${CHILD_SYMBOL}${returned}`;
  }).join("") : "";
}
function createPortableTextDiff(diff2, schemaType) {
  const displayValue = diff2.action === "removed" ? diff2.fromValue : diff2.toValue, _diff = {
    ...diff2,
    origin: diff2,
    displayValue
  };
  if (displayValue) {
    const annotationMap = {}, decoratorMap = {}, inlineMap = {}, spanSchemaType = getChildSchemaType(schemaType.fields, {
      _key: "bogus",
      _type: "span"
    });
    spanSchemaType && getDecorators(spanSchemaType).forEach((dec2, index) => {
      decoratorMap[dec2.value] = DECORATOR_SYMBOLS[index];
    }), getAllMarkDefs(_diff.origin).forEach((markDef, index) => {
      annotationMap[markDef._key] = ANNOTATION_SYMBOLS[index];
    }), getInlineObjects(_diff.origin).forEach((inline, index) => {
      inlineMap[inline._key] = INLINE_SYMBOLS[index];
    });
    const fromText = blockToSymbolizedText(
      _diff.origin,
      _diff.fromValue,
      decoratorMap,
      annotationMap,
      inlineMap
    ), toText = blockToSymbolizedText(
      _diff.origin,
      _diff.toValue,
      decoratorMap,
      annotationMap,
      inlineMap
    ), toPseudoValue = {
      ...displayValue,
      children: [
        {
          _type: "span",
          _key: "pseudoSpanKey",
          text: toText,
          marks: []
        }
      ]
    }, fromPseudoValue = {
      displayValue,
      children: [
        {
          _type: "span",
          _key: "pseudoSpanKey",
          text: fromText,
          marks: []
        }
      ]
    };
    return {
      origin: diff2,
      action: "changed",
      type: "object",
      displayValue: toPseudoValue,
      fromValue: fromPseudoValue,
      toValue: toPseudoValue,
      isChanged: !0,
      fields: {
        children: {
          action: "changed",
          type: "array",
          isChanged: !0,
          items: [
            {
              diff: {
                action: "changed",
                type: "object",
                isChanged: !0,
                fields: {
                  text: {
                    type: "string",
                    action: "changed",
                    isChanged: !0,
                    fromValue: fromText,
                    toValue: toText,
                    segments: buildSegments(fromText, toText).map((seg) => ({
                      ...seg,
                      ..._diff.action !== "unchanged" && _diff.annotation ? { annotation: _diff.annotation } : {}
                    }))
                  }
                },
                fromValue: fromPseudoValue.children[0],
                toValue: toPseudoValue.children[0]
              },
              annotation: null,
              fromIndex: 0,
              toIndex: 0,
              hasMoved: !1
            }
          ],
          fromValue: fromPseudoValue.children,
          toValue: toPseudoValue.children
        }
      }
    };
  }
  throw new Error("Can not display this diff");
}
function buildSegments(fromInput, toInput) {
  const segments = [], dmpDiffs = diffMatchPatch$1.cleanupEfficiency(diffMatchPatch$1.makeDiff(fromInput, toInput));
  let fromIdx = 0, toIdx = 0;
  for (const [op, text] of dmpDiffs)
    switch (op) {
      case diffMatchPatch$1.DIFF_EQUAL:
        segments.push({
          type: "stringSegment",
          action: "unchanged",
          text
        }), fromIdx += text.length, toIdx += text.length;
        break;
      case diffMatchPatch$1.DIFF_DELETE:
        segments.push({
          type: "stringSegment",
          action: "removed",
          text: fromInput.substring(fromIdx, fromIdx + text.length),
          annotation: null
        }), fromIdx += text.length;
        break;
      case diffMatchPatch$1.DIFF_INSERT:
        segments.push({
          type: "stringSegment",
          action: "added",
          text: toInput.substring(toIdx, toIdx + text.length),
          annotation: null
        }), toIdx += text.length;
        break;
    }
  return flatten__default.default(
    segments.map((seg) => {
      const newSegments = [];
      if (seg.text.length > 1) {
        const markMatches = [...seg.text.matchAll(segmentRegex)];
        let lastIndex = -1;
        markMatches.forEach((match) => {
          const index = match.index || 0;
          index > lastIndex && (newSegments.push({ ...seg, text: seg.text.substring(lastIndex + 1, index) }), newSegments.push({ ...seg, text: match[0] })), match === markMatches[markMatches.length - 1] && newSegments.push({ ...seg, text: seg.text.substring(index + 1) }), lastIndex = index;
        }), markMatches.length === 0 && newSegments.push(seg);
      } else
        newSegments.push(seg);
      return newSegments;
    })
  );
}
function getInlineObjects(diff2) {
  const allChildren = [
    ...diff2.toValue ? diff2.toValue.children.filter((cld) => cld._type !== "span") : []
  ];
  return (diff2.fromValue ? diff2.fromValue.children.filter((cld) => cld._type !== "span") : []).forEach((oCld) => {
    allChildren.some((cld) => oCld._key === cld._key) || allChildren.push(oCld);
  }), orderBy__default.default(allChildren, ["_key"], ["asc"]);
}
function findSpanDiffFromChild(diff2, child) {
  const candidate = diff2.fields.children && diff2.fields.children.action !== "unchanged" && diff2.fields.children.type === "array" && diff2.fields.children.items.find(
    (item) => item.diff && item.diff.type === "object" && (item.diff.action === "removed" ? item.diff.fromValue && item.diff.fromValue._key === child._key : (item.diff.toValue && item.diff.toValue._key) === child._key)
  );
  if (candidate)
    return candidate.diff;
}
function findAnnotationDiff(diff2, markDefKey) {
  var _a2;
  return diff2.fields.markDefs && diff2.fields.markDefs.isChanged && diff2.fields.markDefs.type === "array" && ((_a2 = diff2.fields.markDefs.items.find(
    (item) => item.diff && item.diff.type === "object" && (item.diff.toValue && item.diff.toValue._key && item.diff.toValue._key === markDefKey || item.diff.fromValue && item.diff.fromValue._key && item.diff.fromValue._key === markDefKey)
  )) == null ? void 0 : _a2.diff) || void 0;
}
function isEmptyObject(object) {
  return object && isEqual__default.default(Object.keys(object), ["_key", "_type"]) || !1;
}
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getAllMarkDefs(diff2) {
  const allDefs = [
    ...diff2.toValue && diff2.toValue.markDefs ? diff2.toValue.markDefs : []
  ];
  return (diff2.fromValue && diff2.fromValue.markDefs ? diff2.fromValue.markDefs : []).forEach((oDef) => {
    allDefs.some((def) => oDef._key === def._key) || allDefs.push(oDef);
  }), orderBy__default.default(allDefs, ["_key"], ["asc"]);
}
function getPrintableType(value) {
  const nativeType = typeof value;
  if (nativeType === "object") {
    if (value === null)
      return "null";
    if (Array.isArray(value))
      return "array";
    if (value instanceof Object && value.constructor.name !== "Object")
      return value.constructor.name;
  }
  return nativeType;
}
function getValueError(value, schemaType) {
  const { jsonType } = schemaType, valueType = Array.isArray(value) ? "array" : typeof value;
  if (!(value === null || valueType === "undefined")) {
    if (valueType !== jsonType)
      return {
        messageKey: "changes.error.incorrect-type-message",
        value,
        expectedType: jsonType,
        actualType: getPrintableType(value)
      };
    if (isObjectType(schemaType) && isObjectValue(value))
      for (const field of schemaType.fields) {
        const fieldError = getValueError(value[field.name], field.type);
        if (fieldError)
          return fieldError;
      }
  }
}
function isObjectType(schemaType) {
  return schemaType.jsonType === "object";
}
function isObjectValue(value) {
  return value !== null && !Array.isArray(value) && typeof value == "object";
}
function noop$2() {
}
function isFieldChange(change) {
  return change.type === "field";
}
function isGroupChange(change) {
  return change.type === "group";
}
function isAddedItemDiff(item) {
  return item.diff.action === "added";
}
function isRemovedItemDiff(item) {
  return item.diff.action === "removed";
}
function isUnchangedDiff(diff2) {
  return diff2.action === "unchanged";
}
const diffResolvers = [];
function Checkbox({ checked, color: color2 }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      width: "17",
      height: "17",
      viewBox: "0 0 17 17",
      xmlns: "http://www.w3.org/2000/svg",
      fill: color2 == null ? void 0 : color2.background,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "0", y: "0", width: "17", height: "17", rx: "2.5" }),
        typeof checked > "u" && /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M4.07996 8.5H12.92", stroke: color2 == null ? void 0 : color2.text, strokeWidth: "2" }),
        checked && /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M3.5 8L7 11.5L13.5 5", stroke: color2 == null ? void 0 : color2.text, strokeWidth: "2" })
      ]
    }
  );
}
function Switch({ checked, color: color2 }) {
  return /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "38", height: "22", viewBox: "0 0 38 22", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "38", height: "22", rx: "11", fill: checked ? color2 == null ? void 0 : color2.border : color2 == null ? void 0 : color2.background }),
    typeof checked > "u" && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "11", y: "3", width: "16", height: "16", rx: "8", fill: "white" }),
    checked && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "18", y: "3", width: "16", height: "16", rx: "8", fill: "white" }),
    typeof checked == "boolean" && !checked && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "4", y: "3", width: "16", height: "16", rx: "8", fill: "white" })
  ] });
}
const BooleanFieldDiff = ({ diff: diff2, schemaType }) => {
  const { fromValue, toValue } = diff2, { title, options } = schemaType, Preview2 = (options == null ? void 0 : options.layout) === "checkbox" ? Checkbox : Switch, userColor = useDiffAnnotationColor(diff2, []), showToValue = toValue != null;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(Preview2, { checked: fromValue, color: userColor }),
      showToValue && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(Preview2, { checked: toValue, color: userColor })
      ] })
    ] }) }),
    showToValue && title && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }) })
  ] });
}, DatetimeWrapper = styled__default.default.div`
  display: inline-block;
  word-wrap: break-word;
`, DatetimePreview = function({
  value,
  schemaType
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: DatetimeWrapper, paddingX: 2, paddingY: 1, children: formatDateTime(value, schemaType) });
};
function formatDateTime(value, schemaType) {
  const { options, name } = schemaType, dateFormat = (options == null ? void 0 : options.dateFormat) || legacyDateFormat__namespace.DEFAULT_DATE_FORMAT, timeFormat = (options == null ? void 0 : options.timeFormat) || legacyDateFormat__namespace.DEFAULT_TIME_FORMAT;
  return legacyDateFormat__namespace.format(
    new Date(value),
    name === "date" ? dateFormat : `${dateFormat} ${timeFormat}`
  );
}
const DatetimeFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    align: "center",
    diff: diff2,
    layout: "grid",
    previewComponent: DatetimePreview,
    schemaType
  }
), DocumentChangeContext = React.createContext(null);
function useDocumentChange() {
  const documentChange = React.useContext(DocumentChangeContext);
  if (!documentChange)
    throw new Error("DocumentChange: missing context value");
  return documentChange;
}
function useRefValue(refId) {
  const [value, setValue] = React.useState(void 0), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useEffect(() => {
    if (!refId)
      return;
    const subscription = client2.observable.getDocument(refId).subscribe(setValue);
    return () => {
      subscription.unsubscribe();
    };
  }, [client2, refId]), refId ? value : void 0;
}
const SizeDiff = styled__default.default.div`
  ${({ theme: theme2 }) => `
    --size-diff-positive: ${theme2.sanity.color.solid.positive.enabled.bg};
    --size-diff-negative: ${theme2.sanity.color.solid.critical.enabled.bg};
  `}
  &:not([hidden]) {
    display: inline-block;
  }

  [data-number='positive'] {
    color: var(--size-diff-positive);
  }

  [data-number='negative'] {
    color: var(--size-diff-negative);
  }
`, FileFieldDiff = ({ diff: diff2, schemaType }) => {
  const { fromValue, toValue, fields } = diff2, fromAsset = fromValue == null ? void 0 : fromValue.asset, toAsset = toValue == null ? void 0 : toValue.asset, { t: t2 } = useTranslation(), prev = useRefValue(fromAsset == null ? void 0 : fromAsset._ref), next = useRefValue(toAsset == null ? void 0 : toAsset._ref), formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 }), changedFields = Object.entries(fields).filter(([name, field]) => field.isChanged && name !== "_type").map(([name]) => name), didAssetChange = changedFields.includes("asset"), nestedFields = schemaType.fields.filter((field) => field.name !== "asset" && changedFields.includes(field.name)).map((field) => field.name), pctDiff = getSizeDiff(prev == null ? void 0 : prev.size, next == null ? void 0 : next.size), prevSize = (prev == null ? void 0 : prev.size) && getHumanFriendlyBytes(prev.size, formatUnit), nextSize = (next == null ? void 0 : next.size) && getHumanFriendlyBytes(next.size, formatUnit), cardStyles2 = React.useMemo(() => ({ display: "block", flex: 1 }), []), from = prev && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "del", diff: diff2, path: "asset._ref", style: cardStyles2, children: /* @__PURE__ */ jsxRuntime.jsx(
    MetaInfo,
    {
      title: prev.originalFilename || t2("changes.file.meta-info-fallback-title"),
      icon: icons.DocumentIcon,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, style: { color: "inherit" }, children: prevSize })
    }
  ) }), to = next && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "ins", diff: diff2, path: "asset._ref", style: cardStyles2, children: /* @__PURE__ */ jsxRuntime.jsx(
    MetaInfo,
    {
      title: next.originalFilename || t2("changes.file.meta-info-fallback-title"),
      icon: icons.DocumentIcon,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, style: { color: "inherit" }, children: nextSize }),
        pctDiff !== 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, padding: 1, as: SizeDiff, marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 0, "data-number": pctDiff > 0 ? "positive" : "negative", children: [
          pctDiff > 0 ? "+" : "-",
          pctDiff,
          "%"
        ] }) })
      ] })
    }
  ) }), FileAssetChange = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    from && !to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", description: t2("changes.removed-label"), children: from }),
    from && to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", children: /* @__PURE__ */ jsxRuntime.jsx(FromTo, { from, layout: "grid", to }) }),
    !from && to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", description: t2("changes.added-label"), children: to })
  ] });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    didAssetChange && FileAssetChange,
    nestedFields.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: didAssetChange ? 4 : 3, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType, fields: nestedFields }) })
  ] });
};
function hexToRgba(hex, opacity) {
  return `rgba(${(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) || []).slice(1).map((num) => parseInt(num, 16)).concat(opacity).join(", ")})`;
}
function simpleHash(str) {
  let hash2 = 0;
  if (str.length == 0)
    return hash2.toString();
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char, hash2 &= hash2;
  }
  return hash2.toString();
}
function getDeviceDpr() {
  const base = Math.ceil(window.devicePixelRatio || 1);
  return Math.min(3, Math.max(1, base));
}
function HotspotCropSVG(props2) {
  const { crop, diff: diff2, hash: hash2, hotspot, width = 100, height = 100, ...restProps } = props2, { t: t2 } = useTranslation(), cropColor = useDiffAnnotationColor(diff2, "crop"), hotspotColor = useDiffAnnotationColor(diff2, "hotspot");
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      ...restProps,
      fill: "none",
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("defs", { children: crop && hotspot && /* @__PURE__ */ jsxRuntime.jsxs("mask", { id: `mask-hotspot-${hash2}`, children: [
          /* @__PURE__ */ jsxRuntime.jsx("rect", { x: 0, y: 0, width, height, fill: "#fff" }),
          /* @__PURE__ */ jsxRuntime.jsx(
            HotspotSVG,
            {
              hotspot,
              fill: "#000",
              offset: 1,
              width,
              height,
              stroke: "#000",
              strokeWidth: 3
            }
          )
        ] }) }),
        crop && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "crop", description: t2("changes.image.crop-changed"), children: /* @__PURE__ */ jsxRuntime.jsx("g", { children: /* @__PURE__ */ jsxRuntime.jsx(
          CropSVG,
          {
            crop,
            fill: hexToRgba(cropColor.border, 0.25),
            mask: hotspot ? `url(#mask-hotspot-${hash2})` : void 0,
            stroke: cropColor.border,
            strokeWidth: 1,
            width,
            height
          }
        ) }) }),
        hotspot && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "hotspot", description: t2("changes.image.crop-changed"), children: /* @__PURE__ */ jsxRuntime.jsx("g", { children: /* @__PURE__ */ jsxRuntime.jsx(
          HotspotSVG,
          {
            hotspot,
            fill: hexToRgba(hotspotColor.border, 0.25),
            stroke: hotspotColor.border,
            strokeWidth: 1,
            width,
            height
          }
        ) }) })
      ]
    }
  );
}
function CropSVG({
  crop,
  width,
  height,
  ...restProps
}) {
  const rectProps = {
    x: crop.left * width,
    y: crop.top * height,
    width: (1 - crop.right - crop.left) * width,
    height: (1 - crop.bottom - crop.top) * height
  };
  return /* @__PURE__ */ jsxRuntime.jsx("rect", { ...restProps, ...rectProps, style: { vectorEffect: "non-scaling-stroke" } });
}
function HotspotSVG({
  hotspot,
  offset = 0,
  width,
  height,
  ...restProps
}) {
  const ellipseProps = {
    cx: hotspot.x * width,
    cy: hotspot.y * height,
    rx: hotspot.width / 2 * width + offset,
    ry: hotspot.height / 2 * height + offset
  };
  return /* @__PURE__ */ jsxRuntime.jsx("ellipse", { ...restProps, ...ellipseProps, style: { vectorEffect: "non-scaling-stroke" } });
}
const ASSET_FIELDS = ["originalFilename"], NoImagePreview = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, tone: "transparent", padding: 4, radius: 2, height: "stretch", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("changes.image.no-image-placeholder") }) }) });
}, ImageWrapper = styled__default.default.div`
  height: 100%;
  max-height: 190px;
  position: relative;

  /* Ideally the checkerboard component currently in the form builder should be made available and used here */
  background-color: ${color.hues.gray[100].hex};
  background-image: linear-gradient(45deg, ${color.hues.gray[50].hex} 25%, transparent 25%),
    linear-gradient(-45deg, ${color.hues.gray[50].hex} 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, ${color.hues.gray[50].hex} 75%),
    linear-gradient(-45deg, transparent 75%, ${color.hues.gray[50].hex} 75%);
  background-size: 16px 16px;
  background-position:
    0 0,
    0 8px,
    8px -8px,
    -8px 0;

  &::after {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    box-shadow: inset 0 0 0 1px var(--card-border-color);
    pointer-events: none;
  }

  &[data-changed] {
    opacity: 0.45;
  }
`, Image$5 = styled__default.default.img`
  display: block;
  flex: 1;
  min-height: 0;
  object-fit: contain;
  width: 100%;
  height: 100%;

  &[data-action='removed'] {
    opacity: 0.45;
  }
`, HotspotDiff = styled__default.default.div`
  svg {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
`;
function ImagePreview$2(props2) {
  var _a2, _b, _c, _d;
  const { id: id2, action, diff: diff2, hotspot, crop, is: is2 } = props2, { t: t2 } = useTranslation(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [imageError, setImageError] = React.useState(), { value: asset } = useDocumentValues(id2, ASSET_FIELDS), dimensions = assetUtils.getImageDimensions(id2), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), assetIsDeleted = asset === null, title = asset && asset.originalFilename, imageSource = imageBuilder.image(id2).height(190).dpr(getDeviceDpr()).fit("max"), assetChanged = ((_b = (_a2 = diff2.fromValue) == null ? void 0 : _a2.asset) == null ? void 0 : _b._ref) !== ((_d = (_c = diff2.toValue) == null ? void 0 : _c.asset) == null ? void 0 : _d._ref);
  let printAction;
  action && action !== "changed" && (printAction = t2(action === "added" ? "changes.added-label" : "changes.removed-label"));
  const metaAction = action === "changed" ? void 0 : action;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", flex: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 2, paddingBottom: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        as: ImageWrapper,
        direction: "column",
        "data-changed": is2 === "from" && assetChanged ? "" : void 0,
        "data-error": imageError ? "" : void 0,
        children: [
          !assetIsDeleted && !imageError && /* @__PURE__ */ jsxRuntime.jsx(
            Image$5,
            {
              src: imageSource.toString() || "",
              alt: title,
              "data-action": metaAction,
              onError: setImageError,
              width: dimensions.width,
              height: dimensions.height
            }
          ),
          (assetIsDeleted || imageError) && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, align: "center", children: t2(assetIsDeleted ? "changes.image.deleted" : "changes.image.error-loading-image") }) }),
          /* @__PURE__ */ jsxRuntime.jsx(HotspotDiff, { children: /* @__PURE__ */ jsxRuntime.jsx(
            HotspotCropSVG,
            {
              crop: crop && !assetUtils.isDefaultCrop(crop) ? crop : void 0,
              diff: diff2,
              hash: simpleHash(`${imageSource.toString() || ""}-${is2}`),
              hotspot: hotspot && !assetUtils.isDefaultHotspot(hotspot) ? hotspot : void 0,
              width: dimensions.width,
              height: dimensions.height
            }
          ) })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      MetaInfo,
      {
        title: title || t2("changes.image.meta-info-fallback-title"),
        icon: icons.ImageIcon,
        markRemoved: assetChanged && is2 === "from",
        children: printAction ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: printAction }) : /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
          dimensions.width,
          " \xD7 ",
          dimensions.height
        ] })
      }
    )
  ] });
}
const IMAGE_META_FIELDS = ["crop", "hotspot"], BASE_IMAGE_FIELDS = ["asset", ...IMAGE_META_FIELDS], CARD_STYLES = {
  flex: 1
}, ImageFieldDiff = ({ diff: diff2, schemaType }) => {
  var _a2, _b;
  const { t: t2 } = useTranslation(), { fromValue, toValue, fields, isChanged } = diff2, fromRef = (_a2 = fromValue == null ? void 0 : fromValue.asset) == null ? void 0 : _a2._ref, toRef = (_b = toValue == null ? void 0 : toValue.asset) == null ? void 0 : _b._ref, assetAnnotation = getAnnotationAtPath(diff2, ["asset", "_ref"]), changedFields = Object.keys(fields).filter(
    (name) => fields[name].isChanged && name !== "_type"
  ), nestedFields = schemaType.fields.filter(
    (field) => !BASE_IMAGE_FIELDS.includes(field.name) && changedFields.includes(field.name)
  ).map((field) => field.name);
  let assetAction = "changed";
  !fromRef && toRef ? assetAction = "added" : !toRef && fromRef && (assetAction = "removed");
  const didAssetChange = changedFields.includes("asset"), didCropChange = changedFields.includes("crop"), didHotspotChange = changedFields.includes("hotspot"), didMetaChange = didCropChange || didHotspotChange, showImageDiff = didAssetChange || didMetaChange, showMetaChange = didMetaChange && !didAssetChange, from = fromValue && fromRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(
    ImagePreview$2,
    {
      is: "from",
      id: fromRef,
      diff: diff2,
      action: assetAction,
      hotspot: showMetaChange && didHotspotChange ? fromValue.hotspot : void 0,
      crop: showMetaChange && didCropChange ? fromValue.crop : void 0
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(NoImagePreview, {}), to = toValue && toRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(
    ImagePreview$2,
    {
      is: "to",
      id: toRef,
      diff: diff2,
      hotspot: showMetaChange && didHotspotChange ? toValue.hotspot : void 0,
      crop: showMetaChange && didCropChange ? toValue.crop : void 0
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(NoImagePreview, {});
  if (!from && !to)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, align: "center", children: t2("changes.image.no-asset-set") }) });
  if (!isChanged)
    return toRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(ImagePreview$2, { id: toRef, is: "to", diff: diff2 }) }) : null;
  const imageDiff = /* @__PURE__ */ jsxRuntime.jsx(FromTo, { align: "center", from, layout: "grid", to });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    showImageDiff && (didAssetChange ? /* @__PURE__ */ jsxRuntime.jsx(
      DiffTooltip,
      {
        annotations: assetAnnotation ? [assetAnnotation] : [],
        description: getChangeDescription(assetAction, t2),
        children: imageDiff
      }
    ) : imageDiff),
    nestedFields.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: showImageDiff ? 4 : 3, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType, fields: nestedFields }) })
  ] });
};
function getChangeDescription(action, t2) {
  switch (action) {
    case "changed":
      return t2("changes.changed-label");
    case "added":
      return t2("changes.added-label");
    case "removed":
      return t2("changes.removed-label");
    default:
      return "Unknown change";
  }
}
const NumberWrapper = styled__default.default.div`
  display: inline-block;
  word-break: break-all;
`, NumberPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: NumberWrapper, paddingX: 2, paddingY: 1, children: value });
}, NumberFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    diff: diff2,
    schemaType,
    previewComponent: NumberPreview,
    layout: "inline"
  }
), InlineBox = styled__default.default(ui.Box)`
  &:not([hidden]) {
    display: inline;
    align-items: center;

    &[data-changed] {
      cursor: pointer;
    }
  }
`, InlineText = styled__default.default(ui.Text)`
  &:not([hidden]) {
    display: inline;
    color: inherit;
  }
`, PreviewContainer$1 = styled__default.default(ui.Box)`
  &:not([hidden]) {
    display: inline-flex;
    align-items: center;

    ${InlineBox} [data-ui="Text"] {
      opacity: 0.5;
    }
  }
`, PopoverContainer$1 = styled__default.default(ui.Box)`
  min-width: 160px;
  max-height: 40vh;
  overflow-y: auto;
`, AnnotationWrapper = styled__default.default.div`
  text-decoration: none;
  display: inline;
  position: relative;
  border: 0;
  padding: 0;
  border-bottom: 2px dotted currentColor;
  box-shadow: inset 0 0 0 1px var(--card-border-color);
  white-space: nowrap;
  align-items: center;
  background-color: color(var(--card-fg-color) a(10%));

  &[data-changed] {
    cursor: pointer;
  }

  &[data-removed] {
    text-decoration: line-through;
  }

  &:hover ${PreviewContainer$1} {
    opacity: 1;
  }
`;
function Annotation$1({
  children,
  diff: diff2,
  object,
  schemaType,
  path,
  ...restProps
}) {
  const { t: t2 } = useTranslation();
  return schemaType ? diff2 && diff2.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(
    AnnnotationWithDiff,
    {
      ...restProps,
      diff: diff2,
      object,
      schemaType,
      path,
      children
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(AnnotationWrapper, { children }) : /* @__PURE__ */ jsxRuntime.jsx(AnnotationWrapper, { ...restProps, children: t2("changes.portable-text.unknown-annotation-schema-type") });
}
function AnnnotationWithDiff({
  diff: diff2,
  children,
  object,
  schemaType,
  path,
  ...restProps
}) {
  const { onSetFocus } = React.useContext(ConnectorContext), { path: fullPath } = React.useContext(DiffContext), [popoverElement, setPopoverElement] = React.useState(null), { t: t2 } = useTranslation(), color2 = useDiffAnnotationColor(diff2, []), style = React.useMemo(
    () => color2 ? { background: color2.background, color: color2.text } : {},
    [color2]
  ), isRemoved = diff2.action === "removed", [open, setOpen] = React.useState(!1), emptyObject = object && isEmptyObject(object), markDefPath = React.useMemo(
    () => [path[0]].concat(["markDefs", { _key: object._key }]),
    [object._key, path]
  ), prefix = React.useMemo(
    () => fullPath.slice(
      0,
      fullPath.findIndex((seg) => types.isKeySegment(seg) && seg._key === object._key)
    ),
    [fullPath, object._key]
  ), annotationPath = React.useMemo(() => prefix.concat(path), [path, prefix]), myPath = React.useMemo(() => prefix.concat(markDefPath), [markDefPath, prefix]), myValue = `field-${PathUtils.toString(myPath)}`, values2 = useReportedValues$1(), isEditing = React.useMemo(
    () => values2.filter(([p]) => p.startsWith(myValue)).length > 0,
    [myValue, values2]
  );
  React.useEffect(() => {
    !open && isEditing && (setOpen(!0), onSetFocus(myPath));
  }, [isEditing, myPath, onSetFocus, open]);
  const handleOpenPopup = React.useCallback(
    (event) => {
      event.stopPropagation(), setOpen(!0), isRemoved || (event.preventDefault(), onSetFocus(annotationPath), setTimeout(() => onSetFocus(myPath), 10));
    },
    [annotationPath, isRemoved, myPath, onSetFocus]
  ), handleClickOutside = React.useCallback(() => {
    isEditing || setOpen(!1);
  }, [isEditing]);
  ui.useClickOutside(handleClickOutside, [popoverElement]);
  const annotation = diff2.action !== "unchanged" && diff2.annotation || null, annotations = React.useMemo(() => annotation ? [annotation] : [], [annotation]), popoverContent = /* @__PURE__ */ jsxRuntime.jsx(DiffContext.Provider, { value: { path: myPath }, children: /* @__PURE__ */ jsxRuntime.jsx(PopoverContainer$1, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
    emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("changes.portable-text.empty-object-annotation", {
      annotationType: schemaType.title || schemaType.name
    }) }),
    !emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType })
  ] }) }) });
  return /* @__PURE__ */ jsxRuntime.jsx(
    AnnotationWrapper,
    {
      ...restProps,
      onClick: handleOpenPopup,
      style,
      "data-changed": "",
      "data-removed": diff2.action === "removed" ? "" : void 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Popover, { content: popoverContent, open, ref: setPopoverElement, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewContainer$1, { paddingLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        DiffTooltip,
        {
          annotations,
          description: t2("changes.portable-text.annotation", { context: diff2.action }),
          children: /* @__PURE__ */ jsxRuntime.jsxs(InlineBox, { style: { display: "inline-flex" }, children: [
            /* @__PURE__ */ jsxRuntime.jsx("span", { children }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(InlineText, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
          ] })
        }
      ) }) })
    }
  );
}
const Quote = styled__default.default.blockquote`
  margin: 0;
`;
function Blockquote({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Quote, { children }) });
}
const headingSizes = {
  h1: 2,
  h2: 1,
  h3: 0,
  h4: 0,
  h5: 0,
  h6: 0
}, StyledHeading = styled__default.default(ui.Heading)`
  &:not([hidden]) {
    display: inline;
    text-transform: none;
    margin: 0;

    &::before,
    &::after {
      content: unset;
    }
  }
`;
function Header$1({ style, children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(StyledHeading, { size: headingSizes[style], children });
}
const StyledParagraph = styled__default.default.div`
  text-transform: none;
  white-space: wrap;
  overflow-wrap: break-word;
  margin: 0;
`;
function Paragraph({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(StyledParagraph, { children });
}
const EMPTY_PATH = [];
function Block(props2) {
  var _a2, _b, _c;
  const { diff: diff2, block, children } = props2, color2 = useDiffAnnotationColor(diff2, EMPTY_PATH), { path: fullPath } = React.useContext(DiffContext), { onSetFocus } = React.useContext(ConnectorContext), { t: t2 } = useTranslation(), isRemoved = diff2.action === "removed";
  let returned = children;
  const handleClick = React.useCallback(
    (event) => {
      event.stopPropagation(), isRemoved || onSetFocus(fullPath);
    },
    [fullPath, isRemoved, onSetFocus]
  );
  block.style === "blockquote" ? returned = /* @__PURE__ */ jsxRuntime.jsx(Blockquote, { children: returned }) : block.style && isHeader(block) ? returned = /* @__PURE__ */ jsxRuntime.jsx(Header$1, { style: block.style, children: returned }) : returned = /* @__PURE__ */ jsxRuntime.jsx(Paragraph, { children: returned });
  let fromStyle;
  if (diff2.origin.action === "changed" && diff2.origin.fields.style && diff2.origin.fields.style.action === "changed" && diff2.origin.fields.style.annotation) {
    fromStyle = (_b = (_a2 = diff2 == null ? void 0 : diff2.origin) == null ? void 0 : _a2.fromValue) == null ? void 0 : _b.style;
    const style = color2 ? { background: color2.background, color: color2.text } : {};
    returned = /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        padding: 3,
        border: !0,
        radius: 2,
        style: { borderStyle: "dotted" },
        "diff-block-action": diff2.action,
        "data-block-note": `changed_from_style_${fromStyle || "undefined"}`,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            DiffTooltip,
            {
              annotations: [(_c = diff2.origin.fields.style) == null ? void 0 : _c.annotation],
              diff: diff2.origin.fields.style,
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: t2("changes.portable-text.block-style-changed", { fromStyle, toStyle: block.style }) })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style, children: returned })
        ] })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    "div",
    {
      onClick: handleClick,
      "data-diff-block-action": diff2.action,
      "data-block-note": `changed_from_style_${fromStyle || "undefined"}`,
      children: returned
    }
  );
}
const DecoratorWrapper = styled__default.default.span`
  display: inline;
  ${({ theme: theme2, decoration }) => {
  switch (decoration) {
    case "strong":
      return "font-weight: bold;";
    case "em":
      return "font-style: italic;";
    case "underline":
      return "text-decoration: underline;";
    case "overline":
      return "text-decoration: overline;";
    case "strike-through":
      return "text-decoration: line-through;";
    case "code":
      return `
          font-family: ${theme2.sanity.fonts.code.family};
          background: ${theme2.sanity.color.muted.default.enabled.bg};
        `;
    default:
      return "";
  }
}}
`;
function Decorator$1({ mark, children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(DecoratorWrapper, { decoration: mark, children });
}
const InlineObjectWrapper = styled__default.default(ui.Card)`
  &:not([hidden]) {
    display: inline;
    cursor: pointer;
    white-space: nowrap;
    align-items: center;

    &[data-removed] {
      text-decoration: line-through;
    }

    ${InlineBox} {
      display: inline-flex;
    }
  }
`;
function InlineObject$1({ diff: diff2, object, schemaType, ...restProps }) {
  const { t: t2 } = useTranslation();
  return schemaType ? diff2 ? /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWithDiff, { ...restProps, diff: diff2, object, schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(Preview, { schemaType, value: object, layout: "inline" }) }) : /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWrapper, { ...restProps, border: !0, radius: 1, children: t2("changes.portable-text.unknown-inline-object-schema-type", { schemaType: object._type }) });
}
function InlineObjectWithDiff({
  diff: diff2,
  object,
  path,
  schemaType,
  ...restProps
}) {
  const { path: fullPath } = React.useContext(DiffContext), { onSetFocus } = React.useContext(ConnectorContext), { t: t2 } = useTranslation(), color2 = useDiffAnnotationColor(diff2, []), style = React.useMemo(
    () => color2 ? { background: color2.background, color: color2.text } : {},
    [color2]
  ), [open, setOpen] = React.useState(!1), emptyObject = object && isEmptyObject(object), isRemoved = diff2.action === "removed", myPath = fullPath.slice(
    0,
    fullPath.findIndex((seg) => types.isKeySegment(seg) && seg._key === object._key)
  ).concat(path), myValue = `field-${PathUtils.toString(myPath)}`, isEditing = useReportedValues$1().filter(([p]) => p.startsWith(myValue)).length > 0, focusPath = fullPath.slice(0, -1).concat(path).concat([PathUtils.FOCUS_TERMINATOR]);
  React.useEffect(() => {
    isEditing && (setOpen(!0), onSetFocus(focusPath));
  }, [focusPath, isEditing, onSetFocus]);
  const handleOpenPopup = React.useCallback(
    (event) => {
      if (event.stopPropagation(), setOpen(!0), !isRemoved) {
        onSetFocus(focusPath);
        return;
      }
      event.preventDefault();
    },
    [focusPath, isRemoved, onSetFocus]
  ), handleClose = React.useCallback(() => {
    setOpen(!1);
  }, []), popoverContent = /* @__PURE__ */ jsxRuntime.jsx(DiffContext.Provider, { value: { path: myPath }, children: /* @__PURE__ */ jsxRuntime.jsx(
    PopoverContent$1,
    {
      diff: diff2,
      emptyObject,
      onClose: handleClose,
      schemaType
    }
  ) }), annotation = diff2.action !== "unchanged" && diff2.annotation || null, annotations = annotation ? [annotation] : [];
  return /* @__PURE__ */ jsxRuntime.jsx(
    InlineObjectWrapper,
    {
      ...restProps,
      onClick: handleOpenPopup,
      style,
      "data-removed": diff2.action === "removed" ? "" : void 0,
      border: !0,
      radius: 2,
      children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Popover, { content: popoverContent, open, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewContainer$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
        DiffTooltip,
        {
          annotations,
          description: t2("changes.portable-text.inline-object", { context: diff2.action }),
          children: /* @__PURE__ */ jsxRuntime.jsxs(InlineBox, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(Preview, { schemaType, value: object, layout: "inline" }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(InlineText, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
          ] })
        }
      ) }) })
    }
  );
}
function PopoverContent$1({
  diff: diff2,
  emptyObject,
  onClose,
  schemaType
}) {
  const { t: t2 } = useTranslation(), [popoverElement, setPopoverElement] = React.useState(null);
  return ui.useClickOutside(onClose, [popoverElement]), /* @__PURE__ */ jsxRuntime.jsxs(PopoverContainer$1, { ref: setPopoverElement, padding: 3, children: [
    emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("changes.portable-text.empty-inline-object", {
      inlineObjectType: schemaType.title || schemaType.name
    }) }),
    !emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType })
  ] });
}
function Text({
  diff: diff2,
  childDiff,
  children,
  path,
  segment,
  ...restProps
}) {
  const diffWithFallback = diff2 || childDiff;
  return diffWithFallback && diffWithFallback.action !== "unchanged" && segment.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(TextWithDiff, { ...restProps, childDiff, diff: diff2, segment, path, children }) : /* @__PURE__ */ jsxRuntime.jsx(InlineBox, { children });
}
function TextWithDiff({ diff: diff2, childDiff, children, path, segment, ...restProps }) {
  const { onSetFocus } = React.useContext(ConnectorContext), { path: fullPath } = React.useContext(DiffContext), spanSegment = React.useMemo(() => path.slice(-2, 1)[0], [path]), { t: t2 } = useTranslation(), isRemoved = diff2 && diff2.action === "removed", focusPath = fullPath.slice(
    0,
    fullPath.findIndex(
      (seg) => types.isKeySegment(seg) && types.isKeySegment(spanSegment) && seg._key === spanSegment._key
    )
  ).concat(path), handleClick = React.useCallback(
    (event) => {
      event.stopPropagation(), isRemoved || (event.preventDefault(), onSetFocus(focusPath));
    },
    [focusPath, isRemoved, onSetFocus]
  ), diffWithFallback = diff2 && diff2.segments.find((rSeg) => rSeg.text === segment.text) || diff2 || childDiff, annotation = diffWithFallback && diffWithFallback.action !== "unchanged" && diffWithFallback.annotation || null, diffCard = annotation && segment.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation,
      as: segment.action === "removed" ? "del" : "ins",
      tooltip: { description: t2("changes.portable-text.text", { context: segment.action }) },
      children
    }
  ) : null;
  return /* @__PURE__ */ jsxRuntime.jsx(InlineBox, { ...restProps, onClick: handleClick, "data-changed": "", children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: diffCard || children }) }) });
}
const decoratorSymbolsStart = DECORATOR_SYMBOLS.map((set2) => set2[0]), decoratorSymbolsEnd = DECORATOR_SYMBOLS.map((set2) => set2[1]), annotationSymbolsStart = ANNOTATION_SYMBOLS.map((set2) => set2[0]), annotationSymbolsEnd = ANNOTATION_SYMBOLS.map((set2) => set2[1]), allSymbolsStart = decoratorSymbolsStart.concat(annotationSymbolsStart), allSymbolsEnd = decoratorSymbolsEnd.concat(annotationSymbolsEnd), allDecoratorSymbols = decoratorSymbolsStart.concat(decoratorSymbolsEnd), markRegex = new RegExp(`${allDecoratorSymbols.concat(allSymbolsEnd).join("|")}`, "g");
function PortableText(props2) {
  const { diff: diff2, schemaType } = props2, block = diff2.origin.toValue || diff2.origin.fromValue, { t: t2 } = useTranslation(), inlineObjects = React.useMemo(
    () => diff2.origin.toValue ? getInlineObjects(diff2.origin) : [],
    [diff2.origin]
  ), renderChild = React.useCallback(
    (ptDiffChild) => {
      const spanSchemaType = getChildSchemaType(schemaType.fields, ptDiffChild);
      let decoratorTypes = [];
      if (spanSchemaType) {
        decoratorTypes = getDecorators(spanSchemaType);
        const childrenDiff = diff2.fields.children, segments = childrenDiff.items[0].diff && childrenDiff.items[0].diff.type === "object" && childrenDiff.items[0].diff.fields.text.type === "string" && childrenDiff.items[0].diff.fields.text.segments || [], returnedChildren = [], annotationSegments = {};
        if (isEmptyTextChange(block, diff2) && (diff2.origin.action === "added" || diff2.origin.action === "removed")) {
          const textDiff = findChildDiff(diff2.origin, block.children[0]) || diff2.origin;
          if (textDiff && textDiff.action !== "unchanged")
            return /* @__PURE__ */ jsxRuntime.jsx(
              DiffCard,
              {
                annotation: textDiff.annotation,
                as: textDiff.action === "removed" ? "del" : "ins",
                tooltip: {
                  description: t2("changes.portable-text.empty-text", { context: textDiff.action })
                },
                children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: EMPTY_BLOCK_SYMBOL })
              },
              `empty-block-${block._key}`
            );
        }
        let childToIndex = -1, segIndex = -1;
        const activeAnnotations = [];
        let endedAnnotation;
        const allMarkDefs = getAllMarkDefs(diff2.origin);
        return segments.forEach((seg) => {
          var _a2, _b, _c;
          segIndex++;
          const isInline = INLINE_SYMBOLS.includes(seg.text), isMarkStart = allSymbolsStart.includes(seg.text), isMarkEnd = allSymbolsEnd.includes(seg.text), isChildStart = seg.text === CHILD_SYMBOL, isRemoved = seg.action === "removed";
          if (isChildStart)
            isRemoved || childToIndex++;
          else if (isMarkStart || isMarkEnd) {
            if (isMarkStart && annotationSymbolsStart.includes(seg.text)) {
              const object = allMarkDefs[annotationSymbolsStart.indexOf(seg.text)];
              object && activeAnnotations.push({
                mark: object._key,
                symbols: [
                  seg.text,
                  annotationSymbolsEnd[annotationSymbolsStart.indexOf(seg.text)]
                ],
                object
              });
            }
            isMarkEnd && annotationSymbolsEnd.includes(seg.text) && (endedAnnotation = activeAnnotations.pop());
          } else if (isInline) {
            const indexOfSymbol = INLINE_SYMBOLS.findIndex((sym) => sym === seg.text), key = (_a2 = inlineObjects[indexOfSymbol]) == null ? void 0 : _a2._key, originChild = inlineObjects[indexOfSymbol];
            if (key) {
              const objectSchemaType = getChildSchemaType(schemaType.fields, originChild), objectDiff = findChildDiff(diff2.origin, originChild);
              returnedChildren.push(
                /* @__PURE__ */ jsxRuntime.jsx(
                  InlineObject$1,
                  {
                    object: originChild,
                    path: [{ _key: block._key }, "children", { _key: originChild._key }],
                    diff: objectDiff,
                    schemaType: objectSchemaType
                  },
                  `inline-object-${originChild._key}`
                )
              );
            }
          } else if (seg.text) {
            const getChildFromFromValue = () => {
              var _a22;
              return (_a22 = diff2.origin.fromValue) == null ? void 0 : _a22.children.find(
                (cld) => cld.text && cld.text.match(escapeRegExp(seg.text))
              );
            }, child = block.children[childToIndex] || getChildFromFromValue(), childDiff = child && findSpanDiffFromChild(diff2.origin, child);
            if (!child)
              throw new Error("Could not find child");
            const textDiff = (_b = childDiff == null ? void 0 : childDiff.fields) != null && _b.text ? (_c = childDiff == null ? void 0 : childDiff.fields) == null ? void 0 : _c.text : void 0, text = /* @__PURE__ */ jsxRuntime.jsx(
              Text,
              {
                diff: textDiff,
                path: [{ _key: block._key }, "children", { _key: child._key }],
                childDiff,
                segment: seg,
                children: renderTextSegment({
                  diff: diff2,
                  child,
                  decoratorTypes,
                  seg,
                  segIndex,
                  spanSchemaType,
                  t: t2
                })
              },
              `text-${child._key}-${segIndex}`
            );
            if (activeAnnotations.length > 0 && activeAnnotations.forEach((active) => {
              annotationSegments[active.mark] = annotationSegments[active.mark] || [], annotationSegments[active.mark].push(text);
            }), endedAnnotation) {
              const key = `annotation-${endedAnnotation.object._key}`, lastChild = returnedChildren[returnedChildren.length - 1];
              if (lastChild && lastChild.key !== key) {
                const annotationDiff = findAnnotationDiff(diff2.origin, endedAnnotation.mark), objectSchemaType = endedAnnotation && spanSchemaType.annotations && spanSchemaType.annotations.find(
                  (type) => endedAnnotation && endedAnnotation.object && type.name === endedAnnotation.object._type
                );
                returnedChildren.push(
                  /* @__PURE__ */ jsxRuntime.jsx(
                    Annotation$1,
                    {
                      object: endedAnnotation.object,
                      diff: annotationDiff,
                      path: [{ _key: block._key }, "children", { _key: child._key }],
                      schemaType: objectSchemaType,
                      children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: annotationSegments[endedAnnotation.mark] })
                    },
                    key
                  )
                );
              }
              endedAnnotation = void 0;
            }
            activeAnnotations.length === 0 && returnedChildren.push(text);
          }
        }), React.createElement("div", { key: block._key }, ...returnedChildren);
      }
      throw new Error("'span' schemaType not found");
    },
    [block, diff2, inlineObjects, schemaType, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Block, { block: diff2.displayValue, diff: diff2, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (diff2.displayValue.children || []).map((child) => renderChild(child)) }) });
}
function renderTextSegment({
  diff: diff2,
  child,
  decoratorTypes,
  seg,
  segIndex,
  spanSchemaType,
  t: t2
}) {
  if (seg.text === `
`)
    return /* @__PURE__ */ jsxRuntime.jsx("br", {});
  let children = /* @__PURE__ */ jsxRuntime.jsx("span", { children: seg.text.replace(/ /g, TRAILING_SPACE_SYMBOL) }, `text-${segIndex}`);
  const spanDiff = child && findSpanDiffFromChild(diff2.origin, child), activeMarks = types.isPortableTextSpan(child) ? child.marks || [] : [];
  return spanDiff && (children = renderDecorators({
    activeMarks,
    decoratorTypes,
    diff: diff2,
    children,
    seg,
    segIndex,
    spanDiff,
    spanSchemaType,
    t: t2
  })), activeMarks && activeMarks.length > 0 && activeMarks.forEach((mark) => {
    isDecorator(mark, spanSchemaType) && (children = // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ jsxRuntime.jsx(Decorator$1, { mark, children }, `decorator-${mark}-${child._key}-${segIndex}`));
  }), children;
}
function renderDecorators({
  activeMarks,
  decoratorTypes,
  diff: diff2,
  children,
  seg,
  segIndex,
  spanDiff,
  spanSchemaType,
  t: t2
}) {
  var _a2;
  let returned = /* @__PURE__ */ jsxRuntime.jsx("span", { children }, `text-segment-${segIndex}`);
  const fromPtDiffText = diff2.origin.fromValue && diff2.fromValue && diff2.fromValue.children[0].text || "", indirectMarksAnnotation = spanDiff && spanDiff.action !== "unchanged" && spanDiff.annotation || void 0, marksDiff = (_a2 = spanDiff == null ? void 0 : spanDiff.fields) == null ? void 0 : _a2.marks, marksAnnotation = marksDiff && marksDiff.action !== "unchanged" && marksDiff.annotation || indirectMarksAnnotation;
  let marksChanged = [];
  const ptDiffMatchString = fromPtDiffText.split(CHILD_SYMBOL).filter((text) => !!text).join(""), controlString = ptDiffMatchString.substring(
    0,
    ptDiffMatchString.indexOf(seg.text) + seg.text.length
  ), toTest = controlString.substring(0, controlString.indexOf(seg.text)), marks = [];
  return [...toTest.matchAll(markRegex)].forEach((match) => {
    var _a22;
    const sym = match[0], set2 = DECORATOR_SYMBOLS.concat(ANNOTATION_SYMBOLS).find(
      (aSet) => aSet.indexOf(sym) > -1
    );
    if (set2) {
      const isMarkStart = sym === set2[0], mark = ((_a22 = decoratorTypes[isMarkStart ? decoratorSymbolsStart.indexOf(sym) : decoratorSymbolsEnd.indexOf(sym)]) == null ? void 0 : _a22.value) || sym;
      toTest.lastIndexOf(sym) > toTest.lastIndexOf(set2[1]) && marks.push(mark);
    }
  }), marksChanged = xor__default.default(activeMarks, uniq__default.default(marks)), marksAnnotation && marksChanged.length > 0 && marksChanged.some((m) => isDecorator(m, spanSchemaType)) && (returned = /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: marksAnnotation,
      as: "ins",
      tooltip: {
        description: t2("changes.portable-text.changed-formatting")
      },
      children: returned
    },
    `diffcard-annotation-${segIndex}-${marksChanged.join("-")}`
  )), returned;
}
function isEmptyTextChange(block, diff2) {
  return block.children.length === 1 && block.children[0]._type === "span" && typeof block.children[0].text == "string" && block.children[0].text === "" && diff2.origin.action !== "unchanged";
}
const PTDiff = (props2) => {
  const { diff: diff2, schemaType } = props2, ptDiff = React.useMemo(() => createPortableTextDiff(diff2, schemaType), [diff2, schemaType]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "data-diff-action": diff2.action, children: /* @__PURE__ */ jsxRuntime.jsx(PortableText, { diff: ptDiff, schemaType }) });
}, ReferenceWrapper = styled__default.default.div`
  word-wrap: break-word;
`, ReferencePreview$1 = ({ value, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: ReferenceWrapper, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Preview, { schemaType, value, layout: "default" }) }), ReferenceFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    align: "center",
    diff: diff2,
    layout: "grid",
    path: "_ref",
    previewComponent: ReferencePreview$1,
    schemaType
  }
), StringWrapper$1 = styled__default.default.div`
  display: inline-block;
  word-break: break-all;
  white-space: pre-wrap;
`, StringPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: StringWrapper$1, paddingX: 2, paddingY: 1, children: value });
}, StringWrapper = styled__default.default.div`
  white-space: pre-wrap;
  word-wrap: break-word;
`, StringFieldDiff = ({ diff: diff2, schemaType }) => {
  const { options } = schemaType;
  return options != null && options.list ? /* @__PURE__ */ jsxRuntime.jsx(DiffFromTo, { diff: diff2, previewComponent: StringPreview, schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(StringWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(DiffString, { diff: diff2 }) });
}, defaultComponents = {
  block: PTDiff,
  boolean: { component: BooleanFieldDiff, showHeader: !1 },
  date: DatetimeFieldDiff,
  datetime: DatetimeFieldDiff,
  file: FileFieldDiff,
  image: ImageFieldDiff,
  number: NumberFieldDiff,
  reference: ReferenceFieldDiff,
  string: StringFieldDiff
};
function resolveDiffComponent(type, parentSchemaType) {
  var _a2;
  let itType = type;
  for (; itType; ) {
    const resolved = ((_a2 = itType == null ? void 0 : itType.components) == null ? void 0 : _a2.diff) || tryResolve(itType, parentSchemaType) || defaultComponents[itType.name];
    if (resolved)
      return resolved;
    itType = itType.type;
  }
  const defaultComponentKey = ["date", "datetime"].includes(type.name) ? type.name : type.jsonType;
  return defaultComponents[defaultComponentKey];
}
function tryResolve(schemaType, parentSchemaType) {
  const resolvers = diffResolvers;
  let resolved;
  for (const resolver of resolvers) {
    if (typeof resolver != "function") {
      console.error("Diff component resolver is not a function: ", resolver);
      continue;
    }
    if (resolved = resolver({ schemaType, parentSchemaType }), resolved)
      return resolved;
  }
}
function buildChangeList(schemaType, diff2, path = [], titlePath = [], context = {}) {
  if (!resolveDiffComponent(schemaType, context.parentSchema)) {
    if (schemaType.jsonType === "object" && diff2.type === "object")
      return buildObjectChangeList(schemaType, diff2, path, titlePath, context);
    if (schemaType.jsonType === "array" && diff2.type === "array")
      return buildArrayChangeList(schemaType, diff2, path, titlePath);
  }
  return getFieldChange(schemaType, diff2, path, titlePath, context);
}
function buildObjectChangeList(schemaType, diff2, path = [], titlePath = [], diffContext = {}) {
  const changes = [], childContext = { ...diffContext, parentSchema: schemaType }, fieldSets = schemaType.fieldsets || schemaType.fields.map((field) => ({ single: !0, field }));
  for (const fieldSet of fieldSets)
    fieldSet.single ? changes.push(...buildFieldChange(fieldSet.field, diff2, path, titlePath, childContext)) : changes.push(
      ...buildFieldsetChangeList(fieldSet, diff2, path, titlePath, childContext)
    );
  return changes.length < 2 ? changes : [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      path,
      titlePath,
      changes: reduceTitlePaths(changes, titlePath.length),
      schemaType
    }
  ];
}
function buildFieldChange(field, diff2, path, titlePath, diffContext = {}) {
  const { fieldFilter, ...context } = diffContext, fieldDiff = diff2.fields[field.name];
  if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name))
    return [];
  const fieldPath = path.concat([field.name]), fieldTitlePath = titlePath.concat([field.type.title || field.name]);
  return buildChangeList(field.type, fieldDiff, fieldPath, fieldTitlePath, context);
}
function buildFieldsetChangeList(fieldSet, diff2, path, titlePath, diffContext = {}) {
  const { fields, name, title, readOnly, hidden } = fieldSet, { fieldFilter, ...context } = diffContext, fieldSetHidden = hidden, fieldsetReadOnly = readOnly, fieldSetTitlePath = titlePath.concat([title || name]), changes = [];
  for (const field of fields) {
    const fieldDiff = diff2.fields[field.name];
    if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name))
      continue;
    const fieldPath = path.concat([field.name]), fieldTitlePath = fieldSetTitlePath.concat([field.type.title || field.name]);
    changes.push(
      ...buildChangeList(
        {
          readOnly: fieldsetReadOnly,
          hidden: fieldSetHidden,
          ...field.type
        },
        fieldDiff,
        fieldPath,
        fieldTitlePath,
        context
      )
    );
  }
  return changes.length < 2 ? changes : [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      fieldsetName: name,
      path,
      titlePath: fieldSetTitlePath,
      changes: reduceTitlePaths(changes, fieldSetTitlePath.length),
      readOnly: fieldsetReadOnly,
      hidden: fieldSetHidden
    }
  ];
}
function buildArrayChangeList(schemaType, diff2, path = [], titlePath = []) {
  const changedOrMoved = diff2.items.filter(
    (item) => item.hasMoved && item.fromIndex !== item.toIndex || item.diff.action !== "unchanged"
  );
  if (changedOrMoved.length === 0)
    return [];
  const isPortableText2 = hasPTMemberType(schemaType), list = [], changes = changedOrMoved.reduce((acc, itemDiff) => {
    const memberTypes = getArrayDiffItemType(itemDiff.diff, schemaType), memberType = memberTypes.toType || memberTypes.fromType;
    if (!memberType)
      return console.warn("Could not determine schema type for item at %s", pathToString$1(path)), acc;
    const segment = getItemKeySegment(itemDiff.diff.fromValue) || getItemKeySegment(itemDiff.diff.toValue) || diff2.items.indexOf(itemDiff), itemPath = path.concat(segment), itemContext = { itemDiff, parentDiff: diff2, parentSchema: schemaType }, itemTitlePath = titlePath.concat({
      hasMoved: itemDiff.hasMoved,
      toIndex: itemDiff.toIndex,
      fromIndex: itemDiff.fromIndex,
      annotation: itemDiff.diff.action === "unchanged" ? itemDiff.annotation : itemDiff.diff.annotation
    }), attachItemDiff = (change) => (change.type === "field" && pathsAreEqual(itemPath, change.path) && (change.itemDiff = itemDiff), change), children = buildChangeList(
      memberType,
      itemDiff.diff,
      itemPath,
      itemTitlePath,
      itemContext
    ).map(attachItemDiff);
    return isPortableText2 && children.filter(isFieldChange).forEach((field, index, siblings) => {
      field.showHeader = siblings.length === 1, field.showIndex = itemDiff.fromIndex !== itemDiff.toIndex && itemDiff.hasMoved;
    }), children.length === 0 ? acc.push(...getFieldChange(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext)) : acc.push(...children), acc;
  }, list);
  return changes.length > 1 ? [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      path,
      titlePath,
      changes: reduceTitlePaths(changes, titlePath.length),
      schemaType
    }
  ] : changes;
}
function getFieldChange(schemaType, diff2, path, titlePath, { itemDiff, parentDiff, parentSchema } = {}) {
  const { fromValue, toValue, type } = diff2;
  if (type === "array" && isEmpty(fromValue) && isEmpty(toValue))
    return [];
  let error;
  typeof fromValue < "u" && (error = getValueError(fromValue, schemaType)), !error && typeof toValue < "u" && (error = getValueError(toValue, schemaType));
  let showHeader = !0, component;
  const diffComponent = resolveDiffComponent(schemaType, parentSchema);
  return diffComponent && typeof diffComponent == "function" ? component = diffComponent : diffComponent && (component = diffComponent.component, showHeader = typeof diffComponent.showHeader > "u" ? showHeader : diffComponent.showHeader), [
    {
      type: "field",
      diff: diff2,
      path,
      error,
      itemDiff,
      parentDiff,
      titlePath,
      schemaType,
      showHeader,
      showIndex: !0,
      key: pathToString$1(path) || "root",
      diffComponent: error ? void 0 : component,
      parentSchema
    }
  ];
}
function reduceTitlePaths(changes, byLength = 1) {
  return changes.map((change) => (change.titlePath = change.titlePath.slice(byLength), change));
}
function isEmpty(item) {
  return Array.isArray(item) && item.length === 0 || item === null || typeof item > "u";
}
const isAddedAction = (change) => change.type === "field" && change.diff.action === "added", flattenChangeNode = (changeNode) => {
  if (changeNode.type !== "group")
    return [changeNode];
  const newSubChanges = [];
  return changeNode.changes.forEach((cChange) => {
    newSubChanges.push(...flattenChangeNode(cChange));
  }), newSubChanges;
}, isSubpathOf = (subPath, parentPath) => {
  if (parentPath.length >= subPath.length)
    return !1;
  for (let i = 0; i < parentPath.length; i++)
    if (parentPath[i] !== subPath[i])
      return !1;
  return !0;
}, pathSegmentOfCorrectType = (item, child) => {
  const nextItem = item[child], key = getItemKey(nextItem);
  return key ? { _key: key } : Array.isArray(item) ? parseInt(child, 10) : child;
}, diffOptions = {
  diffMatchPatch: { enabled: !1, lengthThresholdAbsolute: 30, lengthThresholdRelative: 1.2 }
};
function undoChange(change, rootDiff, documentOperations) {
  if (!rootDiff)
    return;
  const patches = [];
  if (change.type === "group") {
    const allChanges = flattenChangeNode(change), unsetChanges = allChanges.filter(isAddedAction);
    allChanges.filter((child) => !isAddedAction(child)).forEach((child) => undoChange(child, rootDiff, documentOperations)), patches.push(
      ...buildUnsetPatches(rootDiff, unsetChanges.map((unsetChange) => unsetChange.path).reverse())
    );
  } else
    change.diff.action === "added" ? patches.push(...buildUnsetPatches(rootDiff, [change.path])) : change.type === "field" && change.itemDiff && change.parentDiff && change.parentDiff.type === "array" && change.itemDiff.hasMoved ? patches.push(...buildMovePatches(change.itemDiff, change.parentDiff, change.path)) : patches.push(...buildUndoPatches(change.diff, rootDiff, change.path));
  documentOperations.patch.execute(patches);
}
function buildUnsetPatch(rootDiff, path, concurrentUnsetPaths) {
  const previousValue = rootDiff.toValue;
  return furthestEmptyAncestor(previousValue, path, concurrentUnsetPaths);
}
function buildUnsetPatches(rootDiff, paths) {
  const patches = [];
  for (let i = 0; i < paths.length; i++)
    patches.some((patch2) => isSubpathOf(paths[i], patch2)) || patches.push(buildUnsetPatch(rootDiff, paths[i], paths));
  return [{ unset: [...new Set(patches.map(pathToString$1))] }];
}
function furthestEmptyAncestor(previousValue, currentPath, ignorePaths = [], initialPath) {
  if (currentPath.length <= 0) {
    if (!initialPath)
      throw new Error("Root has no ancestor");
    return initialPath;
  }
  const ancestorPath = currentPath.slice(0, -1), ancestorValue = getValueAtPath(previousValue, ancestorPath), updatedIgnorePaths = [
    ancestorPath,
    /*
     * We can filter out all the subpaths from under this ancestor
     * because since we ignore it higher up in the tree it doesn't
     * matter anymore what the values of subpaths are.
     */
    ...ignorePaths.filter((path) => !isSubpathOf(path, ancestorPath))
  ];
  return isStub(ancestorValue, ancestorPath, ignorePaths) ? furthestEmptyAncestor(previousValue, ancestorPath, updatedIgnorePaths, initialPath) : currentPath;
}
function buildMovePatches(itemDiff, parentDiff, path) {
  const basePath = path.slice(0, -1), { parentValue, fromIndex, fromValue } = getFromItem(parentDiff, itemDiff);
  let insertLocation;
  if (fromIndex === 0)
    insertLocation = { before: pathToString$1([...basePath, 0]) };
  else {
    const prevIndex = fromIndex - 1, prevSegment = getItemKeySegment(parentValue[prevIndex]) || prevIndex;
    insertLocation = { after: pathToString$1([...basePath, prevSegment]) };
  }
  return [
    {
      unset: [pathToString$1(path)]
    },
    {
      insert: { ...insertLocation, items: [fromValue] }
    }
  ];
}
function buildUndoPatches(diff2, rootDiff, path) {
  const patches = sanityDiffPatch.diffItem(diff2.toValue, diff2.fromValue, diffOptions, path), inserts = patches.filter((patch2) => patch2.op === "insert").map(({ after, items }) => ({ insert: { after: pathToString$1(after), items } })), unsets = patches.filter((patch2) => patch2.op === "unset").reduce((acc, patch2) => acc.concat(pathToString$1(patch2.path)), []), stubbedPaths = /* @__PURE__ */ new Set(), stubs = [];
  let hasSets = !1;
  const sets = patches.filter((patch2) => patch2.op === "set").reduce(
    (acc, patch2) => (hasSets = !0, stubs.push(...getParentStubs(patch2.path, rootDiff, stubbedPaths)), acc[pathToString$1(patch2.path)] = patch2.value, acc),
    {}
  );
  return [
    ...stubs,
    ...inserts,
    ...unsets.length > 0 ? [{ unset: unsets }] : [],
    ...hasSets ? [{ set: sets }] : []
  ];
}
function getParentStubs(path, rootDiff, stubbed) {
  const value = rootDiff.fromValue, nextValue = rootDiff.toValue, stubs = [];
  for (let i = 1; i <= path.length; i++) {
    const subPath = path.slice(0, i), pathStr = pathToString$1(subPath);
    if (stubbed.has(pathStr))
      continue;
    const nextSegment = path[i], nextIsArrayElement = types.isKeySegment(nextSegment) || types.isIndexSegment(nextSegment), itemValue = getValueAtPath(value, subPath), stub = getStubValue(itemValue);
    if (nextIsArrayElement && Array.isArray(itemValue) && !getValueAtPath(nextValue, path.slice(0, i + 1))) {
      const indexAtPrev = findIndex(itemValue, nextSegment), prevItem = itemValue[indexAtPrev - 1], nextItem = getValueAtPath(value, subPath.concat(nextSegment)), prevSeg = types.isKeyedObject(prevItem) ? { _key: prevItem._key } : indexAtPrev - 1, after = pathToString$1(subPath.concat(indexAtPrev < 1 ? 0 : prevSeg));
      stubs.push({ setIfMissing: { [pathStr]: [] } }), stubs.push({ insert: { after, items: [getStubValue(nextItem)] } }), i++;
      continue;
    }
    typeof stub > "u" || (stubbed.add(pathStr), stubs.push({ setIfMissing: { [pathStr]: stub } }));
  }
  return stubs;
}
function onlyContainsStubs(item, path, ignorePaths) {
  if (!isRecord$4(item) || !Array.isArray(item))
    return !1;
  for (const child in item) {
    if (!Object.prototype.hasOwnProperty.call(item, child) || child === "_type" || child === "_key")
      continue;
    const nextPath = [...path, pathSegmentOfCorrectType(item, child)];
    if (!isStub(item[child], nextPath, ignorePaths))
      return !1;
  }
  return !0;
}
function isStub(item, path, ignorePaths) {
  const isIgnoredPath = ignorePaths == null ? void 0 : ignorePaths.some(
    (ignorePath) => pathToString$1(ignorePath) === pathToString$1(path)
  ), isEmptyArray2 = Array.isArray(item) && item.length <= 0;
  return isIgnoredPath || item === void 0 || item === null || isEmptyArray2 || isEmptyObject$1(item) || onlyContainsStubs(item, path, ignorePaths);
}
function getStubValue(item) {
  if (Array.isArray(item))
    return [];
  if (typeof item != "object" || item === null)
    return;
  const props2 = {};
  return types.isKeyedObject(item) && (props2._key = item._key), types.isTypedObject(item) && (props2._type = item._type), props2;
}
function getFromItem(parentDiff, itemDiff) {
  if (parentDiff.fromValue && typeof itemDiff.fromIndex == "number") {
    const fromValue = parentDiff.fromValue[itemDiff.fromIndex];
    return {
      parentValue: parentDiff.fromValue,
      fromIndex: itemDiff.fromIndex,
      fromValue
    };
  }
  throw new Error(`Failed to find item at index ${itemDiff.fromIndex}`);
}
const DiffContext = React.createContext({ path: [] }), ChangeListWrapper$1 = styled__default.default.div`
  display: grid;
  grid-template-columns: minmax(0, 1fr);
`, isDev = process.env.NODE_ENV !== "production", isProd = !isDev;
class DiffErrorBoundary extends React.Component {
  constructor() {
    super(...arguments), this.state = {};
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  // eslint-disable-next-line class-methods-use-this
  componentDidCatch(error) {
    console.error("Error rendering diff component: "), console.error(error);
  }
  render() {
    const { t: t2 } = this.props, { error } = this.state;
    return error ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { paddingLeft: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h3", size: 1, weight: "medium", children: t2("changes.error-boundary.title") }),
        isDev && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: t2("changes.error-boundary.developer-info") }) })
      ] })
    ] }) }) : this.props.children;
  }
}
const arrowComponents = {
  down: icons.ArrowDownIcon,
  right: icons.ArrowRightIcon
};
function FromToArrow(props2) {
  const { direction = "right", ...restProps } = props2, arrowComponent = arrowComponents[direction];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, ...restProps, children: React.createElement(arrowComponent) });
}
const CodeWrapper$1 = styled__default.default.pre`
  overflow-x: auto;
  position: relative;
`, Meta = styled__default.default.div`
  position: absolute;
  top: 0;
  right: 0;
`;
function DiffInspectWrapper(props2) {
  const { children, as, change, ...restProps } = props2, isHovering = React.useRef(!1), [isInspecting, setIsInspecting] = React.useState(!1), toggleInspect = React.useCallback(() => setIsInspecting((state) => !state), [setIsInspecting]), handleMouseEnter = React.useCallback(() => isHovering.current = !0, []), handleMouseLeave = React.useCallback(() => isHovering.current = !1, [isHovering]);
  return React.useEffect(() => {
    function onKeyDown(evt) {
      const { metaKey, key } = evt;
      metaKey && key === "i" && isHovering.current && toggleInspect();
    }
    return window.addEventListener("keydown", onKeyDown, !1), () => window.removeEventListener("keydown", onKeyDown, !1);
  }, [toggleInspect]), /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...restProps, children: isInspecting ? /* @__PURE__ */ jsxRuntime.jsx(DiffInspector, { change }) : children });
}
const MetaLabel = ({ title }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, display: "inline-block", as: Meta, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: title }) });
function DiffInspector({ change }) {
  var _a2, _b, _c;
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { padding: 3, tone: "transparent", as: CodeWrapper$1, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.meta-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: printMeta({
        path: pathToString$1(change.path),
        fromIndex: (_a2 = change.itemDiff) == null ? void 0 : _a2.fromIndex,
        toIndex: (_b = change.itemDiff) == null ? void 0 : _b.toIndex,
        hasMoved: (_c = change.itemDiff) == null ? void 0 : _c.hasMoved,
        action: change.diff.action,
        isChanged: change.diff.isChanged
      }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: CodeWrapper$1, tone: "critical", padding: 3, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.from-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: jsonify(change.diff.fromValue) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, { direction: "down", align: "center" }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: CodeWrapper$1, tone: "positive", padding: 3, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.to-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: jsonify(change.diff.toValue) })
    ] })
  ] });
}
function jsonify(value) {
  return typeof value > "u" ? "undefined" : JSON.stringify(value, null, 2);
}
function printMeta(keys) {
  const lines = [];
  return Object.entries(keys).forEach(([key, value]) => {
    typeof value < "u" && value !== null && lines.push(`${key}: ${value}`);
  }), lines.join(`
`);
}
function useChangeVerb(diff2) {
  const { t: t2 } = useTranslation(), hadPrevValue = hasValue(diff2.fromValue), hasNextValue = hasValue(diff2.toValue);
  return t2(!hadPrevValue && hasNextValue ? "changes.added-label" : !hasNextValue && hadPrevValue ? "changes.removed-label" : "changes.changed-label");
}
function hasValue(value) {
  return value !== null && typeof value < "u" && value !== "";
}
const INLINE_COLUMN_STYLES = { flexShrink: 0 }, BLOCK_COLUMN_STYLES = { alignItems: "stretch" }, FLEX_ALIGN = {
  top: "flex-start",
  center: "center",
  bottom: "flex-end",
  default: "flex-start"
}, FromTo = React.forwardRef(function(props2, ref) {
  const { align: align2 = "top", layout = "inline", from, to, style, ...restProps } = props2, theme2 = ui.useTheme(), Layout2 = layout === "inline" ? ui.Flex : ui.Grid, layoutStyles = React.useMemo(
    () => ({
      ...style,
      ...layout === "inline" ? { maxWidth: "100%", display: "inline-flex" } : { gridTemplateColumns: `minmax(0, 1fr) ${ui.rem(theme2.sanity.space[5])} minmax(0, 1fr)` }
    }),
    [layout, style, theme2]
  ), columnStyles = layout === "inline" ? INLINE_COLUMN_STYLES : BLOCK_COLUMN_STYLES;
  return /* @__PURE__ */ jsxRuntime.jsxs(Layout2, { ...restProps, ref, style: layoutStyles, "data-from-to-layout": !0, children: [
    from && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: from }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: to })
  ] });
}), cardStyles = {
  flex: 1,
  minWidth: 0,
  display: "block",
  whiteSpace: "break-spaces"
};
function DiffFromTo(props2) {
  const { align: align2, cardClassName, diff: diff2, layout, path, previewComponent, schemaType } = props2, { action } = diff2, changeVerb = useChangeVerb(diff2);
  if (action === "unchanged")
    return /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { className: cardClassName, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.toValue }) });
  const from = diff2.fromValue !== void 0 && diff2.fromValue !== null && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "del", className: cardClassName, diff: diff2, path, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.fromValue }) }), to = diff2.toValue !== void 0 && diff2.toValue !== null && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "ins", className: cardClassName, diff: diff2, path, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.toValue }) });
  return from && !to ? /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: from }) : !from && to ? /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: to }) : /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: /* @__PURE__ */ jsxRuntime.jsx(FromTo, { align: align2, from, layout, to }) });
}
const FallbackPreview = ({ value, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Preview, { schemaType, value, layout: "default" }) }), FallbackDiff = (props2) => {
  const { diff: diff2, schemaType } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    DiffFromTo,
    {
      diff: diff2,
      schemaType,
      previewComponent: FallbackPreview,
      layout: "grid"
    }
  );
}, FieldChangeContainer = styled__default.default.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  &[data-revert-all-changes-hover] [data-revert-all-hover]::before {
    border-left: 2px solid var(--field-change-error);
  }
`, DiffBorder = styled__default.default.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  --diff-inspect-padding-xsmall: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  --diff-inspect-padding-small: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[2])};

  position: relative;
  padding: var(--diff-inspect-padding-xsmall) 0 var(--diff-inspect-padding-xsmall)
    var(--diff-inspect-padding-small);

  &::before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: 1px solid var(--card-border-color);
  }

  &[data-error]:hover::before,
  &[data-revert-field-hover]:hover::before {
    border-left: 2px solid var(--field-change-error);
  }
`, Root$r = styled__default.default(getJsonStream.Button)`
  [data-ui='Text'] {
    font-weight: normal;
  }

  div[data-ui='Box'] {
    display: none;
  }

  &:not([data-disabled='true']):hover,
  &:not([data-disabled='true']):focus {
    --card-fg-color: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
    --card-bg-color: transparent;
    --card-border-color: transparent;

    div[data-ui='Box'] {
      display: block;
    }
  }
`, RevertChangesButton = React.forwardRef(function(props2, ref) {
  const { selected, changeCount, ...restProps } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$r,
    {
      icon: icons.RevertIcon,
      selected,
      text: t2("changes.action.revert-changes-confirm-change", { count: changeCount }),
      mode: "bleed",
      ref,
      tooltipProps: null,
      ...restProps
    }
  );
});
function ValueError({ error }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "critical", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: "p", children: t2(error.messageKey, {
      expectedType: error.expectedType,
      actualType: error.actualType
    }) }) })
  ] }) });
}
function FieldChange(props2) {
  var _a2;
  const { change, hidden, readOnly } = props2, DiffComponent = change.diffComponent || FallbackDiff, {
    documentId,
    schemaType,
    rootDiff,
    isComparingCurrent,
    FieldWrapper: FieldWrapper2 = React.Fragment
  } = useDocumentChange(), ops = useDocumentOperation(documentId, schemaType.name), [confirmRevertOpen, setConfirmRevertOpen] = React.useState(!1), [revertHovered, setRevertHovered] = React.useState(!1), [revertButtonElement, setRevertButtonElement] = React.useState(null), { t: t2 } = useTranslation(), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), handleRevertChanges = React.useCallback(() => {
    undoChange(change, rootDiff, ops);
  }, [change, rootDiff, ops]), handleRevertChangesConfirm = React.useCallback(() => {
    setConfirmRevertOpen(!0);
  }, []), closeRevertChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertOpen(!1);
  }, []), handleRevertButtonMouseEnter = React.useCallback(() => {
    setRevertHovered(!0);
  }, []), handleRevertButtonMouseLeave = React.useCallback(() => {
    setRevertHovered(!1);
  }, []), handleClickOutside = React.useCallback(() => setConfirmRevertOpen(!1), []);
  ui.useClickOutside(handleClickOutside, [revertButtonElement]);
  const fieldPath = ((_a2 = change.parentSchema) == null ? void 0 : _a2.jsonType) === "array" ? change.path.slice(0, -1) : change.path;
  return React.useMemo(
    () => hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, as: FieldChangeContainer, children: [
      change.showHeader && /* @__PURE__ */ jsxRuntime.jsx(ChangeBreadcrumb, { change, titlePath: change.titlePath }),
      /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper2, { path: fieldPath, hasHover: revertHovered, children: /* @__PURE__ */ jsxRuntime.jsxs(
        DiffInspectWrapper,
        {
          change,
          as: DiffBorder,
          "data-revert-field-hover": revertHovered ? "" : void 0,
          "data-error": change.error ? "" : void 0,
          "data-revert-all-hover": !0,
          children: [
            change.error ? /* @__PURE__ */ jsxRuntime.jsx(ValueError, { error: change.error }) : /* @__PURE__ */ jsxRuntime.jsx(DiffErrorBoundary, { t: t2, children: /* @__PURE__ */ jsxRuntime.jsx(DiffContext.Provider, { value: { path: change.path }, children: /* @__PURE__ */ jsxRuntime.jsx(
              DiffComponent,
              {
                diff: change.diff,
                schemaType: change.schemaType
              }
            ) }) }),
            isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.Popover,
              {
                content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
                  /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-changes-description", { count: 1 }) }) }),
                  /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
                    /* @__PURE__ */ jsxRuntime.jsx(
                      getJsonStream.Button,
                      {
                        mode: "ghost",
                        onClick: closeRevertChangesConfirmDialog,
                        text: t2("changes.action.revert-all-cancel")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntime.jsx(
                      getJsonStream.Button,
                      {
                        tone: "critical",
                        onClick: handleRevertChanges,
                        text: t2("changes.action.revert-changes-confirm-change", { count: 1 })
                      }
                    )
                  ] })
                ] }),
                open: confirmRevertOpen,
                padding: 3,
                portal: !0,
                placement: "left",
                ref: setRevertButtonElement,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  RevertChangesButton,
                  {
                    changeCount: 1,
                    onClick: handleRevertChangesConfirm,
                    onMouseEnter: handleRevertButtonMouseEnter,
                    onMouseLeave: handleRevertButtonMouseLeave,
                    selected: confirmRevertOpen,
                    disabled: readOnly,
                    "data-testid": `single-change-revert-button-${change == null ? void 0 : change.key}`
                  }
                )
              }
            )
          ]
        }
      ) })
    ] }),
    [
      change,
      closeRevertChangesConfirmDialog,
      confirmRevertOpen,
      DiffComponent,
      fieldPath,
      FieldWrapper2,
      handleRevertButtonMouseEnter,
      handleRevertButtonMouseLeave,
      handleRevertChanges,
      handleRevertChangesConfirm,
      hidden,
      isComparingCurrent,
      isPermissionsLoading,
      permissions == null ? void 0 : permissions.granted,
      readOnly,
      revertHovered,
      t2
    ]
  );
}
function useHover() {
  const ref = React.useRef(null), [value, setValue] = React.useState(!1);
  return React.useEffect(() => {
    const node = ref.current;
    if (!node)
      return () => {
      };
    const handleMouseOver = () => setValue(!0), handleMouseOut = () => setValue(!1);
    return node.addEventListener("mouseover", handleMouseOver), node.addEventListener("mouseout", handleMouseOut), () => {
      node.removeEventListener("mouseover", handleMouseOver), node.removeEventListener("mouseout", handleMouseOut);
    };
  }, []), [ref, value];
}
const ChangeListWrapper = styled__default.default.div`
  display: grid;
  grid-template-columns: minmax(0, 1fr);
`, GroupChangeContainer = styled__default.default.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  --diff-inspect-padding-xsmall: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  --diff-inspect-padding-small: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[2])};

  position: relative;
  padding: var(--diff-inspect-padding-xsmall) var(--diff-inspect-padding-small);

  &::before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: 1px solid var(--card-border-color);
  }

  &[data-error]:hover::before,
  &[data-revert-group-hover]:hover::before,
  &[data-revert-all-groups-hover]::before {
    border-left: 2px solid var(--field-change-error);
  }
`;
function GroupChange(props2) {
  const { change: group2, readOnly, hidden, ...restProps } = props2, { titlePath, changes, path: groupPath } = group2, { path: diffPath } = React.useContext(DiffContext), { documentId, schemaType, FieldWrapper: FieldWrapper2, rootDiff, isComparingCurrent } = useDocumentChange(), { t: t2 } = useTranslation(), isPortableText2 = changes.every(
    (change) => isFieldChange(change) && isPTSchemaType(change.schemaType)
  ), isNestedInDiff = pathsAreEqual(diffPath, groupPath), [revertButtonRef, isRevertButtonHovered] = useHover(), docOperations = useDocumentOperation(documentId, schemaType.name), [confirmRevertOpen, setConfirmRevertOpen] = React.useState(!1), [revertPopoverElement, setRevertPopoverElement] = React.useState(null), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), handleRevertChanges = React.useCallback(
    () => undoChange(group2, rootDiff, docOperations),
    [group2, rootDiff, docOperations]
  ), handleRevertChangesConfirm = React.useCallback(() => {
    setConfirmRevertOpen(!0);
  }, []), closeRevertChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertOpen(!1);
  }, []);
  ui.useClickOutside(() => setConfirmRevertOpen(!1), [revertPopoverElement]);
  const content2 = React.useMemo(
    () => hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Stack,
      {
        space: 1,
        as: GroupChangeContainer,
        "data-revert-group-hover": isRevertButtonHovered ? "" : void 0,
        "data-portable-text": isPortableText2 ? "" : void 0,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: ChangeListWrapper, space: 5, children: changes.map((change) => /* @__PURE__ */ jsxRuntime.jsx(
            ChangeResolver,
            {
              change,
              readOnly,
              hidden
            },
            change.key
          )) }),
          isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Popover,
            {
              content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
                /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-changes-description", { count: changes.length }) }) }),
                /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
                  /* @__PURE__ */ jsxRuntime.jsx(
                    getJsonStream.Button,
                    {
                      mode: "ghost",
                      onClick: closeRevertChangesConfirmDialog,
                      text: t2("changes.action.revert-all-cancel")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    getJsonStream.Button,
                    {
                      tone: "critical",
                      onClick: handleRevertChanges,
                      text: t2("changes.action.revert-changes-confirm-change", { count: 1 })
                    }
                  )
                ] })
              ] }),
              padding: 3,
              portal: !0,
              placement: "left",
              open: confirmRevertOpen,
              ref: setRevertPopoverElement,
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
                RevertChangesButton,
                {
                  changeCount: changes.length,
                  onClick: handleRevertChangesConfirm,
                  ref: revertButtonRef,
                  selected: confirmRevertOpen,
                  disabled: readOnly,
                  "data-testid": `group-change-revert-button-${group2.fieldsetName}`
                }
              ) })
            }
          )
        ]
      }
    ),
    [
      changes,
      closeRevertChangesConfirmDialog,
      confirmRevertOpen,
      group2.fieldsetName,
      handleRevertChanges,
      handleRevertChangesConfirm,
      hidden,
      isComparingCurrent,
      isPermissionsLoading,
      isPortableText2,
      isRevertButtonHovered,
      permissions == null ? void 0 : permissions.granted,
      readOnly,
      revertButtonRef,
      t2
    ]
  );
  return hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, ...restProps, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeBreadcrumb, { titlePath }),
    isNestedInDiff || !FieldWrapper2 ? content2 : /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper2, { hasHover: isRevertButtonHovered, path: group2.path, children: content2 })
  ] });
}
function ChangeResolver(props2) {
  var _a2, _b;
  const { change, hidden, readOnly } = props2, { value } = useDocumentChange(), isHidden = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: hidden || ((_a2 = change.schemaType) == null ? void 0 : _a2.hidden),
    checkPropertyKey: "hidden",
    value: change.type === "field" ? change.diff.toValue : void 0
  }), isReadOnly = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: readOnly || ((_b = change.schemaType) == null ? void 0 : _b.readOnly),
    checkPropertyKey: "readOnly",
    value: change.type === "field" ? change.diff.toValue : void 0
  });
  return isHidden ? null : change.type === "field" ? /* @__PURE__ */ jsxRuntime.jsx(FieldChange, { change, readOnly: isReadOnly }) : change.type === "group" ? /* @__PURE__ */ jsxRuntime.jsx(
    GroupChange,
    {
      change,
      "data-testid": `group-change-${change.fieldsetName}`,
      readOnly: isReadOnly
    }
  ) : (
    // eslint-disable-next-line i18next/no-literal-string
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
      "Unknown change type: ",
      /* @__PURE__ */ jsxRuntime.jsx("code", { children: change.type || "undefined" })
    ] })
  );
}
function NoChanges() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", as: "h3", children: t2("changes.no-changes-title") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, muted: !0, children: t2("changes.no-changes-description") })
  ] });
}
function ChangeList({ diff: diff2, fields, schemaType }) {
  const { documentId, isComparingCurrent, value } = useDocumentChange(), docOperations = useDocumentOperation(documentId, schemaType.name), { path } = React.useContext(DiffContext), isRoot = path.length === 0, [confirmRevertAllOpen, setConfirmRevertAllOpen] = React.useState(!1), [confirmRevertAllHover, setConfirmRevertAllHover] = React.useState(!1), { t: t2 } = useTranslation(), isReadOnly = useConditionalProperty({
    document: value,
    value: void 0,
    checkProperty: schemaType.readOnly,
    checkPropertyKey: "readOnly"
  });
  if (schemaType.jsonType !== "object")
    throw new Error("Only object schema types are allowed in ChangeList");
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), allChanges = React.useMemo(
    () => buildObjectChangeList(schemaType, diff2, path, [], { fieldFilter: fields }),
    [schemaType, fields, path, diff2]
  ), changes = React.useMemo(
    () => fields && fields.length === 0 ? [] : maybeFlatten(allChanges),
    [allChanges, fields]
  ), rootChange = allChanges[0], revertAllChanges = React.useCallback(() => {
    undoChange(rootChange, diff2, docOperations), setConfirmRevertAllOpen(!1);
  }, [rootChange, diff2, docOperations]), handleRevertAllChangesClick = React.useCallback(() => {
    setConfirmRevertAllOpen(!0);
  }, []), handleRevertAllChangesMouseEnter = React.useCallback(() => {
    setConfirmRevertAllHover(!0);
  }, []), handleRevertAllChangesMouseLeave = React.useCallback(() => {
    setConfirmRevertAllHover(!1);
  }, []), closeRevertAllChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertAllOpen(!1);
  }, []), [revertAllContainerElement, setRevertAllContainerElement] = React.useState(
    null
  ), handleClickOutside = React.useCallback(() => setConfirmRevertAllOpen(!1), []);
  if (ui.useClickOutside(handleClickOutside, [revertAllContainerElement]), changes.length === 0)
    return isRoot ? /* @__PURE__ */ jsxRuntime.jsx(NoChanges, {}) : null;
  const showFooter = isRoot && changes.length > 1;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: ChangeListWrapper$1, space: 5, children: changes.map((change) => /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
      ChangeResolver,
      {
        change,
        "data-revert-all-changes-hover": confirmRevertAllHover ? "" : void 0,
        readOnly: isReadOnly || (change == null ? void 0 : change.readOnly),
        hidden: change == null ? void 0 : change.hidden
      },
      change.key
    ) }, change.key)) }),
    showFooter && isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Popover,
      {
        content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-all-description", {
            count: changes.length
          }) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.Button,
              {
                mode: "ghost",
                text: t2("changes.action.revert-all-cancel"),
                onClick: closeRevertAllChangesConfirmDialog
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.Button,
              {
                tone: "critical",
                text: t2("changes.action.revert-all-confirm"),
                onClick: revertAllChanges
              }
            )
          ] })
        ] }),
        open: confirmRevertAllOpen,
        padding: 3,
        placement: "left",
        portal: !0,
        ref: setRevertAllContainerElement,
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            tone: "critical",
            mode: "ghost",
            text: t2("changes.action.revert-all-confirm"),
            icon: icons.RevertIcon,
            onClick: handleRevertAllChangesClick,
            onMouseEnter: handleRevertAllChangesMouseEnter,
            onMouseLeave: handleRevertAllChangesMouseLeave,
            disabled: isReadOnly,
            size: "large"
          }
        ) })
      }
    )
  ] }) });
}
function maybeFlatten(changes) {
  return changes.length === 1 && changes[0].type === "group" && changes[0].path.length === 0 ? changes[0].changes : changes;
}
const RoundedCard = styled__default.default.span`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
`, ChangeSegment = styled__default.default(ui.Text)`
  &:not([hidden]) {
    display: inline;
    line-height: calc(1.25em + 2px);
  }

  &:hover {
    background-color: none !important;
    background-image: linear-gradient(
      to bottom,
      var(--card-bg-color) 0,
      var(--card-bg-color) 33.333%,
      currentColor 33.333%,
      currentColor 100%
    );
    background-size: 1px 3px;
    background-repeat: repeat-x;
    background-position-y: bottom;
    padding-bottom: 3px;
    box-shadow: 0 0 0 1px var(--card-bg-color);
    z-index: 1;
  }
`;
function DiffStringSegment(props2) {
  const { segment } = props2, { text } = segment, { t: t2 } = useTranslation();
  return segment.action === "added" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: segment.annotation,
      disableHoverEffect: !0,
      tooltip: { description: t2("changes.added-label") },
      as: RoundedCard,
      children: /* @__PURE__ */ jsxRuntime.jsx(ChangeSegment, { as: "ins", style: { textDecoration: "none" }, children: text })
    }
  ) : segment.action === "removed" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: segment.annotation,
      as: RoundedCard,
      disableHoverEffect: !0,
      tooltip: { description: t2("changes.removed-label") },
      children: /* @__PURE__ */ jsxRuntime.jsx(ChangeSegment, { as: "del", children: text })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "span", radius: 2, style: { display: "inline" }, children: text });
}
function DiffString(props2) {
  const { diff: diff2 } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (diff2.segments || []).map((segment, segmentIndex) => /* @__PURE__ */ jsxRuntime.jsx(
    DiffStringSegment,
    {
      segment
    },
    segmentIndex
  )) });
}
const MetaText = styled__default.default(ui.Text)`
  color: inherit;
`;
function MetaInfo(props2) {
  const { title, action, icon, children, markRemoved } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 2, align: "center", children: [
    icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(MetaText, { size: 4, forwardedAs: markRemoved ? "del" : "div", children: React.createElement(icon) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, paddingLeft: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        MetaText,
        {
          size: 1,
          weight: "medium",
          forwardedAs: markRemoved ? "del" : "h3",
          textOverflow: "ellipsis",
          children: title
        }
      ),
      action && /* @__PURE__ */ jsxRuntime.jsx("div", { children: action }),
      /* @__PURE__ */ jsxRuntime.jsx(MetaText, { size: 0, textOverflow: "ellipsis", children })
    ] })
  ] });
}
const SlugWrapper = styled__default.default.div`
  display: inline-block;
  word-break: break-all;
  white-space: pre-wrap;
`, SlugPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: SlugWrapper, paddingX: 2, paddingY: 1, children: value.current });
};
function immutableReconcile(previous, next) {
  return _immutableReconcile(previous, next, /* @__PURE__ */ new WeakSet());
}
function _immutableReconcile(previous, next, parents) {
  if (previous === next)
    return previous;
  if (parents.has(next) || previous == null || next == null || typeof previous != typeof next)
    return next;
  if (Array.isArray(next)) {
    parents.add(next);
    let allEqual = previous.length === next.length;
    const result = [];
    for (let index = 0; index < next.length; index++) {
      const nextItem = _immutableReconcile(previous[index], next[index], parents);
      nextItem !== previous[index] && (allEqual = !1), result[index] = nextItem;
    }
    return parents.delete(next), allEqual ? previous : result;
  }
  if (typeof next == "object") {
    parents.add(next);
    const nextKeys = Object.keys(next);
    let allEqual = Object.keys(previous).length === nextKeys.length;
    const result = {};
    for (const key of nextKeys) {
      const nextValue = _immutableReconcile(previous[key], next[key], parents);
      nextValue !== previous[key] && (allEqual = !1), result[key] = nextValue;
    }
    return parents.delete(next), allEqual ? previous : result;
  }
  return next;
}
const PresenceContext = React.createContext([]);
function PresenceProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(PresenceContext.Provider, { value: props2.presence, children: props2.children });
}
function useFormFieldPresence() {
  const ctx = React.useContext(PresenceContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function useChildPresence(path, inclusive) {
  const presence = useFormFieldPresence(), prev = React.useRef(presence), next = immutableReconcile(
    prev.current,
    presence.filter(
      (item) => PathUtils.startsWith(path, item.path) && (inclusive || !PathUtils.isEqual(path, item.path))
    )
  );
  return prev.current = next, next;
}
const FormBuilderContext = React.createContext(null);
function useFormBuilder() {
  const formBuilder = React.useContext(FormBuilderContext);
  if (!formBuilder)
    throw new Error("FormBuilder: missing context value");
  return formBuilder;
}
const getIcon = (level) => level === "error" ? /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) : level === "warning" ? /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}), IconText = styled__default.default(ui.Text)(({ theme: theme2 }) => styled.css`
    &[data-info] {
      color: ${theme2.sanity.color.muted.primary.enabled.fg};
    }

    &[data-warning] {
      color: ${theme2.sanity.color.muted.caution.enabled.fg};
    }

    &[data-error] {
      color: ${theme2.sanity.color.muted.critical.enabled.fg};
    }
  `);
function DefaultMarkers(props2) {
  const { markers, validation: validation2, renderCustomMarkers } = props2, { CustomMarkers } = useFormBuilder().__internal.components;
  return markers.length === 0 && validation2.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
    validation2.length > 0 && validation2.map(({ message, level }, index) => (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 2, marginBottom: index + 1 === validation2.length ? 0 : 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          IconText,
          {
            size: 1,
            "data-error": level === "error" ? "" : void 0,
            "data-warning": level === "warning" ? "" : void 0,
            "data-info": level === "info" ? "" : void 0,
            children: getIcon(level)
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: message || "Error" }) })
      ] }, `validationItem-${index}`)
    )),
    markers.length > 0 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { marginTop: validation2.length > 0 ? 3 : 0, children: [
      renderCustomMarkers && renderCustomMarkers(markers),
      !renderCustomMarkers && /* @__PURE__ */ jsxRuntime.jsx(CustomMarkers, { markers })
    ] })
  ] });
}
const ValidationContext = React.createContext([]);
function ValidationProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ValidationContext.Provider, { value: props2.validation, children: props2.children });
}
function useValidationMarkers() {
  const ctx = React.useContext(ValidationContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function useChildValidation(path, inclusive = !1) {
  const validation2 = useValidationMarkers();
  return React.useMemo(
    () => validation2.filter((item) => PathUtils.startsWith(path, item.path) && (inclusive || !PathUtils.isEqual(path, item.path))).map((marker) => ({
      message: marker.message,
      level: marker.level,
      path: marker.path
    })),
    [inclusive, path, validation2]
  );
}
const NONEXISTENT_PATH = ["@@_NONEXISTENT_PATH_@@"];
function useMemberValidation(member) {
  const prev = React.useRef(null), memberValidation = member != null && member.validation && member.validation.length > 0 ? member.validation : EMPTY_ARRAY$b, childValidation = useChildValidation((member == null ? void 0 : member.path) || NONEXISTENT_PATH), validation2 = React.useMemo(
    () => member != null && member.schemaType && isBlockType(member == null ? void 0 : member.schemaType) ? memberValidation : memberValidation.concat(childValidation),
    [childValidation, member, memberValidation]
  ), [hasError, hasWarning, hasInfo] = React.useMemo(
    () => [
      validation2.filter((v) => v.level === "error").length > 0,
      validation2.filter((v) => v.level === "warning").length > 0,
      validation2.filter((v) => v.level === "info").length > 0
    ],
    [validation2]
  ), reconciled = immutableReconcile(prev.current, validation2);
  return prev.current = reconciled, React.useMemo(() => ({
    validation: reconciled,
    hasError,
    hasWarning,
    hasInfo
  }), [reconciled, hasError, hasWarning, hasInfo]);
}
const PortableTextMarkersContext = React.createContext([]);
function PortableTextMarkersProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(PortableTextMarkersContext.Provider, { value: props2.markers, children: props2.children });
}
function usePortableTextMarkers(path) {
  const ctx = React.useContext(PortableTextMarkersContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return React.useMemo(() => ctx.filter((m) => PathUtils.isEqual(m.path, path)), [ctx, path]);
}
const POPOVER_PROPS$4 = {
  placement: "right",
  fallbackPlacements: ["top", "bottom"]
};
function FieldActionMenuGroup(props2) {
  const { group: group2 } = props2, { title } = useI18nText(group2);
  return group2.expanded ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, paddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: title }) }),
    group2.children.map((item, idx) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntime.jsx(
        FieldActionMenuNode,
        {
          action: item,
          isFirst: idx === 0,
          prevIsGroup: ((_a2 = group2.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
        },
        idx
      );
    })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuGroup, { icon: group2.icon, popover: POPOVER_PROPS$4, text: title, tone: group2.tone, children: group2.children.map((item, idx) => {
    var _a2;
    return /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionMenuNode,
      {
        action: item,
        isFirst: idx === 0,
        prevIsGroup: ((_a2 = group2.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
      },
      idx
    );
  }) });
}
function FieldActionMenuItem(props2) {
  const { action } = props2, { title } = useI18nText(action), handleClick = React.useCallback(() => {
    action.onAction();
  }, [action]), disabledTooltipContent = typeof action.disabled == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: action.disabled.reason });
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipOfDisabled, { content: disabledTooltipContent, placement: "left", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      disabled: !!action.disabled,
      icon: action.icon,
      iconRight: action.iconRight || (action.selected ? icons.CheckmarkIcon : void 0),
      onClick: handleClick,
      pressed: action.selected,
      text: title,
      tone: action.tone
    }
  ) });
}
function FieldActionMenuNode(props2) {
  const { action, isFirst, prevIsGroup } = props2;
  return action.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}) : action.type === "group" ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    !isFirst && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenuGroup, { group: action })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    prevIsGroup && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenuItem, { action })
  ] });
}
const STATUS_BUTTON_TOOLTIP_PROPS = {
  placement: "top"
};
function renderAsButton(node) {
  return "renderAsButton" in node && node.renderAsButton;
}
const FieldActionMenu = React.memo(function(props2) {
  const { nodes, onMenuOpenChange } = props2, [open, setOpen] = React.useState(!1), handleOpen = React.useCallback(() => {
    onMenuOpenChange(!0), setOpen(!0);
  }, [onMenuOpenChange]), handleClose = React.useCallback(() => {
    onMenuOpenChange(!1), setOpen(!1);
  }, [onMenuOpenChange]), buttonNodes = React.useMemo(() => nodes.filter(renderAsButton), [nodes]), menuNodesProp = React.useMemo(() => nodes.filter((node) => !renderAsButton(node)), [nodes]), menuNodes = React.useMemo(() => {
    const len = menuNodesProp.length;
    if (len === 0 || len > 1)
      return menuNodesProp;
    const node = menuNodesProp[0];
    return node.type === "group" ? [{ ...node, expanded: !0 }] : menuNodesProp;
  }, [menuNodesProp]), rootNodes = React.useMemo(
    () => [
      ...menuNodes.length ? [
        {
          type: "group",
          children: menuNodes,
          icon: icons.EllipsisHorizontalIcon,
          title: "Field actions"
        }
      ] : [],
      ...buttonNodes
    ],
    [buttonNodes, menuNodes]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: rootNodes.map((node, idx) => /* @__PURE__ */ jsxRuntime.jsx(
    RootFieldActionMenuNode,
    {
      node,
      onOpen: handleOpen,
      onClose: handleClose,
      open
    },
    idx
  )) });
}), RootFieldActionMenuNode = React.memo(function(props2) {
  const { node, onOpen, onClose, open } = props2;
  return node.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderLeft: !0, flex: "none" }) : node.type === "action" ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      icon: node.icon,
      mode: "bleed",
      onClick: node.onAction,
      tooltipProps: {
        ...STATUS_BUTTON_TOOLTIP_PROPS,
        content: node.title
      }
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(RootFieldActionMenuGroup, { node, onOpen, onClose, open });
}), ROOT_MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "right",
  portal: !0,
  fallbackPlacements: ["top", "bottom"]
};
function RootFieldActionMenuGroup(props2) {
  const { node, onOpen, onClose, open } = props2, { title } = useI18nText(node);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: node.icon,
          label: open ? void 0 : title,
          mode: "bleed",
          tooltipProps: {
            ...STATUS_BUTTON_TOOLTIP_PROPS,
            content: node.title
          }
        }
      ),
      id: React.useId(),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: node.children.map((action, idx) => {
        var _a2;
        return /* @__PURE__ */ jsxRuntime.jsx(
          FieldActionMenuNode,
          {
            action,
            isFirst: idx === 0,
            prevIsGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
          },
          idx
        );
      }) }),
      onOpen,
      onClose,
      popover: ROOT_MENU_BUTTON_POPOVER_PROPS
    }
  );
}
const HoveredFieldContext = React.createContext({
  hoveredStack: [],
  onMouseEnter: () => {
  },
  onMouseLeave: () => {
  }
});
function useHoveredField() {
  return React.useContext(HoveredFieldContext);
}
const FieldActionsContext = React.createContext({
  actions: [],
  focused: !1,
  hovered: !1,
  onMouseEnter: () => {
  },
  onMouseLeave: () => {
  }
});
function FieldActionsProvider(props2) {
  const { actions, children, path, focused } = props2, { onMouseEnter: onFieldMouseEnter, onMouseLeave: onFieldMouseLeave } = useHoveredField(), hoveredPath = useHoveredField().hoveredStack[0], hovered = supportsTouch || (hoveredPath ? pathToString$1(path) === hoveredPath : !1), handleMouseEnter = React.useCallback(() => {
    onFieldMouseEnter(path);
  }, [onFieldMouseEnter, path]), handleMouseLeave = React.useCallback(() => {
    onFieldMouseLeave(path);
  }, [onFieldMouseLeave, path]), context = React.useMemo(
    () => ({
      actions,
      focused,
      hovered,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }),
    [actions, focused, handleMouseEnter, handleMouseLeave, hovered]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FieldActionsContext.Provider, { value: context, children });
}
function filterActions(actions) {
  return actions.filter(Boolean).filter((node) => "hidden" in node ? node.hidden !== !0 : !0).map((node) => node.type === "group" ? {
    ...node,
    children: filterActions(node.children)
  } : node);
}
const FieldActionsResolver = React.memo(function(props2) {
  const { actions, documentId, documentType, onActions, path, schemaType } = props2, len = actions.length, lenRef = React.useRef(len), [fieldActions, setFieldActions] = React.useState(
    () => Array.from(new Array(len))
  ), fieldActionsRef = React.useRef(fieldActions), setFieldAction = React.useCallback((index, node) => {
    setFieldActions((prev) => {
      const next = [...prev];
      return next[index] = node, next;
    });
  }, []);
  return React.useEffect(() => {
    fieldActionsRef.current !== fieldActions && (fieldActionsRef.current = fieldActions, onActions(filterActions(fieldActions)));
  }, [fieldActions, onActions]), React.useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = fieldActionsRef.current[i];
      lenRef.current = len, setFieldActions(newFieldActions), fieldActionsRef.current = newFieldActions;
    }
  }, [len]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: actions.map((a, aIdx) => /* @__PURE__ */ jsxRuntime.jsx(
    FieldAction,
    {
      action: a,
      index: aIdx,
      documentId,
      documentType,
      path,
      schemaType,
      setFieldAction
    },
    aIdx
  )) });
}), FieldAction = React.memo(function(props2) {
  const { action, documentId, documentType, index, path, schemaType, setFieldAction } = props2, node = useUnique(
    action.useAction({
      documentId,
      documentType,
      path,
      schemaType
    })
  );
  return React.useEffect(() => {
    setFieldAction(index, node);
  }, [index, node, setFieldAction]), null;
});
function useFieldActions() {
  return React.useContext(FieldActionsContext);
}
const FormFieldPresenceContext = React.createContext([]), PRESENCE_MENU_POPOVER_PROPS = {
  portal: !0
}, AvatarStackBox = styled__default.default.div((props2) => {
  const { space } = theme.getTheme_v2(props2.theme);
  return styled.css`
    margin: ${0 - space[1]}px;
  `;
}), getTooltipText = (presence) => {
  if (presence.length === 1)
    return `${presence[0].user.displayName} is editing this document`;
  if (presence.length > 1)
    return `${presence.length} people are editing this document right now`;
};
function DocumentPreviewPresence(props2) {
  const { presence } = props2, uniqueUsers = React.useMemo(
    () => Array.from(new Set(presence.map((a) => a.user.id))).map((id2) => presence.find((a) => a.user.id === id2)).filter(isNonNullable$2),
    [presence]
  ), tooltipContent = React.useMemo(() => getTooltipText(uniqueUsers), [uniqueUsers]);
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: tooltipContent, ...PRESENCE_MENU_POPOVER_PROPS, children: /* @__PURE__ */ jsxRuntime.jsx(AvatarStackBox, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength: 2, "aria-label": getTooltipText(uniqueUsers), size: 0, children: uniqueUsers.map((item) => /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 0, user: item.user }, item.user.id)) }) }) });
}
const symbols = /[^\p{Alpha}\p{White_Space}]/gu, whitespace = new RegExp("\\p{White_Space}+", "u"), LEGACY_TO_UI_AVATAR_SIZES = {
  small: 0,
  medium: 1,
  large: 2
};
function nameToInitials(fullName) {
  const namesArray = fullName.replace(symbols, "").split(whitespace);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function UserAvatar(props2) {
  const { user, ...restProps } = props2;
  return isRecord$4(user) ? restProps.withTooltip ? /* @__PURE__ */ jsxRuntime.jsx(TooltipUserAvatar, { ...restProps, user }) : /* @__PURE__ */ jsxRuntime.jsx(StaticUserAvatar, { ...restProps, user }) : /* @__PURE__ */ jsxRuntime.jsx(UserAvatarLoader, { ...props2, user });
}
function TooltipUserAvatar(props2) {
  const {
    user: { displayName }
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: displayName, placement: "top", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { display: "inline-block" }, children: /* @__PURE__ */ jsxRuntime.jsx(StaticUserAvatar, { ...props2 }) }) });
}
const StaticUserAvatar = React.forwardRef(function(props2, ref) {
  const { user, animateArrowFrom, position, size, status, tone, ...restProps } = props2, [imageLoadError, setImageLoadError] = React.useState(null), userColor = useUserColor(user.id), imageUrl = imageLoadError || user == null ? void 0 : user.imageUrl;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Avatar,
    {
      __unstable_hideInnerStroke: !0,
      animateArrowFrom,
      arrowPosition: position,
      color: userColor.name,
      "data-legacy-tone": tone,
      initials: (user == null ? void 0 : user.displayName) && nameToInitials(user.displayName),
      src: imageUrl,
      onImageLoadError: setImageLoadError,
      ref,
      size: typeof size == "string" ? LEGACY_TO_UI_AVATAR_SIZES[size] : size,
      status,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  );
});
function UserAvatarLoader({ user, ...loadedProps }) {
  const [value] = useUser(user);
  return value ? /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { ...loadedProps, user: value }) : null;
}
const MAX_AVATARS_DOCK = 3, DEFAULT_MAX_AVATARS_FIELDS = 3, AVATAR_DISTANCE = -4, AVATAR_SIZE = 25, AVATAR_ARROW_HEIGHT = 4, INTERSECTION_THRESHOLDS = [0, 0.25, 0.75, 1], INTERSECTION_ELEMENT_PADDING = 23, SNAP_TO_DOCK_DISTANCE_TOP = 8, SNAP_TO_DOCK_DISTANCE_BOTTOM = 8, SLIDE_RIGHT_THRESHOLD_TOP = 20, SLIDE_RIGHT_THRESHOLD_BOTTOM = 20, DEBUG = !1, FlexWrapper$1 = styled__default.default(ui.Flex)`
  & > div:first-child {
    flex: 1;
    min-width: 0;
  }
`, InnerBox = styled__default.default(ui.Flex)`
  height: ${AVATAR_SIZE}px;
  min-width: 23px;
  vertical-align: top;
`, { Tracker, useReporter, useReportedValues } = createTrackerScope();
function PresenceTooltip(props2) {
  const { children, items } = props2, content2 = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { sizing: "border", children: items.map((item) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { user: item.user, status: "online" }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: item.user.displayName })
    ] }, item.user.id)) }),
    [items]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: content2, placement: "top", portal: "documentScrollElement", children });
}
const splitRight = (array, max) => {
  const indexFromMax = array.length > max ? max - 1 : max, idx = Math.max(0, array.length - indexFromMax);
  return [array.slice(0, idx), array.slice(idx)];
};
function calcAvatarStackWidth(len) {
  return -AVATAR_DISTANCE + (AVATAR_SIZE + AVATAR_DISTANCE) * len;
}
const FieldPresenceInner = React.memo(function({
  presence,
  position = "inside",
  animateArrowFrom = "inside",
  maxAvatars = DEFAULT_MAX_AVATARS_FIELDS,
  stack = !0
}) {
  const uniquePresence = uniqBy__default.default(presence || [], (item) => item.user.id), sorted = sortBy__default.default(uniquePresence, (_presence) => _presence.lastActiveAt), [hidden, visible] = stack ? splitRight(sorted, maxAvatars) : [[], sorted], avatars = [
    ...visible.reverse().map((_visible) => ({
      key: _visible.user.id,
      element: /* @__PURE__ */ jsxRuntime.jsx(
        UserAvatar,
        {
          animateArrowFrom,
          position,
          status: "online",
          user: _visible.user
        }
      )
    })),
    hidden.length >= 2 ? {
      key: "counter",
      element: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarCounter, { count: hidden.length })
    } : null
  ].filter(Boolean);
  return /* @__PURE__ */ jsxRuntime.jsxs(FlexWrapper$1, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", {}),
    /* @__PURE__ */ jsxRuntime.jsx(InnerBox, { direction: "row-reverse", children: avatars.map(
      (av, i) => av && /* @__PURE__ */ jsxRuntime.jsx(
        "div",
        {
          style: {
            position: "absolute",
            transform: `translate3d(${-i * (AVATAR_SIZE + AVATAR_DISTANCE)}px, 0px, 0px)`,
            transitionProperty: "transform",
            transitionDuration: "200ms",
            transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)",
            zIndex: 100 - i
          },
          children: av.element
        },
        av.key
      )
    ) })
  ] });
});
function FieldPresenceWithOverlay(props2) {
  const contextPresence = React.useContext(FormFieldPresenceContext), { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2, ref = React.useRef(null);
  useReporter(React.useId(), () => ({ presence, element: ref.current, maxAvatars }));
  const uniquePresence = React.useMemo(() => uniqBy__default.default(presence || [], (item) => item.user.id), [presence]);
  return /* @__PURE__ */ jsxRuntime.jsx(PresenceTooltip, { items: uniquePresence, children: /* @__PURE__ */ jsxRuntime.jsx(FlexWrapper$1, { ref, style: { minHeight: AVATAR_SIZE, minWidth: AVATAR_SIZE } }) });
}
function FieldPresenceWithoutOverlay(props2) {
  const contextPresence = React.useContext(FormFieldPresenceContext), { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2;
  return presence.length ? /* @__PURE__ */ jsxRuntime.jsx(FieldPresenceInner, { presence, maxAvatars }) : null;
}
const FieldPresence = FieldPresenceWithOverlay, createIntersectionObserver = (options) => {
  const entries$ = new rxjs.Subject(), intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      entries$.next(entry);
    });
  }, options);
  return {
    observe: (element) => new rxjs.Observable((subscriber) => {
      const subscription = entries$.pipe(operators.filter((entry) => entry.target === element)).subscribe(subscriber);
      return intersectionObserver.observe(element), () => {
        subscription.unsubscribe(), intersectionObserver.unobserve(element);
      };
    })
  };
}, WithIntersection = (props2) => {
  const { onIntersection, io, id: id2, ...rest } = props2, element = React.useRef(null);
  return React.useEffect(() => {
    const el = element.current;
    if (!el)
      return;
    const subscription = io.observe(el).pipe(operators.tap((entry) => onIntersection(id2, entry))).subscribe();
    return () => subscription.unsubscribe();
  }, [io, id2, onIntersection]), /* @__PURE__ */ jsxRuntime.jsx("div", { ref: element, ...rest });
}, RootWrapper = styled__default.default.div`
  position: relative;
`, OverlayWrapper = styled__default.default.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 13;
`, RegionWrapper = styled.css`
  overflow: hidden;
  overflow: clip;
  pointer-events: none;
  position: absolute;
`, TopRegionWrapper = styled__default.default(WithIntersection)(({ $debug, margins }) => styled.css`
    ${RegionWrapper}

    z-index: 100;
    position: sticky;
    height: 1px;
    top: ${margins ? `${margins[0] - 1}px` : void 0};
    background-color: ${$debug ? "red" : "none"};
  `), MiddleRegionWrapper = styled__default.default(WithIntersection)(({ $debug }) => styled.css`
    ${RegionWrapper}

    visibility: none;

    ${$debug && styled.css`
      background: rgba(255, 0, 0, 0.25);
      outline: 1px solid #00b;
      visibility: visible;
    `}
  `), BottomRegionWrapper = styled__default.default(WithIntersection)(({ $debug }) => styled.css`
    ${RegionWrapper}

    position: sticky;
    bottom: -1px;
    height: 1px;
    background-color: ${$debug ? "blue" : "transparent"};
  `), toPx = (num) => `${num}px`, negate = (num) => 0 - num, RegionsWithIntersections = React.forwardRef(function(props2, ref) {
  const { regions, render: render2, children, margins: marginsProp } = props2, overlayRef = React.useRef(null), margins = React.useMemo(() => marginsProp, [JSON.stringify(marginsProp)]), io = React.useMemo(
    () => createIntersectionObserver({
      rootMargin: margins.map(negate).map(toPx).join(" "),
      threshold: INTERSECTION_THRESHOLDS
    }),
    [margins]
  ), [intersections, setIntersections] = React.useState({}), onIntersection = React.useCallback((id2, entry) => {
    setIntersections((current) => ({ ...current, [id2]: entry }));
  }, []), top = intersections["::top"], bottom2 = intersections["::bottom"], regionsWithIntersectionDetails = React.useMemo(
    () => top && bottom2 ? regions.filter((region) => {
      var _a2;
      return ((_a2 = region.presence) == null ? void 0 : _a2.length) > 0;
    }).map((region) => {
      const intersection2 = intersections[region.id];
      if (!intersection2)
        return null;
      const { bottom: boundsBottom, top: boundsTop } = intersection2.boundingClientRect, aboveTop = intersection2.boundingClientRect.top < top.boundingClientRect.bottom, belowBottom = intersection2.boundingClientRect.top < bottom2.boundingClientRect.top, distanceTop = intersection2.isIntersecting ? boundsTop - (intersection2.intersectionRect.top - INTERSECTION_ELEMENT_PADDING) : aboveTop ? -top.boundingClientRect.bottom : bottom2.boundingClientRect.top, distanceBottom = intersection2.isIntersecting ? -(boundsBottom - (intersection2.intersectionRect.bottom + INTERSECTION_ELEMENT_PADDING)) : belowBottom ? bottom2.boundingClientRect.top : -top.boundingClientRect.bottom, position = (
        // eslint-disable-next-line no-nested-ternary
        distanceTop <= SNAP_TO_DOCK_DISTANCE_TOP ? "top" : distanceBottom <= SNAP_TO_DOCK_DISTANCE_BOTTOM ? "bottom" : "inside"
      );
      return {
        distanceTop,
        distanceBottom,
        region,
        position
      };
    }).filter(Boolean) : [],
    [bottom2, intersections, regions, top]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(RootWrapper, { ref, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TopRegionWrapper,
      {
        $debug: DEBUG,
        io,
        id: "::top",
        onIntersection,
        margins
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx("div", { children }),
    /* @__PURE__ */ jsxRuntime.jsx(OverlayWrapper, { ref: overlayRef, children: overlayRef.current && render2(regionsWithIntersectionDetails, overlayRef.current.offsetWidth) }),
    regions.map((region) => {
      const forceWidth = region.rect.width === 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        MiddleRegionWrapper,
        {
          $debug: DEBUG,
          io,
          onIntersection,
          id: region.id,
          style: {
            width: forceWidth ? 1 : region.rect.width,
            left: region.rect.left - (forceWidth ? 1 : 0),
            top: region.rect.top - INTERSECTION_ELEMENT_PADDING,
            height: region.rect.height + INTERSECTION_ELEMENT_PADDING * 2
          }
        },
        region.id
      );
    }),
    /* @__PURE__ */ jsxRuntime.jsx(BottomRegionWrapper, { $debug: DEBUG, id: "::bottom", io, onIntersection })
  ] });
}), ITEM_TRANSITION = {
  transitionProperty: "transform",
  transitionDuration: "200ms",
  transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)"
}, bottom = (rect) => rect.top + rect.height;
function withSpacerHeight(regionsWithIntersectionDetails) {
  return regionsWithIntersectionDetails.map(
    (withIntersection, idx, _regionsWithIntersectionDetails) => {
      var _a2;
      const prevRect = (_a2 = _regionsWithIntersectionDetails[idx - 1]) == null ? void 0 : _a2.region.rect, prevBottom = prevRect ? bottom(prevRect) : 0;
      return { ...withIntersection, spacerHeight: withIntersection.region.rect.top - prevBottom };
    }
  );
}
const orderByTop = (regionsWithIntersectionDetails) => orderBy__default.default(regionsWithIntersectionDetails, (withIntersection) => withIntersection.region.rect.top), plus = (a, b) => a + b, sum = (array) => array.reduce(plus, 0);
function group(regionsWithIntersectionDetails) {
  const regionsWithSpacerHeight = withSpacerHeight(orderByTop(regionsWithIntersectionDetails)), grouped = {
    top: [],
    inside: [],
    bottom: [],
    ...groupBy__default.default(regionsWithSpacerHeight, (_withSpacerHeight) => _withSpacerHeight.position)
  };
  return {
    top: orderByTop(grouped.top).map(
      (withIntersection, i, grp) => ({
        ...withIntersection,
        indent: grp.slice(i + 1).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0)
      })
    ),
    inside: orderByTop(grouped.inside).map(
      (withIntersection) => ({
        ...withIntersection,
        indent: 0
      })
    ),
    bottom: orderByTop(grouped.bottom).map(
      (withIntersection, i, grp) => ({
        ...withIntersection,
        indent: grp.slice(0, i).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0)
      })
    )
  };
}
const Spacer = ({ height, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx("div", { style: { height: Math.max(0, height), ...rest == null ? void 0 : rest.style } }), DEFAULT_MARGINS$1 = [0, 0, 0, 0], getOffsetsTo = (source, target) => {
  let el = source, top = -el.scrollTop, left = 0;
  for (; el && el !== target; )
    top += el.offsetTop - el.scrollTop, left += el.offsetLeft, el = el.offsetParent instanceof HTMLElement ? el.offsetParent : null;
  return { top, left };
};
function getRelativeRect(element, parent) {
  return {
    ...getOffsetsTo(element, parent),
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function regionsWithComputedRects(regions, parent) {
  return regions.map(([id2, region]) => ({
    ...region,
    id: id2,
    rect: getRelativeRect(region.element, parent)
  }));
}
function StickyOverlay(props2) {
  const { children, margins = DEFAULT_MARGINS$1 } = props2, reportedValues = useReportedValues(), ref = React.useRef(null), regions = React.useMemo(
    () => ref.current ? regionsWithComputedRects(reportedValues, ref.current) : EMPTY_ARRAY$a,
    [reportedValues]
  ), renderCallback = React.useCallback(
    (regionsWithIntersectionDetails, containerWidth) => {
      const grouped = group(
        regionsWithIntersectionDetails.filter((item) => item.region.presence.length > 0)
      ), topSpacing = sum(grouped.top.map((n) => n.region.rect.height + n.spacerHeight)), bottomSpacing = sum(
        [...grouped.inside, ...grouped.bottom].map((n) => n.region.rect.height + n.spacerHeight)
      ), counts = grouped.inside.reduce(
        (_counts, withIntersection) => {
          const { distanceTop, distanceBottom } = withIntersection, nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP, nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
          return {
            nearTop: _counts.nearTop + (nearTop ? withIntersection.region.presence.length : 0),
            nearBottom: _counts.nearBottom + (nearBottom ? withIntersection.region.presence.length : 0)
          };
        },
        { nearTop: 0, nearBottom: 0 }
      );
      return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceDock,
          {
            closeCount: counts.nearTop,
            margins,
            position: "top",
            regionsWithIntersectionDetails: grouped.top
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(Spacer, { height: topSpacing }),
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceInside,
          {
            containerWidth,
            regionsWithIntersectionDetails: grouped.inside
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(Spacer, { height: bottomSpacing }),
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceDock,
          {
            closeCount: counts.nearBottom,
            margins,
            position: "bottom",
            regionsWithIntersectionDetails: grouped.bottom
          }
        )
      ] });
    },
    [margins]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(RegionsWithIntersections, { ref, margins, regions, render: renderCallback, children });
}
const EMPTY_ARRAY$a = [], PresenceDock = React.memo(function(props2) {
  const { closeCount, margins, position, regionsWithIntersectionDetails } = props2, dir = position === "top" ? 1 : -1, allPresenceItems = React.useMemo(() => regionsWithIntersectionDetails.length ? flatten__default.default(
    sortBy__default.default(regionsWithIntersectionDetails, (r) => r.region.rect.top * dir).map(
      (withIntersection) => withIntersection.region.presence || EMPTY_ARRAY$a
    )
  ) : EMPTY_ARRAY$a, [dir, regionsWithIntersectionDetails]), [topMargin, rightMargin, bottomMargin, leftMargin] = margins, leftOffset = (leftMargin || 0) + (allPresenceItems.length > 0 ? -closeCount * (AVATAR_SIZE + AVATAR_DISTANCE) : 0) - rightMargin, margin = position === "top" ? topMargin : bottomMargin, style = React.useMemo(
    () => ({
      zIndex: 2,
      position: "sticky",
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-end",
      ...ITEM_TRANSITION,
      transform: `translate3d(${leftOffset}px, 0px, 0px)`,
      top: AVATAR_ARROW_HEIGHT + 1 + margin,
      bottom: AVATAR_ARROW_HEIGHT + 1 + margin
    }),
    [leftOffset, margin]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "data-dock": position, style, children: /* @__PURE__ */ jsxRuntime.jsx(
    FieldPresenceInner,
    {
      position,
      maxAvatars: MAX_AVATARS_DOCK,
      presence: allPresenceItems
    }
  ) }, `sticky-${position}`);
});
function PresenceInside(props2) {
  const { regionsWithIntersectionDetails, containerWidth } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: regionsWithIntersectionDetails.map((withIntersection) => {
    const originalLeft = withIntersection.region.rect.left, { distanceTop, distanceBottom } = withIntersection, nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP, nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM, diffRight = containerWidth - originalLeft - withIntersection.region.rect.width, { presence, maxAvatars } = withIntersection.region;
    return /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
      "div",
      {
        style: {
          zIndex: 2,
          position: "absolute",
          ...ITEM_TRANSITION,
          left: originalLeft,
          transform: `translate3d(${nearTop || nearBottom ? diffRight : 0}px, 0px, 0px)`,
          height: withIntersection.region.rect.height,
          top: withIntersection.region.rect.top
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(DebugValue, { value: () => `\u2912${distanceTop} | ${distanceBottom}\u2913`, children: /* @__PURE__ */ jsxRuntime.jsx(
          FieldPresenceInner,
          {
            stack: !nearTop && !nearBottom,
            position: nearTop ? "top" : nearBottom ? "bottom" : "inside",
            maxAvatars,
            presence
          }
        ) })
      }
    ) }, withIntersection.region.id);
  }) });
}
const PassThrough = (props2) => props2.children, DebugValue = PassThrough, DEFAULT_MARGINS = [0, 0, 0, 0];
function OverlayEnabled({ children, margins }) {
  return /* @__PURE__ */ jsxRuntime.jsx(Tracker, { children: /* @__PURE__ */ jsxRuntime.jsx(StickyOverlay, { margins: margins || DEFAULT_MARGINS, children }) });
}
function OverlayDisabled(props2) {
  return props2.children;
}
const PresenceOverlay = OverlayEnabled, Root$q = styled__default.default(ui.Flex)(({ theme: theme2, $floatingCardWidth, $slotWidth, $floatingCardVisible }) => {
  const { space } = theme2.sanity;
  return styled.css`
    /* Prevent buttons from taking up extra vertical space */
    line-height: 1;
    width: 100%;
    /* For floating actions menu */
    position: relative;

    [data-ui='PresenceBox'] {
      position: absolute;
      bottom: 0;
      right: ${$slotWidth + $floatingCardWidth + space[1]}px;
    }
    @media (hover: hover) {
      // If hover is supported, we hide the floating card by default, so only add space for it when it's visible.
      [data-ui='PresenceBox'] {
        position: absolute;
        bottom: 0;
        right: ${$slotWidth + ($floatingCardVisible ? $floatingCardWidth : 0) + space[1]}px;
      }
    }
  `;
}), ContentBox = styled__default.default(ui.Box)(({ theme: theme2, $presenceMaxWidth }) => {
  const { space } = theme2.sanity;
  return styled.css`
    max-width: calc(100% - ${$presenceMaxWidth + space[1]}px);
    min-width: 75%;
  `;
}), SlotBox = styled__default.default(ui.Box)(({ theme: theme2, $right, $fieldActionsVisible }) => {
  const { space } = theme2.sanity, right = $fieldActionsVisible ? $right + space[1] : $right;
  return styled.css`
    position: absolute;
    bottom: 0;
    right: ${right}px;
  `;
}), FieldActionsFloatingCard = styled__default.default(ui.Card)`
  align-items: center;
  bottom: 0;
  position: absolute;
  right: 0;
  transition: opacity 150ms ease;
  line-height: 1;

  @media (hover: hover) {
    // If hover is supported, we hide the floating card by default
    // and only show it when it has focus within or when the field is hovered or focused.
    opacity: 0;
    pointer-events: none;

    [data-ui='FieldActionsFlex'] {
      opacity: 0;
    }

    &[data-actions-visible='false']:not(:focus-within) {
      // Remove the shadow when the field actions are not visible
      box-shadow: none;

      // Since the field actions always will be present in the DOM (to make them focusable) –
      // they will always affect the width of the floating card, even when they are not visible.
      // Therefore, we remove the background of the floating card when the field actions are not visible.
      background: transparent;
    }

    // Remove the shadow when the field has comments but no actions
    &[data-has-comments='true']:not([data-has-actions='true']) {
      box-shadow: none;
    }

    // Show the floating card when it has focus within (ie when field actions are focused).
    &:focus-within {
      opacity: 1;
      pointer-events: auto;
      width: max-content;

      [data-ui='FieldActionsFlex'] {
        opacity: 1;
        pointer-events: auto;
        width: max-content;
      }
    }
  }

  &[data-visible='true'] {
    opacity: 1;
    pointer-events: auto;
    width: max-content;
  }

  &[data-actions-visible='true'] {
    [data-ui='FieldActionsFlex'] {
      opacity: 1;
      pointer-events: auto;
      width: max-content;
    }
  }
`, FieldActionsFlex = styled__default.default(ui.Flex)`
  gap: inherit;
  transition: opacity 150ms ease;
`, MAX_AVATARS = 4;
function FormFieldBaseHeader(props2) {
  const {
    __internal_comments: comments,
    __internal_slot: slot,
    actions,
    content: content2,
    fieldFocused,
    fieldHovered,
    presence
  } = props2, [focused, setFocused] = React.useState(!1), [menuOpen, setMenuOpen] = React.useState(!1), [floatingCardElement, setFloatingCardElement] = React.useState(null), [floatingCardWidth, setFloatingCardWidth] = React.useState(0), [slotElement, setSlotElement] = React.useState(null), [slotWidth, setSlotWidth] = React.useState(0), {
    hasComments = !1,
    button: commentButton = null,
    isAddingComment = !1
  } = comments || {}, hasActions = actions && actions.length > 0, showFieldActions = fieldFocused || fieldHovered || menuOpen || isAddingComment, hasCommentsButtonOrActions = (comments == null ? void 0 : comments.button) || hasActions, shouldShowFloatingCard = focused || showFieldActions || hasComments, handleSetFloatingCardElementWidth = React.useCallback(() => {
    if (floatingCardElement) {
      const { width } = floatingCardElement.getBoundingClientRect();
      setFloatingCardWidth(width || 0);
    }
  }, [floatingCardElement]), handleFocusCapture = React.useCallback(() => {
    handleSetFloatingCardElementWidth(), setFocused(!0);
  }, [handleSetFloatingCardElementWidth]), handleBlurCapture = React.useCallback(() => {
    handleSetFloatingCardElementWidth(), setFocused(!1);
  }, [handleSetFloatingCardElementWidth]);
  React.useEffect(() => {
    handleSetFloatingCardElementWidth();
  }, [handleSetFloatingCardElementWidth, showFieldActions]), React.useEffect(() => {
    if (slotElement) {
      const { width } = slotElement.getBoundingClientRect();
      setSlotWidth(width || 0);
    }
  }, [slotElement]);
  const slotEl = React.useMemo(() => slot ? /* @__PURE__ */ jsxRuntime.jsx(
    SlotBox,
    {
      $fieldActionsVisible: !!showFieldActions,
      $right: floatingCardWidth,
      ref: setSlotElement,
      children: slot
    }
  ) : null, [floatingCardWidth, showFieldActions, slot]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$q,
    {
      align: "flex-end",
      justify: "space-between",
      $floatingCardVisible: shouldShowFloatingCard,
      $floatingCardWidth: floatingCardWidth,
      $slotWidth: slotWidth,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ContentBox,
          {
            "data-ui": "fieldHeaderContentBox",
            flex: 1,
            paddingY: 2,
            $presenceMaxWidth: calcAvatarStackWidth(MAX_AVATARS),
            children: content2
          }
        ),
        presence && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-ui": "PresenceBox", flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { maxAvatars: MAX_AVATARS, presence }) }),
        slotEl,
        (hasCommentsButtonOrActions || hasComments) && /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(
          FieldActionsFloatingCard,
          {
            "data-actions-visible": showFieldActions ? "true" : "false",
            "data-has-actions": hasActions ? "true" : "false",
            "data-has-comments": hasComments ? "true" : "false",
            "data-visible": shouldShowFloatingCard ? "true" : "false",
            display: "flex",
            onBlurCapture: handleBlurCapture,
            onFocusCapture: handleFocusCapture,
            ref: setFloatingCardElement,
            sizing: "border",
            children: [
              hasActions && /* @__PURE__ */ jsxRuntime.jsx(FieldActionsFlex, { align: "center", "data-ui": "FieldActionsFlex", children: /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenu, { nodes: actions, onMenuOpenChange: setMenuOpen }) }),
              commentButton
            ]
          }
        ) })
      ]
    }
  );
}
function createDescriptionId(id2, description) {
  if (!(!description || !id2))
    return `desc_${id2}`;
}
const EMPTY_ARRAY$9 = [], VALIDATION_ICONS = {
  error: ValidationErrorIcon,
  warning: ValidationWarningIcon,
  info: ValidationInfoIcon
}, StyledStack = styled__default.default(ui.Stack)`
  max-width: 200px;
`, StatusText = styled__default.default(ui.Text)(({ $status }) => $status === "error" ? { "--card-icon-color": "var(--card-badge-critical-icon-color)" } : $status === "warning" ? { "--card-icon-color": "var(--card-badge-caution-icon-color)" } : $status === "info" ? { "--card-icon-color": "var(--card-badge-primary-icon-color)" } : {});
function FormFieldValidationStatus(props2) {
  const { validation: validation2 = EMPTY_ARRAY$9, __unstable_showSummary: showSummary, fontSize, placement } = props2, hasErrors = validation2.some((v) => v.level === "error"), hasWarnings = validation2.some((v) => v.level === "warning"), status = hasErrors ? "error" : hasWarnings ? "warning" : "info", StatusIcon = VALIDATION_ICONS[status];
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsxs(StyledStack, { space: 3, children: [
        showSummary && /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationSummary, { validation: validation2 }),
        !showSummary && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: validation2.map((item, itemIndex) => (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatusItem, { validation: item }, itemIndex)
        )) })
      ] }),
      portal: !0,
      placement,
      fallbackPlacements: ["bottom", "right", "left"],
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(StatusText, { $status: status, size: fontSize, weight: "medium", children: StatusIcon && /* @__PURE__ */ jsxRuntime.jsx(StatusIcon, {}) }) })
    }
  );
}
function FormFieldValidationStatusItem(props2) {
  const { validation: validation2 } = props2, StatusIcon = VALIDATION_ICONS[validation2.level];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 2, children: /* @__PURE__ */ jsxRuntime.jsx(StatusText, { $status: validation2.level, size: 1, children: StatusIcon && /* @__PURE__ */ jsxRuntime.jsx(StatusIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: validation2.message }) })
  ] });
}
function FormFieldValidationSummary({ validation: validation2 }) {
  const { t: t2 } = useTranslation(), listFormatter = useListFormat(), errorCount = validation2.reduce(
    (count, item) => item.level === "error" ? count + 1 : count,
    0
  ), warningCount = validation2.reduce(
    (count, item) => item.level === "warning" ? count + 1 : count,
    0
  ), hasErrors = errorCount > 0, hasWarnings = warningCount > 0;
  if (!hasErrors && !hasWarnings)
    return null;
  const errorText = hasErrors && t2("form.validation.summary.errors-count", { count: errorCount }), warningText = hasWarnings && t2("form.validation.summary.warnings-count", { count: warningCount });
  return errorText && warningText ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: listFormatter.format([errorText, warningText]) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: errorText || warningText });
}
function ValidationErrorIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.ErrorOutlineIcon,
    {
      "data-testid": "input-validation-icon-error",
      "aria-label": t2("form.validation.has-error-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
function ValidationWarningIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.WarningOutlineIcon,
    {
      "data-testid": "input-validation-icon-warning",
      "aria-label": t2("form.validation.has-warning-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
function ValidationInfoIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.InfoOutlineIcon,
    {
      "data-testid": "input-validation-icon-info",
      "aria-label": t2("form.validation.has-info-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
const LabelSuffix = styled__default.default(ui.Flex)`
  /*
   * Prevent the block size of appended elements (such as the deprecated field badge) affecting
   * the intrinsic block size of the label.
   */
  contain: size;
`, EMPTY_ARRAY$8 = [], FormFieldHeaderText = React.memo(function(props2) {
  const { description, inputId, title, deprecated, validation: validation2 = EMPTY_ARRAY$8 } = props2, { t: t2 } = useTranslation(), hasValidations = validation2.length > 0, hasLabelSuffix = deprecated || hasValidations;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", paddingY: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "label", htmlFor: inputId, weight: "medium", size: 1, children: title || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("form.field.untitled-field-label") }) }),
      hasLabelSuffix && /* @__PURE__ */ jsxRuntime.jsxs(LabelSuffix, { align: "center", flex: 1, children: [
        deprecated && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { "data-testid": `deprecated-badge-${title}`, tone: "caution", children: t2("form.field.deprecated-label") }) }),
        hasValidations && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { fontSize: 1, placement: "top", validation: validation2 }) })
      ] })
    ] }),
    deprecated && /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { "data-testid": `deprecated-message-${title}`, tone: "caution", size: 1, children: deprecated.reason }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, id: createDescriptionId(inputId, description), children: description })
  ] });
}), EMPTY_ARRAY$7 = [], FormField = React.memo(function(props2) {
  const {
    __unstable_headerActions: actions = EMPTY_ARRAY$7,
    __unstable_presence: presence = EMPTY_ARRAY$7,
    __internal_slot: slot = null,
    __internal_comments: comments,
    children,
    description,
    inputId,
    level,
    title,
    validation: validation2,
    deprecated,
    ...restProps
  } = props2, { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Stack,
    {
      ...restProps,
      "data-level": level,
      onMouseEnter,
      onMouseLeave,
      space: 2,
      children: [
        title && /* @__PURE__ */ jsxRuntime.jsx(
          FormFieldBaseHeader,
          {
            __internal_comments: comments,
            __internal_slot: slot,
            actions,
            fieldFocused: !!focused,
            fieldHovered: hovered,
            presence,
            content: /* @__PURE__ */ jsxRuntime.jsx(
              FormFieldHeaderText,
              {
                description,
                inputId,
                title,
                validation: validation2,
                deprecated
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("div", { children })
      ]
    }
  );
}), Root$p = styled__default.default.legend`
  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */
  padding: 0;
  display: table;
`, ToggleButton = styled__default.default(ui.Flex).attrs({ forwardedAs: "button" })((props2) => {
  const { theme: theme2 } = props2, { focusRing, radius } = theme2.sanity, { base } = theme2.sanity.color;
  return styled.css`
    appearance: none;
    border: 0;
    background: none;
    color: inherit;
    -webkit-font-smoothing: inherit;
    font: inherit;
    outline: none;
    border-radius: ${ui.rem(radius[2])};
    position: relative;

    &:not([hidden]) {
      display: flex;
    }

    &:focus {
      box-shadow: ${focusRingStyle$2({ base, focusRing })};
    }

    &:focus:not(:focus-visible) {
      box-shadow: none;
    }

    /* Added to increase the hit area of the collapsible fieldset */
    &::after {
      content: '';
      position: absolute;
      top: -10px;
      right: -10px;
      bottom: -10px;
      left: -10px;
    }
  `;
}), ToggleIconBox = styled__default.default(ui.Box)`
  width: 9px;
  height: 9px;
  margin-right: 3px;

  & svg {
    transition: transform 100ms;
  }
`, FormFieldSetLegend = React.memo(function(props2) {
  const { collapsed, collapsible, onClick, title } = props2, { t: t2 } = useTranslation(), text = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("form.field.untitled-fieldset-label") }) });
  return collapsible ? /* @__PURE__ */ jsxRuntime.jsx(Root$p, { children: /* @__PURE__ */ jsxRuntime.jsxs(ToggleButton, { type: "button", onClick, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ToggleIconBox, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      icons.ToggleArrowRightIcon,
      {
        style: {
          transform: `rotate(${collapsed ? "0" : "90deg"}) translate3d(0, 0, 0)`
        }
      }
    ) }) }),
    text
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(Root$p, { children: text });
});
function getChildren(children) {
  return typeof children == "function" ? children() : children;
}
const Root$o = styled__default.default(ui.Stack).attrs({ forwardedAs: "fieldset" })`
  border: none;

  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */
  body:not(:-moz-handler-blocked) & {
    display: table-cell;
  }
`, Content$1 = styled__default.default(ui.Box)((props2) => {
  const { $borderLeft, theme: theme2 } = props2, { focusRing } = theme2.sanity, { base } = theme2.sanity.color;
  return styled.css`
    outline: none;
    border-left: ${$borderLeft ? "1px solid var(--card-border-color)" : void 0};

    &:focus {
      box-shadow: ${focusRingStyle$2({ base, focusRing: { ...focusRing, offset: 2 } })};
    }

    &:focus:not(:focus-visible) {
      box-shadow: none;
    }
  `;
}), EMPTY_ARRAY$6 = [], FormFieldSet = React.forwardRef(function(props2, ref) {
  const {
    __internal_comments: comments,
    __internal_slot: slot = null,
    __unstable_headerActions: actions = EMPTY_ARRAY$6,
    __unstable_presence: presence = EMPTY_ARRAY$6,
    children,
    collapsed,
    collapsible,
    columns,
    description,
    level = 0,
    onCollapse,
    onExpand,
    onFocus,
    tabIndex,
    title,
    validation: validation2 = EMPTY_ARRAY$6,
    inputId,
    deprecated,
    ...restProps
  } = props2, { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions(), hasValidationMarkers = validation2.length > 0, forwardedRef = ui.useForwardedRef(ref), { t: t2 } = useTranslation(), handleFocus = React.useCallback(
    (event) => {
      forwardedRef.current === event.target && onFocus && onFocus(event);
    },
    [forwardedRef, onFocus]
  ), handleToggle = React.useCallback(
    () => collapsed ? onExpand == null ? void 0 : onExpand() : onCollapse == null ? void 0 : onCollapse(),
    [collapsed, onCollapse, onExpand]
  ), content2 = React.useMemo(() => collapsed ? null : /* @__PURE__ */ jsxRuntime.jsx(AlignedBottomGrid$1, { columns, gapX: 4, gapY: 5, children: getChildren(children) }), [children, collapsed, columns]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$o,
    {
      "data-level": level,
      ...restProps,
      onMouseEnter,
      onMouseLeave,
      space: 2,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          FormFieldBaseHeader,
          {
            __internal_comments: comments,
            __internal_slot: slot,
            actions,
            fieldFocused: !!focused,
            fieldHovered: hovered,
            presence,
            content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  FormFieldSetLegend,
                  {
                    collapsed: !!collapsed,
                    collapsible,
                    onClick: collapsible ? handleToggle : void 0,
                    title
                  }
                ),
                deprecated && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { "data-testid": `deprecated-badge-${title}`, tone: "caution", children: t2("form.field.deprecated-label") }) }),
                hasValidationMarkers && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { fontSize: 1, placement: "top", validation: validation2 }) })
              ] }),
              deprecated && /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { "data-testid": `deprecated-message-${title}`, tone: "caution", size: 1, children: deprecated.reason }),
              description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, id: createDescriptionId(inputId, description), children: description })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          Content$1,
          {
            $borderLeft: level > 0,
            hidden: collapsed,
            paddingLeft: level === 0 ? 0 : 3,
            onFocus: typeof tabIndex == "number" && tabIndex > -1 ? handleFocus : void 0,
            ref: forwardedRef,
            tabIndex,
            children: !collapsed && content2
          }
        )
      ]
    }
  );
}), Root$n = styled__default.default.div`
  display: flex;
  justify-content: flex-end;
  box-sizing: border-box;
  min-height: var(--avatar-height);
  width: 77px;
  margin-left: var(--small-padding);

  &[data-max-avatars='1'] {
    max-width: 23px;
  }

  &[data-position='top'] {
    align-self: flex-start;
  }

  &[data-position='bottom'] {
    align-self: flex-end;
  }
`;
function FormFieldStatus({ children, maxAvatars, position = "bottom" }) {
  return /* @__PURE__ */ jsxRuntime.jsx(Root$n, { "data-max-avatars": maxAvatars, "data-position": position, children });
}
function usePrevious(value, initial) {
  const ref = React.useRef(initial || null);
  return React.useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
function useDidUpdate(current, didUpdate, compare = shallowEquals__default.default) {
  const previous = usePrevious(current);
  React.useEffect(() => {
    compare(previous, current) || didUpdate(previous, current);
  }, [didUpdate, current, previous, compare]);
}
const SANITY_PATCH_TYPE = Symbol.for("sanity.patch");
function setIfMissing(value, path = []) {
  return {
    patchType: SANITY_PATCH_TYPE,
    type: "setIfMissing",
    path,
    value
  };
}
function insert(items, position, path = []) {
  return {
    patchType: SANITY_PATCH_TYPE,
    type: "insert",
    path,
    position,
    items
  };
}
function set(value, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "set", path, value };
}
function unset(path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "unset", path };
}
function diffMatchPatch(value, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "diffMatchPatch", path, value };
}
function inc(amount = 1, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "inc", path, value: amount };
}
function dec(amount = 1, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "dec", path, value: amount };
}
function prefixPath(patch2, segment) {
  return {
    ...patch2,
    path: [segment, ...patch2.path]
  };
}
class PatchEvent {
  static from(input) {
    return input instanceof PatchEvent ? input : new PatchEvent(Array.isArray(input) ? flatten__default.default(input) : [input]);
  }
  constructor(patches) {
    this.patches = patches;
  }
  prepend(...patches) {
    return PatchEvent.from([...flatten__default.default(patches), ...this.patches]);
  }
  append(...patches) {
    return PatchEvent.from([...this.patches, ...flatten__default.default(patches)]);
  }
  prefixAll(segment) {
    return PatchEvent.from(this.patches.map((patch2) => prefixPath(patch2, segment)));
  }
}
const IGNORE_KEYS = ["_key", "_type", "_weak"];
function isEmptyItem(value) {
  return Object.keys(value).every((key) => IGNORE_KEYS.includes(key));
}
const FormCallbacksContext = React.createContext(null), FormCallbacksProvider = React.memo(function(props2) {
  const ref = React.useRef(props2);
  ref.current = props2;
  const transformPatches = React.useCallback(
    (patches) => {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = ref.current) == null ? void 0 : _a2.transformPatches) == null ? void 0 : _b.call(_a2, patches)) != null ? _c : [];
    },
    [ref]
  ), onChange = React.useCallback((patchEvent) => {
    ref.current.onChange(patchEvent);
  }, []), onPathFocus = React.useCallback((path) => {
    ref.current.onPathFocus(path);
  }, []), onPathBlur = React.useCallback((path) => {
    ref.current.onPathBlur(path);
  }, []), onPathOpen = React.useCallback((path) => {
    ref.current.onPathOpen(path);
  }, []), onSetPathCollapsed = React.useCallback((path, collapsed) => {
    ref.current.onSetPathCollapsed(path, collapsed);
  }, []), onSetFieldSetCollapsed = React.useCallback((path, collapsed) => {
    ref.current.onSetFieldSetCollapsed(path, collapsed);
  }, []), onFieldGroupSelect = React.useCallback((path, fieldGroupName) => {
    ref.current.onFieldGroupSelect(path, fieldGroupName);
  }, []), contextValue = React.useMemo(
    () => ({
      transformPatches,
      onChange,
      onPathFocus,
      onPathBlur,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      onFieldGroupSelect
    }),
    [
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      transformPatches
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
function useFormCallbacks() {
  const ctx = React.useContext(FormCallbacksContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function createProtoValue(type) {
  if (types.isObjectSchemaType(type))
    return type.name === "object" ? {} : { _type: type.name };
  if (types.isArraySchemaType(type))
    return [];
  if (type.jsonType === "string")
    return "";
  if (type.jsonType === "number")
    return 0;
  if (type.jsonType === "boolean")
    return !1;
}
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues__default.default(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (() => {
  let table;
  return () => {
    if (table)
      return table;
    table = [];
    for (let i = 0; i < 256; ++i)
      table[i] = (i + 256).toString(16).substring(1);
    return table;
  };
})();
function randomKey(length) {
  const table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], "").slice(0, length);
}
function hasKey(item) {
  return item._key !== void 0;
}
function ensureKey(item) {
  return hasKey(item) ? item : { ...item, _key: randomKey(12) };
}
const getMemberTypeOfItem$2 = (schemaType, item) => {
  const itemTypeName = content.resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
};
function assign(values2, path) {
  return Object.entries(values2).map(([key, value]) => set(value, [...path, key]));
}
function resolveInitialArrayValues(items, schemaType, resolver) {
  return rxjs.from(items).pipe(
    operators.mergeMap((item) => {
      const itemPathSegment = { _key: item._key };
      return rxjs.of(getMemberTypeOfItem$2(schemaType, item)).pipe(
        operators.mergeMap((memberType) => memberType ? rxjs.of(memberType) : rxjs.EMPTY),
        operators.mergeMap((memberType) => !isEmptyItem(item) || !resolver ? rxjs.EMPTY : rxjs.concat(
          rxjs.of({
            type: "patch",
            patches: [set(!0, [itemPathSegment, "_resolvingInitialValue"])]
          }),
          rxjs.defer(() => resolver(memberType, item)).pipe(
            operators.filter(isNonNullable$2),
            operators.map((initial) => ({
              type: "patch",
              patches: assign(initial, [itemPathSegment])
            })),
            operators.catchError(
              (error) => rxjs.of({ type: "error", error, item, schemaType: memberType })
            )
          ),
          rxjs.of({
            type: "patch",
            patches: [unset([itemPathSegment, "_resolvingInitialValue"])]
          })
        ))
      );
    })
  );
}
function ArrayOfObjectsItem(props2) {
  const focusRef = React.useRef(), {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2, { t: t2 } = useTranslation(), {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), resolveInitialValue2 = useResolveInitialValueForType();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const onRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([{ _key: member.key }])]));
  }, [member.key, onChange]), handleOpenItem = React.useCallback(
    (path) => {
      onPathOpen(path), onSetPathCollapsed(path, !1);
    },
    [onPathOpen, onSetPathCollapsed]
  ), toast = ui.useToast(), handleInsert = React.useCallback(
    (event) => {
      if (event.items.length === 0)
        throw new Error("Insert event should include at least one item");
      const itemsWithKeys = event.items.map((item) => ensureKey(item));
      onChange(PatchEvent.from([insert(itemsWithKeys, event.position, [{ _key: member.key }])]));
      const focusItemKey = itemsWithKeys[0]._key, itemPath = [...member.item.path.slice(0, -1), { _key: focusItemKey }];
      onPathFocus(itemPath);
      const shouldOpen = event.open !== !1;
      event.skipInitialValue ? shouldOpen && handleOpenItem(itemPath) : resolveInitialArrayValues(itemsWithKeys, member.parentSchemaType, resolveInitialValue2).pipe(
        operators.tap((result) => {
          result.type === "patch" ? onChange(PatchEvent.from(result.patches)) : toast.push({
            title: t2("inputs.array.error.cannot-resolve-initial-value-title"),
            description: t2("inputs.array.error.cannot-resolve-initial-value-description", {
              schemaTypeTitle: result.schemaType.title,
              errorMessage: result.error.message
            }),
            status: "error"
          });
        })
      ).subscribe({
        complete: () => {
          shouldOpen && handleOpenItem(itemPath);
        }
      });
    },
    [
      handleOpenItem,
      member.item.path,
      member.key,
      member.parentSchemaType,
      onChange,
      onPathFocus,
      resolveInitialValue2,
      toast,
      t2
    ]
  ), handleBlur = React.useCallback(() => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]), handleFocusChildPath = React.useCallback(
    (path) => {
      onPathFocus(member.item.path.concat(path));
    },
    [member.item.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      onChange(
        PatchEvent.from(event).prepend(setIfMissing(createProtoValue(member.item.schemaType))).prefixAll({ _key: member.key })
      );
    },
    [onChange, member.item.schemaType, member.key]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.item.path, !0);
  }, [onSetPathCollapsed, member.item.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.item.path, !1);
  }, [onSetPathCollapsed, member.item.path]), handleCollapseField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.item.path.concat(fieldName), !0);
    },
    [onSetPathCollapsed, member.item.path]
  ), handleExpandField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.item.path.concat(fieldName), !1);
    },
    [onSetPathCollapsed, member.item.path]
  ), handleCloseField = React.useCallback(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]), handleOpenField = React.useCallback(
    (fieldName) => {
      onPathOpen(member.item.path.concat(fieldName));
    },
    [onPathOpen, member.item.path]
  ), handleExpandFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), !1);
    },
    [onSetFieldSetCollapsed, member.item.path]
  ), handleCollapseFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), !0);
    },
    [onSetFieldSetCollapsed, member.item.path]
  ), handleOpen = React.useCallback(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]), isEmptyValue = !member.item.value || isEmptyItem(member.item.value), handleClose = React.useCallback(() => {
    isEmptyValue && onRemove();
    const parentPath = member.item.path.slice(0, -1);
    onPathOpen(parentPath), onPathFocus(parentPath);
  }, [isEmptyValue, onPathOpen, member.item.path, onPathFocus, onRemove]), handleSelectFieldGroup = React.useCallback(
    (groupName) => {
      onFieldGroupSelect(member.item.path, groupName);
    },
    [onFieldGroupSelect, member.item.path]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.item.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description)
    }),
    [handleBlur, handleFocus, member.item.id, member.item.schemaType.description]
  ), inputProps = React.useMemo(() => ({
    changed: member.item.changed,
    focusPath: member.item.focusPath,
    focused: member.item.focused,
    groups: member.item.groups,
    id: member.item.id,
    level: member.item.level,
    members: member.item.members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onFieldGroupSelect: handleSelectFieldGroup,
    onPathFocus: handleFocusChildPath,
    onFieldOpen: handleOpenField,
    path: member.item.path,
    presence: member.item.presence,
    readOnly: member.item.readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType: member.item.schemaType,
    validation: member.item.validation,
    value: member.item.value,
    elementProps
  }), [
    elementProps,
    handleChange,
    handleCloseField,
    handleCollapseField,
    handleCollapseFieldSet,
    handleExpandField,
    handleExpandFieldSet,
    handleFocusChildPath,
    handleOpenField,
    handleSelectFieldGroup,
    member.item.changed,
    member.item.focusPath,
    member.item.focused,
    member.item.groups,
    member.item.id,
    member.item.level,
    member.item.members,
    member.item.path,
    member.item.presence,
    member.item.readOnly,
    member.item.schemaType,
    member.item.validation,
    member.item.value,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), itemProps = React.useMemo(() => ({
    key: member.key,
    index: member.index,
    level: member.item.level,
    value: member.item.value,
    title: member.item.schemaType.title,
    description: member.item.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    schemaType: member.item.schemaType,
    parentSchemaType: member.parentSchemaType,
    onInsert: handleInsert,
    onRemove,
    presence: member.item.presence,
    validation: member.item.validation,
    open: member.open,
    onOpen: handleOpen,
    onClose: handleClose,
    onExpand: handleExpand,
    onCollapse: handleCollapse,
    readOnly: member.item.readOnly,
    focused: member.item.focused,
    onFocus: handleFocus,
    onBlur: handleBlur,
    inputId: member.item.id,
    path: member.item.path,
    children: renderedInput,
    changed: member.item.changed,
    inputProps
  }), [
    member.key,
    member.index,
    member.item.level,
    member.item.value,
    member.item.schemaType,
    member.parentSchemaType,
    member.item.presence,
    member.item.validation,
    member.item.readOnly,
    member.item.focused,
    member.item.id,
    member.item.path,
    member.item.changed,
    member.collapsible,
    member.collapsed,
    member.open,
    handleInsert,
    onRemove,
    handleOpen,
    handleClose,
    handleExpand,
    handleCollapse,
    handleFocus,
    handleBlur,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderItem(itemProps), [itemProps, renderItem])
    }
  );
}
const PopoverCard$2 = styled__default.default(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType$2(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard$2, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.type-is-incompatible-prompt",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          flex: 1,
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) }) })
          ] })
        }
      )
    }
  );
}
function MemberItemError(props2) {
  const { member } = props2, { t: t2 } = useTranslation();
  return member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$2, { value: member.error.value }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) });
}
function getEmptyValue(type) {
  switch (type.jsonType) {
    case "string":
      return "";
    case "number":
      return -0;
    case "boolean":
      return !1;
    default:
      throw new Error(`Unable to create value from type "${type.jsonType}"`);
  }
}
function resolveNativeNumberInputValue(schemaType, value, localValue) {
  return types.isNumberSchemaType(schemaType) && typeof localValue == "string" && Number(localValue) === value ? localValue : String(value != null ? value : "");
}
function ArrayOfPrimitivesItem(props2) {
  const focusRef = React.useRef(), { member, renderItem, renderInput } = props2, [localValue, setLocalValue] = React.useState(), { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleBlur = React.useCallback(
    (event) => {
      onPathBlur(member.item.path);
    },
    [member.item.path, onPathBlur]
  ), handleFocus = React.useCallback(
    (event) => {
      onPathFocus(member.item.path);
    },
    [member.item.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.index));
    },
    [onChange, member.index]
  ), handleNativeChange = React.useCallback(
    (event) => {
      let inputValue = event.currentTarget.value;
      if (types.isNumberSchemaType(member.item.schemaType)) {
        if (inputValue = event.currentTarget.valueAsNumber, inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER)
          return;
      } else
        types.isBooleanSchemaType(member.item.schemaType) && (inputValue = event.currentTarget.checked);
      const hasEmptyValue = inputValue === "" || typeof inputValue == "number" && isNaN(inputValue);
      types.isNumberSchemaType(member.item.schemaType) && setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value), handleChange(
        set(
          hasEmptyValue ? (
            // Map direct unset patches to empty value instead in order to not *remove* elements as the user clears out the value
            // note: this creates the rather curious case where the input renders ´0´ when you try to clear it.
            getEmptyValue(member.item.schemaType)
          ) : inputValue
        )
      );
    },
    [handleChange, member.item.schemaType]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.item.id,
      ref: focusRef,
      onChange: handleNativeChange,
      value: resolveNativeInputValue(member.item.schemaType, member.item.value, localValue),
      readOnly: !!member.item.readOnly,
      placeholder: member.item.schemaType.placeholder,
      "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description)
    }),
    [
      handleBlur,
      handleFocus,
      handleNativeChange,
      member.item.id,
      member.item.readOnly,
      member.item.schemaType,
      member.item.value,
      localValue
    ]
  ), inputProps = React.useMemo(() => ({
    changed: member.item.changed,
    level: member.item.level,
    value: member.item.value,
    readOnly: member.item.readOnly,
    schemaType: member.item.schemaType,
    id: member.item.id,
    path: member.item.path,
    focused: member.item.focused,
    onChange: handleChange,
    validation: member.item.validation,
    presence: member.item.presence,
    elementProps
  }), [
    member.item.changed,
    member.item.level,
    member.item.value,
    member.item.readOnly,
    member.item.schemaType,
    member.item.id,
    member.item.path,
    member.item.focused,
    member.item.validation,
    member.item.presence,
    handleChange,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), onRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([member.index])]));
  }, [member.index, onChange]), onInsert = React.useCallback(
    (event) => {
      onChange(PatchEvent.from([insert(event.items, event.position, [member.index])]));
    },
    [member.index, onChange]
  ), itemProps = React.useMemo(() => ({
    key: member.key,
    index: member.index,
    level: member.item.level,
    value: member.item.value,
    title: member.item.schemaType.title,
    description: member.item.schemaType.description,
    schemaType: member.item.schemaType,
    parentSchemaType: member.parentSchemaType,
    onInsert,
    onRemove,
    presence: member.item.presence,
    validation: member.item.validation,
    readOnly: member.item.readOnly,
    focused: member.item.focused,
    onFocus: handleFocus,
    onBlur: handleBlur,
    inputId: member.item.id,
    path: member.item.path,
    children: renderedInput
  }), [
    member.key,
    member.index,
    member.item.level,
    member.item.value,
    member.item.schemaType,
    member.item.presence,
    member.item.validation,
    member.item.readOnly,
    member.item.focused,
    member.item.id,
    member.item.path,
    member.parentSchemaType,
    onInsert,
    onRemove,
    handleFocus,
    handleBlur,
    renderedInput
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: React.useMemo(() => renderItem(itemProps), [itemProps, renderItem]) });
}
function resolveNativeInputValue(schemaType, value, localValue) {
  return Object.is(value, -0) ? "" : resolveNativeNumberInputValue(schemaType, value, localValue);
}
function createProtoArrayValue(type) {
  if (!types.isObjectSchemaType(type))
    throw new Error(
      `Invalid item type: "${type.type}". Default array input can only contain objects (for now)`
    );
  return { ...createProtoValue(type), _key: content.randomKey(12) };
}
const BEFORE = "before", AFTER = "after";
function arrayInsert(array, position, index, ...args) {
  if (position !== BEFORE && position !== AFTER)
    throw new Error(`Invalid position "${position}", must be either ${BEFORE} or ${AFTER}`);
  const items = flatten(...args);
  if (array.length === 0)
    return items;
  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === "after" ? idx + 1 : idx, copy = array.slice();
  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;
}
function flatten(...values2) {
  return values2.reduce((prev, item) => prev.concat(item), []);
}
const hasOwn = (obj, property) => Object.prototype.hasOwnProperty.call(obj, property);
function move$1(arr, from, to) {
  const nextValue = arr.slice(), val = nextValue[from];
  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? !1 : index;
}
function _arrayApply(value, patch2) {
  const nextValue = value.slice();
  if (patch2.path.length === 0) {
    if (patch2.type === "setIfMissing") {
      if (!Array.isArray(patch2.value))
        throw new Error("Cannot set value of an array to a non-array");
      return value === void 0 ? patch2.value : value;
    } else if (patch2.type === "set") {
      if (!Array.isArray(patch2.value))
        throw new Error("Cannot set value of an array to a non-array");
      return patch2.value;
    } else {
      if (patch2.type === "unset")
        return;
      if (patch2.type === "move") {
        if (!patch2.value || !hasOwn(patch2.value, "from") || !hasOwn(patch2.value, "to"))
          throw new Error(
            `Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: ${JSON.stringify(
              patch2.value
            )}`
          );
        return move$1(nextValue, patch2.value.from, patch2.value.to);
      }
    }
    throw new Error(`Invalid array operation: ${patch2.type}`);
  }
  const [head, ...tail] = patch2.path, index = findTargetIndex(value, head);
  if (index === !1)
    return nextValue;
  if (tail.length === 0) {
    if (patch2.type === "insert") {
      const { position, items } = patch2;
      return arrayInsert(value, position, index, items);
    } else if (patch2.type === "unset") {
      if (typeof index != "number")
        throw new Error(`Expected array index to be a number, instead got "${index}"`);
      return nextValue.splice(index, 1), nextValue;
    }
  }
  return nextValue[index] = applyPatch(nextValue[index], {
    ...patch2,
    path: tail
  }), nextValue;
}
function _objectApply(value, patch2) {
  const nextValue = clone__default.default(value);
  if (patch2.path.length === 0) {
    if (patch2.type === "set") {
      if (!isObject__default.default(patch2.value))
        throw new Error("Cannot set value of an object to a non-object");
      return patch2.value;
    } else {
      if (patch2.type === "unset")
        return;
      if (patch2.type === "setIfMissing")
        return value === void 0 ? patch2.value : value;
    }
    throw new Error(`Invalid object operation: ${patch2.type}`);
  }
  const [head, ...tail] = patch2.path;
  if (typeof head != "string")
    throw new Error(`Expected field name to be a string, instad got: ${head}`);
  return tail.length === 0 && patch2.type === "unset" ? omit__default.default(nextValue, head) : (nextValue[head] = applyPatch(nextValue[head], {
    ...patch2,
    path: tail
  }), nextValue);
}
const OPERATIONS$1 = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function _primitiveApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch2.type))
    throw new Error(
      `Received patch of unsupported type "${patch2.type}" for primitives. This is most likely a bug.`
    );
  if (patch2.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on primitive values. Received patch with type "${patch2.type}" and path "${patch2.path.map((path) => JSON.stringify(path)).join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  return OPERATIONS$1[patch2.type](value, patch2.value);
}
const OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
  },
  diffMatchPatch(currentValue, dmpPatch) {
    const [result] = diffMatchPatch$1.applyPatches(diffMatchPatch$1.parsePatch(dmpPatch), currentValue, { allowExceedingIndices: !0 });
    return result;
  }
}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function _stringApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch2.type))
    throw new Error(
      `Received patch of unsupported type: "${JSON.stringify(
        patch2.type
      )}" for string. This is most likely a bug.`
    );
  if (patch2.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on string values. Received patch with type "${patch2.type}" and path "${patch2.path.join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  return OPERATIONS[patch2.type](value, patch2.value);
}
function applyAll(value, patches) {
  return patches.reduce(applyPatch, value);
}
function _applyPatch(value, patch2) {
  return Array.isArray(value) ? _arrayApply(value, patch2) : isString__default.default(value) ? _stringApply(value, patch2) : isObject__default.default(value) ? _objectApply(value, patch2) : _primitiveApply(value, patch2);
}
function applyPatch(value, patch2) {
  return _applyPatch(value, patch2);
}
const DocumentFieldActionsContext = React.createContext(null);
function DocumentFieldActionsProvider(props2) {
  const value = React.useMemo(() => ({ actions: props2.actions || EMPTY_ARRAY$b }), [props2.actions]);
  return /* @__PURE__ */ jsxRuntime.jsx(DocumentFieldActionsContext.Provider, { value, children: props2.children });
}
function useDocumentFieldActions() {
  const context = React.useContext(DocumentFieldActionsContext);
  if (!context)
    throw new Error("useDocumentFieldActions must be used within a DocumentFieldActionsProvider");
  return context.actions;
}
function is$1(typeName, type) {
  return type.name === typeName || !!(type.type && is$1(typeName, type.type));
}
function accepts(file, acceptedFiles) {
  if (!file || !acceptedFiles)
    return !0;
  const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(","), fileName = file.name || "", mimeType = (file.type || "").toLowerCase(), baseMimeType = mimeType.replace(/\/.*$/, "");
  return acceptedFilesArray.some((type) => {
    const validType = type.trim().toLowerCase();
    return validType.charAt(0) === "." ? fileName ? fileName.toLowerCase().endsWith(validType) : !0 : validType.endsWith("/*") ? baseMimeType === validType.replace(/\/.*$/, "") : mimeType === validType;
  });
}
const DEFAULT_CONCURRENCY = 4;
function remove(array, item) {
  const index = array.indexOf(item);
  return index > -1 && array.splice(index, 1), array;
}
function withMaxConcurrency(func, concurrency = DEFAULT_CONCURRENCY) {
  const throttler = createThrottler(concurrency);
  return (...args) => rxjs.from(throttler(func(...args)));
}
function createThrottler(concurrency = DEFAULT_CONCURRENCY) {
  const currentSubscriptions = [], pendingObservables = [], ready$ = new rxjs.Subject();
  return request;
  function request(observable) {
    return new rxjs.Observable((observer) => {
      if (currentSubscriptions.length >= concurrency)
        return scheduleAndWait(observable).pipe(operators.mergeMap(request)).subscribe(observer);
      const subscription = observable.subscribe(observer);
      return currentSubscriptions.push(subscription), () => {
        remove(currentSubscriptions, subscription), remove(pendingObservables, observable), subscription.unsubscribe(), check();
      };
    });
  }
  function scheduleAndWait(observable) {
    return pendingObservables.push(observable), ready$.asObservable().pipe(operators.first((obs) => obs === observable));
  }
  function check() {
    for (; pendingObservables.length > 0 && currentSubscriptions.length < concurrency; )
      ready$.next(pendingObservables.shift());
  }
}
const MAX_CONCURRENT_UPLOADS = 4;
function uploadSanityAsset(client2, assetType, file, options = {}) {
  const extract = options.metadata, preserveFilename = options.storeOriginalFilename, { label, title, description, creditLine, source } = options;
  return hashFile(file).pipe(
    operators.catchError(
      () => (
        // ignore if hashing fails for some reason
        rxjs.of(null)
      )
    ),
    operators.mergeMap(
      (hash2) => (
        // note: the sanity api will still dedupe unique files, but this saves us from uploading the asset file entirely
        hash2 ? fetchExisting(client2, `sanity.${assetType}Asset`, hash2) : rxjs.of(null)
      )
    ),
    operators.mergeMap((existing) => existing ? rxjs.of({
      // complete with the existing asset document
      type: "complete",
      id: existing._id,
      asset: existing
    }) : client2.observable.assets.upload(assetType, file, {
      tag: "asset.upload",
      extract,
      preserveFilename,
      label,
      title,
      description,
      creditLine,
      source
    }).pipe(
      operators.map(
        (event) => event.type === "response" ? {
          // rewrite to a 'complete' event
          type: "complete",
          id: event.body.document._id,
          asset: event.body.document
        } : event
      )
    ))
  );
}
const uploadAsset = withMaxConcurrency(uploadSanityAsset, MAX_CONCURRENT_UPLOADS), uploadImageAsset = (client2, file, options) => uploadAsset(client2, "image", file, options), uploadFileAsset = (client2, file, options) => uploadAsset(client2, "file", file, options);
function observeAssetDoc(documentPreviewStore, id2) {
  return documentPreviewStore.observePaths({ _type: "reference", _ref: id2 }, [
    "originalFilename",
    "url",
    "metadata",
    "label",
    "title",
    "description",
    "creditLine",
    "source",
    "size"
  ]);
}
function observeImageAsset(documentPreviewStore, id2) {
  return observeAssetDoc(documentPreviewStore, id2);
}
function observeFileAsset(documentPreviewStore, id2) {
  return observeAssetDoc(documentPreviewStore, id2);
}
function fetchExisting(client2, type, hash2) {
  return client2.observable.fetch(
    "*[_type == $documentType && sha1hash == $hash][0]",
    { documentType: type, hash: hash2 },
    { tag: "asset.find-duplicate" }
  );
}
function readFile(file) {
  return new rxjs.Observable((subscriber) => {
    const reader = new FileReader();
    return reader.onload = () => {
      subscriber.next(reader.result), subscriber.complete();
    }, reader.onerror = (err) => {
      subscriber.error(err);
    }, reader.readAsArrayBuffer(file), () => {
      reader.abort();
    };
  });
}
function hashFile(file) {
  return !window.crypto || !window.crypto.subtle || !window.FileReader ? rxjs.of(null) : readFile(file).pipe(
    operators.mergeMap((arrayBuffer) => crypto.subtle.digest("SHA-1", arrayBuffer)),
    operators.map(hexFromBuffer)
  );
}
function hexFromBuffer(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => `00${x.toString(16)}`.slice(-2)).join("");
}
const UPLOAD_STATUS_KEY = "_upload", UNSET_UPLOAD_PATCH = unset([UPLOAD_STATUS_KEY]);
function createUploadEvent(patches = []) {
  return {
    type: "uploadProgress",
    patches
  };
}
const CLEANUP_EVENT = createUploadEvent([UNSET_UPLOAD_PATCH]);
function createInitialUploadEvent(file) {
  const now = (/* @__PURE__ */ new Date()).toISOString(), value = {
    progress: 2,
    createdAt: now,
    updatedAt: now,
    file: { name: file.name, type: file.type }
  };
  return createUploadEvent([set(value, [UPLOAD_STATUS_KEY])]);
}
function uploadFile(client2, file, options) {
  const upload$ = uploadFileAsset(client2, file, options).pipe(
    operators.map((event) => event.type === "complete" ? createUploadEvent([
      set({ _type: "reference", _ref: event.asset._id }, ["asset"]),
      set(100, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])
    ]) : createUploadEvent([
      set(event.percent, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])
    ]))
  );
  return rxjs.concat(rxjs.of(createInitialUploadEvent(file)), upload$, rxjs.of(CLEANUP_EVENT));
}
function rotated(n) {
  return [5, 6, 7, 8].indexOf(n) > -1;
}
function rotate$1(ctx, options) {
  const x = options.x, y = options.y, radians = (options.degrees || 0) * (Math.PI / 180);
  ctx == null || ctx.translate(x, y), ctx == null || ctx.rotate(radians), ctx == null || ctx.translate(-x, -y);
}
function flip(canvas, x, y) {
  const ctx = canvas.getContext("2d");
  ctx == null || ctx.translate(x ? canvas.width : 0, y ? canvas.height : 0), ctx == null || ctx.scale(x ? -1 : 1, y ? -1 : 1);
}
const ORIENTATION_OPS = [
  { op: "none", degrees: 0 },
  { op: "flip-x", degrees: 0 },
  {
    op: "none",
    degrees: 180
  },
  { op: "flip-y", degrees: 0 },
  { op: "flip-x", degrees: 90 },
  { op: "none", degrees: 90 },
  {
    op: "flip-x",
    degrees: -90
  },
  { op: "none", degrees: -90 }
], ORIENTATIONS = [
  "top-left",
  "top-right",
  "bottom-right",
  "bottom-left",
  "left-top",
  "right-top",
  "right-bottom",
  "left-bottom"
], DEFAULT_ORIENTATION = "top-left", THUMB_SIZE = 120;
function _orient(img, orientationNumber) {
  const orientation = ORIENTATION_OPS[orientationNumber - 1], ratio = img.height / img.width;
  img.width = THUMB_SIZE / ratio, img.height = img.width * ratio;
  const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
  if (rotated(orientationNumber) ? (canvas.height = img.width, canvas.width = img.height) : (canvas.width = img.width, canvas.height = img.height), orientation.op === "flip-x" && flip(canvas, !0, !1), orientation.op === "flip-y" && flip(canvas, !1, !0), orientation.degrees && (rotate$1(ctx, {
    degrees: orientation.degrees,
    x: canvas.width / 2,
    y: canvas.height / 2
  }), rotated(orientationNumber))) {
    const d = canvas.width - canvas.height;
    ctx == null || ctx.translate(d / 2, -d / 2);
  }
  return ctx == null || ctx.drawImage(img, 0, 0, img.width, img.height), canvas;
}
function orient(image, orientationId) {
  return new rxjs.Observable((observer) => {
    const orientation = ORIENTATIONS.indexOf(orientationId) + 1, canvas = _orient(image, orientation);
    observer.next(canvas.toDataURL("image/jpeg", 0.1)), observer.complete();
  });
}
function readFileAsArrayBuffer(file, length) {
  return new rxjs.Observable((observer) => {
    const reader = new window.FileReader();
    return reader.onerror = (err) => observer.error(err), reader.onload = () => {
      observer.next(reader.result), observer.complete();
    }, reader.readAsArrayBuffer(length === void 0 ? file : file.slice(0, length)), () => reader.abort();
  });
}
const SKIP_EXIF_ERROR_RE = /(invalid image format)|(No exif data)/i, EXIF_BUFFER_LENGTH = 128e3;
function readExif(file) {
  return rxjs.from(readFileAsArrayBuffer(file, EXIF_BUFFER_LENGTH)).pipe(
    operators.map((buf) => exif__default.default(buf)),
    operators.catchError((error) => (SKIP_EXIF_ERROR_RE.test(error.message) || console.warn(`Exif read failed, continuing anyway: ${error.message}`), rxjs.of({})))
  );
}
function loadImage$1(url) {
  return new rxjs.Observable((observer) => {
    const image = new window.Image();
    return image.onerror = () => {
      observer.error(
        new Error(`Could not load image from url "${url}". Image may be of an unsupported format`)
      );
    }, image.onload = () => {
      observer.next(image), observer.complete();
    }, image.src = url, () => {
    };
  });
}
function rotateImage(file, orientation) {
  return loadImage$1(window.URL.createObjectURL(file)).pipe(
    operators.mergeMap((image) => orient(image, orientation))
  );
}
function uploadImage(client2, file, options) {
  const upload$ = uploadImageAsset(client2, file, options).pipe(
    operators.filter((event) => event.stage !== "download"),
    operators.map((event) => ({
      ...event,
      progress: 2 + event.percent / 100 * 98
    })),
    operators.map((event) => event.type === "complete" ? createUploadEvent([
      set({ _type: "reference", _ref: event.asset._id }, ["asset"]),
      set(100, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])
    ]) : createUploadEvent([
      set(event.percent, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])
    ]))
  ), setPreviewUrl$ = readExif(file).pipe(
    operators.mergeMap(
      (exifData) => rotateImage(file, exifData.orientation || DEFAULT_ORIENTATION)
    ),
    operators.catchError((error) => (console.warn(
      'Image preprocessing failed for "%s" with the error: %s',
      file.name,
      error.message
    ), rxjs.of(null))),
    operators.filter(Boolean),
    operators.map((imageUrl) => createUploadEvent([set(imageUrl, [UPLOAD_STATUS_KEY, "previewImage"])]))
  );
  return rxjs.concat(
    rxjs.of(createInitialUploadEvent(file)),
    rxjs.merge(upload$, setPreviewUrl$),
    rxjs.of(CLEANUP_EVENT)
  );
}
const UPLOAD_IMAGE = {
  type: "image",
  accepts: "image/*",
  upload: (client2, file, type, options) => uploadImage(client2, file, options)
}, UPLOAD_FILE = {
  type: "file",
  accepts: "",
  upload: (client2, file, type, options) => uploadFile(client2, file, options)
}, UPLOAD_TEXT = {
  type: "string",
  accepts: "text/*",
  upload: (client2, file, type, options) => uploadFile(client2, file, options).pipe(
    operators.map((content2) => ({
      type: "uploadProgress",
      patches: [set(content2)]
    }))
  )
  // Todo: promote this to a "first-class" form-builder abstraction
  // and make it possible to register custom uploaders
}, uploaders = [UPLOAD_IMAGE, UPLOAD_TEXT, UPLOAD_FILE].map(
  (uploader, i) => ({
    ...uploader,
    priority: i
  })
);
function resolveUploader(type, file) {
  return uploaders.find((uploader) => {
    var _a2;
    return is$1(uploader.type, type) && accepts(file, uploader.accepts) && accepts(file, ((_a2 = type.options) == null ? void 0 : _a2.accept) || "");
  }) || null;
}
function ArrayOfObjectsField(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onPathOpen,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), uploadSubscriptions = React.useRef({});
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathFocus(member.field.path);
    },
    [member.field.path, onPathFocus]
  ), handleBlur = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathBlur(member.field.path);
    },
    [member.field.path, onPathBlur]
  ), valueRef = React.useRef(member.field.value);
  React.useEffect(() => {
    valueRef.current = member.field.value;
  }, [member.field.value]);
  const handleChange = React.useCallback(
    (event) => {
      const patches = PatchEvent.from(event).patches;
      if (patches.some(
        (patch2) => patch2.type === "unset" && patch2.path.length === 1
      ) && (valueRef.current = applyAll(valueRef.current || [], patches), Array.isArray(valueRef.current) && !valueRef.current.length)) {
        onChange(PatchEvent.from(unset([member.name])));
        return;
      }
      onChange(PatchEvent.from(event).prepend(setIfMissing([])).prefixAll(member.name));
    },
    [onChange, member.name, valueRef]
  ), resolveInitialValue2 = useResolveInitialValueForType(), toast = ui.useToast(), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), handleCollapseItem = React.useCallback(
    (itemKey) => {
      onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), !0);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleExpandItem = React.useCallback(
    (itemKey) => {
      onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), !1);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleOpenItem = React.useCallback(
    (path) => {
      onPathOpen(path), onSetPathCollapsed(path, !1);
    },
    [onPathOpen, onSetPathCollapsed]
  ), handleCloseItem = React.useCallback(() => {
    onPathOpen(member.field.path), onSetPathCollapsed(member.field.path, !0);
  }, [onPathOpen, member.field.path, onSetPathCollapsed]), handleInsert = React.useCallback(
    (event) => {
      if (event.items.length === 0)
        throw new Error("Insert event should include at least one item");
      const itemsWithKeys = event.items.map((item) => ensureKey(item));
      handleChange(PatchEvent.from([insert(itemsWithKeys, event.position, [event.referenceItem])]));
      const focusItemKey = itemsWithKeys[0]._key, itemPath = [...member.field.path, { _key: focusItemKey }];
      onPathFocus(itemPath);
      const shouldOpen = event.open !== !1;
      event.skipInitialValue ? shouldOpen && handleOpenItem(itemPath) : resolveInitialArrayValues(itemsWithKeys, member.field.schemaType, resolveInitialValue2).pipe(
        operators.tap((result) => {
          result.type === "patch" ? handleChange(result.patches) : toast.push({
            title: "Could not resolve initial value",
            description: `Unable to resolve initial value for type: ${result.schemaType.title}: ${result.error.message}.`,
            status: "error"
          });
        })
      ).subscribe({
        complete: () => {
          shouldOpen && handleOpenItem(itemPath);
        }
      });
    },
    [
      handleChange,
      handleOpenItem,
      member.field.path,
      member.field.schemaType,
      onPathFocus,
      resolveInitialValue2,
      toast
    ]
  ), handleMoveItem = React.useCallback(
    (event) => {
      const value = member.field.value, item = value == null ? void 0 : value[event.fromIndex], refItem = value == null ? void 0 : value[event.toIndex];
      if (event.fromIndex !== event.toIndex) {
        if (!(item != null && item._key) || !(refItem != null && refItem._key)) {
          console.error(
            "Neither the item you are moving nor the item you are moving to have a key. Cannot continue."
          );
          return;
        }
        handleChange([
          unset([{ _key: item._key }]),
          insert([item], event.fromIndex > event.toIndex ? "before" : "after", [
            { _key: refItem._key }
          ])
        ]);
      }
    },
    [handleChange, member.field.value]
  ), handlePrependItem = React.useCallback(
    (item) => {
      handleChange([setIfMissing([]), insert([ensureKey(item)], "before", [0])]);
    },
    [handleChange]
  ), handleAppendItem = React.useCallback(
    (item) => {
      handleChange([setIfMissing([]), insert([ensureKey(item)], "after", [-1])]);
    },
    [handleChange]
  ), handleRemoveItem = React.useCallback(
    (itemKey) => {
      uploadSubscriptions.current[itemKey] && (uploadSubscriptions.current[itemKey].unsubscribe(), delete uploadSubscriptions.current[itemKey]), handleChange([unset([{ _key: itemKey }])]);
    },
    [handleChange]
  ), handleFocusChildPath = React.useCallback(
    (path) => {
      onPathFocus(member.field.path.concat(path));
    },
    [member.field.path, onPathFocus]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), formBuilder = useFormBuilder(), supportsImageUploads = formBuilder.__internal.image.directUploads, supportsFileUploads = formBuilder.__internal.file.directUploads, resolveUploader$1 = React.useCallback(
    (type, file) => is$1("image", type) && !supportsImageUploads || is$1("file", type) && !supportsFileUploads ? null : resolveUploader(type, file),
    [supportsFileUploads, supportsImageUploads]
  ), handleUpload = React.useCallback(
    ({ file, schemaType, uploader }) => {
      const item = createProtoArrayValue(schemaType), key = item._key;
      handleInsert({
        items: [item],
        position: "after",
        referenceItem: -1,
        open: !1
      });
      const events$ = uploader.upload(client2, file, schemaType).pipe(
        operators.map(
          (uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || []).prefixAll({ _key: key })
        ),
        operators.tap((event) => handleChange(event.patches))
      );
      uploadSubscriptions.current = {
        ...uploadSubscriptions.current,
        [key]: events$.subscribe()
      };
    },
    [client2, handleChange, handleInsert]
  ), inputProps = React.useMemo(() => ({
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    onItemExpand: handleExpandItem,
    onItemCollapse: handleCollapseItem,
    onItemClose: handleCloseItem,
    onItemOpen: handleOpenItem,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    path: member.field.path,
    onChange: handleChange,
    onInsert: handleInsert,
    onItemMove: handleMoveItem,
    onItemRemove: handleRemoveItem,
    onItemAppend: handleAppendItem,
    onItemPrepend: handlePrependItem,
    onPathFocus: handleFocusChildPath,
    resolveInitialValue: resolveInitialValue2,
    onUpload: handleUpload,
    resolveUploader: resolveUploader$1,
    validation: member.field.validation,
    presence: member.field.presence,
    renderAnnotation,
    renderBlock,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem,
    renderPreview,
    elementProps
  }), [
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.focusPath,
    member.field.focused,
    member.field.path,
    member.field.validation,
    member.field.presence,
    handleExpandItem,
    handleCollapseItem,
    handleCloseItem,
    handleOpenItem,
    handleChange,
    handleInsert,
    handleMoveItem,
    handleRemoveItem,
    handleAppendItem,
    handlePrependItem,
    handleFocusChildPath,
    resolveInitialValue2,
    handleUpload,
    resolveUploader$1,
    renderAnnotation,
    renderBlock,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem,
    renderPreview,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    changed: member.field.changed,
    onCollapse: handleCollapse,
    onExpand: handleExpand,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    presence: member.field.presence,
    validation: member.field.validation,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.presence,
    member.field.validation,
    member.collapsible,
    member.collapsed,
    handleCollapse,
    handleExpand,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathOpen,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
}
function readAsText(file, encoding) {
  return new rxjs.Observable((observer) => {
    const reader = new FileReader();
    return reader.onerror = (error) => observer.error(error), reader.onload = () => {
      observer.next(reader.result), observer.complete();
    }, reader.readAsText(file, encoding), () => {
      reader.abort();
    };
  });
}
function move(arr, from, to) {
  const copy = arr.slice(), val = copy[from];
  return copy.splice(from, 1), copy.splice(to, 0, val), copy;
}
function insertAfter(index, arr, items) {
  const copy = arr.slice();
  return copy.splice(index + 1, 0, ...items), copy;
}
function isStringNumeric(input) {
  return /^\d+$/.test(input);
}
function convertToSchemaType(line, candidates) {
  let acceptsBooleans = !1, acceptsNumbers = !1, acceptsStrings = !1;
  return candidates.forEach((candidate) => {
    types.isBooleanSchemaType(candidate) && (acceptsBooleans = !0), types.isStringSchemaType(candidate) && (acceptsStrings = !0), types.isNumberSchemaType(candidate) && (acceptsNumbers = !0);
  }), acceptsBooleans && (line === "true" || line === "false") ? line === "true" : acceptsNumbers && isStringNumeric(line) ? Number(line) : acceptsStrings ? line : void 0;
}
function createPlainTextUploader(itemTypes) {
  return {
    priority: 0,
    accepts: "text/*",
    type: "string",
    upload(client2, file) {
      return readAsText(file, "utf-8").pipe(
        operators.map(
          (textContent) => textContent == null ? void 0 : textContent.split(/[\n\r]/).map((value) => convertToSchemaType(value, itemTypes)).filter((v) => v !== void 0)
        ),
        operators.filter((v) => Array.isArray(v)),
        operators.map((lines) => ({
          type: "uploadProgress",
          patches: [insert(lines, "after", [-1])]
        }))
      );
    }
  };
}
function ArrayOfPrimitivesField(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), uploadSubscriptions = React.useRef(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathFocus(member.field.path);
    },
    [member.field.path, onPathFocus]
  ), handleBlur = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathBlur(member.field.path);
    },
    [member.field.path, onPathBlur]
  ), handleChange = React.useCallback(
    (event) => {
      const patches = PatchEvent.from(event).patches;
      if (patches.some(
        (patch2) => patch2.type === "unset" && patch2.path.length === 1
      )) {
        const result = applyAll(member.field.value || [], patches);
        if (Array.isArray(result) && !result.length) {
          onChange(PatchEvent.from(unset([member.name])));
          return;
        }
      }
      onChange(PatchEvent.from(event).prepend(setIfMissing([])).prefixAll(member.name));
    },
    [onChange, member.name, member.field.value]
  ), handleSetCollapsed = React.useCallback(
    (collapsed) => {
      onSetPathCollapsed(member.field.path, collapsed);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), setValue = React.useCallback(
    (nextValue) => {
      handleChange(nextValue.length === 0 ? unset() : set(nextValue));
    },
    [handleChange]
  ), handleMoveItem = React.useCallback(
    (event) => {
      const { value = [] } = member.field;
      event.fromIndex !== event.toIndex && setValue(move(value, event.fromIndex, event.toIndex));
    },
    [member.field, setValue]
  ), handleAppend = React.useCallback(
    (itemValue) => {
      const { value = [] } = member.field;
      setValue(value.concat(itemValue));
    },
    [member.field, setValue]
  ), handlePrepend = React.useCallback(
    (itemValue) => {
      const { value = [] } = member.field;
      setValue([itemValue].concat(value || []));
    },
    [member.field, setValue]
  ), handleInsert = React.useCallback(
    (event) => {
      const { value = [] } = member.field, insertIndex = event.referenceIndex + (event.position === "before" ? -1 : 0);
      setValue(insertAfter(insertIndex, value, event.items));
    },
    [member.field, setValue]
  ), handleRemoveItem = React.useCallback(
    (index) => {
      handleChange(unset([index]));
    },
    [handleChange]
  ), handleFocusIndex = React.useCallback(
    (index) => {
      onPathFocus(member.field.path.concat([index]));
    },
    [member.field.path, onPathFocus]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), plainTextUploader = React.useMemo(
    () => createPlainTextUploader(member.field.schemaType.of),
    [member.field.schemaType.of]
  ), resolveUploader2 = React.useCallback(
    (schemaType, file) => accepts(file, "text/*") ? plainTextUploader : null,
    [plainTextUploader]
  ), handleUpload = React.useCallback(
    ({ file, schemaType, uploader }) => {
      const events$ = uploader.upload(client2, file, schemaType).pipe(
        operators.map(
          (uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || [])
        ),
        operators.tap((event) => handleChange(event.patches))
      );
      uploadSubscriptions.current && uploadSubscriptions.current.unsubscribe(), uploadSubscriptions.current = events$.subscribe();
    },
    [client2, handleChange]
  ), inputProps = React.useMemo(() => ({
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    onSetCollapsed: handleSetCollapsed,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    elementProps,
    path: member.field.path,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    onChange: handleChange,
    onInsert: handleInsert,
    onMoveItem: handleMoveItem,
    onItemRemove: handleRemoveItem,
    onItemAppend: handleAppend,
    onItemPrepend: handlePrepend,
    validation: member.field.validation,
    presence: member.field.presence,
    resolveUploader: resolveUploader2,
    onUpload: handleUpload,
    renderAnnotation,
    renderBlock,
    renderInlineBlock,
    renderInput,
    renderItem,
    onIndexFocus: handleFocusIndex,
    renderPreview
  }), [
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focusPath,
    member.field.focused,
    member.field.validation,
    member.field.presence,
    handleSetCollapsed,
    elementProps,
    handleChange,
    handleInsert,
    handleMoveItem,
    handleRemoveItem,
    handleAppend,
    handlePrepend,
    resolveUploader2,
    handleUpload,
    renderAnnotation,
    renderBlock,
    renderInlineBlock,
    renderInput,
    renderItem,
    handleFocusIndex,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    onExpand: handleExpand,
    changed: member.field.changed,
    onCollapse: handleCollapse,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    presence: member.field.presence,
    validation: member.field.validation,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.presence,
    member.field.validation,
    member.collapsible,
    member.collapsed,
    handleExpand,
    handleCollapse,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
}
function isMemberObject(member) {
  return types.isObjectSchemaType(member.field.schemaType);
}
function isMemberArrayOfPrimitives(member) {
  return types.isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => types.isPrimitiveSchemaType(ofType));
}
function isMemberArrayOfObjects(member) {
  return types.isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => types.isObjectSchemaType(ofType));
}
const ObjectField = function(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), pendingValue = React.useRef(member.field.value);
  React.useEffect(() => {
    pendingValue.current = member.field.value;
  }, [member.field.value]), useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleBlur = React.useCallback(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]), handleFocusChildPath = React.useCallback(
    (path) => {
      onPathFocus(member.field.path.concat(path));
    },
    [member.field.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      if (member.field.path.length !== 0) {
        const patches = PatchEvent.from(event).patches;
        if (pendingValue.current = applyAll(pendingValue.current || {}, patches), pendingValue.current && content.isShallowEmptyObject(pendingValue.current)) {
          onChange(PatchEvent.from(unset([member.name])));
          return;
        }
      }
      onChange(
        PatchEvent.from(event).prepend(setIfMissing(createProtoValue(member.field.schemaType))).prefixAll(member.name)
      );
    },
    [onChange, member, pendingValue]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), handleCollapseField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.field.path.concat(fieldName), !0);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleExpandField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.field.path.concat(fieldName), !1);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleOpenField = React.useCallback(
    (fieldName) => {
      onPathOpen(member.field.path.concat(fieldName));
    },
    [onPathOpen, member.field.path]
  ), handleCloseField = React.useCallback(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]), handleExpandFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), !1);
    },
    [onSetFieldSetCollapsed, member.field.path]
  ), handleCollapseFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), !0);
    },
    [onSetFieldSetCollapsed, member.field.path]
  ), handleOpen = React.useCallback(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]), handleClose = React.useCallback(() => {
    onPathOpen(member.field.path.slice(0, -1));
  }, [onPathOpen, member.field.path]), handleSelectFieldGroup = React.useCallback(
    (groupName) => {
      onFieldGroupSelect(member.field.path, groupName);
    },
    [onFieldGroupSelect, member.field.path]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), inputProps = React.useMemo(() => ({
    elementProps,
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    validation: member.field.validation,
    presence: member.field.presence,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    onFieldGroupSelect: handleSelectFieldGroup,
    onFieldOpen: handleOpenField,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onFieldSetCollapse: handleCollapseFieldSet,
    onPathFocus: handleFocusChildPath,
    path: member.field.path,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    groups: member.field.groups,
    onChange: handleChange,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  }), [
    elementProps,
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.validation,
    member.field.presence,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focusPath,
    member.field.focused,
    member.field.groups,
    handleSelectFieldGroup,
    handleOpenField,
    handleCloseField,
    handleCollapseField,
    handleExpandField,
    handleExpandFieldSet,
    handleCollapseFieldSet,
    handleFocusChildPath,
    handleChange,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    validation: member.field.validation,
    presence: member.field.presence,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    onCollapse: handleCollapse,
    onExpand: handleExpand,
    open: member.open,
    changed: member.field.changed,
    onOpen: handleOpen,
    onClose: handleClose,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.validation,
    member.field.presence,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.collapsible,
    member.collapsed,
    member.open,
    handleCollapse,
    handleExpand,
    handleOpen,
    handleClose,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onSetFieldSetCollapsed,
      onPathOpen,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
};
function PrimitiveField$1(props2) {
  const { member, renderInput, renderField } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), [localValue, setLocalValue] = React.useState(), { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  React.useEffect(() => {
    var _a2;
    member.field.focused && ((_a2 = focusRef.current) == null || _a2.focus());
  }, [member.field.focused]);
  const handleBlur = React.useCallback(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.name));
    },
    [onChange, member.name]
  ), handleNativeChange = React.useCallback(
    (event) => {
      let inputValue = event.currentTarget.value;
      if (types.isNumberSchemaType(member.field.schemaType)) {
        if (inputValue = event.currentTarget.valueAsNumber, inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER)
          return;
      } else
        types.isBooleanSchemaType(member.field.schemaType) && (inputValue = event.currentTarget.checked);
      const hasEmptyValue = inputValue === "" || typeof inputValue == "number" && isNaN(inputValue);
      types.isNumberSchemaType(member.field.schemaType) && setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value), onChange(PatchEvent.from(hasEmptyValue ? unset() : set(inputValue)).prefixAll(member.name));
    },
    [member.name, member.field.schemaType, onChange]
  ), validationError = React.useMemo(
    () => member.field.validation.filter((item) => item.level === "error").map((item) => item.message).join(`
`),
    [member.field.validation]
  ) || void 0, elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      onChange: handleNativeChange,
      value: resolveNativeNumberInputValue(member.field.schemaType, member.field.value, localValue),
      readOnly: !!member.field.readOnly,
      placeholder: member.field.schemaType.placeholder,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [
      handleBlur,
      handleFocus,
      handleNativeChange,
      member.field.id,
      member.field.readOnly,
      member.field.schemaType,
      member.field.value,
      localValue
    ]
  ), inputProps = React.useMemo(() => ({
    value: member.field.value,
    readOnly: member.field.readOnly,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    path: member.field.path,
    focused: member.field.focused,
    level: member.field.level,
    onChange: handleChange,
    validation: member.field.validation,
    presence: member.field.presence,
    validationError,
    elementProps
  }), [
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focused,
    member.field.level,
    member.field.validation,
    member.field.presence,
    handleChange,
    validationError,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    changed: member.field.changed,
    children: renderedInput,
    description: member.field.schemaType.description,
    index: member.index,
    inputId: member.field.id,
    inputProps,
    level: member.field.level,
    name: member.name,
    path: member.field.path,
    presence: member.field.presence,
    schemaType: member.field.schemaType,
    title: member.field.schemaType.title,
    validation: member.field.validation,
    value: member.field.value
  }), [
    fieldActions,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.id,
    member.field.path,
    member.field.validation,
    member.field.presence,
    member.field.changed,
    member.name,
    member.index,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderField(fieldProps) });
}
const MemberField = React.memo(function(props2) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2;
  return isMemberObject(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ObjectField,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    }
  ) : isMemberArrayOfPrimitives(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ArrayOfPrimitivesField,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInput,
      renderInlineBlock,
      renderItem,
      renderPreview
    }
  ) : isMemberArrayOfObjects(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ArrayOfObjectsField,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(PrimitiveField$1, { member, renderField, renderInput });
}), STATUS_TONES$1 = {
  warning: "caution",
  error: "critical"
}, SuffixBox = styled__default.default(ui.Box)`
  border-top: 1px solid var(--card-border-color);
`;
function Alert(props2) {
  const { children, status = "warning", suffix, title, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { radius: 2, tone: STATUS_TONES$1[status], ...rest, "data-ui": "Alert", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
        status === "warning" && /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
        status === "error" && /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {})
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, marginLeft: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }),
        children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children })
      ] })
    ] }),
    suffix && /* @__PURE__ */ jsxRuntime.jsx(SuffixBox, { children: suffix })
  ] });
}
const HeaderButton = styled__default.default.button`
  display: block;
  -webkit-font-smoothing: inherit;
  appearance: none;
  font: inherit;
  background: none;
  width: 100%;
  text-align: left;
  border: 0;
  margin: 0;
  padding: 0;
  outline: none;
`, ToggleArrow = styled__default.default(icons.ToggleArrowRightIcon)`
  transform: ${(props2) => props2.open ? "rotate(90deg)" : ""};
`, Header = styled__default.default(ui.Flex)`
  cursor: default;
`, IconBox = styled__default.default(ui.Box)`
  & > div > svg {
    transform: rotate(0);
    transition: transform 100ms;
  }

  &[data-open] > div > svg {
    transform: rotate(90deg);
  }
`;
function Details(props2) {
  const { children, open: openProp, icon, title = "Details", ...restProps } = props2, [open, setOpen] = React.useState(openProp || !1), handleToggle = React.useCallback(() => setOpen((v) => !v), []);
  return React.useEffect(() => setOpen(openProp || !1), [openProp]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { ...restProps, children: [
    /* @__PURE__ */ jsxRuntime.jsx(HeaderButton, { type: "button", onClick: handleToggle, children: /* @__PURE__ */ jsxRuntime.jsx(Header, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(IconBox, { "data-open": open ? "" : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ToggleArrow, { open }) }) }),
      icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children: icon }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }) })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { hidden: !open, marginTop: 3, children })
  ] });
}
const TRUTHY_STRINGS = ["yes", "true", "1"], FALSEY_STRINGS = ["false", "no", "false", "0", "null"], BOOL_STRINGS = TRUTHY_STRINGS.concat(FALSEY_STRINGS), TRUE = () => !0, has = (prop) => (val) => val && val[prop], is = (typeName) => (val) => (val && val._type) === typeName;
function toLocalDate(input) {
  const newDate = new Date(input.getTime() + input.getTimezoneOffset() * 60 * 1e3), offset = input.getTimezoneOffset() / 60, hours = input.getHours();
  return newDate.setHours(hours - offset), newDate;
}
function getTZName() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch {
  }
  return null;
}
const converters = {
  string: {
    number: {
      test: Number,
      convert: Number
    },
    boolean: {
      test: (value) => BOOL_STRINGS.includes(value.toLowerCase()),
      convert: (value) => TRUTHY_STRINGS.includes(value.toLowerCase()) || !FALSEY_STRINGS.includes(value.toLowerCase())
    },
    richDate: {
      test: (value) => isValidDate__default.default(value),
      convert: (value) => ({
        _type: "richDate",
        local: toLocalDate(new Date(value)).toJSON(),
        utc: new Date(value).toJSON(),
        timezone: getTZName(),
        offset: (/* @__PURE__ */ new Date()).getTimezoneOffset()
      })
    }
  },
  date: {
    richDate: {
      test: is("date"),
      convert: (value) => Object.assign({}, value, { _type: "richDate" })
    }
  },
  richDate: {
    datetime: {
      test: has("utc"),
      convert: (value) => value.utc
    }
  },
  number: {
    string: {
      test: TRUE,
      convert: String
    },
    boolean: {
      test: TRUE,
      convert: Number
    }
  },
  boolean: {
    string: {
      test: TRUE,
      convert: (value) => value ? "Yes" : "No"
    },
    number: {
      test: TRUE,
      convert: Number
    }
  }
};
function SetMissingTypeButton({
  value,
  targetType,
  onChange
}) {
  const itemValue = React.useMemo(() => ({ ...value, _type: targetType }), [targetType, value]), handleClick = React.useCallback(
    () => onChange(PatchEvent.from(setIfMissing(targetType, ["_type"])), itemValue),
    [itemValue, onChange, targetType]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      onClick: handleClick,
      text: t2("inputs.untyped-value.convert-button.text", {
        targetType
      })
    }
  );
}
function UnsetItemButton({
  value,
  onChange,
  validTypes
}) {
  const itemValue = React.useMemo(() => ({ ...value, _type: validTypes[0] }), [validTypes, value]), handleClick = React.useCallback(
    () => onChange(PatchEvent.from(unset()), itemValue),
    [itemValue, onChange]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      onClick: handleClick,
      tone: "critical",
      text: t2("inputs.untyped-value.unset-item-button.text")
    }
  );
}
function UntypedValueInput({ validTypes, value, onChange }) {
  const schema2 = useSchema(), isSingleValidType = validTypes.length === 1, isHoistedType = schema2.has(validTypes[0]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Alert,
    {
      status: "warning",
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.title" }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(Details, { open: isDev, title: t2("inputs.untyped-value.details.title"), children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.description" }) }),
        isSingleValidType && !isHoistedType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.details.description" }) }),
        !isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.untyped-value.details.multi-type-description") }),
        !isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 2, children: validTypes.map((validType) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "li", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("code", { children: validType }) }, validType)) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h4", weight: "medium", size: 1, children: t2("inputs.untyped-value.details.json-dump-prefix") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", children: JSON.stringify(value, null, 2) }) })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: [1, 2, 2], gap: 1, children: [
          isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(SetMissingTypeButton, { onChange, targetType: validTypes[0], value }),
          /* @__PURE__ */ jsxRuntime.jsx(UnsetItemButton, { onChange, validTypes, value })
        ] })
      ] }) })
    }
  );
}
function getConverters(value, actualType, validTypes) {
  return actualType in converters ? Object.keys(converters[actualType]).filter((targetType) => validTypes.includes(targetType)).map((targetType) => ({
    from: actualType,
    to: targetType,
    ...converters[actualType][targetType]
  })).filter((converter) => converter.test(value)) : [];
}
const InvalidValueInput = React.forwardRef(
  (props2, ref) => {
    const { value, actualType, validTypes, onChange } = props2;
    React.useImperativeHandle(ref, () => ({
      // @todo
      focus: () => {
      }
    }));
    const handleClearClick = React.useCallback(() => {
      onChange(PatchEvent.from(unset()));
    }, [onChange]), handleConvertTo = React.useCallback(
      (converted) => {
        onChange(PatchEvent.from(set(converted)));
      },
      [onChange]
    ), converters2 = React.useMemo(
      () => getConverters(value, actualType, validTypes),
      [value, actualType, validTypes]
    ), { t: t2 } = useTranslation();
    if (isPlainObject__default.default(value) && !("_type" in value))
      return /* @__PURE__ */ jsxRuntime.jsx(
        UntypedValueInput,
        {
          value,
          validTypes,
          onChange
        }
      );
    const suffix = /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        onClick: handleClearClick,
        tone: "critical",
        text: t2("inputs.invalid-value.reset-button.text")
      }
    ) });
    return /* @__PURE__ */ jsxRuntime.jsxs(Alert, { status: "error", suffix, title: t2("inputs.invalid-value.title"), children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.description") }),
      /* @__PURE__ */ jsxRuntime.jsx(Details, { marginTop: 4, open: isDev, title: t2("inputs.invalid-value.details.title"), children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        validTypes.length === 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.invalid-value.details.description",
            values: {
              validType: validTypes[0]
            }
          }
        ) }),
        validTypes.length === 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.details.possible-reason") }),
        validTypes.length !== 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.details.multi-type-description") }),
        validTypes.length !== 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 2, children: validTypes.map((validType) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx("code", { children: validType }) }, validType)) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { marginTop: 2, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "inputs.invalid-value.current-type",
              values: {
                actualType
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: JSON.stringify(value, null, 2) }) })
        ] }),
        converters2.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: converters2.map((converter) => /* @__PURE__ */ jsxRuntime.jsx(
          ConvertButton,
          {
            converter,
            onConvert: handleConvertTo,
            value
          },
          `${converter.from}-${converter.to}`
        )) })
      ] }) })
    ] });
  }
);
InvalidValueInput.displayName = "InvalidValueInput";
function ConvertButton({
  converter,
  onConvert,
  value
}) {
  const handleClick = React.useCallback(
    () => onConvert(converter.convert(value)),
    [converter, onConvert, value]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      onClick: handleClick,
      text: t2("inputs.invalid-value.convert-button.text", { targetType: converter.to })
    }
  );
}
function DuplicateKeysAlert(props2) {
  const { error, onChange } = props2, handleFixDuplicateKeys = React.useCallback(() => {
    onChange(
      PatchEvent.from(
        (error.duplicates || []).map(
          ([index, key]) => set(`${key}_deduped_${index}`, [index, "_key"])
        )
      )
    );
  }, [error.duplicates, onChange]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          onClick: handleFixDuplicateKeys,
          text: t2("form.error.duplicate-keys-alert.generate-button.text"),
          tone: "caution"
        }
      ) }),
      title: t2("form.error.duplicate-keys-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.duplicate-keys-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("form.error.duplicate-keys-alert.details.title"),
            children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.duplicate-keys-alert.details.description" }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: "form.error.duplicate-keys-alert.details.additional-description"
                }
              ) })
            ] })
          }
        )
      ]
    }
  ) });
}
function MissingKeysAlert(props2) {
  const { error, onChange } = props2, handleFixMissingKeys = React.useCallback(() => {
    onChange(
      PatchEvent.from((error.value || []).map((val, i) => setIfMissing(content.randomKey(), [i, "_key"])))
    );
  }, [error.value, onChange]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          onClick: handleFixMissingKeys,
          text: t2("form.error.missing-keys-alert.add-button.text"),
          tone: "caution"
        }
      ) }),
      title: t2("form.error.missing-keys-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.missing-keys-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("form.error.missing-keys-alert.details.title"),
            children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.missing-keys-alert.details.description" }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: "form.error.missing-keys-alert.details.additional-description"
                }
              ) })
            ] })
          }
        )
      ]
    }
  ) });
}
function MixedArrayAlert(props2) {
  const { error, onChange } = props2, handleRemoveNonObjectValues = () => {
    const patches = (error.value || []).flatMap((item, index) => isPlainObject__default.default(item) ? [] : [index]).reverse().map((index) => unset([index]));
    onChange(PatchEvent.from(patches));
  }, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "error",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          onClick: handleRemoveNonObjectValues,
          text: t2("form.error.mixed-array-alert.remove-button.text"),
          tone: "critical"
        }
      ) }),
      title: t2("form.error.mixed-array-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.mixed-array-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(Details, { marginTop: 4, open: isDev, title: t2("form.error.mixed-array-alert.details.title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.mixed-array-alert.details.description") }) }) })
      ]
    }
  ) });
}
function MemberFieldError(props2) {
  const { member } = props2, { onChange } = useFormCallbacks(), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.fieldName));
    },
    [onChange, member.fieldName]
  ), { t: t2 } = useTranslation();
  return member.error.type === "INCOMPATIBLE_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(
    InvalidValueInput,
    {
      value: member.error.value,
      onChange: handleChange,
      actualType: member.error.resolvedValueType,
      validTypes: [member.error.expectedSchemaType.name]
    }
  ) : member.error.type === "MISSING_KEYS" ? /* @__PURE__ */ jsxRuntime.jsx(MissingKeysAlert, { error: member.error, onChange: handleChange }) : member.error.type === "DUPLICATE_KEYS" ? /* @__PURE__ */ jsxRuntime.jsx(DuplicateKeysAlert, { error: member.error, onChange: handleChange }) : member.error.type === "MIXED_ARRAY" ? /* @__PURE__ */ jsxRuntime.jsx(MixedArrayAlert, { onChange: handleChange, error: member.error }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: t2("member-field-error.unexpected-error", { error: props2.member.error.type }) });
}
const MemberFieldSet = React.memo(function(props2) {
  var _a2;
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props2, { onSetFieldSetCollapsed } = useFormCallbacks(), handleCollapse = React.useCallback(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, !0);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]), handleExpand = React.useCallback(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, !1);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormFieldSet,
    {
      title: member.fieldSet.title || capitalize__default.default(member.fieldSet.name),
      description: member.fieldSet.description,
      level: member.fieldSet.level,
      collapsible: member.fieldSet.collapsible,
      collapsed: member.fieldSet.collapsed,
      onCollapse: handleCollapse,
      onExpand: handleExpand,
      columns: (_a2 = member == null ? void 0 : member.fieldSet) == null ? void 0 : _a2.columns,
      "data-testid": `fieldset-${member.fieldSet.name}`,
      inputId: member.fieldSet.name,
      children: member.fieldSet.members.map((fieldsetMember) => fieldsetMember.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member: fieldsetMember }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(
        MemberField,
        {
          member: fieldsetMember,
          renderAnnotation,
          renderBlock,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderPreview
        },
        fieldsetMember.key
      ))
    }
  );
}), ObjectInputMember = React.memo(function(props2) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderInput,
    renderInlineBlock,
    renderField,
    renderItem,
    renderPreview
  } = props2;
  return member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
    MemberField,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderInlineBlock,
      renderInput,
      renderField,
      renderItem,
      renderPreview
    },
    member.key
  ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
    MemberFieldSet,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderInlineBlock,
      renderInput,
      renderField,
      renderItem,
      renderPreview
    },
    member.key
  ) : (console.warn(new Error(`Unhandled member kind ${member.kind}`)), null);
});
function ObjectInputMembers(props2) {
  const {
    members,
    renderAnnotation,
    renderBlock,
    renderInput,
    renderInlineBlock,
    renderField,
    renderItem,
    renderPreview
  } = props2, renderMembers = React.useMemo(
    () => members.map((member) => /* @__PURE__ */ jsxRuntime.jsx(
      ObjectInputMember,
      {
        member,
        renderAnnotation,
        renderBlock,
        renderField,
        renderInlineBlock,
        renderInput,
        renderItem,
        renderPreview
      },
      member.key
    )),
    [
      members,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderMembers });
}
const ObjectMembers = ObjectInputMembers;
function isObjectInputProps$1(inputProps) {
  return types.isObjectSchemaType(inputProps.schemaType);
}
function isArrayInputProps(inputProps) {
  return types.isArraySchemaType(inputProps.schemaType);
}
const pass = ({ children }) => children;
function hasAbsolutePath(a) {
  return "absolutePath" in a;
}
const FormInput = React.memo(function(props2) {
  const absolutePath = React.useMemo(() => hasAbsolutePath(props2) ? props2.absolutePath : props2.path.concat(props2.relativePath), [props2]), nullRender = React.useCallback(() => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "Missing destination render function" }), []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormInputInner,
    {
      ...props2,
      absolutePath,
      destinationRenderAnnotation: props2.renderAnnotation || nullRender,
      destinationRenderBlock: props2.renderBlock || nullRender,
      destinationRenderField: props2.renderField,
      destinationRenderInlineBlock: props2.renderInlineBlock || nullRender,
      destinationRenderInput: props2.renderInput,
      destinationRenderItem: props2.renderItem,
      destinationRenderPreview: props2.renderPreview
    }
  );
}), FormInputInner = React.memo(function FormInputInner2(props2) {
  const {
    absolutePath,
    destinationRenderAnnotation,
    destinationRenderBlock,
    destinationRenderField,
    destinationRenderInlineBlock,
    destinationRenderInput,
    destinationRenderItem,
    destinationRenderPreview
  } = props2, { t: t2 } = useTranslation(), renderInput = React.useCallback(
    (inputProps) => {
      if (PathUtils.isEqual(inputProps.path, absolutePath) || PathUtils.startsWith(absolutePath, inputProps.path))
        return destinationRenderInput(inputProps);
      if (!isObjectInputProps$1(inputProps) && !isArrayInputProps(inputProps))
        throw new Error(
          `Expected either object input props or array input props for: ${JSON.stringify(
            inputProps.path
          )}`
        );
      return /* @__PURE__ */ jsxRuntime.jsx(
        FormInputInner2,
        {
          ...inputProps,
          absolutePath,
          destinationRenderAnnotation,
          destinationRenderBlock,
          destinationRenderInput,
          destinationRenderItem,
          destinationRenderField,
          destinationRenderInlineBlock,
          destinationRenderPreview
        }
      );
    },
    [
      absolutePath,
      destinationRenderAnnotation,
      destinationRenderBlock,
      destinationRenderField,
      destinationRenderInlineBlock,
      destinationRenderInput,
      destinationRenderItem,
      destinationRenderPreview
    ]
  ), renderField = React.useCallback(
    (fieldProps) => PathUtils.startsWith(absolutePath, fieldProps.path) && (props2.includeField || !PathUtils.isEqual(absolutePath, fieldProps.path)) ? destinationRenderField(fieldProps) : pass(fieldProps),
    [absolutePath, destinationRenderField, props2.includeField]
  ), renderItem = React.useCallback(
    (itemProps) => PathUtils.startsWith(absolutePath, itemProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, itemProps.path)) ? destinationRenderItem(itemProps) : pass(itemProps),
    [absolutePath, destinationRenderItem, props2.includeItem]
  ), renderBlock = React.useCallback(
    (blockProps) => PathUtils.startsWith(absolutePath, blockProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, blockProps.path)) ? destinationRenderBlock(blockProps) : pass(blockProps),
    [absolutePath, destinationRenderBlock, props2.includeItem]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => PathUtils.startsWith(absolutePath, blockProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, blockProps.path)) ? destinationRenderInlineBlock(blockProps) : pass(blockProps),
    [absolutePath, destinationRenderInlineBlock, props2.includeItem]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => PathUtils.startsWith(absolutePath, annotationProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, annotationProps.path)) ? destinationRenderAnnotation(annotationProps) : pass(annotationProps),
    [absolutePath, destinationRenderAnnotation, props2.includeItem]
  );
  if (isArrayInputProps(props2)) {
    const childPath = PathUtils.trimLeft(props2.path, absolutePath), itemMember = props2.members.find(
      (member) => member.kind == "item" && types.isKeySegment(childPath[0]) && member.key === childPath[0]._key
    );
    if (!itemMember) {
      const path = pathToString$1(props2.path), relativePath = PathUtils.trimLeft(props2.path, absolutePath);
      if (types.isKeySegment(relativePath[0])) {
        const key = relativePath[0]._key;
        return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.no-array-item-at-key", values: { key, path } }) });
      }
      const index = types.isIndexSegment(relativePath[0]) ? relativePath[0] : relativePath[0][0];
      return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.no-array-item-at-index", values: { index, path } }) });
    }
    return itemMember.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberItemError, { member: itemMember }) : /* @__PURE__ */ jsxRuntime.jsx(
      ArrayOfObjectsItem,
      {
        member: itemMember,
        renderAnnotation,
        renderBlock,
        renderInput,
        renderField,
        renderInlineBlock,
        renderItem,
        renderPreview: destinationRenderPreview
      }
    );
  }
  if (isObjectInputProps$1(props2)) {
    const childPath = PathUtils.trimLeft(props2.path, absolutePath), fieldMember = props2.members.find(
      (member) => member.kind == "field" && childPath[0] === member.name
    );
    if (!fieldMember) {
      const fieldName = typeof childPath[0] == "string" ? childPath[0] : JSON.stringify(childPath[0]);
      return /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("form.error.field-not-found", { fieldName }) });
    }
    return /* @__PURE__ */ jsxRuntime.jsx(
      MemberField,
      {
        member: fieldMember,
        renderAnnotation,
        renderBlock,
        renderInput,
        renderInlineBlock,
        renderField,
        renderItem,
        renderPreview: destinationRenderPreview
      }
    );
  }
  throw new Error("FormInput can only be used with arrays or objects");
}), PortableTextMemberItemsContext = React.createContext([]);
function PortableTextMemberItemsProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(PortableTextMemberItemsContext.Provider, { value: props2.memberItems, children: props2.children });
}
function usePortableTextMemberItem(key) {
  const ctx = React.useContext(PortableTextMemberItemsContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx.find((m) => m.key === key);
}
function usePortableTextMemberItems() {
  const ctx = React.useContext(PortableTextMemberItemsContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function usePortableTextMemberItemsFromProps(props2) {
  const portableTextMemberItemsRef = React.useRef([]);
  return reconcilePortableTextMembers({ props: props2, ref: portableTextMemberItemsRef }), portableTextMemberItemsRef.current;
}
const reconcilePortableTextMembers = ({
  props: props2,
  ref
}) => {
  var _a2;
  const result = [], {
    members,
    path,
    schemaType,
    renderAnnotation,
    renderField,
    renderBlock,
    renderInput,
    renderItem,
    renderInlineBlock,
    renderPreview
  } = props2;
  for (const member of members)
    if (member.kind === "item")
      if (!isBlockType(member.item.schemaType))
        result.push({ kind: "objectBlock", member, node: member.item });
      else {
        (member.item.validation.length > 0 || member.item.changed || (_a2 = member.item.presence) != null && _a2.length || member.open || member.item.focusPath.length) && result.push({ kind: "textBlock", member, node: member.item });
        const childrenField = member.item.members.find(
          (f) => f.kind === "field" && f.name === "children"
        );
        if (childrenField && childrenField.kind === "field" && isMemberArrayOfObjects(childrenField))
          for (const child of childrenField.field.members)
            child.kind === "item" && child.item.schemaType.name !== "span" && result.push({ kind: "inlineObject", member: child, node: child.item });
        const markDefArrayMember = member.item.members.filter(isArrayOfObjectsFieldMember).find((f) => f.name === "markDefs");
        if (markDefArrayMember)
          for (const child of markDefArrayMember.field.members)
            child.kind === "item" && child.item.schemaType.jsonType === "object" && result.push({
              kind: "annotation",
              member: child,
              node: child.item
            });
      }
  const items = result.map((item) => {
    const key = pathToString$1(item.node.path), existingItem = ref.current.find((refItem) => refItem.key === key), isObject2 = item.kind !== "textBlock";
    let input = null;
    if (isObject2 && item.member !== (existingItem == null ? void 0 : existingItem.member) || item.node !== (existingItem == null ? void 0 : existingItem.node)) {
      const inputProps = {
        absolutePath: PathUtils.pathFor(item.node.path),
        includeField: !1,
        members,
        path: PathUtils.pathFor(path),
        renderAnnotation,
        renderBlock,
        renderField,
        renderInlineBlock,
        renderInput,
        renderItem,
        renderPreview,
        schemaType
      };
      input = /* @__PURE__ */ jsxRuntime.jsx(FormInput, { ...inputProps });
    }
    return existingItem ? (existingItem.member = item.member, existingItem.node = item.node, existingItem.input = input || existingItem.input, existingItem) : {
      kind: item.kind,
      key,
      member: item.member,
      node: item.node,
      elementRef: React.createRef(),
      input
    };
  });
  return ref.current = items, items;
}, Root$m = styled__default.default.span(
  (props2) => {
    var _a2, _b, _c, _d;
    const { $toneKey = "default", theme: theme2 } = props2;
    return styled.css`
      text-decoration: none;
      display: inline;
      background-color: ${(_a2 = theme2.sanity.color.selectable) == null ? void 0 : _a2[$toneKey].enabled.bg};
      border-bottom: 1px dashed ${(_b = theme2.sanity.color.selectable) == null ? void 0 : _b[$toneKey].enabled.fg};
      color: ${(_c = theme2.sanity.color.selectable) == null ? void 0 : _c[$toneKey].enabled.fg};

      &[data-link] {
        border-bottom: 1px solid ${(_d = theme2.sanity.color.selectable) == null ? void 0 : _d[$toneKey].enabled.fg};
      }

      &[data-custom-markers] {
        background-color: ${theme2.sanity.color.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
      }

      &[data-warning] {
        background-color: ${theme2.sanity.color.muted.caution.hovered.bg};
      }

      &[data-error] {
        background-color: ${theme2.sanity.color.muted.critical.hovered.bg};
      }
    `;
  }
), TooltipBox$3 = styled__default.default(ui.Box).attrs({ forwardedAs: "span" })`
  max-width: 250px;
`, POPOVER_FALLBACK_PLACEMENTS$2 = ["top", "bottom"];
function AnnotationToolbarPopover(props2) {
  const {
    annotationOpen,
    floatingBoundary,
    onOpen,
    onRemove,
    referenceBoundary,
    referenceElement,
    selected,
    title
  } = props2, [renderPopover, setRenderPopover] = React.useState(!1), [popoverOpen, setPopoverOpen] = React.useState(!1), [cursorRect, setCursorRect] = React.useState(null), rangeRef = React.useRef(null), { sanity } = ui.useTheme(), { t: t2 } = useTranslation(), popoverRef = React.useRef(null), popoverScheme = sanity.color.dark ? "light" : "dark", handleOpenPopover = React.useCallback((open) => {
    setRenderPopover(open), open ? React.startTransition(() => {
      setPopoverOpen(open);
    }) : setPopoverOpen(open);
  }, []), cursorElement = React.useMemo(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        popoverOpen && event.key === "Escape" && handleOpenPopover(!1);
      },
      [handleOpenPopover, popoverOpen]
    )
  );
  const handleSelectionChange = React.useCallback(() => {
    if (annotationOpen) {
      handleOpenPopover(!1), setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0)
      return;
    const range2 = sel.getRangeAt(0);
    if (!(referenceElement != null && referenceElement.contains(range2.commonAncestorContainer))) {
      handleOpenPopover(!1), setCursorRect(null);
      return;
    }
    const rect = range2 == null ? void 0 : range2.getBoundingClientRect();
    rect && (setCursorRect(rect), handleOpenPopover(!0));
  }, [annotationOpen, referenceElement, handleOpenPopover]);
  React.useEffect(() => (document.addEventListener("selectionchange", handleSelectionChange, { passive: !0 }), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]);
  const handleEditButtonClicked = React.useCallback(() => {
    handleOpenPopover(!1), onOpen();
  }, [onOpen, handleOpenPopover]);
  React.useEffect(() => {
    !annotationOpen && selected && cursorRect && handleOpenPopover(!0), annotationOpen && handleOpenPopover(!1);
  }, [annotationOpen, selected, cursorRect, handleOpenPopover]);
  const handleRemoveButtonClicked = React.useCallback(() => {
    handleOpenPopover(!1), onRemove();
  }, [onRemove, handleOpenPopover]), handleScroll = React.useCallback(() => {
    rangeRef.current && setCursorRect(rangeRef.current.getBoundingClientRect());
  }, []);
  return React.useEffect(() => {
    const sel = window.getSelection();
    sel && sel.rangeCount > 0 && (rangeRef.current = sel.getRangeAt(0));
  }, [popoverOpen]), React.useEffect(() => {
    if (popoverOpen && referenceBoundary)
      return referenceBoundary.addEventListener("scroll", handleScroll), () => referenceBoundary.removeEventListener("scroll", handleScroll);
    if (popoverOpen)
      return referenceBoundary == null || referenceBoundary.addEventListener("scroll", handleScroll), () => {
        referenceBoundary == null || referenceBoundary.removeEventListener("scroll", handleScroll);
      };
  }, [popoverOpen, referenceBoundary, handleScroll]), renderPopover ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      open: popoverOpen,
      floatingBoundary,
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, "data-testid": "annotation-toolbar-popover", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title }) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            "aria-label": t2("inputs.portable-text.action.edit-annotation-aria-label"),
            icon: icons.EditIcon,
            mode: "bleed",
            onClick: handleEditButtonClicked,
            tabIndex: 0,
            tooltipProps: null
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            "aria-label": t2("inputs.portable-text.action.remove-annotation-aria-label"),
            icon: icons.TrashIcon,
            mode: "bleed",
            onClick: handleRemoveButtonClicked,
            tabIndex: 0,
            tone: "critical",
            tooltipProps: null
          }
        )
      ] }) }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      ref: popoverRef,
      referenceBoundary,
      referenceElement: cursorElement,
      scheme: popoverScheme
    }
  ) : null;
}
const parseResponsiveWidth = (value) => Array.isArray(value) ? value.flatMap(parseResponsiveWidth) : typeof value == "number" ? [value] : value === "auto" ? ["auto"] : [], parseModalType = (value) => value === "dialog" || value === "popover" ? value : void 0;
function _getModalOption(schemaType) {
  var _a2;
  const raw = (_a2 = schemaType.options) == null ? void 0 : _a2.modal;
  return typeof raw == "object" && raw !== null ? {
    type: parseModalType(raw.type),
    width: parseResponsiveWidth(raw.width)
  } : void 0;
}
const VirtualizerScrollInstanceContext = React.createContext(
  null
);
function useVirtualizerScrollInstance() {
  const ref = React.useContext(VirtualizerScrollInstanceContext);
  if (!ref)
    throw new Error("VirtualizerScrollInstance: missing context value");
  return ref;
}
function VirtualizerScrollInstanceProvider(props2) {
  const { scrollElement, containerElement } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    VirtualizerScrollInstanceContext.Provider,
    {
      value: { scrollElement, containerElement },
      children: props2.children
    }
  );
}
function DefaultEditDialog(props2) {
  const { onClose, children, title, width = 1, autoFocus } = props2, dialogId = React.useId(), [contentElement, setContentElement] = React.useState(null), containerElement = React.useRef(null);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      header: title,
      id: dialogId,
      onClickOutside: onClose,
      onClose,
      portal: "default",
      width,
      contentRef: setContentElement,
      "data-testid": "default-edit-object-dialog",
      __unstable_autoFocus: autoFocus,
      children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: [0, 0, 1, 0], children: /* @__PURE__ */ jsxRuntime.jsx(
        VirtualizerScrollInstanceProvider,
        {
          scrollElement: contentElement,
          containerElement,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ref: containerElement, children })
        }
      ) })
    }
  );
}
const RootPopover = styled__default.default(getJsonStream.Popover)`
  & > div {
    overflow: hidden;
    overflow: clip;
  }
`, ContentScrollerBox = styled__default.default(ui.Box)`
  /* Prevent overflow caused by change indicator */
  overflow-x: hidden;
  overflow-y: auto;
`, ContentHeaderBox = styled__default.default(ui.Box)`
  box-shadow: 0 1px 0 var(--card-shadow-outline-color);
  position: relative;
  z-index: 10;
  min-height: auto;
`, POPOVER_FALLBACK_PLACEMENTS$1 = ["top", "bottom"];
function PopoverEditDialog(props2) {
  const { floatingBoundary, referenceBoundary, referenceElement, width = 1 } = props2, [open, setOpen] = React.useState(!1);
  return React.useEffect(() => {
    setOpen(!0);
  }, []), /* @__PURE__ */ jsxRuntime.jsx(
    RootPopover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(Content, { ...props2 }),
      constrainSize: !0,
      "data-testid": "popover-edit-dialog",
      "data-ui": "PopoverEditDialog",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1,
      floatingBoundary,
      open,
      overflow: "auto",
      placement: "bottom",
      portal: "default",
      preventOverflow: !0,
      referenceBoundary,
      referenceElement,
      width
    }
  );
}
function Content(props2) {
  const { onClose, referenceBoundary, referenceElement, title, autoFocus } = props2;
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        event.key === "Escape" && onClose();
      },
      [onClose]
    )
  ), ui.useClickOutside(onClose, referenceElement ? [referenceElement] : [], referenceBoundary);
  const [contentElement, setContentElement] = React.useState(null), containerElement = React.useRef(null);
  return /* @__PURE__ */ jsxRuntime.jsx(
    VirtualizerScrollInstanceProvider,
    {
      scrollElement: contentElement,
      containerElement,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { ref: containerElement, direction: "column", height: "fill", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ContentHeaderBox, { flex: "none", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: title }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              autoFocus: !!autoFocus,
              icon: icons.CloseIcon,
              mode: "bleed",
              onClick: onClose,
              tooltipProps: { content: "Close" }
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ContentScrollerBox, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: [0, 0, 1, 0], children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, ref: setContentElement, children: props2.children }) }) })
      ] })
    }
  );
}
function ObjectEditModal(props2) {
  const {
    autoFocus,
    defaultType,
    floatingBoundary,
    onClose,
    referenceBoundary,
    referenceElement,
    schemaType
  } = props2, { t: t2 } = useTranslation(), schemaModalOption = React.useMemo(() => _getModalOption(schemaType), [schemaType]), modalType = (schemaModalOption == null ? void 0 : schemaModalOption.type) || defaultType, schemaTypeTitle = schemaType.i18nTitleKey ? t2(schemaType.i18nTitleKey) : schemaType.title || schemaType.name, modalTitle = t2("inputs.portable-text.annotation-editor.title", {
    schemaType: schemaTypeTitle
  }), handleClose = React.useCallback(() => {
    onClose();
  }, [onClose]), modalWidth = schemaModalOption == null ? void 0 : schemaModalOption.width;
  return modalType === "popover" ? /* @__PURE__ */ jsxRuntime.jsx(
    PopoverEditDialog,
    {
      autoFocus,
      floatingBoundary,
      onClose: handleClose,
      referenceBoundary,
      referenceElement,
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: modalTitle }),
      width: modalWidth,
      children: props2.children
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    DefaultEditDialog,
    {
      onClose: handleClose,
      title: modalTitle,
      width: modalWidth,
      autoFocus,
      children: props2.children
    }
  );
}
function Annotation(props2) {
  var _a2;
  const {
    children,
    editorNodeFocused,
    floatingBoundary,
    focused,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    renderAnnotation,
    renderBlock,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { Markers = DefaultMarkers } = useFormBuilder().__internal.components, editor2 = portableTextEditor.usePortableTextEditor(), markDefPath = React.useMemo(
    () => path.slice(0, path.length - 2).concat(["markDefs", { _key: value._key }]),
    [path, value._key]
  ), [spanElement, setSpanElement] = React.useState(null), spanPath = React.useMemo(() => path.slice(path.length - 3, path.length), [path]), memberItem = usePortableTextMemberItem(pathToString$1(markDefPath)), { validation: validation2 } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), markers = usePortableTextMarkers(path), text = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsx("span", { "data-annotation": "", children }), [children]), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onPathFocus(memberItem.node.focusPath), onItemOpen(memberItem.node.path));
  }, [editor2, memberItem, onItemOpen, onPathFocus]), onClose = React.useCallback(() => {
    onItemClose();
    const sel = portableTextEditor.PortableTextEditor.getSelection(editor2), focusOffset = (sel == null ? void 0 : sel.focus.path) && PathUtils.isEqual(sel.focus.path, spanPath) && sel.focus.offset, anchorOffset = (sel == null ? void 0 : sel.anchor.path) && PathUtils.isEqual(sel.anchor.path, spanPath) && sel.anchor.offset;
    portableTextEditor.PortableTextEditor.select(editor2, {
      anchor: { path: spanPath, offset: anchorOffset || 0 },
      focus: { path: spanPath, offset: focusOffset || 0 }
    }), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2, spanPath, onItemClose]), onRemove = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.removeAnnotation(editor2, schemaType), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2, schemaType]), markersToolTip = React.useMemo(
    () => validation2.length > 0 || markers.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Tooltip,
      {
        placement: "bottom",
        portal: "default",
        content: /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$3, { children: /* @__PURE__ */ jsxRuntime.jsx(
          Markers,
          {
            markers,
            renderCustomMarkers,
            validation: validation2
          }
        ) }),
        children: text
      }
    ) : void 0,
    [Markers, markers, renderCustomMarkers, text, validation2]
  ), presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b, referenceElement = spanElement, componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement,
      __unstable_textElementFocus: editorNodeFocused,
      // Is there focus on the related text element for this object?
      children: input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      parentSchemaType: editor2.schemaTypes.block,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderPreview,
      renderItem,
      renderDefault: DefaultAnnotationComponent,
      schemaType,
      selected,
      textElement: markersToolTip || text,
      validation: validation2,
      value
    }),
    [
      editor2.schemaTypes.block,
      editorNodeFocused,
      floatingBoundary,
      focused,
      input,
      isOpen,
      markers,
      markersToolTip,
      nodePath,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      readOnly,
      referenceBoundary,
      referenceElement,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      rootPresence,
      schemaType,
      selected,
      text,
      validation2,
      value
    ]
  ), CustomComponent = (_a2 = schemaType.components) == null ? void 0 : _a2.annotation, setRef = React.useCallback(
    (elm) => {
      memberItem != null && memberItem.elementRef && (memberItem.elementRef.current = elm), setSpanElement(elm);
    },
    [memberItem]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx("span", { ref: setRef, style: void 0, children: CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultAnnotationComponent, { ...componentProps }) }),
    [CustomComponent, componentProps, setRef]
  );
}
const DefaultAnnotationComponent = (props2) => {
  const {
    __unstable_floatingBoundary: floatingBoundary,
    __unstable_referenceBoundary: referenceBoundary,
    __unstable_referenceElement: referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    selected,
    schemaType,
    textElement,
    validation: validation2
  } = props2, isLink = schemaType.name === "link", hasError = validation2.some((v) => v.level === "error"), hasWarning = validation2.some((v) => v.level === "warning"), hasMarkers = markers.length > 0, { t: t2 } = useTranslation(), toneKey = React.useMemo(() => hasError ? "critical" : hasWarning ? "caution" : isLink ? "primary" : "default", [isLink, hasError, hasWarning]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$m,
    {
      $toneKey: toneKey,
      "aria-label": t2("inputs.portable-text.annotation-aria-label"),
      "data-link": isLink ? "" : void 0,
      "data-error": hasError ? "" : void 0,
      "data-warning": hasWarning ? "" : void 0,
      "data-markers": hasMarkers || void 0,
      onClick: readOnly ? onOpen : void 0,
      children: [
        textElement,
        /* @__PURE__ */ jsxRuntime.jsx(
          AnnotationToolbarPopover,
          {
            annotationOpen: open,
            floatingBoundary,
            onOpen,
            onRemove,
            referenceBoundary,
            referenceElement,
            selected,
            title: schemaType.i18nTitleKey ? t2(schemaType.i18nTitleKey) : schemaType.title || schemaType.name
          }
        ),
        open && /* @__PURE__ */ jsxRuntime.jsx(
          ObjectEditModal,
          {
            defaultType: "popover",
            floatingBoundary,
            onClose,
            autoFocus: focused,
            referenceBoundary,
            referenceElement,
            schemaType,
            children
          }
        )
      ]
    }
  );
}, Context = React.createContext({});
function useReferenceInputOptions() {
  return React.useContext(Context);
}
function ReferenceInputOptionsProvider(props2) {
  const {
    children,
    activePath,
    EditReferenceLinkComponent,
    onEditReference,
    initialValueTemplateItems
  } = props2, contextValue = React.useMemo(
    () => ({
      activePath,
      EditReferenceLinkComponent,
      onEditReference,
      initialValueTemplateItems
    }),
    [activePath, EditReferenceLinkComponent, onEditReference, initialValueTemplateItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Context.Provider, { value: contextValue, children });
}
const ReviewChangesContext = React.createContext(null), DocumentIdContext = React.createContext(null);
function DocumentIdProvider(props2) {
  const value = React.useMemo(() => ({ id: props2.id }), [props2.id]);
  return /* @__PURE__ */ jsxRuntime.jsx(DocumentIdContext.Provider, { value, children: props2.children });
}
function useGivenDocumentId() {
  const ctx = React.useContext(DocumentIdContext);
  if (!ctx)
    throw new Error("useDocumentId must be used within a DocumentIdProvider");
  return ctx.id;
}
function usePublishedId() {
  return getPublishedId(useGivenDocumentId());
}
function useScrollIntoViewOnFocusWithin(elementRef, hasFocusWithin) {
  return useDidUpdate(
    hasFocusWithin,
    React.useCallback(
      (hadFocus, hasFocus) => {
        elementRef.current && !hadFocus && hasFocus && scrollIntoView__default.default(elementRef.current, { scrollMode: "always" });
      },
      [elementRef]
    )
  );
}
const Root$l = styled__default.default(ui.Text)`
  &[data-status='edited'] {
    --card-icon-color: var(--card-badge-caution-dot-color);
  }
  &[data-status='unpublished'] {
    --card-icon-color: var(--card-badge-default-dot-color);
    opacity: 0.5 !important;
  }
`;
function DocumentStatusIndicator({ draft, published }) {
  const $draft = !!draft, $published = !!published, status = React.useMemo(() => $draft && !$published ? "unpublished" : "edited", [$draft, $published]);
  return !$draft && !$published || !$draft && $published ? null : /* @__PURE__ */ jsxRuntime.jsx(Root$l, { "data-status": status, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DotIcon, {}) });
}
function ReferencePreview(props2) {
  var _a2, _b;
  const { id: id2, layout, preview, refType, renderPreview, showTypeLabel } = props2, documentPresence = useDocumentPresence(id2), previewId = ((_a2 = preview.draft) == null ? void 0 : _a2._id) || ((_b = preview.published) == null ? void 0 : _b._id) || // note: during publish of the referenced document we might have both a missing draft and a missing published version
  // this happens because the preview system tries to optimistically re-fetch as soon as it sees a mutation, but
  // when publishing, the draft is deleted, and therefore both the draft and the published may be missing for a brief
  // moment before the published version appears. In this case, it's safe to fallback to the given id, which is always
  // the published id
  id2, previewStub = React.useMemo(
    () => ({ _id: previewId, _type: refType.name }),
    [previewId, refType.name]
  ), { draft, published } = preview, previewProps = React.useMemo(
    () => ({
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 3, children: [
        showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType.title }),
        documentPresence && documentPresence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(DocumentPreviewPresence, { presence: documentPresence }),
        /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusIndicator, { draft: preview.draft, published: preview.published })
      ] }) }),
      layout,
      schemaType: refType,
      tooltip: /* @__PURE__ */ jsxRuntime.jsx(DocumentStatus, { draft, published }),
      value: previewStub
    }),
    [
      documentPresence,
      draft,
      layout,
      preview.draft,
      preview.published,
      previewStub,
      published,
      refType,
      showTypeLabel
    ]
  );
  return renderPreview(previewProps);
}
function PreviewReferenceValue$1(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const { layout = "default", referenceInfo, renderPreview, type, value, showTypeLabel } = props2, { t: t2 } = useTranslation();
  if (referenceInfo.isLoading || referenceInfo.error)
    return /* @__PURE__ */ jsxRuntime.jsx(SanityDefaultPreview, { isPlaceholder: !0, layout });
  if (((_a2 = referenceInfo.result) == null ? void 0 : _a2.availability.reason) === "NOT_FOUND" && value._strengthenOnPublish) {
    const refType2 = type.to.find((toType) => {
      var _a22;
      return toType.name === ((_a22 = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _a22.type);
    });
    if (!refType2)
      return /* @__PURE__ */ jsxRuntime.jsx(
        InvalidType,
        {
          documentId: value._ref,
          actualType: (_b = value._strengthenOnPublish) == null ? void 0 : _b.type,
          declaredTypes: type.to.map((toType) => toType.name)
        }
      );
    const stub = (_c = value._strengthenOnPublish) != null && _c.type ? {
      _id: value._ref,
      _type: (_d = value._strengthenOnPublish) == null ? void 0 : _d.type
    } : value;
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: renderPreview({
        layout,
        schemaType: refType2,
        value: stub,
        skipVisibilityCheck: !0
      }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 4, children: showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType2.title }) }) })
    ] });
  }
  const availability = referenceInfo.result.availability, notFound = availability.reason === "NOT_FOUND", insufficientPermissions = availability.reason === "PERMISSION_DENIED";
  if (insufficientPermissions || notFound)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.document-unavailable-title") }) }) }) }),
      insufficientPermissions || notFound ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Tooltip,
        {
          portal: !0,
          content: notFound ? /* @__PURE__ */ jsxRuntime.jsx(
            UnavailableMessage,
            {
              title: t2("inputs.reference.error.nonexistent-document-title"),
              icon: icons.HelpCircleIcon,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  i18nKey: "inputs.reference.error.nonexistent-document-description",
                  t: t2,
                  values: { documentId: value._ref }
                }
              )
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(
            UnavailableMessage,
            {
              title: t2("inputs.reference.error.missing-read-permissions-title"),
              icon: icons.AccessDeniedIcon,
              children: t2("inputs.reference.error.missing-read-permissions-description")
            }
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) })
        }
      ) }) : null
    ] });
  const refTypeName = (_e = referenceInfo.result) == null ? void 0 : _e.type, refType = type.to.find((toType) => toType.name === refTypeName);
  return refType ? /* @__PURE__ */ jsxRuntime.jsx(
    ReferencePreview,
    {
      id: value._ref,
      layout,
      preview: (_f = referenceInfo.result) == null ? void 0 : _f.preview,
      refType,
      renderPreview,
      showTypeLabel
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    InvalidType,
    {
      documentId: value._ref,
      actualType: refTypeName || "<unknown>",
      declaredTypes: type.to.map((toType) => toType.name)
    }
  );
}
function UnavailableMessage(props2) {
  const Icon = props2.icon;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Icon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: props2.title }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: props2.children }) })
    ] })
  ] });
}
function InvalidType({
  declaredTypes,
  documentId,
  actualType
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.invalid-type-title") }) }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Tooltip,
      {
        portal: !0,
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.error.invalid-type-description",
            values: { documentId, actualType },
            components: {
              AllowedTypes: () => /* @__PURE__ */ jsxRuntime.jsx(HumanizedList, { values: declaredTypes })
            }
          }
        ) }) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) }) })
      }
    ) })
  ] });
}
function HumanizedList(props2) {
  const parts = useListFormat({ type: "disjunction" }).formatToParts(props2.values);
  return /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: parts.map(
    (segment) => segment.type === "element" ? /* @__PURE__ */ jsxRuntime.jsx("code", { children: segment.value }, segment.value) : segment.value
  ) });
}
const STATUS_TONES = {
  warning: "caution",
  error: "critical",
  info: "positive"
}, STATUS_ICONS = {
  warning: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
  error: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}),
  info: /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {})
};
function AlertStrip(props2) {
  const { children, status = "warning", title, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, tone: STATUS_TONES[status], ...rest, "data-ui": "Alert", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 1, children: children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Details, { icon: STATUS_ICONS[status], title, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 3, marginTop: 3, children }) }) }) }) });
}
function ReferenceFinalizeAlertStrip({
  schemaType,
  handleRemoveStrengthenOnPublish
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2(
        schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-title" : "inputs.reference.incomplete-reference.strengthen-action-title"
      ),
      status: "info",
      "data-testid": "alert-reference-published",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-description" : "inputs.reference.incomplete-reference.strengthen-action-description"
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "ghost",
            onClick: handleRemoveStrengthenOnPublish,
            size: "large",
            text: t2("inputs.reference.incomplete-reference.strengthen-button-label"),
            tone: "positive"
          }
        )
      ] })
    }
  );
}
const StyledCard$2 = styled__default.default(ui.Card)`
  /* this is a hack to avoid layout jumps while previews are loading
     there's probably better ways of solving this */
  min-height: 33px;
  position: relative;

  /* TextWithTone uses its own logic to set color, and we therefore need */
  /* to override this logic in order to set the correct color in different states */
  &[data-selected],
  &[data-pressed],
  &:active {
    [data-ui='TextWithTone'] {
      color: inherit;
    }
  }
`, ReferenceLinkCard = React.forwardRef(function(props2, ref) {
  const { as, documentId, documentType, ...cardProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledCard$2,
    {
      ...cardProps,
      ...documentId && documentType && {
        // this will make @sanity/ui style it as a link
        "data-as": "a",
        // this determines the actual tag inserted into the DOM (either a HTML element or a component)
        forwardedAs: as,
        documentId,
        documentType
      },
      "data-ui": "ReferenceLinkCard",
      ref
    }
  );
});
function ReferenceMetadataLoadErrorAlertStrip({
  errorMessage,
  onHandleRetry
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2("inputs.reference.metadata-error.title"),
      status: "warning",
      "data-testid": "alert-reference-info-failed",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: errorMessage }),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "ghost",
            onClick: onHandleRetry,
            size: "large",
            text: t2("inputs.reference.metadata-error.retry-button-label"),
            tone: "primary"
          }
        )
      ] })
    }
  );
}
function ReferenceStrengthMismatchAlertStrip({
  actualStrength,
  handleFixStrengthMismatch
}) {
  const shouldBe = actualStrength === "weak" ? "strong" : "weak", { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2("inputs.reference.strength-mismatch.title"),
      status: "warning",
      "data-testid": "alert-reference-strength-mismatch",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: actualStrength === "weak" ? "inputs.reference.strength-mismatch.is-weak-description" : "inputs.reference.strength-mismatch.is-strong-description"
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2(
          shouldBe === "weak" ? "inputs.reference.strength-mismatch.is-strong-consquences" : "inputs.reference.strength-mismatch.is-weak-consquences"
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "ghost",
            onClick: handleFixStrengthMismatch,
            size: "large",
            text: t2(
              shouldBe === "weak" ? "inputs.reference.strength-mismatch.weaken-button-label" : "inputs.reference.strength-mismatch.strengthen-button-label"
            ),
            tone: "caution"
          }
        )
      ] })
    }
  );
}
const noop$1 = () => {
}, INITIAL_LOADING_STATE$3 = {
  isLoading: !0,
  result: void 0,
  error: void 0,
  retry: noop$1
}, EMPTY_STATE$1 = {
  isLoading: !1,
  result: void 0,
  error: void 0,
  retry: noop$1
};
function useReferenceInfo$1(id2, getReferenceInfo2) {
  const msgSubject = React.useMemo(() => new rxjs.Subject(), []), msg$ = React.useMemo(() => msgSubject.asObservable(), [msgSubject]), retry = React.useCallback(() => {
    msgSubject.next({ type: "retry" });
  }, [msgSubject]), referenceInfo = reactRx.useMemoObservable(
    () => rxjs.concat(rxjs.of(null), msg$).pipe(
      operators.map(() => id2),
      operators.concatMap(
        (refId) => refId ? getReferenceInfo2(refId).pipe(
          operators.map((result) => ({
            isLoading: !1,
            result,
            error: void 0,
            retry
          })),
          operators.startWith(INITIAL_LOADING_STATE$3),
          operators.catchError((err) => (console.error(err), rxjs.of({ isLoading: !1, result: void 0, error: err, retry })))
        ) : rxjs.of(EMPTY_STATE$1)
      )
    ),
    [getReferenceInfo2, id2, msg$, retry],
    INITIAL_LOADING_STATE$3
  ), previousId = usePrevious(id2, id2);
  return id2 && previousId !== id2 ? INITIAL_LOADING_STATE$3 : referenceInfo;
}
const FormValueContext = React.createContext(null);
function FormValueProvider(props2) {
  const value = React.useMemo(() => ({ value: props2.value }), [props2.value]);
  return /* @__PURE__ */ jsxRuntime.jsx(FormValueContext.Provider, { value, children: props2.children });
}
function useFormValue(path) {
  const uniquePath = PathUtils.pathFor(path), ctx = React.useContext(FormValueContext);
  if (!ctx)
    throw new Error("useFormValue must be used within a FormValueProvider");
  return getValueAtPath(ctx == null ? void 0 : ctx.value, uniquePath);
}
const CACHE = /* @__PURE__ */ new WeakMap(), PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
}, BASE_WEIGHTS = {
  _id: { weight: 1, type: "string" },
  _type: { weight: 1, type: "string" }
}, builtInObjectTypes = ["reference", "crossDatasetReference"], getTypeChain$2 = (type) => type ? [type, ...getTypeChain$2(type.type)] : [], isPtField = (type) => (type == null ? void 0 : type.jsonType) === "array" && type.of.some((arrType) => getTypeChain$2(arrType).some(({ name }) => name === "block")), isStringField = (schemaType) => getTypeChain$2(schemaType).some((type) => type.name === "string"), isSearchConfiguration = (options) => isRecord$4(options) && "search" in options && isRecord$4(options.search);
function isSchemaType(input) {
  return typeof input < "u" && "name" in input;
}
function getLeafWeights(schemaType, maxDepth, getWeight) {
  function traverse2(type, path, depth) {
    if (!type)
      return [];
    if (depth > maxDepth)
      return [];
    const typeChain = getTypeChain$2(type);
    if (isStringField(type) || isPtField(type)) {
      const weight = getWeight(type, path);
      return typeof weight != "number" ? [] : [{ path, weight, type: isPtField(type) ? "pt" : "string" }];
    }
    const results = [], objectTypes = typeChain.filter(
      (t2) => {
        var _a2;
        return t2.jsonType === "object" && !!((_a2 = t2.fields) != null && _a2.length) && !builtInObjectTypes.includes(t2.name);
      }
    );
    for (const objectType of objectTypes)
      for (const field of objectType.fields) {
        const nextPath = PathUtils.toString([path, field.name].filter(Boolean));
        results.push(...traverse2(field.type, nextPath, depth + 1));
      }
    const arrayTypes = typeChain.filter(
      (t2) => {
        var _a2;
        return t2.jsonType === "array" && !!((_a2 = t2.of) != null && _a2.length);
      }
    );
    for (const arrayType of arrayTypes)
      for (const arrayItemType of arrayType.of) {
        const nextPath = `${path}[]`;
        results.push(...traverse2(arrayItemType, nextPath, depth + 1));
      }
    return results;
  }
  return isSchemaType(schemaType) ? traverse2(schemaType, "", 0).reduce(
    (acc, { path, weight, type }) => (acc[path] = { weight, type, path }, acc),
    {}
  ) : {};
}
const getUserSetWeight = (schemaType) => {
  var _a2;
  const searchOptions = getTypeChain$2(schemaType).map((type) => type.options).find(isSearchConfiguration);
  return typeof ((_a2 = searchOptions == null ? void 0 : searchOptions.search) == null ? void 0 : _a2.weight) == "number" ? searchOptions.search.weight : null;
}, getHiddenWeight = (schemaType) => getTypeChain$2(schemaType).some((type) => type.hidden) ? 0 : null, getDefaultWeights = (schemaType) => {
  var _a2;
  return typeof ((_a2 = getUserSetWeight(schemaType)) != null ? _a2 : getHiddenWeight(schemaType)) == "number" ? null : 1;
}, getPreviewWeights = (schemaType, maxDepth, isCrossDataset) => {
  var _a2;
  const select2 = (_a2 = schemaType == null ? void 0 : schemaType.preview) == null ? void 0 : _a2.select;
  if (!select2)
    return null;
  const selectionKeysBySelectionPath = Object.fromEntries(
    Object.entries(select2).map(([selectionKey, selectionPath]) => [
      // replace indexed paths with `[]`
      // e.g. `arrayOfObjects.0.myField` becomes `arrayOfObjects[].myField`
      selectionPath.replace(/\.\d+/g, "[]"),
      selectionKey
    ])
  ), defaultWeights = getLeafWeights(schemaType, maxDepth, getDefaultWeights), nestedWeightsBySelectionPath = Object.fromEntries(
    Object.entries(defaultWeights).map(([path, { type }]) => ({ path, type })).filter(({ path }) => selectionKeysBySelectionPath[path]).map(({ path, type }) => [
      path,
      {
        type,
        weight: PREVIEW_FIELD_WEIGHT_MAP[selectionKeysBySelectionPath[path]]
      }
    ])
  );
  return isCrossDataset ? Object.fromEntries(
    Object.values(selectionKeysBySelectionPath).map((path) => [
      path,
      {
        path,
        type: "string",
        weight: PREVIEW_FIELD_WEIGHT_MAP[path]
      }
    ])
  ) : getLeafWeights(schemaType, maxDepth, (_, path) => {
    const nested = nestedWeightsBySelectionPath[path];
    return nested ? nested.weight : null;
  });
};
function deriveSearchWeightsFromType({
  schemaType,
  maxDepth,
  isCrossDataset,
  processPaths = (paths) => paths
}) {
  const cached = CACHE.get(schemaType);
  if (cached)
    return cached;
  const userSetWeights = getLeafWeights(schemaType, maxDepth, getUserSetWeight), hiddenWeights = getLeafWeights(schemaType, maxDepth, getHiddenWeight), defaultWeights = getLeafWeights(schemaType, maxDepth, getDefaultWeights), previewWeights = getPreviewWeights(schemaType, maxDepth, isCrossDataset), weights = {
    ...BASE_WEIGHTS,
    ...defaultWeights,
    ...hiddenWeights,
    ...previewWeights,
    ...userSetWeights
  }, result = {
    typeName: isSchemaType(schemaType) ? schemaType.name : schemaType.type,
    paths: processPaths(
      Object.entries(weights).map(([path, { type, weight }]) => ({
        path,
        weight,
        ...type === "pt" && { mapWith: "pt::text" }
      }))
    )
  };
  return CACHE.set(schemaType, result), result;
}
const isDocumentType = (type) => !!(type.type && type.type.name === "document"), isIgnoredType = (type) => type.name.startsWith("sanity.") && type.name !== "sanity.previewUrlSecret", getSearchableTypes = (schema2) => schema2.getTypeNames().map((typeName) => schema2.get(typeName)).filter(isNonNullable$2).filter(isDocumentType).filter((type) => !isIgnoredType(type)), DEFAULT_LIMIT$1 = 1e3;
function normalizeSearchTerms(searchParams, fallbackTypes) {
  return typeof searchParams == "string" ? {
    query: searchParams,
    types: fallbackTypes
  } : {
    ...searchParams,
    types: searchParams.types.length ? searchParams.types : fallbackTypes
  };
}
function optimizeSearchWeights(paths) {
  return paths.filter((path) => path.weight !== 1);
}
function getDocumentTypeConfiguration(searchOptions, searchTerms) {
  return searchTerms.types.map(
    (schemaType) => deriveSearchWeightsFromType({
      schemaType,
      maxDepth: searchOptions.maxDepth || _internal.DEFAULT_MAX_FIELD_DEPTH,
      processPaths: optimizeSearchWeights
    })
  ).filter(({ paths }) => paths.length).reduce((nextTypes, spec) => ({
    ...nextTypes,
    [spec.typeName]: spec.paths.reduce(
      (nextType, { path, weight }) => ({
        ...nextType,
        weights: {
          ...nextType.weights,
          [path]: weight
        }
      }),
      {}
    )
  }), {});
}
function getOrder(sort = []) {
  return sort.map(
    ({ field, direction }) => ({
      attribute: field,
      direction
    }),
    {}
  );
}
const createTextSearch = (typesFromFactory, client2, factoryOptions) => function(searchParams, searchOptions = {}) {
  var _a2;
  const searchTerms = normalizeSearchTerms(searchParams, typesFromFactory), filters = [
    "_type in $__types",
    searchOptions.includeDrafts === !1 && "!(_id in path('drafts.**'))",
    factoryOptions.filter ? `(${factoryOptions.filter})` : !1,
    searchTerms.filter ? `(${searchTerms.filter})` : !1
  ].filter((baseFilter) => !!baseFilter), textSearchParams = {
    query: { string: searchTerms.query },
    filter: filters.join(" && "),
    params: {
      __types: searchTerms.types.map((type) => "name" in type ? type.name : type.type),
      ...factoryOptions.params,
      ...searchTerms.params
    },
    types: getDocumentTypeConfiguration(searchOptions, searchTerms),
    order: getOrder(searchOptions.sort),
    includeAttributes: ["_id", "_type"],
    fromCursor: searchOptions.cursor,
    limit: (_a2 = searchOptions.limit) != null ? _a2 : DEFAULT_LIMIT$1
  };
  return client2.observable.request({
    uri: `/data/textsearch/${client2.config().dataset}`,
    method: "POST",
    json: !0,
    body: textSearchParams,
    tag: factoryOptions.tag
  }).pipe(
    operators.map((response) => {
      let documents = response.hits.map((hit) => hit.attributes);
      return factoryOptions.unique && (documents = removeDupes(documents)), {
        type: "text",
        hits: documents.map((hit) => ({ hit })),
        nextCursor: response.nextCursor
      };
    })
  );
}, calculateScore = (searchTerms, value) => {
  const { phrases: uniqueSearchPhrases, words: uniqueSearchWords } = partitionAndSanitizeSearchTerms(searchTerms), [phraseScore, phraseWhy] = calculatePhraseScore(uniqueSearchPhrases, value), [wordScore, wordWhy] = calculateWordScore(uniqueSearchWords, value);
  return [phraseScore + wordScore, [wordWhy, phraseWhy].join(", ")];
}, stringify = (value) => typeof value == "string" ? value : JSON.stringify(value);
function applyWeights(searchSpec, hits, terms = []) {
  const specByType = keyBy__default.default(searchSpec, (spec) => spec.typeName);
  return hits.map((hit, index) => {
    var _a2;
    const stories = (_a2 = specByType[hit._type].paths || []) == null ? void 0 : _a2.map((pathSpec, idx) => {
      const value = stringify(hit[`w${idx}`]);
      if (!value)
        return { path: pathSpec.path, score: 0, why: "No match" };
      const [score, why] = calculateScore(terms, value);
      return {
        path: pathSpec.path,
        score: score * pathSpec.weight,
        why: `${why} (*${pathSpec.weight})`
      };
    }), totalScore = stories.reduce((acc, rank) => acc + rank.score, 0);
    return { hit, resultIndex: hits.length - index, score: totalScore, stories };
  });
}
function calculatePhraseScore(uniqueSearchPhrases, value) {
  const sanitizedValue = value.toLowerCase().trim();
  let fieldScore = 0, matchCount = 0;
  return uniqueSearchPhrases.forEach((term) => {
    sanitizedValue.includes(term) && (fieldScore += term.length / sanitizedValue.length, matchCount += term.length);
  }), fieldScore === 1 ? [1, "[Phrase] Exact match"] : [fieldScore / 2, `[Phrase] Matched ${matchCount} of ${sanitizedValue.length} characters`];
}
function calculateWordScore(uniqueSearchTerms, value) {
  const uniqueValueTerms = uniq__default.default(compact__default.default(words__default.default(toLower__default.default(value)))), matches = intersection__default.default(uniqueSearchTerms, uniqueValueTerms), all = union__default.default(uniqueValueTerms, uniqueSearchTerms), fieldScore = matches.length / all.length;
  return fieldScore === 1 ? [1, "[Word] Exact match"] : [
    fieldScore / 2,
    `[Word] Matched ${matches.length} of ${all.length} terms: [${matches.join(", ")}]`
  ];
}
function partitionAndSanitizeSearchTerms(searchTerms) {
  const uniqueSearchTerms = uniq__default.default(searchTerms.map(toLower__default.default)), [searchPhrases, searchWords] = partition__default.default(uniqueSearchTerms, (term) => /^".*"$/.test(term));
  return {
    phrases: uniq__default.default(searchPhrases).map(toLower__default.default).map(stripWrappingQuotes),
    //
    words: uniq__default.default(searchWords.map(toLower__default.default))
  };
}
function stripWrappingQuotes(str) {
  return str.replace(/^"(.*)"$/, "$1");
}
const FINDABILITY_MVI = 4, DEFAULT_LIMIT = 1e3, combinePaths = flow__default.default([flatten__default.default, union__default.default, compact__default.default]), pathWithMapper = ({ mapWith, path }) => mapWith ? `${mapWith}(${path})` : path;
function createConstraints(terms, specs) {
  const combinedSearchPaths = combinePaths(
    specs.map((configForType) => (configForType.paths || []).map((opt) => pathWithMapper(opt)))
  );
  return terms.map((_term, i) => combinedSearchPaths.map((joinedPath) => `${joinedPath} match $t${i}`)).filter((constraint) => constraint.length > 0).map((constraint) => `(${constraint.join(" || ")})`);
}
const SPECIAL_CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g, STRIP_EDGE_CHARS = /(^[.]+)|([.]+$)/;
function tokenize(string) {
  return (string.match(SPECIAL_CHARS) || []).map((token) => token.replace(STRIP_EDGE_CHARS, ""));
}
function extractTermsFromQuery(query) {
  const quotedQueries = [], unquotedQuery = query.replace(/("[^"]*")/g, (match) => words__default.default(match).length > 1 ? (quotedQueries.push(match), "") : match), quotedTerms = quotedQueries.map((str) => trim__default.default(toLower__default.default(str))), remainingTerms = uniq__default.default(compact__default.default(tokenize(toLower__default.default(unquotedQuery))));
  return [...quotedTerms, ...remainingTerms];
}
function toOrderClause(orderBy2) {
  function wrapFieldWithFn(ordering) {
    return ordering.mapWith ? `${ordering.mapWith}(${ordering.field})` : ordering.field;
  }
  return (orderBy2 || []).map(
    (ordering) => [wrapFieldWithFn(ordering), (ordering.direction || "").toLowerCase()].map((str) => str.trim()).filter(Boolean).join(" ")
  ).join(",");
}
function createSearchQuery(searchTerms, searchOpts = {}) {
  var _a2;
  const { filter, params, tag } = searchOpts, specs = searchTerms.types.map(
    (schemaType) => deriveSearchWeightsFromType({
      schemaType,
      maxDepth: searchOpts.maxDepth || _internal.DEFAULT_MAX_FIELD_DEPTH,
      isCrossDataset: searchOpts.isCrossDataset
    })
  ).filter(({ paths }) => paths.length), terms = extractTermsFromQuery(searchTerms.query), filters = [
    "_type in $__types",
    searchOpts.includeDrafts === !1 && "!(_id in path('drafts.**'))",
    ...createConstraints(terms, specs),
    filter ? `(${filter})` : "",
    searchTerms.filter ? `(${searchTerms.filter})` : ""
  ].filter(Boolean), selections = specs.map((spec) => {
    const constraint = `_type == "${spec.typeName}" => `, selection2 = `{ ${spec.paths.map((cfg, i) => `"w${i}": ${pathWithMapper(cfg)}`)} }`;
    return `${constraint}${selection2}`;
  }), sortOrder = toOrderClause((searchOpts == null ? void 0 : searchOpts.sort) || [{ field: "_id", direction: "asc" }]), projectionFields = ["_type", "_id"], selection = selections.length > 0 ? `...select(${selections.join(`,
`)})` : "", finalProjection = projectionFields.join(", ") + (selection ? `, ${selection}` : "");
  let query = `*[${filters.join(" && ")}]| order(${sortOrder})[0...$__limit]{${finalProjection}}`;
  if (searchOpts != null && searchOpts.__unstable_extendedProjection) {
    const extendedProjection = searchOpts == null ? void 0 : searchOpts.__unstable_extendedProjection, firstProjection = projectionFields.concat(extendedProjection).join(", ");
    query = [
      `*[${filters.join(" && ")}]{${firstProjection}}`,
      `order(${sortOrder})[0...$__limit]{${finalProjection}}`
    ].join("|");
  }
  const groqComments = [`findability-mvi:${FINDABILITY_MVI}`].concat((searchOpts == null ? void 0 : searchOpts.comments) || []).map((s) => `// ${s}`).join(`
`), updatedQuery = groqComments ? `${groqComments}
${query}` : query, limit = (_a2 = searchOpts == null ? void 0 : searchOpts.limit) != null ? _a2 : DEFAULT_LIMIT;
  return {
    query: updatedQuery,
    params: {
      ...toGroqParams(terms),
      __types: specs.map((spec) => spec.typeName),
      __limit: limit,
      ...params || {}
    },
    options: { tag },
    searchSpec: specs,
    terms
  };
}
const toGroqParams = (terms) => {
  const params = {};
  return terms.reduce((acc, term, i) => (acc[`t${i}`] = `${term}*`, acc), params);
};
function getSearchTerms(searchParams, types2) {
  return typeof searchParams == "string" ? {
    query: searchParams,
    types: types2
  } : searchParams.types.length ? searchParams : { ...searchParams, types: types2 };
}
const createWeightedSearch = (types2, client2, factoryOptions) => function(searchParams, searchOptions = {}) {
  const searchTerms = getSearchTerms(searchParams, types2), { query, params, options, searchSpec, terms } = createSearchQuery(searchTerms, {
    ...factoryOptions,
    ...searchOptions
  });
  return client2.observable.fetch(query, params, options).pipe(
    factoryOptions.unique ? operators.map(removeDupes) : operators.tap(),
    // Assign weighting and scores based on current search terms.
    // No scores will be assigned when terms are empty.
    operators.map((hits) => applyWeights(searchSpec, hits, terms)),
    // Optionally skip client-side score sorting.
    // This can be relevant when ordering results by specific fields, especially dates.
    searchOptions != null && searchOptions.skipSortByScore ? operators.tap() : operators.map((hits) => sortBy__default.default(hits, (hit) => -hit.score)),
    operators.map((hits) => ({ type: "weighted", hits }))
  );
}, createSearch = (searchableTypes, client2, options) => (options.unstable_enableNewSearch ? createTextSearch : createWeightedSearch)(searchableTypes, client2, options), READABLE = {
  available: !0,
  reason: "READABLE"
}, PERMISSION_DENIED = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, NOT_FOUND = {
  available: !1,
  reason: "NOT_FOUND"
};
function getReferenceInfo(documentPreviewStore, id2, referenceType) {
  const { publishedId, draftId } = getIdPair(id2);
  return documentPreviewStore.unstable_observeDocumentPairAvailability(id2).pipe(
    operators.switchMap((pairAvailability) => {
      if (!pairAvailability.draft.available && !pairAvailability.published.available) {
        const availability = pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND;
        return rxjs.of({
          id: id2,
          type: void 0,
          availability,
          preview: {
            draft: void 0,
            published: void 0
          }
        });
      }
      const draftRef = { _type: "reference", _ref: draftId }, publishedRef = { _type: "reference", _ref: publishedId };
      return rxjs.combineLatest([
        documentPreviewStore.observeDocumentTypeFromId(draftId),
        documentPreviewStore.observeDocumentTypeFromId(publishedId)
      ]).pipe(
        // assume draft + published are always same type
        operators.map(([draftTypeName, publishedTypeName]) => draftTypeName || publishedTypeName)
      ).pipe(
        operators.switchMap((typeName) => {
          if (!typeName)
            return rxjs.of({
              id: id2,
              type: void 0,
              availability: { available: !0, reason: "READABLE" },
              preview: {
                draft: void 0,
                published: void 0
              }
            });
          const refSchemaType = referenceType.to.find((memberType) => memberType.name === typeName);
          if (!refSchemaType)
            return rxjs.of({
              id: id2,
              type: typeName,
              availability: { available: !0, reason: "READABLE" },
              preview: {
                draft: void 0,
                published: void 0
              }
            });
          const previewPaths = getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], draftPreview$ = documentPreviewStore.observePaths(draftRef, previewPaths).pipe(
            operators.map(
              (result) => result ? {
                _id: draftId,
                ...prepareForPreview(result, refSchemaType)
              } : void 0
            ),
            operators.startWith(void 0)
          ), publishedPreview$ = documentPreviewStore.observePaths(publishedRef, previewPaths).pipe(
            operators.map(
              (result) => result ? {
                _id: publishedId,
                ...prepareForPreview(result, refSchemaType)
              } : void 0
            ),
            operators.startWith(void 0)
          );
          return rxjs.combineLatest([draftPreview$, publishedPreview$]).pipe(
            operators.map(([draft, published]) => ({ draft, published }))
          ).pipe(
            operators.map((value) => {
              const availability = (
                // eslint-disable-next-line no-nested-ternary
                pairAvailability.draft.available || pairAvailability.published.available ? READABLE : pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND
              );
              return {
                type: typeName,
                id: publishedId,
                availability,
                preview: {
                  draft: isRecord$4(value.draft) ? value.draft : void 0,
                  published: isRecord$4(value.published) ? value.published : void 0
                }
              };
            })
          );
        })
      );
    })
  );
}
function getCounterpartIds(collatedHits) {
  return collatedHits.filter(
    (collatedHit) => (
      // we're interested in hits where either draft or published is missing
      !collatedHit.draft || !collatedHit.published
    )
  ).map(
    (collatedHit) => (
      // if we have the draft, return the published id or vice versa
      collatedHit.draft ? collatedHit.id : getDraftId(collatedHit.id)
    )
  );
}
function getExistingCounterparts(client2, ids) {
  return ids.length === 0 ? rxjs.of([]) : client2.observable.fetch("*[_id in $ids]._id", { ids }, { tag: "get-counterpart-ids" });
}
function referenceSearch(client2, textTerm, type, options, unstable_enableNewSearch) {
  return createSearch(type.to, client2, {
    ...options,
    unstable_enableNewSearch,
    maxDepth: options.maxFieldDepth || _internal.DEFAULT_MAX_FIELD_DEPTH
  })(textTerm, { includeDrafts: !0 }).pipe(
    operators.map(({ hits }) => hits.map(({ hit }) => hit)),
    operators.map(collate),
    // pick the 100 best matches
    operators.map((collated) => collated.slice(0, 100)),
    operators.mergeMap((collated) => getExistingCounterparts(client2, getCounterpartIds(collated)).pipe(
      operators.map((existingCounterpartIds) => collated.map((entry) => {
        const draftId = getDraftId(entry.id);
        return {
          id: entry.id,
          type: entry.type,
          draft: entry.draft || existingCounterpartIds.includes(draftId) ? { _id: draftId, _type: entry.type } : void 0,
          published: entry.published || existingCounterpartIds.includes(entry.id) ? { _id: entry.id, _type: entry.type } : void 0
        };
      }))
    ))
  );
}
function useValueRef$2(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function useReferenceInput(options) {
  var _a2, _b, _c, _d;
  const { path, schemaType } = options, schema2 = useSchema(), documentPreviewStore = useDocumentPreviewStore(), { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions(), documentValue = useFormValue([]), documentTypeName = (_a2 = useValueRef$2(documentValue).current) == null ? void 0 : _a2._type, isCurrentDocumentLiveEdit = React.useMemo(() => {
    var _a22;
    return (_a22 = schema2.get(documentTypeName)) == null ? void 0 : _a22.liveEdit;
  }, [documentTypeName, schema2]), disableNew = ((_b = schemaType.options) == null ? void 0 : _b.disableNew) === !0, template = (_d = (_c = options.value) == null ? void 0 : _c._strengthenOnPublish) == null ? void 0 : _d.template, EditReferenceLink = React.useMemo(
    () => React.forwardRef(function(_props, forwardedRef) {
      return EditReferenceLinkComponent ? /* @__PURE__ */ jsxRuntime.jsx(
        EditReferenceLinkComponent,
        {
          ..._props,
          ref: forwardedRef,
          parentRefPath: path,
          template
        }
      ) : null;
    }),
    [EditReferenceLinkComponent, path, template]
  ), handleEditReference = React.useCallback(
    (event) => {
      onEditReference == null || onEditReference({
        parentRefPath: path,
        id: event.id,
        type: event.type,
        template: event.template
      });
    },
    [onEditReference, path]
  ), selectedState = PathUtils__namespace.startsWith(path, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none", createOptions = React.useMemo(() => disableNew ? [] : (initialValueTemplateItems || []).filter((i) => schemaType.to.some((refType) => {
    var _a22;
    return refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
  })).map(
    (item) => {
      var _a22;
      return (_a22 = item.template) != null && _a22.schemaType ? {
        id: item.id,
        title: item.title || `${item.template.schemaType} from template ${item.template.id}`,
        type: item.template.schemaType,
        icon: item.icon,
        template: {
          id: item.template.id,
          params: item.parameters
        },
        permission: { granted: item.granted, reason: item.reason }
      } : void 0;
    }
  ).filter(isNonNullable$2), [disableNew, initialValueTemplateItems, schemaType.to]), getReferenceInfo$1 = React.useCallback(
    (id2) => getReferenceInfo(documentPreviewStore, id2, schemaType),
    [documentPreviewStore, schemaType]
  );
  return {
    selectedState,
    isCurrentDocumentLiveEdit,
    handleEditReference,
    EditReferenceLink,
    createOptions,
    getReferenceInfo: getReferenceInfo$1
  };
}
function getTone$3({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$a = { portal: !0, tone: "default" };
function ReferenceField(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const elementRef = React.useRef(null), { schemaType, path, open, inputId, children, inputProps } = props2, { readOnly, focused, renderPreview, onChange } = props2.inputProps, [fieldActionsNodes, setFieldActionNodes] = React.useState([]), documentId = usePublishedId(), handleClear = React.useCallback(() => inputProps.onChange(unset()), [inputProps]), value = props2.value, { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({
    path,
    schemaType,
    value
  });
  useScrollIntoViewOnFocusWithin(elementRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    !hadFocus && hasFocus && elementRef.current && elementRef.current.focus();
  });
  const hasErrors = props2.validation.some((v) => v.level === "error"), hasWarnings = props2.validation.some((v) => v.level === "warning"), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), refTypeName = ((_a2 = loadableReferenceInfo.result) == null ? void 0 : _a2.type) || ((_b = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _b.type), refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0, pressed = selectedState === "pressed", selected = selectedState === "selected", hasRef = value == null ? void 0 : value._ref, publishedReferenceExists = hasRef && ((_e = (_d = (_c = loadableReferenceInfo.result) == null ? void 0 : _c.preview) == null ? void 0 : _d.published) == null ? void 0 : _e._id), handleRemoveStrengthenOnPublish = React.useCallback(() => {
    onChange([
      schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]),
      unset(["_strengthenOnPublish"])
    ]);
  }, [onChange, schemaType.weak]), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), handleReplace = React.useCallback(() => {
    inputProps.onPathFocus(["_ref"]);
  }, [inputProps]), actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish), showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_f = loadableReferenceInfo.result) == null ? void 0 : _f.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride, tone = getTone$3({ readOnly, hasErrors, hasWarnings }), isEditing = !(value != null && value._ref) || inputProps.focusPath[0] === "_ref", { t: t2 } = useTranslation(), footer = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceFinalizeAlertStrip,
      {
        schemaType,
        handleRemoveStrengthenOnPublish
      }
    ),
    showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceStrengthMismatchAlertStrip,
      {
        actualStrength,
        handleFixStrengthMismatch
      }
    ),
    loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceMetadataLoadErrorAlertStrip,
      {
        errorMessage: loadableReferenceInfo.error.message,
        onHandleRetry: loadableReferenceInfo.retry
      }
    )
  ] }), OpenLink = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(restProps, _ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...restProps,
            intent: "edit",
            params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name },
            target: "_blank",
            rel: "noopener noreferrer",
            ref: _ref
          }
        );
      })
    ),
    [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]
  ), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
        id: `${inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                text: t2("inputs.reference.action.clear"),
                tone: "critical",
                icon: icons.TrashIcon,
                onClick: handleClear
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                text: t2("inputs.reference.action.replace"),
                icon: icons.SyncIcon,
                onClick: handleReplace
              }
            )
          ] }),
          !readOnly && (value == null ? void 0 : value._ref) && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          (value == null ? void 0 : value._ref) && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              as: OpenLink,
              "data-as": "a",
              text: t2("inputs.reference.action.open-in-new-tab"),
              icon: icons.LaunchIcon
            }
          )
        ] }),
        popover: MENU_POPOVER_PROPS$a
      }
    ) }),
    [handleClear, handleReplace, inputId, OpenLink, readOnly, t2, value == null ? void 0 : value._ref]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && props2.actions && props2.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: props2.actions,
        documentId,
        documentType: schemaType.name,
        onActions: setFieldActionNodes,
        path,
        schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsProvider,
      {
        actions: fieldActionsNodes,
        focused: !!props2.inputProps.focused,
        path,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          FormField,
          {
            __internal_comments: props2.__internal_comments,
            __internal_slot: props2.__internal_slot,
            __unstable_headerActions: fieldActionsNodes,
            __unstable_presence: props2.presence,
            description: props2.description,
            level: props2.level,
            title: props2.title,
            validation: props2.validation,
            deprecated: props2.schemaType.deprecated,
            children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 2, padding: 1, tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { gap: 1, align: "center", style: { lineHeight: 0 }, children: /* @__PURE__ */ jsxRuntime.jsxs(getJsonStream.TooltipDelayGroupProvider, { children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  ReferenceLinkCard,
                  {
                    __unstable_focusRing: !0,
                    as: EditReferenceLink,
                    "data-pressed": pressed ? !0 : void 0,
                    "data-selected": selected ? !0 : void 0,
                    documentId: value == null ? void 0 : value._ref,
                    documentType: refType == null ? void 0 : refType.name,
                    flex: 1,
                    pressed,
                    radius: 2,
                    ref: elementRef,
                    selected,
                    tone: "inherit",
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      PreviewReferenceValue$1,
                      {
                        value,
                        referenceInfo: loadableReferenceInfo,
                        renderPreview,
                        type: schemaType
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: menu })
              ] }) }),
              footer
            ] }) })
          }
        )
      }
    )
  ] });
}
function getOption(type, optionName) {
  return get__default.default(type.options, optionName);
}
const PSEUDO_OBJECTS = ["array", "file", "image", "reference", "slug"], HIDDEN_FIELDS = ["asset", "crop", "hotspot", "_ref", "_weak"], NO_LEVEL_LAYOUTS = ["tags"], NO_LEVEL_TYPES = ["slug"];
function getTypeChain$1(type, visited) {
  if (!type)
    return [];
  if (visited.has(type))
    return [];
  visited.add(type);
  const next = type.type ? getTypeChain$1(type.type, visited) : [];
  return [type, ...next];
}
function getFieldLevel(schemaType, currentLevel) {
  return types.isArraySchemaType(schemaType) ? getArrayFieldLevel(schemaType, currentLevel) : getObjectFieldLevel(schemaType, currentLevel);
}
function getObjectFieldLevel(schemaType, currentLevel) {
  var _a2, _b, _c;
  const { type, options } = schemaType, typeIfRelevant = asType(type, PSEUDO_OBJECTS), fields = (schemaType == null ? void 0 : schemaType.jsonType) === "object" ? schemaType.fields : void 0, typeName = (typeIfRelevant == null ? void 0 : typeIfRelevant.name) || "";
  if (NO_LEVEL_TYPES.includes(typeName))
    return 0;
  const isPseudoObject = PSEUDO_OBJECTS.includes(typeName), hasVisibleFields = ((_a2 = fields == null ? void 0 : fields.filter((f) => !HIDDEN_FIELDS.includes(f.name)).length) != null ? _a2 : 0) > 0, hasListOptions2 = ((_c = (_b = options == null ? void 0 : options.list) == null ? void 0 : _b.length) != null ? _c : 0) > 0;
  return hasVisibleFields || hasListOptions2 || !isPseudoObject ? currentLevel : 0;
}
function getArrayFieldLevel(schemaType, currentLevel) {
  var _a2;
  const { options } = schemaType, hasListOptions2 = ((_a2 = (options == null ? void 0 : options.list) || []) == null ? void 0 : _a2.length) > 0, isNoLevelLayout = NO_LEVEL_LAYOUTS.includes((options == null ? void 0 : options.layout) || "");
  return hasListOptions2 && !isNoLevelLayout ? currentLevel : 0;
}
function asType(schemaType, asOneOfTypes) {
  if (schemaType != null && schemaType.name && asOneOfTypes.includes(schemaType == null ? void 0 : schemaType.name))
    return schemaType;
  if (schemaType)
    return asType(schemaType.type, asOneOfTypes);
}
const EMPTY_ARRAY$5 = [];
function BooleanField(field) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ChangeIndicator,
    {
      hasFocus: !!field.inputProps.focused,
      isChanged: field.inputProps.changed,
      path: field.path,
      children: field.children
    }
  );
}
function PrimitiveField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$5), documentId = usePublishedId(), focused = !!field.inputProps.focused;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormField,
      {
        __internal_slot: field.__internal_slot,
        __internal_comments: field.__internal_comments,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: field.presence,
        "data-testid": `field-${field.inputId}`,
        description: field.description,
        inputId: field.inputId,
        level: field.level,
        title: field.title,
        validation: field.validation,
        deprecated: field.schemaType.deprecated,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ChangeIndicator,
          {
            hasFocus: focused,
            isChanged: field.inputProps.changed,
            path: field.path,
            children: field.children
          }
        )
      }
    ) })
  ] });
}
function ObjectOrArrayField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$5), documentId = usePublishedId(), focused = !!field.inputProps.focused;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldSet,
      {
        __internal_comments: field.__internal_comments,
        __internal_slot: field.__internal_slot,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: field.presence,
        collapsed: field.collapsed,
        collapsible: field.collapsible,
        "data-testid": `field-${field.inputId}`,
        description: field.description,
        level: field.level,
        onCollapse: field.onCollapse,
        onExpand: field.onExpand,
        title: field.title,
        validation: field.validation,
        inputId: field.inputId,
        deprecated: field.schemaType.deprecated,
        children: field.children
      }
    ) })
  ] });
}
function ImageOrFileField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$5), documentId = usePublishedId(), focused = !!field.inputProps.focused, hotspotField = field.inputProps.members.find(
    (member) => member.kind === "field" && member.name === "hotspot"
  ), presence = hotspotField != null && hotspotField.open ? field.presence : field.presence.concat((hotspotField == null ? void 0 : hotspotField.field.presence) || EMPTY_ARRAY$5);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldSet,
      {
        __internal_comments: field.__internal_comments,
        __internal_slot: field.__internal_slot,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: presence,
        collapsed: field.collapsed,
        collapsible: field.collapsible,
        description: field.description,
        level: field.level,
        onCollapse: field.onCollapse,
        onExpand: field.onExpand,
        title: field.title,
        validation: field.validation,
        inputId: field.inputId,
        deprecated: field.schemaType.deprecated,
        children: field.children
      }
    ) })
  ] });
}
function defaultResolveFieldComponent(schemaType) {
  var _a2;
  if ((_a2 = schemaType.components) != null && _a2.field)
    return schemaType.components.field;
  if (types.isBooleanSchemaType(schemaType))
    return BooleanField;
  const typeChain = getTypeChain$1(schemaType, /* @__PURE__ */ new Set());
  return typeChain.some((t2) => t2.name === "image" || t2.name === "file") ? ImageOrFileField : typeChain.some((t2) => types.isCrossDatasetReferenceSchemaType(t2)) || typeChain.some((t2) => t2.name === "slug") ? PrimitiveField : typeChain.some((t2) => types.isReferenceSchemaType(t2)) ? ReferenceField : schemaType.jsonType !== "object" && schemaType.jsonType !== "array" ? PrimitiveField : ObjectOrArrayField;
}
const WorkspaceContext = React.createContext(null);
function WorkspaceProvider({ children, workspace }) {
  return /* @__PURE__ */ jsxRuntime.jsx(WorkspaceContext.Provider, { value: workspace, children });
}
function useWorkspace() {
  const workspace = React.useContext(WorkspaceContext);
  if (!workspace)
    throw new Error("Workspace: missing context value");
  return workspace;
}
const DEFAULT_API_FIELD_DEPTH = 0, INITIAL_LOADING_STATE$2 = {
  isLoading: !0,
  settings: {
    partialIndexSettings: {
      maxFieldDepth: DEFAULT_API_FIELD_DEPTH
    }
  }
};
function fetchMaxDepth({ client: client2 }) {
  const { projectId, dataset } = client2.config();
  return client2.observable.request({
    uri: `/projects/${projectId}/datasets/${dataset}/settings/indexing`,
    tag: "search.getPartialIndexSettings"
  });
}
const cachedSettings = /* @__PURE__ */ new Map();
function useSearchMaxFieldDepth(overrideClient) {
  var _a2, _b, _c, _d;
  const isEnabled = (_b = (_a2 = useWorkspace().search) == null ? void 0 : _a2.unstable_partialIndexing) == null ? void 0 : _b.enabled, workspaceClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), client2 = React.useMemo(() => overrideClient || workspaceClient, [overrideClient, workspaceClient]), dataset = React.useMemo(() => client2.config().dataset, [client2]);
  isEnabled || cachedSettings.set(dataset, rxjs.of(INITIAL_LOADING_STATE$2.settings)), cachedSettings.has(dataset) || cachedSettings.set(dataset, fetchMaxDepth({ client: client2 }).pipe(operators.shareReplay()));
  const indexSettings = reactRx.useMemoObservable(
    () => cachedSettings.get(dataset).pipe(
      operators.map((settings) => ({
        isLoading: !1,
        settings
      })),
      operators.startWith(INITIAL_LOADING_STATE$2),
      operators.catchError((err) => (console.error(err), rxjs.of({
        isLoading: !1,
        enabled: !0,
        settings: { partialIndexSettings: { maxFieldDepth: DEFAULT_API_FIELD_DEPTH } }
      })))
    ),
    [dataset],
    INITIAL_LOADING_STATE$2
  ), maxFieldDepth = (_d = (_c = indexSettings == null ? void 0 : indexSettings.settings) == null ? void 0 : _c.partialIndexSettings) == null ? void 0 : _d.maxFieldDepth;
  return isFinite__default.default(maxFieldDepth) ? Math.min(maxFieldDepth, _internal.DEFAULT_MAX_FIELD_DEPTH) : _internal.DEFAULT_MAX_FIELD_DEPTH;
}
function useOnClickOutside(refs, handler) {
  React.useEffect(() => {
    const listener = (event) => {
      const target = event.target;
      if (target instanceof HTMLElement) {
        if (refs.some((ref) => {
          var _a2;
          return (_a2 = ref.current) == null ? void 0 : _a2.contains(target);
        }))
          return;
        handler(event);
      }
    };
    return document.addEventListener("mousedown", listener), document.addEventListener("touchstart", listener), () => {
      document.removeEventListener("mousedown", listener), document.removeEventListener("touchstart", listener);
    };
  }, [refs, handler]);
}
const NARROW_LAYOUT = styled.css`
  grid-template-columns: minmax(0px, 1fr);
`, WIDE_LAYOUT = styled.css`
  grid-template-columns: 1fr min-content;
`, Root$k = styled__default.default(ui.Grid)(
  (props2) => props2.$narrow ? NARROW_LAYOUT : WIDE_LAYOUT
), AutocompleteContainer = React.forwardRef(function(props2, forwardedRef) {
  const [rootElement, setRootElement] = React.useState(null), handleNewRef = React.useCallback(
    (element) => {
      setForwardedRef(forwardedRef, element), setRootElement(element);
    },
    [forwardedRef]
  ), inputWrapperRect = ui.useElementRect(rootElement);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$k, { ref: handleNewRef, gap: 1, $narrow: ((inputWrapperRect == null ? void 0 : inputWrapperRect.width) || 0) < 480, children: props2.children });
});
function setForwardedRef(ref, instance) {
  typeof ref == "function" ? ref(instance) : ref && (ref.current = instance);
}
const INLINE_BLOCK_STYLE = { display: "inline-flex" }, FULL_WIDTH = { width: "100%" }, POPOVER_PROPS$3 = {
  portal: !0,
  tone: "default",
  constrainSize: !0,
  fallbackPlacements: ["bottom", "left", "top"],
  placement: "right",
  preventOverflow: !0
};
function CreateButton(props2) {
  const { createOptions, onCreate, id: id2, menuRef, ...rest } = props2, currentUser = useCurrentUser(), { t: t2 } = useTranslation(), getI18nText = useGetI18nText(createOptions);
  return createOptions.some((option) => option.permission.granted) ? createOptions.length > 1 ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          ...rest,
          disabled: props2.readOnly,
          text: t2("inputs.reference.action.create-new-document-select"),
          mode: "ghost",
          icon: icons.AddIcon,
          size: "large"
        }
      ),
      id: id2,
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: menuRef, children: createOptions.map((createOption) => /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Tooltip,
        {
          disabled: createOption.permission.granted,
          content: /* @__PURE__ */ jsxRuntime.jsx(
            InsufficientPermissionsMessage,
            {
              currentUser,
              context: "create-document-type"
            }
          ),
          portal: !0,
          children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              disabled: !createOption.permission.granted,
              icon: createOption.icon,
              text: getI18nText(createOption).title,
              onClick: () => onCreate(createOption)
            }
          ) })
        },
        createOption.id
      )) }),
      popover: POPOVER_PROPS$3
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ...rest,
      text: t2("inputs.reference.action.create-new-document-select"),
      mode: "ghost",
      disabled: !createOptions[0].permission.granted || props2.readOnly,
      onClick: () => onCreate(createOptions[0]),
      icon: icons.AddIcon,
      size: "large"
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(
        InsufficientPermissionsMessage,
        {
          currentUser,
          context: "create-new-reference"
        }
      ),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: INLINE_BLOCK_STYLE, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          text: t2("inputs.reference.action.create-new-document"),
          mode: "ghost",
          disabled: !0,
          icon: icons.AddIcon,
          style: FULL_WIDTH
        }
      ) })
    }
  );
}
function OptionPreview$1(props2) {
  const { getReferenceInfo: getReferenceInfo2, id: documentId, renderPreview } = props2, { isLoading, result: referenceInfo, error } = useReferenceInfo$1(documentId, getReferenceInfo2), { t: t2 } = useTranslation();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !0 })
    ] });
  if (error)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Alert, { title: t2("inputs.reference.error.failed-to-load-document-title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: error.message }) }) });
  if (!referenceInfo)
    return null;
  if (referenceInfo.availability.reason === "PERMISSION_DENIED")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.missing-read-permissions-description") });
  const refType = props2.type.to.find((toType) => toType.name === referenceInfo.type);
  return refType ? referenceInfo && refType && /* @__PURE__ */ jsxRuntime.jsx(
    ReferencePreview,
    {
      id: referenceInfo.id,
      layout: "default",
      preview: referenceInfo.preview,
      refType,
      renderPreview,
      showTypeLabel: props2.type.to.length > 1
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.invalid-search-result-type-title", {
    returnedType: referenceInfo.type
  }) });
}
const StyledPopover$3 = styled__default.default(getJsonStream.Popover)`
  & > div {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
`, StyledText$4 = styled__default.default(ui.Text)`
  word-break: break-word;
`, FALLBACK_PLACEMENTS$2 = ["top-start", "bottom-start"], ReferenceAutocomplete$2 = React.forwardRef(function(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2, { t: t2 } = useTranslation(), hasResults = props2.options && props2.options.length > 0, renderPopover = React.useCallback(
    ({
      content: content2,
      hidden,
      inputElement,
      onMouseEnter,
      onMouseLeave
    }, contentRef) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$3,
      {
        placement: "bottom-start",
        fallbackPlacements: FALLBACK_PLACEMENTS$2,
        arrow: !1,
        constrainSize: !0,
        onMouseEnter,
        onMouseLeave,
        content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$4, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.no-results-for-query",
            values: { searchTerm: searchString || "" }
          }
        ) }) }) }) }),
        open: !loading && !hidden,
        ref: portalRef,
        portal: !0,
        referenceElement: referenceElement || inputElement,
        matchReferenceWidth: !0
      }
    ),
    [hasResults, t2, searchString, loading, portalRef, referenceElement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Autocomplete, { ...restProps, loading, ref, renderPopover });
}), ReferenceItemRefContext = React.createContext(null);
function useReferenceItemRef() {
  return React.useContext(ReferenceItemRefContext) || { menuRef: { current: null }, containerRef: { current: null } };
}
let StyledPreviewCardImpl;
const StyledPreviewCard = React.forwardRef(function(props2, ref) {
  return StyledPreviewCardImpl || (StyledPreviewCardImpl = styled__default.default(PreviewCard)`
      /* this is a hack to avoid layout jumps while previews are loading
      there's probably better ways of solving this */
      min-height: 36px;
    `), /* @__PURE__ */ jsxRuntime.jsx(StyledPreviewCardImpl, { ref, ...props2 });
}), INITIAL_SEARCH_STATE$2 = {
  hits: [],
  isLoading: !1
}, NO_FILTER$2 = () => !0;
function nonNullable$1(v) {
  return v !== null;
}
function ReferenceInput(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    createOptions,
    onChange,
    onEditReference,
    onSearch,
    schemaType,
    readOnly,
    id: id2,
    onPathFocus,
    value,
    renderPreview,
    path,
    elementProps,
    focusPath
  } = props2, { getReferenceInfo: getReferenceInfo2 } = useReferenceInput({
    path,
    schemaType,
    value
  }), [searchState, setSearchState] = React.useState(INITIAL_SEARCH_STATE$2), handleCreateNew = React.useCallback(
    (option) => {
      const newDocumentId = uuid.uuid(), patches = [
        setIfMissing({}),
        set(schemaType.name, ["_type"]),
        set(newDocumentId, ["_ref"]),
        set(!0, ["_weak"]),
        set({ type: option.type, weak: schemaType.weak, template: option.template }, [
          "_strengthenOnPublish"
        ])
      ].filter(isNonNullable$2);
      onChange(patches), onEditReference({ id: newDocumentId, type: option.type, template: option.template }), onPathFocus([]);
    },
    [onChange, onEditReference, onPathFocus, schemaType]
  ), handleChange = React.useCallback(
    (nextId) => {
      if (!nextId) {
        onChange(unset()), onPathFocus([]);
        return;
      }
      const hit = searchState.hits.find((h) => h.id === nextId);
      if (!hit)
        throw new Error("Selected an item that wasnt part of the result set");
      const patches = [
        setIfMissing({}),
        set(schemaType.name, ["_type"]),
        set(getPublishedId(nextId), ["_ref"]),
        hit.published && !schemaType.weak ? unset(["_weak"]) : set(!0, ["_weak"]),
        hit.published ? unset(["_strengthenOnPublish"]) : set({ type: hit == null ? void 0 : hit.type, weak: schemaType.weak }, ["_strengthenOnPublish"])
      ].filter(isNonNullable$2);
      onChange(patches), onPathFocus([]);
    },
    [onChange, onPathFocus, schemaType.name, schemaType.weak, searchState.hits]
  ), handleClear = React.useCallback(() => {
    onChange(unset());
  }, [onChange]), handleCancelEdit = React.useCallback(() => {
    value != null && value._ref || handleClear();
  }, [handleClear, value == null ? void 0 : value._ref]), handleAutocompleteKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && onPathFocus([]);
    },
    [onPathFocus]
  ), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), autocompletePopoverReferenceElementRef = React.useRef(null), { push } = ui.useToast(), { t: t2 } = useTranslation(), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      operators.filter(nonNullable$1),
      operators.switchMap(
        (searchString) => rxjs.concat(
          rxjs.of({ isLoading: !0 }),
          onSearch(searchString).pipe(
            operators.map((hits2) => ({ hits: hits2, searchString, isLoading: !1 })),
            operators.catchError((error) => (push({
              title: t2("inputs.reference.error.search-failed-title"),
              description: error.message,
              status: "error",
              id: `reference-search-fail-${id2}`
            }), console.error(error), rxjs.of({ hits: [] })))
          )
        )
      ),
      operators.scan(
        (prevState, nextState) => ({ ...prevState, ...nextState }),
        INITIAL_SEARCH_STATE$2
      ),
      operators.tap(setSearchState)
    ),
    [id2, onSearch, push, t2]
  ), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleQueryChange("");
  }, [handleQueryChange]), handleCreateButtonKeyDown = React.useCallback(
    (e) => {
      e.key === "Escape" && onPathFocus([]);
    },
    [onPathFocus]
  ), renderOption = React.useCallback(
    (option) => {
      var _a22, _b2;
      const documentId = ((_a22 = option.hit.draft) == null ? void 0 : _a22._id) || ((_b2 = option.hit.published) == null ? void 0 : _b2._id) || option.value;
      return /* @__PURE__ */ jsxRuntime.jsx(StyledPreviewCard, { forwardedAs: "button", type: "button", radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
        OptionPreview$1,
        {
          getReferenceInfo: getReferenceInfo2,
          id: documentId,
          renderPreview,
          type: schemaType
        }
      ) });
    },
    [schemaType, getReferenceInfo2, renderPreview]
  ), renderValue = React.useCallback(() => {
    var _a22, _b2, _c2, _d2;
    return ((_b2 = (_a22 = loadableReferenceInfo.result) == null ? void 0 : _a22.preview.draft) == null ? void 0 : _b2.title) || ((_d2 = (_c2 = loadableReferenceInfo.result) == null ? void 0 : _c2.preview.published) == null ? void 0 : _d2.title) || "";
  }, [
    (_b = (_a2 = loadableReferenceInfo.result) == null ? void 0 : _a2.preview.draft) == null ? void 0 : _b.title,
    (_d = (_c = loadableReferenceInfo.result) == null ? void 0 : _c.preview.published) == null ? void 0 : _d.title
  ]), handleFocus = React.useCallback(() => onPathFocus(["_ref"]), [onPathFocus]), handleBlur = React.useCallback(
    (event) => {
      var _a22;
      (_a22 = autocompletePopoverReferenceElementRef.current) != null && _a22.contains(event.relatedTarget) || props2.elementProps.onBlur(event);
    },
    [props2.elementProps]
  ), isWeakRefToNonexistent = ((_f = (_e = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _e.availability) == null ? void 0 : _f.reason) === "NOT_FOUND" && !(value != null && value._strengthenOnPublish) && (value == null ? void 0 : value._weak);
  useDidUpdate((focusPath == null ? void 0 : focusPath[0]) === "_ref", (hadFocusAtRef, hasFocusAtRef) => {
    var _a22;
    !hadFocusAtRef && hasFocusAtRef && ((_a22 = elementProps.ref.current) == null || _a22.focus());
  });
  const hits = React.useMemo(
    () => searchState.hits.map((hit) => ({
      value: hit.id,
      hit
    })),
    [searchState.hits]
  ), isEditing = focusPath.length === 1 && focusPath[0] === "_ref", { menuRef, containerRef } = useReferenceItemRef(), clickOutsideBoundaryRef = React.useRef(null), autoCompletePortalRef = React.useRef(null), createButtonMenuPortalRef = React.useRef(null);
  return useOnClickOutside(
    [
      containerRef,
      clickOutsideBoundaryRef,
      autoCompletePortalRef,
      createButtonMenuPortalRef,
      menuRef
    ],
    () => {
      isEditing && handleCancelEdit();
    }
  ), /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, "data-testid": "reference-input", ref: clickOutsideBoundaryRef, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    isWeakRefToNonexistent ? /* @__PURE__ */ jsxRuntime.jsx(
      Alert,
      {
        "data-testid": "alert-nonexistent-document",
        title: t2("inputs.reference.error.nonexistent-document-title"),
        suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            text: t2("inputs.reference.error.nonexistent-document.clear-button-label"),
            onClick: handleClear
          }
        ) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            i18nKey: "inputs.reference.error.nonexistent-document-description",
            t: t2,
            values: { documentId: value._ref }
          }
        ) })
      }
    ) : null,
    /* @__PURE__ */ jsxRuntime.jsxs(AutocompleteContainer, { ref: autocompletePopoverReferenceElementRef, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ReferenceAutocomplete$2,
        {
          ...elementProps,
          onFocus: handleFocus,
          onBlur: handleBlur,
          "data-testid": "autocomplete",
          loading: searchState.isLoading,
          referenceElement: autocompletePopoverReferenceElementRef.current,
          options: hits,
          radius: 2,
          placeholder: t2("inputs.reference.search-placeholder"),
          onKeyDown: handleAutocompleteKeyDown,
          readOnly: loadableReferenceInfo.isLoading || readOnly,
          onQueryChange: handleQueryChange,
          searchString: searchState.searchString,
          onChange: handleChange,
          filterOption: NO_FILTER$2,
          renderOption,
          renderValue,
          openButton: { onClick: handleAutocompleteOpenButtonClick },
          portalRef: autoCompletePortalRef,
          value: value == null ? void 0 : value._ref
        }
      ),
      createOptions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CreateButton,
        {
          id: `${id2}-selectTypeMenuButton`,
          readOnly,
          createOptions,
          onCreate: handleCreateNew,
          onKeyDown: handleCreateButtonKeyDown,
          menuRef: createButtonMenuPortalRef
        }
      )
    ] })
  ] }) });
}
async function resolveUserDefinedFilter$1(options, document2, valuePath, getClient) {
  if (!options)
    return {};
  if (typeof options.filter == "function") {
    const parentPath = valuePath.slice(0, -1), parent = PathUtils.get(document2, parentPath);
    return await options.filter({ document: document2, parentPath, parent, getClient });
  }
  return {
    filter: options.filter,
    params: "filterParams" in options ? options.filterParams : void 0
  };
}
function useValueRef$1(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function StudioReferenceInput(props2) {
  var _a2, _b, _c, _d;
  const source = useSource(), searchClient = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), schema2 = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), documentPreviewStore = useDocumentPreviewStore(), { path, schemaType } = props2, { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions(), { unstable_enableNewSearch = !1 } = source.search, documentValue = useFormValue([]), documentRef = useValueRef$1(documentValue), documentTypeName = (_a2 = documentRef.current) == null ? void 0 : _a2._type, refType = schema2.get(documentTypeName), isDocumentLiveEdit = React.useMemo(() => refType == null ? void 0 : refType.liveEdit, [refType]), disableNew = ((_b = schemaType.options) == null ? void 0 : _b.disableNew) === !0, getClient = source.getClient, handleSearch = React.useCallback(
    (searchString) => rxjs.from(resolveUserDefinedFilter$1(schemaType.options, documentRef.current, path, getClient)).pipe(
      operators.mergeMap(
        ({ filter, params }) => referenceSearch(
          searchClient,
          searchString,
          schemaType,
          {
            ...schemaType.options,
            filter,
            params,
            tag: "search.reference",
            maxFieldDepth
          },
          unstable_enableNewSearch
        )
      ),
      operators.catchError((err) => {
        var _a22;
        const isQueryError = err.details && err.details.type === "queryParseError";
        return (_a22 = schemaType.options) != null && _a22.filter && isQueryError && (err.message = 'Invalid reference filter, please check the custom "filter" option'), rxjs.throwError(err);
      })
    ),
    [
      schemaType,
      documentRef,
      path,
      getClient,
      searchClient,
      maxFieldDepth,
      unstable_enableNewSearch
    ]
  ), template = (_d = (_c = props2.value) == null ? void 0 : _c._strengthenOnPublish) == null ? void 0 : _d.template, EditReferenceLink = React.useMemo(
    () => React.forwardRef(function(_props, forwardedRef) {
      return EditReferenceLinkComponent ? /* @__PURE__ */ jsxRuntime.jsx(
        EditReferenceLinkComponent,
        {
          ..._props,
          ref: forwardedRef,
          parentRefPath: path,
          template
        }
      ) : null;
    }),
    [EditReferenceLinkComponent, path, template]
  ), handleEditReference = React.useCallback(
    (event) => {
      onEditReference == null || onEditReference({
        parentRefPath: path,
        id: event.id,
        type: event.type,
        template: event.template
      });
    },
    [onEditReference, path]
  ), selectedState = PathUtils__namespace.startsWith(path, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none", createOptions = React.useMemo(() => disableNew ? [] : (initialValueTemplateItems || []).filter((i) => schemaType.to.some((_refType) => {
    var _a22;
    return _refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
  })).map(
    (item) => {
      var _a22, _b2, _c2;
      return (_a22 = item.template) != null && _a22.schemaType ? {
        id: item.id,
        title: item.title || `${item.template.schemaType} from template ${(_b2 = item.template) == null ? void 0 : _b2.id}`,
        i18n: item.i18n,
        type: item.template.schemaType,
        icon: item.icon,
        template: {
          id: (_c2 = item.template) == null ? void 0 : _c2.id,
          params: item.parameters
        },
        permission: { granted: item.granted, reason: item.reason }
      } : void 0;
    }
  ).filter(isNonNullable$2), [disableNew, initialValueTemplateItems, schemaType.to]), getReferenceInfo$1 = React.useCallback(
    (id2, _type) => getReferenceInfo(documentPreviewStore, id2, _type),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ReferenceInput,
    {
      ...props2,
      onSearch: handleSearch,
      liveEdit: isDocumentLiveEdit,
      getReferenceInfo: getReferenceInfo$1,
      selectedState,
      editReferenceLinkComponent: EditReferenceLink,
      createOptions,
      onEditReference: handleEditReference
    }
  );
}
function isObjectItemProps(item) {
  return types.isObjectSchemaType(item.schemaType);
}
function isObjectInputProps(inputProps) {
  return types.isObjectSchemaType(inputProps.schemaType);
}
function isStringInputProps(inputProps) {
  return types.isStringSchemaType(inputProps.schemaType);
}
function isNumberInputProps(inputProps) {
  return types.isNumberSchemaType(inputProps.schemaType);
}
function isBooleanInputProps(inputProps) {
  return types.isBooleanSchemaType(inputProps.schemaType);
}
function isArrayOfObjectsInputProps(inputProps) {
  return types.isArrayOfObjectsSchemaType(inputProps.schemaType);
}
function isArrayOfBlocksInputProps(inputProps) {
  return types.isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function isArrayOfPrimitivesInputProps(inputProps) {
  return types.isArrayOfPrimitivesSchemaType(inputProps.schemaType);
}
function restrictToBoundingRect(transform, rect, boundingRect, margins) {
  const value = {
    ...transform
  }, marginY = margins.y || 0, marginX = margins.x || 0;
  return rect.top + value.y <= boundingRect.top + marginY ? value.y = boundingRect.top - rect.top + marginY : rect.bottom + value.y >= boundingRect.top + boundingRect.height - marginY && (value.y = boundingRect.top + boundingRect.height - rect.bottom - marginY), rect.left + value.x <= boundingRect.left - marginX ? value.x = boundingRect.left - rect.left + marginX : rect.right + value.x >= boundingRect.left + boundingRect.width + marginX && (value.x = boundingRect.left + boundingRect.width - rect.right + marginX), value;
}
const restrictToParentElementWithMargins = (margins) => ({ containerNodeRect, draggingNodeRect, transform }) => !draggingNodeRect || !containerNodeRect ? transform : restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect, margins), DragHandleButton = styled__default.default(getJsonStream.Button)`
  cursor: ${(props2) => props2.$grid ? "move" : "ns-resize"};
`, SortableItemIdContext = React.createContext(null), DragHandle = function(props2) {
  const id2 = React.useContext(SortableItemIdContext), { listeners, attributes } = sortable.useSortable({ id: id2 }), { t: t2 } = useTranslation(), { mode = "bleed", ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    DragHandleButton,
    {
      icon: icons.DragHandleIcon,
      tooltipProps: {
        content: t2("inputs.array.action.drag.tooltip"),
        delay: { open: 1e3 }
      },
      mode,
      "data-ui": "DragHandleButton",
      ...attributes,
      ...rest,
      ...listeners
    }
  );
}, MOVING_ITEM_CLASS_NAME = "moving", ListItem$2 = styled__default.default(ui.Box)`
  ${(props2) => props2.$moving && styled.css`
      z-index: 10000;
      /* prevents hover-effects etc on the dragged element  */
      pointer-events: none;
    `}
`, AUTO_SCROLL_OPTIONS = {
  threshold: {
    x: 0,
    y: 0.02
  }
}, SENSOR_OPTIONS = {
  coordinateGetter: sortable.sortableKeyboardCoordinates
}, TRANSITION = {
  duration: 200,
  easing: "ease"
};
function restrictToAxis(axis) {
  return axis === "x" ? modifiers.restrictToHorizontalAxis : modifiers.restrictToVerticalAxis;
}
function sortingStrategy(axis) {
  return axis === "x" ? sortable.horizontalListSortingStrategy : sortable.verticalListSortingStrategy;
}
const SortableList = React.memo(function(props2) {
  const { items, axis, onItemMove, onItemMoveStart, onItemMoveEnd, children, ...rest } = props2, sensors = core.useSensors(core.useSensor(core.PointerSensor), core.useSensor(core.KeyboardSensor, SENSOR_OPTIONS)), handleDragEnd = React.useCallback(
    (event) => {
      var _a2, _b, _c, _d;
      const { active, over } = event;
      active.id !== (over == null ? void 0 : over.id) && (onItemMove == null || onItemMove({
        fromIndex: (_b = (_a2 = active.data.current) == null ? void 0 : _a2.sortable) == null ? void 0 : _b.index,
        toIndex: (_d = (_c = over == null ? void 0 : over.data.current) == null ? void 0 : _c.sortable) == null ? void 0 : _d.index
      })), onItemMoveEnd == null || onItemMoveEnd();
    },
    [onItemMove, onItemMoveEnd]
  ), modifiers2 = React.useMemo(
    () => [restrictToParentElementWithMargins({ y: 4 }), ...axis ? [restrictToAxis(axis)] : []],
    [axis]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    core.DndContext,
    {
      sensors,
      autoScroll: AUTO_SCROLL_OPTIONS,
      modifiers: modifiers2,
      collisionDetection: core.closestCenter,
      onDragEnd: handleDragEnd,
      onDragStart: onItemMoveStart,
      children: /* @__PURE__ */ jsxRuntime.jsx(sortable.SortableContext, { items, strategy: axis ? sortingStrategy(axis) : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { ...rest, children }) })
    }
  );
}), SortableListItem = React.forwardRef(
  function(props2, ref) {
    const { id: id2, children, disableTransition } = props2, { setNodeRef, transform, transition, active } = sortable.useSortable({
      id: id2,
      transition: disableTransition ? null : TRANSITION
    }), isActive = id2 === (active == null ? void 0 : active.id), style = React.useMemo(
      () => ({
        transform: utilities.CSS.Translate.toString(transform),
        transition,
        pointerEvents: active ? "none" : void 0
      }),
      [transform, transition, active]
    ), setRef = React.useCallback(
      (node) => {
        setNodeRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
      },
      [ref, setNodeRef]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      ListItem$2,
      {
        ref: setRef,
        style,
        $moving: isActive,
        className: isActive ? MOVING_ITEM_CLASS_NAME : "",
        "data-index": props2["data-index"],
        children
      }
    );
  }
);
function List(props2) {
  const { onItemMove, onItemMoveEnd, onItemMoveStart, sortable: sortable2, ...rest } = props2, handleSortEnd = React.useCallback(
    (event) => {
      onItemMove == null || onItemMove(event);
    },
    [onItemMove]
  );
  return sortable2 ? /* @__PURE__ */ jsxRuntime.jsx(
    SortableList,
    {
      onItemMove: handleSortEnd,
      onItemMoveStart,
      onItemMoveEnd,
      ...rest
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { ...rest });
}
const Item = React.forwardRef(function(props2, ref) {
  const { sortable: sortable2, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(SortableItemIdContext.Provider, { value: props2.id, children: sortable2 ? /* @__PURE__ */ jsxRuntime.jsx(SortableListItem, { ref, ...rest }) : /* @__PURE__ */ jsxRuntime.jsx(ListItem$2, { ref, ...rest }) });
});
function focusRingBorderStyle$1(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
function focusRingStyle$1(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle$1(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
function withFocusRing(component) {
  return styled__default.default(component)(
    (props2) => {
      const { $border, $radius } = props2, { card, color: color2, radius } = theme.getTheme_v2(props2.theme), border = { width: $border ? 1 : 0, color: "var(--card-border-color)" };
      return styled.css`
        --card-focus-box-shadow: ${focusRingBorderStyle$1(border)};

        border-radius: ${ui.rem(radius[$radius != null ? $radius : 1])};
        outline: none;
        box-shadow: var(--card-focus-box-shadow);

        &:focus {
          --card-focus-box-shadow: ${focusRingStyle$1({
        border,
        base: color2,
        focusRing: {
          ...card.focusRing,
          // An offset of 0 is needed to avoid the focus ring overlap the border of the inner items, the theme has an offset of -1
          // Detected in empty array items.
          offset: 0
        }
      })};
        }
      `;
    }
  );
}
function extractPastedFiles(dataTransfer) {
  return dataTransfer.files && dataTransfer.files.length > 0 ? Promise.resolve(Array.from(dataTransfer.files || [])) : normalizeItems(Array.from(dataTransfer.items || [])).then(flatten__default.default);
}
function extractDroppedFiles(dataTransfer) {
  const files = Array.from(dataTransfer.files || []), items = Array.from(dataTransfer.items || []);
  return files && files.length > 0 ? Promise.resolve(files) : normalizeItems(items).then(flatten__default.default);
}
function toArray(v) {
  return v === null ? [] : [v];
}
function normalizeItems(items) {
  return Promise.all(
    items.map((item) => {
      if (item.kind === "file" && item.webkitGetAsEntry) {
        let entry;
        try {
          entry = item.webkitGetAsEntry();
        } catch {
          return toArray(item.getAsFile());
        }
        return entry ? entry.isDirectory ? walk(entry) : toArray(item.getAsFile()) : [];
      }
      if (item.kind === "file") {
        const file = item.getAsFile();
        return Promise.resolve(file ? [file] : []);
      }
      return item.kind === "string" ? (console.warn('DataTransfer with kind="string" is currently not supported'), Promise.resolve([])) : (console.warn("Unknown DataTransferItem.kind: %s", item.kind), Promise.resolve([]));
    })
  );
}
function walk(entry) {
  if (entry.isFile)
    return new Promise((resolve, reject) => entry.file(resolve, reject)).then(
      (file) => [file]
    );
  if (entry.isDirectory) {
    const dir = entry.createReader();
    return new Promise((resolve, reject) => dir.readEntries(resolve, reject)).then((entries) => entries.filter((entr) => !entr.name.startsWith("."))).then((entries) => Promise.all(entries.map(walk)).then(flatten__default.default));
  }
  return Promise.resolve([]);
}
function imageUrlToBlob(imageUrl, format = "image/jpeg", quality = 1) {
  return imageUrl.match(/^webkit-fake-url:\/\//) ? Promise.reject(new Error("Cannot read image contents from webkit fake url")) : new Promise((resolve, reject) => {
    const loader = new Image();
    loader.crossOrigin = "anonymous", loader.referrerPolicy = "strict-origin-when-cross-origin", loader.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = loader.width, canvas.height = loader.height;
      const ctx = canvas.getContext("2d");
      ctx == null || ctx.drawImage(loader, 0, 0, canvas.width, canvas.height);
      try {
        canvas.toBlob(resolve, format, quality);
      } catch (error) {
        reject(error);
      }
    }, loader.src = imageUrl;
  });
}
const PASTE_INPUT_STYLE = { opacity: 0, position: "absolute" };
function fileTarget(Component) {
  return React.forwardRef(function(props2, ref) {
    const { onFiles, onFilesOver, onFilesOut, disabled, ...rest } = props2, [showPasteInput, setShowPasteInput] = React.useState(!1), pasteInput = React.useRef(null), forwardedRef = ui.useForwardedRef(ref), enteredElements = React.useRef([]), emitFiles = React.useCallback(
      (files) => {
        onFiles == null || onFiles(files);
      },
      [onFiles]
    ), handleKeyDown = React.useCallback(
      (event) => {
        event.target === forwardedRef.current && (event.ctrlKey || event.metaKey) && event.key === "v" && setShowPasteInput(!0);
      },
      [forwardedRef]
    ), handlePaste = React.useCallback(
      (event) => {
        extractPastedFiles(event.clipboardData).then((files) => pasteInput.current ? files.length > 0 ? files : (
          // Invoke Safari hack if we didn't get any files
          convertImagesToFilesAndClearContentEditable(pasteInput.current, "image/jpeg")
        ) : []).then((files) => {
          var _a2;
          emitFiles(files), setShowPasteInput(!1), (_a2 = forwardedRef.current) == null || _a2.focus();
        });
      },
      [emitFiles, forwardedRef]
    ), handleDrop = React.useCallback(
      (event) => {
        enteredElements.current = [], event.preventDefault(), event.stopPropagation();
        const dataTransfer = event.nativeEvent.dataTransfer;
        onFiles && dataTransfer && extractDroppedFiles(dataTransfer).then((files) => {
          files && emitFiles(files);
        }), onFilesOut == null || onFilesOut();
      },
      [emitFiles, onFiles, onFilesOut]
    ), handleDragOver = React.useCallback(
      (event) => {
        onFiles && (event.preventDefault(), event.stopPropagation());
      },
      [onFiles]
    ), handleDragEnter = React.useCallback(
      (event) => {
        if (event.stopPropagation(), onFilesOver && forwardedRef.current === event.currentTarget) {
          enteredElements.current = [...new Set(enteredElements.current), event.currentTarget];
          const fileTypes = Array.from(event.dataTransfer.items).map((item) => ({
            type: item.type,
            kind: item.kind
          }));
          onFilesOver(fileTypes);
        }
      },
      [onFilesOver, forwardedRef]
    ), handleDragLeave = React.useCallback(
      (event) => {
        event.stopPropagation();
        const idx = enteredElements.current.indexOf(event.currentTarget);
        idx > -1 && enteredElements.current.splice(idx, 1), enteredElements.current.length === 0 && (onFilesOut == null || onFilesOut());
      },
      [onFilesOut]
    ), prevShowPasteInput = React.useRef(!1);
    return React.useEffect(() => {
      var _a2;
      !prevShowPasteInput.current && showPasteInput && pasteInput.current ? (pasteInput.current.focus(), select(pasteInput.current)) : prevShowPasteInput.current && !showPasteInput && ((_a2 = pasteInput.current) == null || _a2.focus()), prevShowPasteInput.current = showPasteInput;
    }, [showPasteInput]), /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        Component,
        {
          ...rest,
          ref: forwardedRef,
          onKeyDown: disabled ? void 0 : handleKeyDown,
          onDragOver: disabled ? void 0 : handleDragOver,
          onDragEnter: disabled ? void 0 : handleDragEnter,
          onDragLeave: disabled ? void 0 : handleDragLeave,
          onDrop: disabled ? void 0 : handleDrop
        }
      ),
      !disabled && showPasteInput && /* @__PURE__ */ jsxRuntime.jsx("div", { contentEditable: !0, onPaste: handlePaste, ref: pasteInput, style: PASTE_INPUT_STYLE })
    ] });
  });
}
function convertImagesToFilesAndClearContentEditable(element, targetFormat = "image/jpeg") {
  return element.isContentEditable ? new Promise((resolve) => setTimeout(resolve, 10)).then(() => Array.from(element.querySelectorAll("img"))).then((imageElements) => (element.innerHTML = "", imageElements)).then((images) => Promise.all(images.map((img) => imageUrlToBlob(img.src)))).then(
    (imageBlobs) => imageBlobs.map((blob) => new File([blob], "pasted-image.jpg", { type: targetFormat }))
  ) : Promise.reject(
    new Error(
      `Expected element to be contentEditable="true". Instead found a non contenteditable ${element.tagName}`
    )
  );
}
function select(el) {
  const range2 = document.createRange();
  range2.selectNodeContents(el);
  const sel = window.getSelection();
  sel == null || sel.removeAllRanges(), sel == null || sel.addRange(range2);
}
function DropMessage(props2) {
  const { hoveringFiles, types: types2, resolveUploader: resolveUploader2 } = props2, acceptedFiles = hoveringFiles.filter(
    (file) => types2.some((type) => resolveUploader2(type, file))
  ), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, multiple = types2.length > 1, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: acceptedFiles.length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UploadIcon, {}) }),
      multiple ? t2("inputs.files.common.drop-message.drop-to-upload-multi", {
        count: acceptedFiles.length
      }) : t2("inputs.files.common.drop-message.drop-to-upload"),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, {})
    ] }),
    rejectedFilesCount > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t2("inputs.files.common.drop-message.drop-to-upload.rejected-file-message", {
        count: rejectedFilesCount
      }) })
    ] }) })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t2("inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message", {
      count: hoveringFiles.length
    }) })
  ] }) });
}
const Overlay$1 = styled__default.default(ui.Layer)`
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  background-color: var(--card-bg-color);
  opacity: 0.8;
`, Root$j = styled__default.default.div`
  position: relative;
`;
function getUploadCandidates(types2, resolveUploader2, file) {
  return types2.map((memberType) => ({
    type: memberType,
    uploader: resolveUploader2(memberType, file)
  })).filter((member) => member.uploader);
}
function uploadTarget(Component) {
  const FileTarget2 = fileTarget(Component);
  return React.forwardRef(function(props2, forwardedRef) {
    const { children, resolveUploader: resolveUploader2, onUpload, types: types2, ...rest } = props2, { push: pushToast } = ui.useToast(), { t: t2 } = useTranslation(), uploadFile2 = React.useCallback(
      (file, resolvedUploader) => {
        const { type, uploader } = resolvedUploader;
        onUpload == null || onUpload({ file, schemaType: type, uploader });
      },
      [onUpload]
    ), handleFiles = React.useCallback(
      (files) => {
        if (!resolveUploader2)
          return;
        const tasks = files.map((file) => ({
          file,
          uploaderCandidates: getUploadCandidates(types2, resolveUploader2, file)
        })), ready = tasks.filter((task) => task.uploaderCandidates.length > 0), rejected = tasks.filter((task) => task.uploaderCandidates.length === 0);
        rejected.length > 0 && pushToast({
          closable: !0,
          status: "warning",
          title: t2("inputs.array.error.cannot-upload-unable-to-convert", {
            count: rejected.length
          }),
          description: rejected.map((task, i) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, padding: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: task.file.name }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
              "(",
              task.file.type,
              ")"
            ] }) })
          ] }, i))
        }), ready.forEach((task) => {
          uploadFile2(
            task.file,
            // eslint-disable-next-line max-nested-callbacks
            sortBy__default.default(task.uploaderCandidates, (candidate) => candidate.uploader.priority)[0]
          );
        });
      },
      [pushToast, resolveUploader2, types2, uploadFile2, t2]
    ), [hoveringFiles, setHoveringFiles] = React.useState([]), handleFilesOut = React.useCallback(() => setHoveringFiles([]), []);
    return /* @__PURE__ */ jsxRuntime.jsx(Root$j, { children: /* @__PURE__ */ jsxRuntime.jsxs(
      FileTarget2,
      {
        ...rest,
        ref: forwardedRef,
        onFiles: handleFiles,
        onFilesOver: setHoveringFiles,
        onFilesOut: handleFilesOut,
        children: [
          resolveUploader2 && hoveringFiles.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(Overlay$1, { zOffset: 10, children: /* @__PURE__ */ jsxRuntime.jsx(
            DropMessage,
            {
              hoveringFiles,
              types: types2,
              resolveUploader: resolveUploader2
            }
          ) }),
          children
        ]
      }
    ) });
  });
}
const UploadTargetCard = withFocusRing(uploadTarget(ui.Card)), POPOVER_PROPS$2 = {
  constrainSize: !0,
  portal: !0,
  fallbackPlacements: ["top", "bottom"]
};
function ArrayOfObjectsFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2, menuButtonId = React.useId(), { t: t2 } = useTranslation(), insertItem = React.useCallback(
    (itemType) => {
      const item = onValueCreate(itemType);
      onItemAppend(item);
    },
    [onValueCreate, onItemAppend]
  ), handleAddBtnClick = React.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]), addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { portal: !0, content: t2("inputs.array.read-only-label"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { icon: icons.AddIcon, mode: "ghost", disabled: !0, size: "large", text: t2(addItemI18nKey) }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [
    schemaType.of.length === 1 ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.AddIcon,
        mode: "ghost",
        onClick: handleAddBtnClick,
        size: "large",
        text: t2(addItemI18nKey)
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { icon: icons.AddIcon, mode: "ghost", size: "large", text: t2(addItemI18nKey) }),
        id: menuButtonId || "",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: schemaType.of.map((memberDef, i) => {
          var _a2, _b;
          const referenceIcon = types.isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon, icon = memberDef.icon || ((_a2 = memberDef.type) == null ? void 0 : _a2.icon) || referenceIcon;
          return /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: memberDef.title || ((_b = memberDef.type) == null ? void 0 : _b.name),
              onClick: () => insertItem(memberDef),
              icon
            },
            i
          );
        }) }),
        popover: POPOVER_PROPS$2
      }
    ),
    children
  ] });
}
const FooterFlex = styled__default.default(ui.Flex)`
  min-height: 33px;
`, PresenceFlex = styled__default.default(ui.Flex)`
  position: absolute;
  top: 0;
  right: 0;
  height: 33px;
`, DragHandleCard = styled__default.default(ui.Card)`
  position: absolute;
  top: 0;
  left: 0;
`, Root$i = styled__default.default(ui.Card)`
  transition: border-color 250ms;
  box-sizing: border-box;
  position: relative;

  @media (hover: hover) {
    ${DragHandleCard} {
      opacity: 0;
    }

    &:hover,
    &:focus-within {
      ${DragHandleCard} {
        opacity: 1;
      }
    }
  }

  .${MOVING_ITEM_CLASS_NAME} & {
    box-shadow:
      0 0 0 0,
      0 8px 17px 2px var(--card-shadow-umbra-color),
      0 3px 14px 2px var(--card-shadow-penumbra-color),
      0 5px 5px -3px var(--card-shadow-ambient-color);
  }

  &[aria-selected='true'] {
    box-shadow: 0 0 0 2px var(--card-focus-ring-color);
  }
`;
function CellLayout(props2) {
  const { validation: validation2, selected, tone, presence, children, dragHandle, menu, footer, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$i,
    {
      forwardedAs: ui.Flex,
      direction: "column",
      border: !0,
      selected,
      "aria-selected": selected,
      radius: 1,
      tone,
      ...rest,
      children: [
        children,
        dragHandle && /* @__PURE__ */ jsxRuntime.jsx(
          DragHandleCard,
          {
            margin: 1,
            radius: 2,
            display: "flex",
            tone: "inherit",
            "data-ui": "DragHandleCard",
            children: /* @__PURE__ */ jsxRuntime.jsx(DragHandle, { $grid: !0, mode: "ghost" })
          }
        ),
        presence && /* @__PURE__ */ jsxRuntime.jsx(PresenceFlex, { align: "center", marginX: 1, children: presence }),
        /* @__PURE__ */ jsxRuntime.jsxs(FooterFlex, { align: "center", paddingX: 1, sizing: "border", justify: "space-between", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: validation2 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: footer }),
          menu
        ] })
      ]
    }
  );
}
const PopoverCard$1 = styled__default.default(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType$1(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard$1, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          style: { height: "100%" },
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, marginTop: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 4, children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) })
          ] })
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$9 = { portal: !0, tone: "default" };
function ErrorItem$1(props2) {
  const { member, sortable: sortable2 } = props2, id2 = React.useId(), { onChange } = useFormCallbacks(), { t: t2 } = useTranslation(), handleRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([{ _key: member.key }])]));
  }, [onChange, member.key]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CellLayout,
    {
      dragHandle: sortable2,
      tone: "caution",
      style: { height: "100%" },
      menu: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.MenuButton,
        {
          button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
          id: `${id2}-menuButton`,
          menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.remove-invalid-item"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: handleRemove
            }
          ) }),
          popover: MENU_POPOVER_PROPS$9
        }
      ),
      children: member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$1, { value: member.error.value, vertical: !0 }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) })
    }
  );
}
function pathToString(path = []) {
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number")
      return `${target}[${segment}]`;
    if (segmentType === "string")
      return `${target}${i === 0 ? "" : "."}${segment}`;
    if (types.isKeyedObject(segment))
      return `${target}[_key=="${segment._key}"]`;
    throw new Error(`Unsupported path segment "${segment}"`);
  }, "");
}
function isNonNullable$1(t2) {
  return t2 !== null || t2 !== void 0;
}
function convertToValidationMarker(validatorResult, level, context) {
  if (!context)
    throw new Error("missing context");
  if (validatorResult === !0)
    return [];
  if (Array.isArray(validatorResult))
    return validatorResult.flatMap((child) => convertToValidationMarker(child, level, context)).filter(isNonNullable$1);
  if (typeof validatorResult == "string")
    return convertToValidationMarker({ message: validatorResult }, level, context);
  if (typeof validatorResult.message != "string")
    throw new Error(
      `${pathToString(
        context.path
      )}: Validator must return 'true' if valid or an error message as a string on errors`
    );
  const { message } = validatorResult, normalizedPaths = [];
  validatorResult.path && normalizedPaths.push(validatorResult.path);
  for (const path of validatorResult.paths || [])
    normalizedPaths.push(path);
  return normalizedPaths.length ? normalizedPaths.map((path) => ({
    path: (context.path || []).concat(path),
    level: level || "error",
    item: { message },
    message
  })) : [
    {
      level: level || "error",
      item: { message },
      message,
      path: context.path || []
    }
  ];
}
function escapeRegex(string) {
  return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
}
function localizeMessage(message, i18n) {
  const { currentLocale } = i18n, locale = currentLocale.id;
  if (message[locale])
    return message[locale];
  if (locale.includes("-")) {
    const language = locale.split("-", 1)[0];
    if (message[language])
      return message[language];
  }
  return message["en-US"] || message["en-GB"] || message.en || "Unknown validation error (not localized)";
}
function isLocalizedMessages(message) {
  return message !== !0 && typeof message < "u" && typeof message != "string" && isPlainObject__default.default(message) && !("message" in message);
}
function deepEquals(a, b) {
  if (a === b)
    return !0;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length != b.length)
      return !1;
    for (let i = 0; i < a.length; i++)
      if (!deepEquals(a[i], b[i]))
        return !1;
    return !0;
  }
  if (Array.isArray(a) != Array.isArray(b))
    return !1;
  if (a && b && typeof a == "object" && typeof b == "object") {
    const keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length)
      return !1;
    if (a instanceof Date && b instanceof Date)
      return a.getTime() === b.getTime();
    if (a instanceof Date != b instanceof Date)
      return !1;
    if (a instanceof RegExp && b instanceof RegExp)
      return a.toString() == b.toString();
    if (a instanceof RegExp != b instanceof RegExp)
      return !1;
    for (let i = 0; i < keys.length; i++)
      if (keys[i] !== "_key" && !Object.prototype.hasOwnProperty.call(b, keys[i]))
        return !1;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== "_key" && !deepEquals(a[key], b[key]))
        return !1;
    }
    return !0;
  }
  return !1;
}
const _toString = {}.toString, builtIns = [Object, Function, Array, String, Boolean, Number, Date, RegExp, Error];
function isBuiltIn(_constructor) {
  for (let i = 0; i < builtIns.length; i++)
    if (builtIns[i] === _constructor)
      return !0;
  return !1;
}
function typeString(obj) {
  const stringType = _toString.call(obj).slice(8, -1);
  if (obj == null)
    return stringType.toLowerCase();
  const constructorType = obj.constructor;
  return constructorType && !isBuiltIn(constructorType) ? constructorType.name : stringType;
}
const SLOW_VALIDATOR_TIMEOUT = 5e3, formatValidationErrors = (options) => {
  var _a2;
  return options.message ? options.message : options.results.length === 1 ? (_a2 = options.results[0]) == null ? void 0 : _a2.message : options.i18n.t("{{messages, list}}", {
    messages: options.results.map((err) => {
      var _a22;
      return err.message || ((_a22 = err.item) == null ? void 0 : _a22.message);
    }),
    formatParams: { messages: { style: "long", type: options.operation } }
  });
}, genericValidators = {
  type: (expectedType, value, message, { i18n }) => {
    const actualType = typeString(value);
    return actualType !== expectedType && actualType !== "undefined" ? message || i18n.t("validation:generic.incorrect-type", { actualType, expectedType }) : !0;
  },
  presence: (expected, value, message, { i18n }) => value === void 0 && expected === "required" ? message || i18n.t("validation:generic.required") : !0,
  all: async (children, value, message, context) => {
    const results = (await Promise.all(children.map((child) => child.validate(value, context)))).flat();
    return results.length === 0 ? !0 : formatValidationErrors({
      message,
      results,
      operation: "conjunction",
      i18n: context.i18n
    });
  },
  either: async (children, value, message, context) => {
    const resolved = await Promise.all(children.map((child) => child.validate(value, context))), results = resolved.flat();
    return resolved.find((result) => !result.length) ? !0 : formatValidationErrors({
      message,
      results,
      operation: "disjunction",
      i18n: context.i18n
    });
  },
  valid: (allowedValues, actual, message, { i18n }) => {
    const valueType = typeof actual;
    if (valueType === "undefined")
      return !0;
    const value = (valueType === "number" || valueType === "string") && `${actual}`, strValue = value && value.length > 30 ? `${value.slice(0, 30)}\u2026` : value;
    return allowedValues.some((expected) => deepEquals(expected, actual)) ? !0 : message || i18n.t(
      "validation:generic.not-allowed",
      value ? { context: "hint", replace: { hint: strValue } } : {}
    );
  },
  custom: async (fn, value, message, context) => {
    const slowTimer = setTimeout(() => {
      context.environment === "studio" && console.warn(
        `Custom validator at ${pathToString(
          context.path
        )} has taken more than ${SLOW_VALIDATOR_TIMEOUT}ms to respond`
      );
    }, SLOW_VALIDATOR_TIMEOUT);
    let result;
    try {
      result = await fn(value, context);
    } finally {
      clearTimeout(slowTimer);
    }
    return isLocalizedMessages(result) ? localizeMessage(result, context.i18n) : typeof result == "string" && message || result;
  }
}, arrayValidators = {
  ...genericValidators,
  min: (minLength, value, message, { i18n, type }) => {
    if (!value || value.length >= minLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.minimum-length", { minLength, context });
  },
  max: (maxLength, value, message, { i18n, type }) => {
    if (!value || value.length <= maxLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.maximum-length", { maxLength, context });
  },
  length: (wantedLength, value, message, { i18n, type }) => {
    if (!value || value.length === wantedLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.exact-length", { wantedLength, context });
  },
  presence: (flag, value, message, { i18n }) => flag === "required" && !value ? message || i18n.t("validation:generic.required", { context: "array" }) : !0,
  valid: (allowedValues, values2, message, { i18n }) => {
    if (typeof values2 > "u")
      return !0;
    const paths = [];
    for (let i = 0; i < values2.length; i++) {
      const value = values2[i];
      if (allowedValues.some((expected) => deepEquals(expected, value)))
        continue;
      const pathSegment = value && value._key ? { _key: value._key } : i;
      paths.push([pathSegment]);
    }
    const sharedMessage = message || i18n.t("validation:generic.not-allowed");
    return paths.map((path) => ({ message: sharedMessage, path }));
  },
  unique: (_unused, value, message, { i18n }) => {
    const dupeIndices = [];
    if (!value)
      return !0;
    for (let x = 0; x < value.length; x++)
      for (let y = x + 1; y < value.length; y++) {
        const itemA = value[x], itemB = value[y];
        deepEquals(itemA, itemB) && (dupeIndices.indexOf(x) === -1 && dupeIndices.push(x), dupeIndices.indexOf(y) === -1 && dupeIndices.push(y));
      }
    const paths = dupeIndices.map((idx) => {
      const item = value[idx];
      return [item && item._key ? { _key: item._key } : idx];
    }), sharedMessage = message || i18n.t("validation:array.item-duplicate");
    return paths.map((path) => ({ message: sharedMessage, path }));
  }
}, booleanValidators = {
  ...genericValidators,
  presence: (flag, value, message, { i18n }) => flag === "required" && typeof value != "boolean" ? message || i18n.t("validation:generic.required", { context: "boolean" }) : !0
};
function isRecord$3(obj) {
  return typeof obj == "object" && obj !== null && !Array.isArray(obj);
}
const isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/, getFormattedDate = (type = "", value, options) => {
  const dateFormat = (options == null ? void 0 : options.dateFormat) || legacyDateFormat__namespace.DEFAULT_DATE_FORMAT, timeFormat = (options == null ? void 0 : options.timeFormat) || legacyDateFormat__namespace.DEFAULT_TIME_FORMAT;
  return legacyDateFormat__namespace.format(
    value,
    type === "date" ? dateFormat : `${dateFormat} ${timeFormat}`,
    type === "date"
  );
};
function parseDate(date, throwOnError = !1) {
  if (!date)
    return null;
  if (date === "now")
    return /* @__PURE__ */ new Date();
  const parsed = new Date(date), isInvalid = isNaN(parsed.getTime());
  if (isInvalid && throwOnError)
    throw new Error(`Unable to parse "${date}" to a date`);
  return isInvalid ? null : parsed;
}
const dateValidators = {
  ...genericValidators,
  type: (_unused, value, message, { i18n }) => typeof value > "u" || isoDate.test(`${value}`) ? !0 : message || i18n.t("validation:date.invalid-format"),
  min: (minDate, value, message, { type, i18n }) => {
    const dateVal = parseDate(value), minDateVal = parseDate(minDate, !0);
    if (!dateVal || !value || dateVal >= minDateVal)
      return !0;
    if (!type)
      throw new Error("`type` was not provided in validation context.");
    const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
    return message || // Note that the `minDate` passed here is _formatted_, while the raw value provided to the
    // validator is available as `providedMinDate`. This because the formatted date is likely
    // what the developer wants to present to the user
    i18n.t("validation:date.minimum", {
      minDate: getFormattedDate(type.name, minDateVal, dateTimeOptions),
      providedMinDate: minDate
    });
  },
  max: (maxDate, value, message, { type, i18n }) => {
    const dateVal = parseDate(value), maxDateVal = parseDate(maxDate, !0);
    if (!dateVal || !value || dateVal <= maxDateVal)
      return !0;
    if (!type)
      throw new Error("`type` was not provided in validation context.");
    const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
    return message || // Note that the `maxDate` passed here is _formatted_, while the raw value provided to the
    // validator is available as `providedMaxDate`. This because the formatted date is likely
    // what the developer wants to present to the user
    i18n.t("validation:date.maximum", {
      maxDate: getFormattedDate(type.name, maxDateVal, dateTimeOptions),
      providedMaxDate: maxDate
    });
  }
}, precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/, numberValidators = {
  ...genericValidators,
  integer: (_unused, value, message, { i18n }) => Number.isInteger(value) ? !0 : message || i18n.t("validation:number.non-integer"),
  precision: (limit, value, message, { i18n }) => {
    if (value === void 0)
      return !0;
    const places = value.toString().match(precisionRx);
    return Math.max(
      (places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0),
      0
    ) > limit ? message || i18n.t("validation:number.maximum-precision", { limit }) : !0;
  },
  min: (minNumber, value, message, { i18n }) => value >= minNumber ? !0 : message || i18n.t("validation:number.minimum", { minNumber }),
  max: (maxNumber, value, message, { i18n }) => value <= maxNumber ? !0 : message || i18n.t("validation:number.maximum", { maxNumber }),
  greaterThan: (threshold, value, message, { i18n }) => value > threshold ? !0 : message || i18n.t("validation:number.greater-than", { threshold }),
  lessThan: (threshold, value, message, { i18n }) => value < threshold ? !0 : message || i18n.t("validation:number.less-than", { threshold })
}, metaKeys = ["_key", "_type", "_weak"], objectValidators = {
  ...genericValidators,
  presence: (expected, value, message, { i18n }) => {
    if (expected !== "required")
      return !0;
    const keys = value && Object.keys(value).filter((key) => !metaKeys.includes(key));
    return value === void 0 || keys && keys.length === 0 ? message || i18n.t("validation:generic.required", { context: "object" }) : !0;
  },
  reference: async (_unused, value, message, context) => {
    if (!value)
      return !0;
    const { type, getDocumentExists, i18n } = context;
    if (!types.isReference(value))
      return message || i18n.t("validation:object.not-reference");
    if (!type)
      throw new Error("`type` was not provided in validation context");
    if ("weak" in type && type.weak)
      return !0;
    if (!getDocumentExists)
      throw new Error("`getDocumentExists` was not provided in validation context");
    return await getDocumentExists({ id: value._ref }) ? !0 : i18n.t("validation:object.reference-not-published", { documentId: value._ref });
  },
  assetRequired: (flag, value, message, { i18n }) => !value || !value.asset || !value.asset._ref ? message || i18n.t("validation:object.asset-required", { context: flag.assetType || "" }) : !0
}, DUMMY_ORIGIN = "http://sanity", isRelativeUrl = (url) => /^\.*\//.test(url), emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, stringValidators = {
  ...genericValidators,
  min: (minLength, value, message, { i18n }) => !value || value.length >= minLength ? !0 : message || i18n.t("validation:string.minimum-length", { minLength }),
  max: (maxLength, value, message, { i18n }) => !value || value.length <= maxLength ? !0 : message || i18n.t("validation:string.maximum-length", { maxLength }),
  length: (wantedLength, value, message, { i18n }) => (value || "").length === wantedLength ? !0 : message || i18n.t("validation:string.exact-length", { wantedLength }),
  uri: (constraints, value, message, { i18n }) => {
    const strValue = value || "";
    if (!strValue)
      return !0;
    const { options } = constraints, { allowCredentials, relativeOnly } = options, allowRelative = options.allowRelative || relativeOnly;
    let url;
    try {
      url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
    } catch {
      return message || i18n.t("validation:string.url.invalid");
    }
    if (relativeOnly && url.origin !== DUMMY_ORIGIN)
      return message || i18n.t("validation:string.url.not-relative");
    if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue))
      return message || i18n.t("validation:string.url.not-absolute");
    if (!allowCredentials && (url.username || url.password))
      return message || i18n.t("validation:string.url.includes-credentials");
    const urlScheme = url.protocol.replace(/:$/, "");
    return options.scheme.some((scheme) => scheme.test(urlScheme)) ? !0 : message || i18n.t("validation:string.url.disallowed-scheme", { scheme: urlScheme });
  },
  stringCasing: (casing, value, message, { i18n }) => {
    const strValue = value || "";
    return casing === "uppercase" && strValue !== strValue.toLocaleUpperCase() ? message || i18n.t("validation:string.uppercase") : casing === "lowercase" && strValue !== strValue.toLocaleLowerCase() ? message || i18n.t("validation:string.lowercase") : !0;
  },
  presence: (flag, value, message, { i18n }) => flag === "required" && !value ? message || i18n.t("validation:generic.required", { context: "string" }) : !0,
  regex: (options, value, message, { i18n }) => {
    const { pattern, name, invert } = options, regName = name || `${pattern.toString()}`, strValue = value || "";
    pattern.lastIndex = 0;
    const matches = pattern.test(strValue);
    return !invert && !matches || invert && matches ? message || (invert ? i18n.t("validation:string.regex-match", { name: regName }) : i18n.t("validation:string.regex-does-not-match", { name: regName })) : !0;
  },
  email: (_unused, value, message, { i18n }) => {
    const strValue = `${value || ""}`.trim();
    return !strValue || emailRegex.test(strValue) ? !0 : message || i18n.t("validation:string.email");
  }
}, typeValidators = {
  Boolean: booleanValidators,
  Number: numberValidators,
  String: stringValidators,
  Array: arrayValidators,
  Object: objectValidators,
  Date: dateValidators
}, getBaseType = (type) => type && type.type ? getBaseType(type.type) : type, isFieldRef = (constraint) => typeof constraint != "object" || !constraint ? !1 : constraint.type === Rule.FIELD_REF, EMPTY_ARRAY$4 = [], FIELD_REF = Symbol("FIELD_REF"), ruleConstraintTypes$1 = [
  "Array",
  "Boolean",
  "Date",
  "Number",
  "Object",
  "String"
];
var _a;
const Rule = (_a = class {
  constructor(typeDef) {
    this._type = void 0, this._level = void 0, this._required = void 0, this._typeDef = void 0, this._message = void 0, this._rules = [], this._fieldRules = void 0, this.valueOfField = _a.valueOfField.bind(_a), this._typeDef = typeDef, this.reset();
  }
  _mergeRequired(next) {
    if (this._required === "required" || next._required === "required")
      return "required";
    if (this._required === "optional" || next._required === "optional")
      return "optional";
  }
  error(message) {
    const rule = this.clone();
    return rule._level = "error", rule._message = message || void 0, rule;
  }
  warning(message) {
    const rule = this.clone();
    return rule._level = "warning", rule._message = message || void 0, rule;
  }
  info(message) {
    const rule = this.clone();
    return rule._level = "info", rule._message = message || void 0, rule;
  }
  reset() {
    return this._type = this._type || void 0, this._rules = (this._rules || []).filter((rule) => rule.flag === "type"), this._message = void 0, this._required = void 0, this._level = "error", this._fieldRules = void 0, this;
  }
  isRequired() {
    return this._required === "required";
  }
  clone() {
    const rule = new _a();
    return rule._type = this._type, rule._message = this._message, rule._required = this._required, rule._rules = cloneDeep__default.default(this._rules), rule._level = this._level, rule._fieldRules = this._fieldRules, rule._typeDef = this._typeDef, rule;
  }
  cloneWithRules(rules) {
    const rule = this.clone(), newRules = /* @__PURE__ */ new Set();
    return rules.forEach((curr) => {
      curr.flag === "type" && (rule._type = curr.constraint), newRules.add(curr.flag);
    }), rule._rules = rule._rules.filter((curr) => {
      const disallowDuplicate = ["type", "uri", "email"].includes(curr.flag), isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules), rule;
  }
  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type)
      throw new Error("merge() failed: conflicting types");
    const newRule = this.cloneWithRules(rule._rules);
    return newRule._type = this._type || rule._type, newRule._message = this._message || rule._message, newRule._required = this._mergeRequired(rule), newRule._level = this._level === "error" ? rule._level : this._level, newRule;
  }
  // Validation flag setters
  type(targetType) {
    const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}`;
    if (!ruleConstraintTypes$1.includes(type))
      throw new Error(`Unknown type "${targetType}"`);
    const rule = this.cloneWithRules([{ flag: "type", constraint: type }]);
    return rule._type = type, rule;
  }
  all(children) {
    return this.cloneWithRules([{ flag: "all", constraint: children }]);
  }
  either(children) {
    return this.cloneWithRules([{ flag: "either", constraint: children }]);
  }
  // Shared rules
  optional() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "optional" }]);
    return rule._required = "optional", rule;
  }
  required() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "required" }]);
    return rule._required = "required", rule;
  }
  custom(fn, options = {}) {
    return options.bypassConcurrencyLimit && Object.assign(fn, { bypassConcurrencyLimit: !0 }), this.cloneWithRules([{ flag: "custom", constraint: fn }]);
  }
  min(len) {
    return this.cloneWithRules([{ flag: "min", constraint: len }]);
  }
  max(len) {
    return this.cloneWithRules([{ flag: "max", constraint: len }]);
  }
  length(len) {
    return this.cloneWithRules([{ flag: "length", constraint: len }]);
  }
  valid(value) {
    const values2 = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{ flag: "valid", constraint: values2 }]);
  }
  // Numbers only
  integer() {
    return this.cloneWithRules([{ flag: "integer" }]);
  }
  precision(limit) {
    return this.cloneWithRules([{ flag: "precision", constraint: limit }]);
  }
  positive() {
    return this.cloneWithRules([{ flag: "min", constraint: 0 }]);
  }
  negative() {
    return this.cloneWithRules([{ flag: "lessThan", constraint: 0 }]);
  }
  greaterThan(num) {
    return this.cloneWithRules([{ flag: "greaterThan", constraint: num }]);
  }
  lessThan(num) {
    return this.cloneWithRules([{ flag: "lessThan", constraint: num }]);
  }
  // String only
  uppercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "uppercase" }]);
  }
  lowercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "lowercase" }]);
  }
  regex(pattern, a, b) {
    var _a2, _b;
    const name = typeof a == "string" ? a : (_a2 = a == null ? void 0 : a.name) != null ? _a2 : b == null ? void 0 : b.name, invert = typeof a == "string" ? !1 : (_b = a == null ? void 0 : a.invert) != null ? _b : b == null ? void 0 : b.invert, constraint = {
      pattern,
      name,
      invert: invert || !1
    };
    return this.cloneWithRules([{ flag: "regex", constraint }]);
  }
  email() {
    return this.cloneWithRules([{ flag: "email" }]);
  }
  uri(opts) {
    const optsScheme = (opts == null ? void 0 : opts.scheme) || ["http", "https"], schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
    if (!schemes.length)
      throw new Error("scheme must have at least 1 scheme specified");
    const constraint = {
      options: {
        scheme: schemes.map((scheme) => {
          if (!(scheme instanceof RegExp) && typeof scheme != "string")
            throw new Error("scheme must be a RegExp or a String");
          return typeof scheme == "string" ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme;
        }),
        allowRelative: (opts == null ? void 0 : opts.allowRelative) || !1,
        relativeOnly: (opts == null ? void 0 : opts.relativeOnly) || !1,
        allowCredentials: (opts == null ? void 0 : opts.allowCredentials) || !1
      }
    };
    return this.cloneWithRules([{ flag: "uri", constraint }]);
  }
  // Array only
  unique() {
    return this.cloneWithRules([{ flag: "unique" }]);
  }
  // Objects only
  reference() {
    return this.cloneWithRules([{ flag: "reference" }]);
  }
  fields(rules) {
    if (this._type !== "Object")
      throw new Error("fields() can only be called on an object type");
    const rule = this.cloneWithRules([]);
    return rule._fieldRules = rules, rule;
  }
  assetRequired() {
    const base = getBaseType(this._typeDef);
    let assetType;
    return base && ["image", "file"].includes(base.name) ? assetType = base.name === "image" ? "image" : "file" : assetType = "asset", this.cloneWithRules([{ flag: "assetRequired", constraint: { assetType } }]);
  }
  async validate(value, { __internal = {}, ...context }) {
    const { customValidationConcurrencyLimiter } = __internal, valueIsEmpty = value == null;
    if (valueIsEmpty && this._required === "optional")
      return EMPTY_ARRAY$4;
    const rules = (
      // Run only the _custom_ functions if the rule is not set to required or optional
      this._required === void 0 && valueIsEmpty ? this._rules.filter((curr) => curr.flag === "custom") : this._rules
    ), validators = this._type && typeValidators[this._type] || genericValidators;
    return (await Promise.all(
      rules.map(async (curr) => {
        if (curr.flag === void 0)
          throw new Error('Invalid rule, did not contain "flag"-property');
        const validator = validators[curr.flag];
        if (!validator) {
          const forType = this._type ? `type "${this._type}"` : "rule without declared type";
          throw new Error(`Validator for flag "${curr.flag}" not found for ${forType}`);
        }
        let specConstraint = "constraint" in curr ? curr.constraint : null;
        if (isFieldRef(specConstraint) && (specConstraint = get__default.default(context.parent, specConstraint.path)), curr.flag === "custom" && customValidationConcurrencyLimiter && !(specConstraint != null && specConstraint.bypassConcurrencyLimit)) {
          const customValidator = specConstraint;
          specConstraint = async (...args) => {
            await customValidationConcurrencyLimiter.ready();
            try {
              return await customValidator(...args);
            } finally {
              customValidationConcurrencyLimiter.release();
            }
          };
        }
        const message = isLocalizedMessages(this._message) ? localizeMessage(this._message, context.i18n) : this._message;
        try {
          const result = await validator(specConstraint, value, message, context);
          return convertToValidationMarker(result, this._level, context);
        } catch (err) {
          const errorMessage = `${pathToString(
            context.path
          )}: Exception occurred while validating value: ${err.message}`;
          return convertToValidationMarker({ message: errorMessage }, "error", context);
        }
      })
    )).flat();
  }
}, _a.FIELD_REF = FIELD_REF, _a.array = (def) => new _a(def).type("Array"), _a.object = (def) => new _a(def).type("Object"), _a.string = (def) => new _a(def).type("String"), _a.number = (def) => new _a(def).type("Number"), _a.boolean = (def) => new _a(def).type("Boolean"), _a.dateTime = (def) => new _a(def).type("Date"), _a.valueOfField = (path) => ({
  type: FIELD_REF,
  path
}), _a), memoizedWarnOnArraySlug = memoize__default.default(warnOnArraySlug);
function getDocumentIds(id2) {
  const isDraft2 = id2.indexOf("drafts.") === 0;
  return {
    published: isDraft2 ? id2.slice(7) : id2,
    draft: isDraft2 ? id2 : `drafts.${id2}`
  };
}
function serializePath(path) {
  return path.reduce((target, part, i) => {
    const isIndex = typeof part == "number", isKey = types.isKeyedObject(part), add = isIndex || isKey ? "[]" : `${i === 0 ? "" : "."}${part}`;
    return `${target}${add}`;
  }, "");
}
const defaultIsUnique = (slug2, context) => {
  const { getClient, document: document2, path, type } = context, schemaOptions = type == null ? void 0 : type.options;
  if (!document2)
    throw new Error("`document` was not provided in validation context.");
  if (!path)
    throw new Error("`path` was not provided in validation context.");
  const disableArrayWarning = (schemaOptions == null ? void 0 : schemaOptions.disableArrayWarning) || !1, { published, draft } = getDocumentIds(document2._id), docType = document2._type, atPath = serializePath(path.concat("current"));
  !disableArrayWarning && atPath.includes("[]") && context.environment === "studio" && memoizedWarnOnArraySlug(serializePath(path));
  const constraints = [
    "_type == $docType",
    "!(_id in [$draft, $published])",
    `${atPath} == $slug`
  ].join(" && ");
  return getClient({ apiVersion: "2023-11-13" }).fetch(
    `!defined(*[${constraints}][0]._id)`,
    {
      docType,
      draft,
      published,
      slug: slug2
    },
    { tag: "validation.slug-is-unique" }
  );
};
function warnOnArraySlug(serializedPath) {
  console.warn(
    [
      `Slug field at path ${serializedPath} is within an array and cannot be automatically checked for uniqueness`,
      'If you need to check for uniqueness, provide your own "isUnique" method',
      "To disable this message, set `disableArrayWarning: true` on the slug `options` field"
    ].join(`
`)
  );
}
const slugValidator = async (value, context) => {
  var _a2;
  if (!value)
    return !0;
  const { i18n } = context;
  if (typeof value != "object" || Array.isArray(value))
    return i18n.t("validation:slug.not-object");
  if (!types.isSlug(value) || value.current.trim().length === 0)
    return i18n.t("validation:slug.missing-current");
  const options = (_a2 = context == null ? void 0 : context.type) == null ? void 0 : _a2.options, isUnique = (options == null ? void 0 : options.isUnique) || defaultIsUnique, slugContext = {
    ...context,
    parent: context.parent,
    type: context.type,
    defaultIsUnique
  };
  return await isUnique(value.current, slugContext) ? !0 : i18n.t("validation:slug.not-unique", { slug: value.current });
}, ruleConstraintTypes = {
  array: !0,
  boolean: !0,
  date: !0,
  number: !0,
  object: !0,
  string: !0
}, isRuleConstraint = (typeString2) => typeString2 in ruleConstraintTypes;
function getTypeChain(type, visited = /* @__PURE__ */ new Set()) {
  return type ? visited.has(type) ? [] : (visited.add(type), [...type.type ? getTypeChain(type.type, visited) : [], type]) : [];
}
function baseRuleReducer(inputRule, type) {
  let baseRule = inputRule;
  isRuleConstraint(type.jsonType) && (baseRule = baseRule.type(type.jsonType));
  const typeOptionsList = (
    // if type.options is truthy
    (type == null ? void 0 : type.options) && // and type.options is an object (non-null from the previous)
    typeof type.options == "object" && // and if `list` is in options
    "list" in type.options && // then finally access the list
    type.options.list
  );
  return Array.isArray(typeOptionsList) && (baseRule = baseRule.valid(
    typeOptionsList.map((option) => extractValueFromListOption(option, type))
  )), type.name === "datetime" || type.name === "date" ? baseRule.type("Date") : type.name === "url" ? baseRule.uri() : type.name === "slug" ? baseRule.custom(slugValidator, { bypassConcurrencyLimit: !0 }) : type.name === "reference" ? baseRule.reference() : type.name === "email" ? baseRule.email() : baseRule;
}
function hasValueField(typeDef) {
  return typeDef ? !("fields" in typeDef) && typeDef.type ? hasValueField(typeDef.type) : !("fields" in typeDef) || !Array.isArray(typeDef.fields) ? !1 : typeDef.fields.some((field) => field.name === "value") : !1;
}
function extractValueFromListOption(option, typeDef) {
  return typeDef.jsonType === "object" && hasValueField(typeDef) || option.value === void 0 ? option : option.value;
}
function normalizeValidationRules(typeDef) {
  if (!typeDef)
    return [];
  const validation2 = typeDef.validation;
  if (Array.isArray(validation2))
    return validation2.flatMap(
      (i) => normalizeValidationRules({
        ...typeDef,
        validation: i
      })
    );
  if (validation2 && typeof validation2 == "object")
    return [validation2];
  const baseRule = (
    // using an object + Object.values to de-dupe the type chain by type name
    Object.values(
      getTypeChain(typeDef).reduce((acc, type) => (acc[type.name] = type, acc), {})
    ).reduce(baseRuleReducer, new Rule(typeDef))
  );
  return validation2 ? normalizeValidationRules({
    ...typeDef,
    validation: validation2(baseRule)
  }) : [baseRule];
}
function inferFromSchemaType(typeDef) {
  return traverse(typeDef, /* @__PURE__ */ new Set()), typeDef;
}
function traverse(typeDef, visited) {
  if (!visited.has(typeDef)) {
    if (visited.add(typeDef), typeDef.validation = normalizeValidationRules(typeDef), "fields" in typeDef)
      for (const field of typeDef.fields)
        traverse(field.type, visited);
    if ("of" in typeDef)
      for (const candidate of typeDef.of)
        traverse(candidate, visited);
    if (typeDef.annotations)
      for (const annotation of typeDef.annotations)
        traverse(annotation, visited);
  }
}
function inferFromSchema(schema2) {
  return schema2.getTypeNames().forEach((typeName) => {
    const schemaType = schema2.get(typeName);
    schemaType && inferFromSchemaType(schemaType);
  }), schema2;
}
const shouldEscape = typeof window > "u" || typeof document > "u", fallbackLocales = [defaultLocale], getFallbackLocaleSource = memoize__default.default(
  function() {
    const i18n = getFallbackI18nInstance();
    return i18n.init(), {
      currentLocale: defaultLocale,
      locales: fallbackLocales,
      loadNamespaces: i18n.loadNamespaces,
      t: i18n.t
    };
  }
);
function getFallbackI18nInstance() {
  var _a2;
  const staticResources = { [defaultLocale.id]: {} }, staticBundles = ((_a2 = usEnglishLocale.bundles) == null ? void 0 : _a2.filter(isStaticResourceBundle)) || [], namespaces = /* @__PURE__ */ new Set();
  for (const bundle of staticBundles)
    staticResources[defaultLocale.id][bundle.namespace] = bundle.resources, namespaces.add(bundle.namespace);
  return i18next.createInstance({
    ns: Array.from(namespaces),
    defaultNS: studioLocaleNamespace,
    initImmediate: !0,
    partialBundledLanguages: !0,
    fallbackLng: defaultLocale.id,
    lng: defaultLocale.id,
    supportedLngs: [defaultLocale.id],
    debug: !1,
    load: "currentOnly",
    resources: staticResources,
    interpolation: {
      // If we're in a browser, assume this is running inside of the studio, eg a React app,
      // and that values returned will be escaped by the framework (eg React) automatically.
      escapeValue: shouldEscape
    }
  });
}
const BUFFER_TIME = 250, MAX_BUFFER_SIZE = 100, MAX_REQUEST_CONCURRENCY = 1;
function createBatchedGetDocumentExists(client2) {
  const id$ = new rxjs.Subject(), limiter = new concurrencyLimiter.ConcurrencyLimiter(MAX_REQUEST_CONCURRENCY), existence$ = id$.pipe(
    rxjs.bufferTime(BUFFER_TIME, null, MAX_BUFFER_SIZE),
    rxjs.map((ids) => Array.from(new Set(ids))),
    rxjs.mergeMap(
      (ids) => rxjs.from(limiter.ready()).pipe(
        rxjs.switchMap(
          () => client2.observable.request({
            uri: client2.getDataUrl("doc", ids.join(",")),
            json: !0,
            query: { excludeContent: "true" },
            tag: "documents-availability"
          }).pipe(rxjs.map((availability) => ({ availability, ids })))
        ),
        rxjs.finalize(limiter.release)
      )
    ),
    rxjs.mergeMap(
      ({ availability, ids }) => ids.map((id2) => {
        const omittedIds = availability.omitted.reduce(
          (acc, next) => (acc[next.id] = next.reason, acc),
          {}
        );
        return omittedIds[id2] ? omittedIds[id2] === "existence" ? { id: id2, exists: !1 } : { id: id2, exists: !0 } : { id: id2, exists: !0 };
      })
    ),
    rxjs.share()
  );
  return async function(options) {
    const result = rxjs.firstValueFrom(existence$.pipe(rxjs.filter(({ id: id2 }) => id2 === options.id)));
    id$.next(options.id);
    const { exists } = await result;
    return exists;
  };
}
const requestIdleCallbackShim = function(callback, options) {
  const start = Date.now();
  return window.setTimeout(() => {
    callback({
      didTimeout: !1,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 0);
}, cancelIdleCallbackShim = function(handle) {
  return window.clearTimeout(handle);
}, win = typeof window > "u" ? void 0 : window, requestIdleCallback = (win == null ? void 0 : win.requestIdleCallback) || requestIdleCallbackShim, cancelIdleCallback = (win == null ? void 0 : win.cancelIdleCallback) || cancelIdleCallbackShim, unknownFieldsValidator = (type) => (value) => {
  var _a2;
  if (typeof value != "object" || !value)
    return !0;
  const fieldNames = new Set((_a2 = type.fields) == null ? void 0 : _a2.map((field) => field.name));
  return Object.keys(value).filter((key) => !key.startsWith("_")).filter((key) => !fieldNames.has(key)).map((unknownField) => ({
    message: `Field '${unknownField}' does not exist on type '${type.name}'`,
    path: [unknownField]
  }));
}, MAX_FETCH_CONCURRENCY = 10, limitConcurrency = client$1.createClientConcurrencyLimiter(MAX_FETCH_CONCURRENCY), isRecord$2 = (maybeRecord) => typeof maybeRecord == "object" && maybeRecord !== null && !Array.isArray(maybeRecord), isNonNullable = (value) => value != null;
function resolveTypeForArrayItem(item, candidates) {
  if (candidates.length === 1)
    return candidates[0];
  const itemType = types.isTypedObject(item) && item._type, primitive = item == null || !itemType && typeString(item).toLowerCase();
  return primitive && primitive !== "object" ? candidates.find((candidate) => candidate.jsonType === primitive) : candidates.find((candidate) => {
    var _a2;
    return ((_a2 = candidate.type) == null ? void 0 : _a2.name) === itemType;
  }) || candidates.find((candidate) => candidate.name === itemType) || candidates.find((candidate) => candidate.name === "object" && primitive === "object");
}
function validateDocument({
  document: document2,
  workspace,
  environment = "studio",
  ...options
}) {
  const getClient = options.getClient || workspace.getClient;
  return rxjs.lastValueFrom(
    validateDocumentObservable({
      document: document2,
      getClient: (clientOptions) => limitConcurrency(getClient(clientOptions)),
      i18n: workspace.i18n,
      schema: workspace.schema,
      getDocumentExists: options.getDocumentExists || createBatchedGetDocumentExists(getClient({ apiVersion: "v2021-03-25" })),
      environment
    })
  );
}
const customValidationConcurrencyLimiters = /* @__PURE__ */ new WeakMap();
function validateDocumentObservable({
  document: document2,
  getClient,
  i18n = getFallbackLocaleSource(),
  schema: schema2,
  getDocumentExists,
  environment,
  maxCustomValidationConcurrency
}) {
  if (typeof (document2 == null ? void 0 : document2._type) != "string")
    throw new Error("Tried to validated a value without a '_type'");
  const documentType = schema2.get(document2._type);
  if (!documentType)
    return environment === "studio" ? (console.warn(
      'Schema type for object type "%s" not found, skipping validation',
      document2._type
    ), rxjs.of([])) : rxjs.of([
      {
        level: "warning",
        message: `Could not find schema type for type '${document2._type}', skipping validation`,
        path: []
      }
    ]);
  let customValidationConcurrencyLimiter = customValidationConcurrencyLimiters.get(schema2);
  !customValidationConcurrencyLimiter && maxCustomValidationConcurrency && (customValidationConcurrencyLimiter = new concurrencyLimiter.ConcurrencyLimiter(maxCustomValidationConcurrency), customValidationConcurrencyLimiters.set(schema2, customValidationConcurrencyLimiter));
  const validationOptions = {
    getClient,
    schema: schema2,
    parent: void 0,
    value: document2,
    path: [],
    document: document2,
    type: documentType,
    i18n,
    getDocumentExists,
    environment,
    customValidationConcurrencyLimiter
  };
  return rxjs.from(i18n.loadNamespaces(["validation"])).pipe(
    operators.switchMap(() => validateItemObservable(validationOptions)),
    operators.catchError((err) => {
      console.error(err);
      const message = (err == null ? void 0 : err.message) || "Unknown error";
      return rxjs.of([{
        level: "error",
        message,
        item: { message },
        path: []
      }]);
    })
  );
}
function validateItemObservable({
  value,
  type,
  path = [],
  parent,
  customValidationConcurrencyLimiter,
  environment,
  ...restOfContext
}) {
  const addUnknownFieldsValidator = (rule) => (
    // if the schema type is an object type
    (type == null ? void 0 : type.jsonType) === "object" && // and if somewhere in it's type chain, it inherits from object or document
    getTypeChain(type).find((t2) => ["object", "document", "file", "image"].includes(t2.name)) && // and the environment is not the studio
    environment !== "studio" ? rule.custom(unknownFieldsValidator(type), { bypassConcurrencyLimit: !0 }).warning() : rule
  ), rules = normalizeValidationRules(type), selfChecks = rules.map(addUnknownFieldsValidator).map(
    (rule) => rxjs.defer(
      () => rule.validate(value, {
        ...restOfContext,
        environment,
        parent,
        path,
        type,
        __internal: { customValidationConcurrencyLimiter }
      })
    )
  );
  let nestedChecks = [];
  const selfIsRequired = rules.some((rule) => rule.isRequired());
  if (
    // run nested validation for objects
    (type == null ? void 0 : type.jsonType) === "object" && // if the value is truthy
    (value || // or
    // (the value is null or undefined) and the top-level value is required
    value == null && selfIsRequired)
  ) {
    const fieldTypes = type.fields.reduce((acc, field) => (acc[field.name] = field.type, acc), {});
    nestedChecks = nestedChecks.concat(
      rules.map((rule) => rule._fieldRules).filter(isNonNullable).flatMap((fieldResults) => Object.entries(fieldResults)).flatMap(([name, validation2]) => {
        const fieldType = fieldTypes[name];
        return normalizeValidationRules({ ...fieldType, validation: validation2 }).map(addUnknownFieldsValidator).map((subRule) => {
          const nestedValue = isRecord$2(value) ? value[name] : void 0;
          return rxjs.defer(
            () => subRule.validate(nestedValue, {
              ...restOfContext,
              parent: value,
              path: path.concat(name),
              type: fieldType,
              environment,
              __internal: { customValidationConcurrencyLimiter }
            })
          );
        });
      })
    ), nestedChecks = nestedChecks.concat(
      type.fields.map(
        (field) => validateItemObservable({
          ...restOfContext,
          parent: value,
          value: isRecord$2(value) ? value[field.name] : void 0,
          path: path.concat(field.name),
          type: field.type,
          environment,
          customValidationConcurrencyLimiter
        })
      )
    );
  }
  return (type == null ? void 0 : type.jsonType) === "array" && Array.isArray(value) && (nestedChecks = nestedChecks.concat(
    value.map(
      (item, index) => validateItemObservable({
        ...restOfContext,
        parent: value,
        value: item,
        path: path.concat(types.isKeyedObject(item) ? { _key: item._key } : index),
        type: resolveTypeForArrayItem(item, type.of),
        environment,
        customValidationConcurrencyLimiter
      })
    )
  )), rxjs.defer(() => rxjs.merge([...selfChecks, ...nestedChecks])).pipe(
    operators.mergeMap((validateNode) => rxjs.concat(idle(), validateNode), 40),
    operators.mergeAll(),
    operators.toArray(),
    operators.map(flatten__default.default),
    operators.map((results) => rules.some((rule) => rule._fieldRules) ? uniqBy__default.default(results, (rule) => JSON.stringify(rule)) : results)
  );
}
function idle(timeout) {
  return new rxjs.Observable((observer) => {
    const handle = requestIdleCallback(
      () => {
        observer.complete();
      },
      timeout ? { timeout } : void 0
    );
    return () => cancelIdleCallback(handle);
  });
}
var assetSourceData = {
  name: "sanity.assetSourceData",
  title: "Asset Source Data",
  type: "object",
  fields: [
    {
      name: "name",
      title: "Source name",
      description: "A canonical name for the source this asset is originating from",
      type: "string"
    },
    {
      name: "id",
      title: "Asset Source ID",
      description: "The unique ID for the asset within the originating source so you can programatically find back to it",
      type: "string"
    },
    {
      name: "url",
      title: "Asset information URL",
      description: "A URL to find more information about this asset in the originating source",
      type: "string"
    }
  ]
}, fileAsset = {
  name: "sanity.fileAsset",
  title: "File",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      title: "File extension",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      title: "Mime type",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      title: "originalFilename",
      path: "path",
      mimeType: "mimeType",
      size: "size"
    },
    prepare(doc) {
      return {
        title: doc.title || doc.path.split("/").slice(-1)[0],
        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, geopoint = {
  title: "Geographical Point",
  name: "geopoint",
  type: "object",
  fields: [
    {
      name: "lat",
      type: "number",
      title: "Latitude"
    },
    {
      name: "lng",
      type: "number",
      title: "Longitude"
    },
    {
      name: "alt",
      type: "number",
      title: "Altitude"
    }
  ]
}, imageAsset = {
  name: "sanity.imageAsset",
  title: "Image",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      readOnly: !0,
      title: "File extension",
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      readOnly: !0,
      title: "Mime type",
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "metadata",
      type: "sanity.imageMetadata",
      title: "Metadata"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      id: "_id",
      title: "originalFilename",
      mimeType: "mimeType",
      size: "size"
    },
    prepare(doc) {
      return {
        title: doc.title || typeof doc.path == "string" && doc.path.split("/").slice(-1)[0],
        media: { asset: { _ref: doc.id } },
        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, imageCrop = {
  name: "sanity.imageCrop",
  title: "Image crop",
  type: "object",
  fields: [
    {
      name: "top",
      type: "number"
    },
    {
      name: "bottom",
      type: "number"
    },
    {
      name: "left",
      type: "number"
    },
    {
      name: "right",
      type: "number"
    }
  ]
}, imageDimensions = {
  name: "sanity.imageDimensions",
  type: "object",
  title: "Image dimensions",
  fields: [
    { name: "height", type: "number", title: "Height", readOnly: !0 },
    { name: "width", type: "number", title: "Width", readOnly: !0 },
    { name: "aspectRatio", type: "number", title: "Aspect ratio", readOnly: !0 }
  ]
}, imageHotspot = {
  name: "sanity.imageHotspot",
  title: "Image hotspot",
  type: "object",
  fields: [
    {
      name: "x",
      type: "number"
    },
    {
      name: "y",
      type: "number"
    },
    {
      name: "height",
      type: "number"
    },
    {
      name: "width",
      type: "number"
    }
  ]
}, imageMetadata = {
  name: "sanity.imageMetadata",
  title: "Image metadata",
  type: "object",
  fieldsets: [
    {
      name: "extra",
      title: "Extra metadata\u2026",
      options: {
        collapsable: !0
      }
    }
  ],
  fields: [
    {
      name: "location",
      type: "geopoint"
    },
    {
      name: "dimensions",
      title: "Dimensions",
      type: "sanity.imageDimensions",
      fieldset: "extra"
    },
    {
      name: "palette",
      type: "sanity.imagePalette",
      title: "Palette",
      fieldset: "extra"
    },
    {
      name: "lqip",
      title: "LQIP (Low-Quality Image Placeholder)",
      type: "string",
      readOnly: !0
    },
    {
      name: "blurHash",
      title: "BlurHash",
      type: "string",
      readOnly: !0
    },
    {
      name: "hasAlpha",
      title: "Has alpha channel",
      type: "boolean",
      readOnly: !0
    },
    {
      name: "isOpaque",
      title: "Is opaque",
      type: "boolean",
      readOnly: !0
    }
  ]
}, imagePalette = {
  name: "sanity.imagePalette",
  title: "Image palette",
  type: "object",
  fields: [
    { name: "darkMuted", type: "sanity.imagePaletteSwatch", title: "Dark Muted" },
    { name: "lightVibrant", type: "sanity.imagePaletteSwatch", title: "Light Vibrant" },
    { name: "darkVibrant", type: "sanity.imagePaletteSwatch", title: "Dark Vibrant" },
    { name: "vibrant", type: "sanity.imagePaletteSwatch", title: "Vibrant" },
    { name: "dominant", type: "sanity.imagePaletteSwatch", title: "Dominant" },
    { name: "lightMuted", type: "sanity.imagePaletteSwatch", title: "Light Muted" },
    { name: "muted", type: "sanity.imagePaletteSwatch", title: "Muted" }
  ]
}, imagePaletteSwatch = {
  name: "sanity.imagePaletteSwatch",
  title: "Image palette swatch",
  type: "object",
  fields: [
    { name: "background", type: "string", title: "Background", readOnly: !0 },
    { name: "foreground", type: "string", title: "Foreground", readOnly: !0 },
    { name: "population", type: "number", title: "Population", readOnly: !0 },
    { name: "title", type: "string", title: "String", readOnly: !0 }
  ]
}, slug = {
  title: "Slug",
  name: "slug",
  type: "object",
  fields: [
    {
      name: "current",
      title: "Current slug",
      type: "string"
    },
    {
      // The source field is deprecated/unused, but leaving it included and hidden
      // to prevent rendering "Unknown field" warnings on legacy data
      name: "source",
      title: "Source field",
      type: "string",
      hidden: !0
    }
  ]
};
const isError$1 = (problem) => problem.severity === "error", builtinTypes = [
  assetSourceData,
  slug,
  geopoint,
  // legacyRichDate,
  imageAsset,
  fileAsset,
  imageCrop,
  imageHotspot,
  imageMetadata,
  imageDimensions,
  imagePalette,
  imagePaletteSwatch
];
function createSchema(schemaDef) {
  const validated = _internal.validateSchema(schemaDef.types).getTypes(), validation2 = _internal.groupProblems(validated), hasErrors = validation2.some((group2) => group2.problems.some(isError$1)), compiled = schema.Schema.compile({
    name: schemaDef.name,
    types: hasErrors ? [] : [...schemaDef.types, ...builtinTypes].filter(Boolean)
  });
  return compiled._validation = validation2, inferFromSchema(compiled);
}
function getSchemaTypeTitle(type) {
  return typeof type.title == "string" ? type.title : type.type ? getSchemaTypeTitle(type.type) : type.name || type.jsonType;
}
const PRESENCE_MARGINS = [0, 0, 1, 0];
function onDragEnter(event) {
  return event.stopPropagation();
}
function onDrop(event) {
  return event.stopPropagation();
}
function EditPortal(props2) {
  const {
    children,
    header,
    id: id2,
    legacy_referenceElement: referenceElement,
    onClose,
    type,
    width,
    autofocus
  } = props2, [documentScrollElement, setDocumentScrollElement] = React.useState(null), containerElement = React.useRef(null), contents = /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: PRESENCE_MARGINS, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ref: containerElement, children }) });
  return type === "dialog" ? /* @__PURE__ */ jsxRuntime.jsx(
    VirtualizerScrollInstanceProvider,
    {
      scrollElement: documentScrollElement,
      containerElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Dialog,
        {
          header,
          id: id2 || "",
          onClickOutside: onClose,
          onClose,
          onDragEnter,
          onDrop,
          width,
          contentRef: setDocumentScrollElement,
          __unstable_autoFocus: autofocus,
          children: contents
        }
      )
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    PopoverDialog,
    {
      header,
      onClose,
      referenceElement,
      width,
      containerRef: setDocumentScrollElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        VirtualizerScrollInstanceProvider,
        {
          scrollElement: documentScrollElement,
          containerElement,
          children: contents
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$8 = {
  portal: !0,
  tone: "default",
  placement: "left",
  constrainSize: !0
}, InsertMenu$1 = React.memo(function(props2) {
  const { types: types2, onInsert } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      InsertMenuGroup,
      {
        pos: "before",
        types: types2,
        onInsert,
        text: t2("inputs.array.action.add-before"),
        icon: icons.InsertAboveIcon
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      InsertMenuGroup,
      {
        pos: "after",
        types: types2,
        onInsert,
        text: t2("inputs.array.action.add-after"),
        icon: icons.InsertBelowIcon
      }
    )
  ] });
});
function InsertMenuGroup(props2) {
  const { types: types2, onInsert, pos, text, icon } = props2;
  return (types2 == null ? void 0 : types2.length) === 1 ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuItem, { text, icon, onClick: () => onInsert(pos, types2[0]) }, pos) : /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuGroup, { text, popover: MENU_POPOVER_PROPS$8, children: types2 == null ? void 0 : types2.map((insertableType) => /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      icon: insertableType.icon,
      text: insertableType.title,
      onClick: () => onInsert(pos, insertableType)
    },
    insertableType.name
  )) }, pos);
}
const PreviewCard$1 = styled__default.default(ui.Card)`
  border-top-right-radius: inherit;
  border-top-left-radius: inherit;
  height: 100%;
  position: relative;

  @media (hover: hover) {
    &:hover {
      filter: brightness(95%);
    }
  }

  &:focus:focus-visible {
    box-shadow: 0 0 0 2px var(--card-focus-ring-color);
  }
`;
function getTone$2({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$7 = { portal: !0, tone: "default" };
function GridItem(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    onFocus,
    onOpen,
    onClose,
    changed,
    focused,
    children,
    inputProps: { renderPreview }
  } = props2, { t: t2 } = useTranslation(), sortable2 = !readOnly && ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, previewCardRef = React.useRef(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && previewCardRef.current && ((_a22 = previewCardRef.current) == null || _a22.focus());
  });
  const resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [createProtoArrayValue(insertType)],
        position: pos
      });
    },
    [onInsert]
  ), childPresence = useChildPresence(path, !0), presence = React.useMemo(() => childPresence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence: childPresence, maxAvatars: 1 }), [childPresence]), childValidation = useChildValidation(path, !0), validation2 = React.useMemo(() => childValidation.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: !0 }) }), [childValidation]), hasErrors = childValidation.some((v) => v.level === "error"), hasWarnings = childValidation.some((v) => v.level === "warning"), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
        id: `${props2.inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.remove"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.duplicate"),
              icon: icons.CopyIcon,
              onClick: handleDuplicate
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
        ] }),
        popover: MENU_POPOVER_PROPS$7
      }
    ),
    [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t2]
  ), tone = getTone$2({ readOnly, hasErrors, hasWarnings }), item = /* @__PURE__ */ jsxRuntime.jsx(
    CellLayout,
    {
      menu,
      presence,
      validation: validation2,
      tone,
      radius: 2,
      border: !0,
      dragHandle: sortable2,
      selected: open,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        PreviewCard$1,
        {
          tone: "inherit",
          overflow: "auto",
          forwardedAs: "button",
          "data-ui": "PreviewCard",
          "data-as": "button",
          type: "button",
          flex: 1,
          tabIndex: 0,
          disabled: resolvingInitialValue,
          onClick: onOpen,
          ref: previewCardRef,
          onFocus,
          __unstable_focusRing: !0,
          children: [
            renderPreview({
              schemaType,
              value,
              layout: "media",
              withBorder: !1,
              withShadow: !1
            }),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ), itemTypeTitle = getSchemaTypeTitle(schemaType);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: item }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      EditPortal,
      {
        header: readOnly ? t2("inputs.array.action.view", { itemTypeTitle }) : t2("inputs.array.action.edit", { itemTypeTitle }),
        type: ((_c = (_b = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b.modal) == null ? void 0 : _c.type) || "dialog",
        width: (_f = (_e = (_d = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d.modal) == null ? void 0 : _e.width) != null ? _f : 1,
        id: value._key,
        onClose,
        autofocus: focused,
        legacy_referenceElement: previewCardRef.current,
        children
      }
    )
  ] });
}
const EMPTY$2 = [];
function GridArrayInput(props2) {
  var _a2;
  const {
    arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions,
    elementProps,
    members,
    onChange,
    onInsert,
    onItemMove,
    onUpload,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderPreview,
    resolveUploader: resolveUploader2,
    schemaType,
    value = EMPTY$2
  } = props2, { t: t2 } = useTranslation(), handlePrepend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "before", referenceItem: 0 });
    },
    [onInsert]
  ), handleAppend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "after", referenceItem: -1 });
    },
    [onInsert]
  ), sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1, renderItem = React.useCallback((itemProps) => /* @__PURE__ */ jsxRuntime.jsx(GridItem, { ...itemProps }), []), memberKeys = React.useMemo(() => members.map((member) => member.key), [members]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      UploadTargetCard,
      {
        types: schemaType.of,
        resolveUploader: resolveUploader2,
        onUpload,
        ...elementProps,
        tabIndex: 0,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-ui": "ArrayInput__content", space: 2, children: [
          (members == null ? void 0 : members.length) === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.array.no-items-label") }) }) }),
          (members == null ? void 0 : members.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            List,
            {
              columns: [2, 3, 4],
              gap: 3,
              padding: 1,
              margin: 1,
              items: memberKeys,
              onItemMove,
              sortable: sortable2,
              children: members.map((member) => /* @__PURE__ */ jsxRuntime.jsxs(Item, { sortable: sortable2, id: member.key, flex: 1, children: [
                member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                  ArrayOfObjectsItem,
                  {
                    member,
                    renderAnnotation,
                    renderBlock,
                    renderInlineBlock,
                    renderItem,
                    renderField,
                    renderInput,
                    renderPreview
                  }
                ),
                member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(ErrorItem$1, { sortable: sortable2, member })
              ] }, member.key))
            }
          ) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ArrayFunctions,
      {
        onChange,
        onItemAppend: handleAppend,
        onItemPrepend: handlePrepend,
        onValueCreate: createProtoArrayValue,
        readOnly,
        schemaType,
        value
      }
    )
  ] });
}
const Root$h = styled__default.default(ui.Card)`
  position: relative;
  border: 1px solid transparent;
  transition: border-color 250ms;

  .${MOVING_ITEM_CLASS_NAME} & {
    border-color: var(--card-shadow-umbra-color);
    box-shadow:
      0 0 0 0,
      0 8px 17px 2px var(--card-shadow-umbra-color),
      0 3px 14px 2px var(--card-shadow-penumbra-color),
      0 5px 5px -3px var(--card-shadow-ambient-color);
  }

  &:hover {
    border-color: var(--card-shadow-umbra-color);
  }

  &[aria-selected='true'] {
    border-color: var(--card-focus-ring-color);
  }
`;
function RowLayout(props2) {
  const { validation: validation2, selected, tone, presence, focused, children, dragHandle, menu, footer } = props2, elementRef = React.useRef(null);
  return useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = elementRef.current) == null || _a2.focus());
  }), /* @__PURE__ */ jsxRuntime.jsx(
    Root$h,
    {
      ref: elementRef,
      selected,
      "aria-selected": selected,
      radius: 1,
      padding: 1,
      tone,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
          dragHandle && /* @__PURE__ */ jsxRuntime.jsx(DragHandle, { paddingY: 3 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children }),
          (presence || validation2 || menu) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: "none", gap: 2, style: { lineHeight: 0 }, children: [
            presence && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: presence }),
            validation2 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: validation2 }),
            menu
          ] })
        ] }),
        footer
      ] })
    }
  );
}
const PopoverCard = styled__default.default(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          flex: 1,
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) }) })
          ] })
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$6 = { portal: !0, tone: "default" };
function ErrorItem(props2) {
  const { member, sortable: sortable2, onRemove } = props2, id2 = React.useId(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      dragHandle: sortable2,
      tone: "caution",
      menu: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.MenuButton,
        {
          button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
          id: `${id2}-menuButton`,
          menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.remove-invalid-item"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ) }),
          popover: MENU_POPOVER_PROPS$6
        }
      ),
      children: member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType, { value: member.error.value }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) })
    }
  ) });
}
function useMemoCompare(next, compare) {
  const previousRef = React.useRef(next), previous = previousRef.current, isEqual2 = compare(previous, next);
  return React.useEffect(() => {
    isEqual2 || (previousRef.current = next);
  }), isEqual2 ? previous : next;
}
const EMPTY$1 = [];
function ListArrayInput(props2) {
  var _a2;
  const {
    arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions,
    elementProps,
    members,
    onChange,
    onInsert,
    onItemMove,
    onUpload,
    focusPath,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    resolveUploader: resolveUploader2,
    schemaType,
    value = EMPTY$1
  } = props2, { t: t2 } = useTranslation(), [activeDragItemIndex, setActiveDragItemIndex] = React.useState(null), { space } = ui.useTheme().sanity, handlePrepend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "before", referenceItem: 0 });
    },
    [onInsert]
  ), handleAppend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "after", referenceItem: -1 });
    },
    [onInsert]
  ), memberKeys = useMemoCompare(
    React.useMemo(() => members.map((member) => member.key), [members]),
    shallowEquals__default.default
  ), { scrollElement, containerElement } = useVirtualizerScrollInstance(), parentRef = React.useRef(null), focusPathKey = React.useMemo(() => types.isKeySegment(focusPath[0]) ? focusPath[0]._key : focusPath[0], [focusPath]), rangeExtractor = React.useCallback(
    (range2) => {
      const newRange = { ...range2 };
      if (activeDragItemIndex !== null && (newRange.startIndex = Math.min(range2.startIndex, activeDragItemIndex), newRange.endIndex = Math.max(range2.endIndex, activeDragItemIndex)), focusPathKey) {
        const index = memberKeys.findIndex((key) => key === focusPathKey);
        index !== -1 && (newRange.startIndex = Math.min(newRange.startIndex, index), newRange.endIndex = Math.max(newRange.endIndex, index));
      }
      return reactVirtual.defaultRangeExtractor(newRange);
    },
    [activeDragItemIndex, focusPathKey, memberKeys]
  ), observeElementOffset = React.useCallback(
    (instance, callback) => {
      if (!instance.scrollElement)
        return;
      const scroll = instance.scrollElement, handleScroll = () => {
        var _a22, _b, _c, _d;
        const containerElementTop = (_b = (_a22 = containerElement.current) == null ? void 0 : _a22.getBoundingClientRect().top) != null ? _b : 0, parentElementTop = (_d = (_c = parentRef.current) == null ? void 0 : _c.getBoundingClientRect().top) != null ? _d : 0, itemOffset = Math.floor(parentElementTop - containerElementTop);
        callback(scroll.scrollTop - itemOffset);
      };
      return handleScroll(), instance.scrollElement.addEventListener("scroll", handleScroll, {
        capture: !1,
        passive: !0
      }), () => {
        scroll.removeEventListener("scroll", handleScroll);
      };
    },
    [containerElement]
  ), estimateSize = React.useCallback(() => 53, []), virtualizer = reactVirtual.useVirtualizer({
    count: members.length,
    estimateSize,
    getScrollElement: React.useCallback(() => scrollElement, [scrollElement]),
    observeElementOffset,
    rangeExtractor,
    getItemKey: React.useCallback((index) => memberKeys[index], [memberKeys]),
    scrollToFn: (offset, options, instance) => {
      offset !== instance.scrollOffset && reactVirtual.elementScroll(offset, options, instance);
    }
  }), items = virtualizer.getVirtualItems(), handleItemMoveStart = React.useCallback((event) => {
    var _a22, _b;
    const { active } = event;
    setActiveDragItemIndex((_b = (_a22 = active.data.current) == null ? void 0 : _a22.sortable) == null ? void 0 : _b.index);
  }, []), handleItemMoveEnd = React.useCallback(() => {
    setActiveDragItemIndex(null);
  }, []), sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1, listGridGap = 1, paddingY = 1, radius = 2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, ref: parentRef, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      UploadTargetCard,
      {
        $radius: radius,
        types: schemaType.of,
        resolveUploader: resolveUploader2,
        onUpload,
        ...elementProps,
        tabIndex: 0,
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-ui": "ArrayInput__content", space: 2, children: members.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.array.no-items-label") }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            border: !0,
            radius,
            style: {
              // This is not memoized since it changes on scroll so it will change anyways making memo useless
              // Account for grid gap
              boxSizing: "border-box",
              height: `${virtualizer.getTotalSize() + items.length * space[listGridGap] + space[paddingY]}px`,
              width: "100%",
              position: "relative"
            },
            children: /* @__PURE__ */ jsxRuntime.jsx(
              List,
              {
                axis: "y",
                gap: listGridGap,
                paddingY,
                items: memberKeys,
                onItemMove,
                onItemMoveStart: handleItemMoveStart,
                onItemMoveEnd: handleItemMoveEnd,
                sortable: sortable2,
                style: {
                  // This is not memoized since it changes on scroll so it will change anyways making memo useless
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  transform: `translateY(${items[0].start}px)`
                },
                children: items.map((virtualRow) => {
                  const member = members[virtualRow.index];
                  return /* @__PURE__ */ jsxRuntime.jsxs(
                    Item,
                    {
                      ref: virtualizer.measureElement,
                      sortable: sortable2,
                      "data-index": virtualRow.index,
                      id: member.key,
                      children: [
                        member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                          ArrayOfObjectsItem,
                          {
                            member,
                            renderAnnotation,
                            renderBlock,
                            renderField,
                            renderInlineBlock,
                            renderInput,
                            renderItem,
                            renderPreview
                          }
                        ),
                        member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(
                          ErrorItem,
                          {
                            sortable: sortable2,
                            member,
                            onRemove: () => props2.onItemRemove(member.key)
                          }
                        )
                      ]
                    },
                    virtualRow.key
                  );
                })
              }
            )
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ArrayFunctions,
      {
        onChange,
        onItemAppend: handleAppend,
        onItemPrepend: handlePrepend,
        onValueCreate: createProtoArrayValue,
        readOnly,
        schemaType,
        value
      }
    )
  ] });
}
function ArrayOfObjectsInput(props2) {
  var _a2;
  return ((_a2 = props2.schemaType.options) == null ? void 0 : _a2.layout) === "grid" ? /* @__PURE__ */ jsxRuntime.jsx(GridArrayInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ListArrayInput, { ...props2 });
}
function isEqual(item, otherItem) {
  if (item === otherItem)
    return !0;
  if (typeof item != typeof otherItem)
    return !1;
  if (typeof item != "object" && !Array.isArray(item))
    return item === otherItem;
  if (item._key && item._key === otherItem._key)
    return !0;
  if (Array.isArray(item))
    return !item.length !== otherItem.length ? !1 : item.every((it, i) => isEqual(item[i], otherItem[i]));
  const keys = Object.keys(item), otherKeys = Object.keys(item);
  return keys.length !== otherKeys.length ? !1 : keys.every((keyName) => isEqual(item[keyName], otherItem[keyName]));
}
function inArray(array, candidate) {
  return array ? array.some((item) => isEqual(item, candidate)) : !1;
}
function getMemberTypeOfItem$1(schemaType, item) {
  return schemaType.of.find((memberType) => memberType.name === content.resolveTypeName(item));
}
const EMPTY_ARRAY$3 = [];
function ArrayOfObjectOptionsInput(props2) {
  var _a2, _b;
  const {
    renderPreview,
    schemaType,
    onChange,
    onPathFocus,
    value = [],
    readOnly,
    elementProps,
    path,
    changed
  } = props2, options = React.useMemo(
    () => {
      var _a22;
      return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || EMPTY_ARRAY$3).map(
        (option, index) => types.isKeyedObject(option) ? option : { ...option, _key: `auto-generated-${index}` }
      );
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), handleChange = React.useCallback(
    (isChecked, changedOption) => {
      if (!isChecked && types.isKeyedObject(changedOption)) {
        onChange(unset([{ _key: changedOption._key }]));
        return;
      }
      const nextValue = options.filter(
        (option) => isEqual(changedOption, option) ? isChecked : inArray(value, option)
      );
      onChange(nextValue.length > 0 ? set(nextValue) : unset());
    },
    [onChange, options, value]
  ), handleItemFocus = React.useCallback(
    (index) => {
      onPathFocus([index]);
    },
    [onPathFocus]
  ), isGrid = ((_b = schemaType.options) == null ? void 0 : _b.layout) === "grid";
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Grid,
    {
      gap: 2,
      columns: isGrid ? Math.min(options.length, 4) : 1,
      tabIndex: 0,
      ...elementProps,
      children: options.map((option, index) => {
        const optionType = getMemberTypeOfItem$1(schemaType, option), checked = inArray(value, option), disabled = !optionType;
        return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", as: "label", muted: disabled, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.Checkbox,
            {
              disabled,
              checked,
              onChange: (e) => handleChange(e.currentTarget.checked, option),
              onFocus: () => handleItemFocus(index),
              readOnly
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 2, children: optionType ? renderPreview({
            layout: "default",
            schemaType: optionType,
            value: option
          }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "caution", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$2, { value: option, onFocus: () => handleItemFocus(index) }) }) })
        ] }, index);
      })
    }
  ) });
}
function isPrimitiveOption(option) {
  return !!(option && typeof option == "object" && "title" in option && "value" in option);
}
function normalizeOptions(options) {
  return options.map((option) => isPrimitiveOption(option) ? {
    title: option.title || startCase__default.default(String(option.value)),
    value: option.value
  } : {
    title: startCase__default.default(String(option)),
    value: option
  });
}
function getMemberTypeOfItem(schemaType, option) {
  return schemaType.of.find((memberType) => memberType.name === content.resolveTypeName(option.value));
}
function ArrayOfPrimitiveOptionsInput(props2) {
  var _a2, _b;
  const {
    schemaType,
    onChange,
    value = [],
    readOnly,
    path,
    changed,
    onIndexFocus,
    elementProps
  } = props2, options = React.useMemo(
    () => {
      var _a22;
      return normalizeOptions(((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []);
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), handleChange = (isChecked, changedValue) => {
    const nextValue = options.map((option) => option.value).filter(
      (optionValue) => (
        // note: sparse arrays are not supported here, so multiple options with same value will all be checked
        optionValue === changedValue ? isChecked : value.includes(optionValue)
      )
    );
    onChange(nextValue.length > 0 ? set(nextValue) : unset());
  }, isGrid = ((_b = schemaType.options) == null ? void 0 : _b.layout) === "grid";
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { gap: 2, columns: isGrid ? Math.min(options.length, 4) : 1, ...elementProps, children: options.map((option, index) => {
    const optionType = getMemberTypeOfItem(schemaType, option), checked = value.includes(option.value), disabled = !optionType;
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", as: "label", muted: disabled, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Checkbox,
        {
          disabled,
          checked,
          onChange: (e) => handleChange(e.currentTarget.checked, option.value),
          onFocus: () => onIndexFocus(index),
          readOnly
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: option.title }) }),
      !optionType && /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType, { value: option, onFocus: () => onIndexFocus(index) })
    ] }, index);
  }) }) });
}
function ArrayOfOptionsInput(props2) {
  return isArrayOfObjectsInputProps(props2) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectOptionsInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ArrayOfPrimitiveOptionsInput, { ...props2 });
}
function ArrayOfPrimitivesFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2, menuButtonId = React.useId(), { t: t2 } = useTranslation(), insertItem = React.useCallback(
    (itemType) => {
      onItemAppend(onValueCreate(itemType));
    },
    [onValueCreate, onItemAppend]
  ), handleAddBtnClick = React.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]), popoverProps = React.useMemo(() => ({ constrainSize: !0, portal: !0 }), []), addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { portal: !0, content: t2("inputs.array.read-only-label"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { icon: icons.AddIcon, mode: "ghost", disabled: !0, size: "large", text: t2(addItemI18nKey) }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [
    schemaType.of.length === 1 ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.AddIcon,
        mode: "ghost",
        onClick: handleAddBtnClick,
        size: "large",
        text: t2(addItemI18nKey)
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { icon: icons.AddIcon, mode: "ghost", size: "large", text: t2(addItemI18nKey) }),
        id: menuButtonId || "",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: schemaType.of.map((memberDef, i) => {
          var _a2, _b;
          const referenceIcon = types.isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon, icon = memberDef.icon || ((_a2 = memberDef.type) == null ? void 0 : _a2.icon) || referenceIcon;
          return /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: memberDef.title || ((_b = memberDef.type) == null ? void 0 : _b.name),
              onClick: () => insertItem(memberDef),
              icon
            },
            i
          );
        }) }),
        popover: popoverProps
      }
    ),
    children
  ] });
}
const MENU_BUTTON_POPOVER_PROPS$1 = { portal: !0, tone: "default" }, ItemRow = React.forwardRef(function(props2, ref) {
  const {
    sortable: sortable2,
    value,
    insertableTypes,
    onInsert,
    onRemove,
    readOnly,
    inputId,
    validation: validation2,
    children,
    presence,
    schemaType
  } = props2, hasError = validation2.filter((item) => item.level === "error").length > 0, hasWarning = validation2.filter((item) => item.level === "warning").length > 0, handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({ position: pos, items: [getEmptyValue(insertType)] });
    },
    [onInsert]
  ), handleDuplicate = React.useCallback(() => {
    value && onInsert({ position: "after", items: [value] });
  }, [onInsert, value]), tone = React.useMemo(() => {
    if (hasError)
      return "critical";
    if (hasWarning)
      return "caution";
  }, [hasError, hasWarning]), { t: t2 } = useTranslation(), menu = /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
      id: `${inputId}-menuButton`,
      popover: MENU_BUTTON_POPOVER_PROPS$1,
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: t2("inputs.array.action.remove"),
            tone: "critical",
            icon: icons.TrashIcon,
            onClick: onRemove
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: t2("inputs.array.action.duplicate"),
            icon: icons.CopyIcon,
            onClick: handleDuplicate
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
      ] })
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      tone,
      menu: !readOnly && menu,
      dragHandle: !readOnly && sortable2,
      presence: presence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence, maxAvatars: 1 }),
      validation: validation2.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: validation2 }) }) : null,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: schemaType ? "flex-end" : "center", ref, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-end", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginRight: 2, children }) }) })
    }
  );
});
function NoItemsPlaceholder({ schemaType }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || t2("inputs.array.no-items-label") }) });
}
function nearestIndexOf(array, startIdx, searchElement) {
  return nearestIndex(array, startIdx, (element) => element === searchElement);
}
function nearestIndex(array, startIdx, predicate) {
  let lowerIdx = startIdx - 1, upperIdx = startIdx;
  const len = array.length;
  for (; lowerIdx > -1 || upperIdx < len; ) {
    const upper = array[upperIdx];
    if (upperIdx < len && predicate(upper, upperIdx))
      return upperIdx;
    const lower = array[lowerIdx];
    if (lowerIdx > -1 && predicate(lower, lowerIdx))
      return lowerIdx;
    lowerIdx--, upperIdx++;
  }
  return -1;
}
class ArrayOfPrimitivesInput extends React.PureComponent {
  constructor(props2) {
    super(props2), this._element = null, this.handleAppend = (itemValue) => {
      const { value = [], onIndexFocus, onItemAppend } = this.props;
      onItemAppend(itemValue), onIndexFocus(value.length);
    }, this.handlePrepend = (itemValue) => {
      const { onIndexFocus, value = [], onItemPrepend } = this.props;
      onItemPrepend(itemValue), onIndexFocus(value.length);
    }, this.handleSortEnd = (event) => {
      const { onIndexFocus, onMoveItem, value } = this.props;
      value && onMoveItem(event), onIndexFocus(event.toIndex);
    }, this.handleItemMoveStart = () => {
      this.setState({ disableTransition: !1 });
    }, this.handleItemMoveEnd = () => {
      this.setState({ disableTransition: !0 });
    }, this.renderArrayItem = (props3) => {
      var _a2;
      const { schemaType } = this.props, sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1;
      return /* @__PURE__ */ jsxRuntime.jsx(ItemRow, { ...props3, sortable: sortable2, insertableTypes: schemaType.of });
    }, this.state = {
      disableTransition: !1
    };
  }
  focus() {
    this._element && this._element.focus();
  }
  getSnapshotBeforeUpdate(prevProps) {
    var _a2;
    const { focusPath: prevFocusPath = [], value: prevValue = [] } = prevProps, { focusPath = [], value = [] } = this.props;
    if (prevFocusPath[0] === focusPath[0] && prevValue.length !== value.length) {
      const focusIndex = focusPath[0], selection = window.getSelection();
      if (!((selection == null ? void 0 : selection.focusNode) instanceof HTMLElement))
        return null;
      const input = (_a2 = selection.focusNode) == null ? void 0 : _a2.querySelector("input,textarea");
      return input instanceof HTMLInputElement ? {
        prevFocusedIndex: focusIndex,
        restoreSelection: {
          text: selection.toString(),
          start: input.selectionStart,
          end: input.selectionEnd,
          value: input.value
        }
      } : {};
    }
    return null;
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    var _a2;
    const { onIndexFocus } = this.props;
    if (snapshot != null && snapshot.restoreSelection && prevProps.value) {
      const prevFocusedValue = prevProps.value[snapshot.prevFocusedIndex], nearestIndex2 = nearestIndexOf(
        this.props.value || [],
        snapshot.prevFocusedIndex,
        prevFocusedValue
      );
      if (nearestIndex2 === -1)
        return;
      const newInput = (_a2 = this._element) == null ? void 0 : _a2.querySelector(
        `[data-item-index='${nearestIndex2}'] input,textarea`
      );
      if (newInput instanceof HTMLInputElement) {
        newInput.focus();
        try {
          newInput.setSelectionRange(snapshot.restoreSelection.start, snapshot.restoreSelection.end);
        } catch {
        }
      }
      onIndexFocus(nearestIndex2);
    }
  }
  render() {
    const {
      schemaType,
      members,
      readOnly,
      renderInput,
      onUpload,
      onItemRemove,
      resolveUploader: resolveUploader2,
      elementProps,
      arrayFunctions: ArrayFunctions = ArrayOfPrimitivesFunctions,
      changed
    } = this.props, isSortable = !readOnly && get__default.default(schemaType, "options.sortable") !== !1, membersWithSortIds = members.map((member) => ({
      id: `${member.key}-${member.kind === "item" ? member.item.value : "error"}`,
      member
    }));
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, "data-testid": "array-primitives-input", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        UploadTargetCard,
        {
          types: schemaType.of,
          resolveUploader: resolveUploader2,
          onUpload,
          ...elementProps,
          tabIndex: 0,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: membersWithSortIds.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(NoItemsPlaceholder, { schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            List,
            {
              onItemMove: this.handleSortEnd,
              onItemMoveStart: this.handleItemMoveStart,
              onItemMoveEnd: this.handleItemMoveEnd,
              items: membersWithSortIds.map((m) => m.id),
              sortable: isSortable,
              gap: 1,
              children: membersWithSortIds.map(({ member, id: id2 }, index) => /* @__PURE__ */ jsxRuntime.jsxs(
                Item,
                {
                  id: id2,
                  sortable: isSortable,
                  disableTransition: this.state.disableTransition,
                  children: [
                    member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                      ChangeIndicator,
                      {
                        path: member.item.path,
                        isChanged: changed,
                        hasFocus: !1,
                        children: /* @__PURE__ */ jsxRuntime.jsx(
                          ArrayOfPrimitivesItem,
                          {
                            member,
                            renderItem: this.renderArrayItem,
                            renderInput
                          }
                        )
                      }
                    ),
                    member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(
                      ErrorItem,
                      {
                        sortable: isSortable,
                        member,
                        onRemove: () => onItemRemove(index)
                      }
                    )
                  ]
                },
                member.key
              ))
            }
          ) }) })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFunctions,
        {
          onChange: this.props.onChange,
          onItemAppend: this.handleAppend,
          onItemPrepend: this.handlePrepend,
          onValueCreate: getEmptyValue,
          readOnly: this.props.readOnly,
          schemaType: this.props.schemaType,
          value: this.props.value
        }
      )
    ] });
  }
}
function UniversalArrayInput(props2) {
  return React.useMemo(
    () => {
      var _a2;
      return Array.isArray((_a2 = props2.schemaType.options) == null ? void 0 : _a2.list);
    },
    [props2.schemaType]
  ) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfOptionsInput, { ...props2 }) : isArrayOfPrimitivesInputProps(props2) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfPrimitivesInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectsInput, { ...props2 });
}
const Root$g = styled__default.default(ui.Card)`
  line-height: 1;
`, CenterAlignedBox = styled__default.default(ui.Box)`
  align-self: center;
`, ZeroLineHeightBox = styled__default.default(ui.Box)`
  line-height: 0;
`;
function BooleanInput(props2) {
  var _a2;
  const { id: id2, value, schemaType, readOnly, elementProps, validation: validation2 } = props2, layout = ((_a2 = schemaType.options) == null ? void 0 : _a2.layout) || "switch", indeterminate = typeof value != "boolean", checked = value || !1;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$g, { border: !0, "data-testid": "boolean-input", radius: 2, tone: readOnly ? "transparent" : void 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ZeroLineHeightBox, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      layout === "checkbox" ? ui.Checkbox : ui.Switch,
      {
        label: schemaType.title,
        ...elementProps,
        checked,
        disabled: readOnly,
        indeterminate,
        style: { margin: -4 }
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldHeaderText,
      {
        deprecated: schemaType.deprecated,
        description: schemaType.description,
        inputId: id2,
        validation: validation2,
        title: schemaType.title
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(CenterAlignedBox, { paddingX: 3, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldStatus, { maxAvatars: 1, position: "top" }) })
  ] }) });
}
const DateTimeInput$1 = React.forwardRef(function(props2, ref) {
  const {
    value,
    inputValue,
    onInputChange,
    onChange,
    selectTime,
    timeStep,
    calendarLabels,
    ...rest
  } = props2, [popoverRef, setPopoverRef] = React.useState(null), forwardedRef = ui.useForwardedRef(ref), buttonRef = React.useRef(null), [isPickerOpen, setPickerOpen] = React.useState(!1);
  ui.useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleDeactivation = React.useCallback(() => {
    var _a2, _b;
    (_a2 = forwardedRef.current) == null || _a2.focus(), (_b = forwardedRef.current) == null || _b.select();
  }, [forwardedRef]), handleKeyUp = React.useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = React.useCallback(() => setPickerOpen(!0), []), suffix = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { padding: "5px" }, children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ref: buttonRef,
      icon: icons.CalendarIcon,
      mode: "bleed",
      onClick: handleClick,
      style: { display: "block" },
      "data-testid": "select-date-button",
      tooltipProps: { content: "Select date" }
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.LazyTextInput,
    {
      ref: forwardedRef,
      ...rest,
      value: inputValue,
      onChange: onInputChange,
      suffix: isPickerOpen ? (
        // Note: we're conditionally inserting the popover here due to an
        // issue with popovers rendering incorrectly on subsequent renders
        // see https://github.com/sanity-io/design/issues/519
        /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 1e3, children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Popover,
          {
            constrainSize: !0,
            "data-testid": "date-input-dialog",
            portal: !0,
            content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { onDeactivation: handleDeactivation, children: /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.DatePicker,
              {
                calendarLabels,
                selectTime,
                timeStep,
                onKeyUp: handleKeyUp,
                value,
                onChange
              }
            ) }) }),
            open: !0,
            placement: "bottom",
            ref: setPopoverRef,
            children: suffix
          }
        ) })
      ) : suffix
    }
  );
}), DEFAULT_PLACEHOLDER_TIME = /* @__PURE__ */ new Date(), CommonDateTimeInput = React.forwardRef(function(props2, ref) {
  const {
    id: id2,
    deserialize: deserialize2,
    formatInputValue,
    onChange,
    parseInputValue,
    placeholder,
    readOnly,
    selectTime,
    serialize: serialize2,
    timeStep,
    value,
    ...restProps
  } = props2, [localValue, setLocalValue] = React.useState(null), { t: t2 } = useTranslation();
  React.useEffect(() => {
    setLocalValue(null);
  }, [value]);
  const handleDatePickerInputChange = React.useCallback(
    (event) => {
      const nextInputValue = event.currentTarget.value, result = nextInputValue === "" ? null : parseInputValue(nextInputValue);
      result === null ? (onChange(null), typeof value > "u" && localValue && setLocalValue(null)) : result.isValid ? onChange(serialize2(result.date)) : setLocalValue(nextInputValue);
    },
    [parseInputValue, onChange, value, localValue, serialize2]
  ), handleDatePickerChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate ? serialize2(nextDate) : null);
    },
    [serialize2, onChange]
  ), forwardedRef = ui.useForwardedRef(ref), parseResult = localValue ? parseInputValue(localValue) : value ? deserialize2(value) : null, inputValue = localValue || (parseResult != null && parseResult.isValid ? formatInputValue(parseResult.date) : value);
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: inputValue, readOnly: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(
    DateTimeInput$1,
    {
      ...restProps,
      calendarLabels: props2.calendarLabels,
      id: id2,
      selectTime,
      timeStep,
      placeholder: placeholder || t2("inputs.datetime.placeholder", {
        example: formatInputValue(DEFAULT_PLACEHOLDER_TIME)
      }),
      ref: forwardedRef,
      value: parseResult == null ? void 0 : parseResult.date,
      inputValue: inputValue || "",
      readOnly: !!readOnly,
      onInputChange: handleDatePickerInputChange,
      onChange: handleDatePickerChange,
      customValidity: parseResult == null ? void 0 : parseResult.error
    }
  );
}), deserialize$1 = (value) => legacyDateFormat.parse(value, legacyDateFormat.DEFAULT_DATE_FORMAT), serialize$2 = (date) => legacyDateFormat.format(date, legacyDateFormat.DEFAULT_DATE_FORMAT);
function DateInput(props2) {
  var _a2;
  const { readOnly, onChange, schemaType, elementProps, value } = props2, dateFormat = ((_a2 = schemaType.options) == null ? void 0 : _a2.dateFormat) || legacyDateFormat.DEFAULT_DATE_FORMAT, { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate === null ? unset() : set(nextDate));
    },
    [onChange]
  ), formatInputValue = React.useCallback((date) => legacyDateFormat.format(date, dateFormat), [dateFormat]), parseInputValue = React.useCallback(
    (inputValue) => legacyDateFormat.parse(inputValue, dateFormat),
    [dateFormat]
  ), calendarLabels = React.useMemo(() => getJsonStream.getCalendarLabels(t2), [t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommonDateTimeInput,
    {
      ...elementProps,
      deserialize: deserialize$1,
      formatInputValue,
      onChange: handleChange,
      parseInputValue,
      placeholder: schemaType.placeholder,
      calendarLabels,
      readOnly,
      selectTime: !1,
      serialize: serialize$2,
      value
    }
  );
}
function parseOptions(options = {}) {
  return {
    dateFormat: options.dateFormat || legacyDateFormat.DEFAULT_DATE_FORMAT,
    timeFormat: options.timeFormat || legacyDateFormat.DEFAULT_TIME_FORMAT,
    timeStep: "timeStep" in options && Number(options.timeStep) || 1
  };
}
function serialize$1(date) {
  return date.toISOString();
}
function deserialize(isoString) {
  const deserialized = new Date(isoString);
  return getJsonStream.isValidDate(deserialized) ? { isValid: !0, date: deserialized } : { isValid: !1, error: `Invalid date value: "${isoString}"` };
}
function enforceTimeStep(dateString, timeStep) {
  if (!timeStep || timeStep === 1)
    return dateString;
  const date = dateFns.parseISO(dateString), minutes = dateFns.getMinutes(date), leftOver = minutes % timeStep;
  return serialize$1(leftOver !== 0 ? dateFns.setMinutes(date, minutes - leftOver) : date);
}
function DateTimeInput(props2) {
  const { onChange, schemaType, value, elementProps } = props2, { dateFormat, timeFormat, timeStep } = parseOptions(schemaType.options), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (nextDate) => {
      let date = nextDate;
      date !== null && timeStep > 1 && (date = enforceTimeStep(date, timeStep)), onChange(date === null ? unset() : set(date));
    },
    [onChange, timeStep]
  ), formatInputValue = React.useCallback(
    (date) => legacyDateFormat.format(date, `${dateFormat} ${timeFormat}`),
    [dateFormat, timeFormat]
  ), parseInputValue = React.useCallback(
    (inputValue) => legacyDateFormat.parse(inputValue, `${dateFormat} ${timeFormat}`),
    [dateFormat, timeFormat]
  ), calendarLabels = React.useMemo(() => getJsonStream.getCalendarLabels(t2), [t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommonDateTimeInput,
    {
      ...elementProps,
      calendarLabels,
      onChange: handleChange,
      deserialize,
      formatInputValue,
      parseInputValue,
      placeholder: schemaType.placeholder,
      selectTime: !0,
      serialize: serialize$1,
      timeStep,
      value
    }
  );
}
function EmailInput(props2) {
  const { validationError, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...elementProps, type: "email", inputMode: "email", customValidity: validationError });
}
const normalizeRules = (validation2, type) => {
  if (typeof validation2 == "function")
    throw new Error(
      `Schema type "${(type == null ? void 0 : type.name) || "<not-found>"}"'s \`validation\` was not run though \`inferFromSchema\``
    );
  return validation2 ? Array.isArray(validation2) ? validation2 : [validation2] : [];
};
function getValidationRule(type, ruleName) {
  for (const rule of normalizeRules(type == null ? void 0 : type.validation, type))
    for (const ruleSpec of rule._rules)
      if (ruleSpec.flag === ruleName)
        return ruleSpec;
  return null;
}
function NumberInput(props2) {
  const { schemaType, validationError, elementProps } = props2, minRule = getValidationRule(schemaType, "min"), integerRule = getValidationRule(schemaType, "integer"), precisionRule = getValidationRule(schemaType, "precision"), onlyPositiveNumber = typeof (minRule == null ? void 0 : minRule.constraint) == "number" && (minRule == null ? void 0 : minRule.constraint) >= 0, onlyIntegers = integerRule || (precisionRule == null ? void 0 : precisionRule.constraint) === 0;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      ...elementProps,
      type: "number",
      step: "any",
      inputMode: onlyPositiveNumber ? onlyIntegers ? "numeric" : "decimal" : "text",
      customValidity: validationError,
      placeholder: schemaType.placeholder,
      pattern: onlyPositiveNumber ? "[d]*" : void 0,
      max: Number.MAX_SAFE_INTEGER,
      min: Number.MIN_SAFE_INTEGER,
      "data-testid": "number-input"
    }
  );
}
const GroupTab = React.forwardRef(function(props2, ref) {
  const { onClick } = props2, handleClick = React.useCallback(() => {
    onClick == null || onClick(props2.name);
  }, [props2.name, onClick]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tab,
    {
      "data-testid": `group-tab-${props2.name}`,
      id: `${props2.name}-tab`,
      label: props2.title,
      ref,
      ...props2,
      onClick: handleClick
    }
  );
}), GroupOption = (props2) => {
  const { name, title, ...rest } = props2, { selected } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    "option",
    {
      title,
      value: name,
      id: `${name}-tab`,
      "aria-controls": rest["aria-controls"],
      "data-testid": `group-select-${name}`,
      "aria-selected": selected ? "true" : "false",
      children: title || name
    }
  );
}, Root$f = styled__default.default(ui.ElementQuery)`
  /* Hide on small screens */
  &[data-eq-max~='0'] [data-ui='TabList'] {
    display: none;
  }

  /* Hide on medium to large screens */
  [data-ui='Select'] {
    display: none;
  }

  /* Show on small screens */
  &[data-eq-max~='0'] [data-ui='Select'] {
    display: block;
  }
`, GroupTabs = ({
  inputId,
  groups,
  onClick,
  shouldAutoFocus = !0,
  disabled
}) => /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 2, "data-testid": "field-group-tabs", children: groups.map((group2) => /* @__PURE__ */ jsxRuntime.jsx(
  GroupTab,
  {
    "aria-controls": `${inputId}-field-group-fields`,
    autoFocus: shouldAutoFocus && group2.selected,
    disabled: disabled || group2.disabled,
    icon: group2 == null ? void 0 : group2.icon,
    name: group2.name,
    onClick,
    selected: !!group2.selected,
    title: group2.title || group2.name
  },
  `${inputId}-${group2.name}-tab`
)) }), GroupSelect = ({
  disabled,
  groups,
  inputId,
  onSelect,
  shouldAutoFocus = !0
}) => {
  var _a2;
  const handleSelect = React.useCallback(
    (event) => {
      onSelect(event.currentTarget.value);
    },
    [onSelect]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Select,
    {
      "aria-label": t2("inputs.object.field-group-tabs.aria-label"),
      autoFocus: shouldAutoFocus,
      "data-testid": "field-group-select",
      disabled,
      fontSize: 2,
      muted: !0,
      onChange: handleSelect,
      value: (_a2 = groups.find((g) => g.selected)) == null ? void 0 : _a2.name,
      children: groups.map((group2) => /* @__PURE__ */ jsxRuntime.jsx(
        GroupOption,
        {
          "aria-controls": `${inputId}-field-group-fields`,
          disabled: group2.disabled,
          name: group2.name,
          selected: !!group2.selected,
          title: group2.title || group2.name
        },
        `${inputId}-${group2.name}-tab`
      ))
    }
  );
}, FieldGroupTabs = React.memo(function({
  disabled = !1,
  onClick,
  ...props2
}) {
  const handleClick = React.useCallback(
    (groupName) => {
      onClick == null || onClick(groupName);
    },
    [onClick]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$f, { "data-testid": "field-group-root", children: [
    /* @__PURE__ */ jsxRuntime.jsx(GroupTabs, { ...props2, disabled, onClick: handleClick }),
    /* @__PURE__ */ jsxRuntime.jsx(GroupSelect, { ...props2, disabled, onSelect: handleClick })
  ] });
}), FieldGroupTabsWrapper = styled__default.default(ui.Card)`
  margin-bottom: ${({ $level, theme: theme2 }) => $level === 0 ? 0 : theme2.sanity.space[5] * -1}px;
  padding-bottom: ${({ $level, theme: theme2 }) => theme2.sanity.space[4]}px;
`, AlignedBottomGrid = styled__default.default(ui.Grid)`
  align-items: flex-end;
`;
function UnknownFields(props2) {
  const { fieldNames, onChange, readOnly, value } = props2, fieldsLen = fieldNames.length, handleUnsetClick = React.useCallback(
    (fieldName) => {
      onChange(unset([fieldName]));
    },
    [onChange]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.title", { count: fieldsLen }) }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.description", { count: fieldsLen }) }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("inputs.object.unknown-fields.warning.details.title"),
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.details.description", { count: fieldsLen }) }) }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 3, children: fieldNames.map((fieldName) => /* @__PURE__ */ jsxRuntime.jsx(
                UnknownField,
                {
                  fieldName,
                  onUnsetClick: handleUnsetClick,
                  readOnly,
                  value: value == null ? void 0 : value[fieldName]
                },
                fieldName
              )) })
            ]
          }
        )
      ]
    }
  );
}
function UnknownField({
  fieldName,
  onUnsetClick,
  readOnly,
  value
}) {
  const handleUnsetClick = React.useCallback(() => {
    onUnsetClick(fieldName);
  }, [fieldName, onUnsetClick]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: "li", overflow: "hidden", radius: 2, shadow: 1, tone: "caution", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: fieldName }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: JSON.stringify(value, null, 2) }) }),
    readOnly && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.object.unknown-fields.read-only.description" }) }) }),
    !readOnly && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.TrashIcon,
        mode: "ghost",
        onClick: handleUnsetClick,
        size: "large",
        tone: "critical",
        text: t2("inputs.object.unknown-fields.remove-field-button.text")
      }
    ) })
  ] });
}
const ObjectInput = React.memo(function(props2) {
  const {
    schemaType,
    groups,
    members,
    onChange,
    renderAnnotation,
    renderBlock,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem,
    renderPreview,
    level,
    value,
    id: id2,
    onFieldGroupSelect
  } = props2, { columns } = schemaType.options || {}, renderedUnknownFields = React.useMemo(() => {
    if (!schemaType.fields)
      return null;
    const knownFieldNames = schemaType.fields.map((field) => field.name), unknownFields = Object.keys(value || {}).filter(
      (key) => !key.startsWith("_") && !knownFieldNames.includes(key)
    );
    return unknownFields.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(UnknownFields, { fieldNames: unknownFields, value, onChange });
  }, [onChange, schemaType.fields, value]), selectedGroup = React.useMemo(() => groups.find(({ selected }) => selected), [groups]), renderObjectMembers = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ObjectInputMembers,
      {
        members,
        renderAnnotation,
        renderBlock,
        renderField,
        renderInlineBlock,
        renderInput,
        renderItem,
        renderPreview
      }
    ),
    [
      members,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    ]
  );
  return members.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 6, children: [
    groups.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(FieldGroupTabsWrapper, { $level: level, "data-testid": "field-groups", children: /* @__PURE__ */ jsxRuntime.jsx(
      FieldGroupTabs,
      {
        groups,
        inputId: id2,
        onClick: onFieldGroupSelect,
        shouldAutoFocus: !1
      }
    ) }) : null,
    /* @__PURE__ */ jsxRuntime.jsx(
      React.Fragment,
      {
        children: columns ? /* @__PURE__ */ jsxRuntime.jsx(AlignedBottomGrid, { columns, gap: 4, marginTop: 1, children: renderObjectMembers() }) : renderObjectMembers()
      },
      selectedGroup == null ? void 0 : selectedGroup.name
    ),
    renderedUnknownFields
  ] });
}), GetFormValueContext = React.createContext(null);
function GetFormValueProvider(props2) {
  const valueRef = React.useRef(props2.value);
  valueRef.current = props2.value;
  const getValue2 = React.useCallback((path) => getValueAtPath(valueRef.current, path), [valueRef]);
  return /* @__PURE__ */ jsxRuntime.jsx(GetFormValueContext.Provider, { value: getValue2, children: props2.children });
}
function useGetFormValue() {
  const ctx = React.useContext(GetFormValueContext);
  if (!ctx)
    throw new Error("useFormValue must be used within a FormValueProvider");
  return ctx;
}
const defaultSlugify = (value, type) => {
  var _a2;
  const maxLength = (_a2 = type.options) == null ? void 0 : _a2.maxLength;
  return value ? speakingurl__default.default(value, { truncate: typeof maxLength == "number" ? maxLength : 200, symbols: !0 }) : "";
};
async function slugify(sourceValue, type, context) {
  var _a2;
  return sourceValue && (((_a2 = type.options) == null ? void 0 : _a2.slugify) || defaultSlugify)(sourceValue, type, context);
}
function useAsync(fn, dependencies) {
  const [state, setState] = React.useState(null), lastId = React.useRef(0), wrappedCallback = React.useCallback(
    (arg) => {
      const asyncId = ++lastId.current;
      setState({ status: "pending" }), Promise.resolve().then(() => fn(arg)).then(
        (res) => {
          asyncId === lastId.current && setState({ status: "complete", result: res });
        },
        (err) => {
          asyncId === lastId.current && setState({ status: "error", error: err });
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- this is under control, and enforced by our linter setup
    [fn, ...dependencies]
  );
  return [state, wrappedCallback];
}
function useSlugContext() {
  const { getClient } = useSource(), schema2 = useSchema(), currentUser = useCurrentUser(), projectId = useProjectId(), dataset = useDataset();
  return React.useMemo(() => ({
    projectId,
    dataset,
    getClient,
    schema: schema2,
    currentUser
  }), [getClient, schema2, currentUser, projectId, dataset]);
}
function getSlugSourceContext(valuePath, document2, context) {
  const parentPath = valuePath.slice(0, -1), parent = PathUtils__namespace.get(document2, parentPath);
  return { parentPath, parent, ...context };
}
async function getNewFromSource(source, document2, context) {
  return typeof source == "function" ? source(document2, context) : PathUtils__namespace.get(document2, source);
}
function SlugInput(props2) {
  var _a2;
  const getFormValue = useGetFormValue(), { path, value, schemaType, validation: validation2, onChange, readOnly, elementProps } = props2, sourceField = (_a2 = schemaType.options) == null ? void 0 : _a2.source, errors = React.useMemo(() => validation2.filter((item) => item.level === "error"), [validation2]), slugContext = useSlugContext(), { t: t2 } = useTranslation(), updateSlug = React.useCallback(
    (nextSlug) => {
      if (!nextSlug) {
        onChange(PatchEvent.from(unset([])));
        return;
      }
      onChange(
        PatchEvent.from([setIfMissing({ _type: schemaType.name }), set(nextSlug, ["current"])])
      );
    },
    [onChange, schemaType.name]
  ), [generateState, handleGenerateSlug] = useAsync(() => {
    if (!sourceField)
      return Promise.reject(
        new Error(t2("inputs.slug.error.missing-source", { schemaType: schemaType.name }))
      );
    const doc = getFormValue([]) || { _type: schemaType.name }, sourceContext = getSlugSourceContext(path, doc, slugContext);
    return getNewFromSource(sourceField, doc, sourceContext).then((newFromSource) => slugify(newFromSource || "", schemaType, sourceContext)).then((newSlug) => updateSlug(newSlug));
  }, [sourceField, getFormValue, schemaType, path, slugContext, updateSlug, t2]), isUpdating = (generateState == null ? void 0 : generateState.status) === "pending", handleChange = React.useCallback(
    (event) => updateSlug(event.currentTarget.value),
    [updateSlug]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.TextInput,
        {
          customValidity: errors.length > 0 ? errors[0].message : "",
          disabled: isUpdating,
          onChange: handleChange,
          value: (value == null ? void 0 : value.current) || "",
          readOnly,
          ...elementProps
        }
      ),
      (generateState == null ? void 0 : generateState.status) === "error" && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, tone: "critical", children: generateState.error.message })
    ] }),
    sourceField && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        mode: "ghost",
        type: "button",
        disabled: readOnly || isUpdating,
        onClick: handleGenerateSlug,
        size: "large",
        text: (generateState == null ? void 0 : generateState.status) === "pending" ? t2("inputs.slug.action.generating") : t2("inputs.slug.action.generate")
      }
    )
  ] }) });
}
function StringInput(props2) {
  const { validationError, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...elementProps, customValidity: validationError, "data-testid": "string-input" });
}
const StyledTextArea = styled__default.default(ui.TextArea)`
  &[data-as='textarea'] {
    resize: vertical;
  }
`;
function TextInput(props2) {
  const { schemaType, validationError, value, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledTextArea,
    {
      customValidity: validationError,
      value: value || "",
      placeholder: schemaType.placeholder,
      rows: typeof schemaType.rows == "number" ? schemaType.rows : 10,
      ...elementProps
    }
  );
}
function UrlInput(props2) {
  var _a2, _b;
  const { schemaType, validationError, elementProps } = props2, uriRule = getValidationRule(schemaType, "uri"), inputType = (_b = (_a2 = uriRule == null ? void 0 : uriRule.constraint) == null ? void 0 : _a2.options) != null && _b.allowRelative ? "text" : "url";
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      type: inputType,
      inputMode: "url",
      customValidity: validationError,
      ...elementProps
    }
  );
}
function DisabledFeatureWarning({ value, onClearValue }) {
  const hasRef = React.useMemo(() => !!(value != null && value._ref), [value == null ? void 0 : value._ref]), { t: t2 } = useTranslation(), description = /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "inputs.reference.cross-dataset.feature-disabled-description",
      components: {
        DocumentationLink: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(
          "a",
          {
            href: "https://www.sanity.io/docs/cross-dataset-references",
            target: "_blank",
            rel: "noreferrer",
            children
          }
        )
      }
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Card,
    {
      tone: "caution",
      padding: 4,
      border: !0,
      radius: 2,
      "data-testid": "alert-cross-dataset-reference-feature-disabled",
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: hasRef ? 4 : void 0, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h2", size: 1, weight: "medium", children: t2("inputs.reference.cross-dataset.feature-unavailable-title") }),
            hasRef && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: description }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: t2("inputs.reference.cross-dataset.feature-disabled-actions") })
            ] }),
            !hasRef && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: description })
          ] })
        ] }),
        onClearValue && hasRef && /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            icon: icons.ResetIcon,
            mode: "ghost",
            onClick: onClearValue,
            text: t2("inputs.reference.action.clear"),
            width: "fill"
          }
        )
      ]
    }
  );
}
const StyledPreviewFlex = styled__default.default(ui.Flex)`
  /* this is a hack to avoid layout jumps while previews are loading
  or the message is not tall enough to fill the card
  there's probably better ways of solving this */
  min-height: 36px;
`;
function CrossDatasetReferencePreview(props2) {
  var _a2, _b, _c;
  const {
    refType,
    showStudioUrlIcon,
    hasStudioUrl,
    showTypeLabel,
    availability,
    preview,
    id: id2,
    dataset,
    projectId
  } = props2, notFound = (availability == null ? void 0 : availability.reason) === "NOT_FOUND", insufficientPermissions = (availability == null ? void 0 : availability.reason) === "PERMISSION_DENIED", previewMedia = (_a2 = preview.published) == null ? void 0 : _a2.media, { t: t2 } = useTranslation(), media = React.useMemo(() => {
    if (previewMedia) {
      const isValidImageAsset = typeof (previewMedia == null ? void 0 : previewMedia.asset) < "u" && assetUtils.isImageSource(previewMedia), isValidElement = React.isValidElement(previewMedia);
      return !isValidImageAsset && !isValidElement ? null : function({ dimensions }) {
        return isValidElement ? previewMedia : /* @__PURE__ */ jsxRuntime.jsx(
          "img",
          {
            src: imageUrlBuilder__default.default({ dataset, projectId }).image(previewMedia).withOptions(dimensions).url(),
            alt: t2("inputs.reference.image-preview-alt-text"),
            referrerPolicy: "strict-origin-when-cross-origin"
          }
        );
      };
    }
    return refType != null && refType.icon ? React.createElement(refType.icon) : null;
  }, [previewMedia, dataset, projectId, refType == null ? void 0 : refType.icon, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledPreviewFlex, { align: "center", justify: "center", flex: 1, "data-testid": "preview", children: [
    availability != null && availability.available ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      DefaultPreview,
      {
        title: (_b = preview.published) == null ? void 0 : _b.title,
        subtitle: (_c = preview.published) == null ? void 0 : _c.subtitle,
        media: media || !1
      }
    ) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.document-unavailable-title") }) }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 4, children: [
      refType && showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType.title || refType.type }),
      (insufficientPermissions || notFound) && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Tooltip,
        {
          portal: !0,
          content: t2(
            notFound ? "inputs.reference.referenced-document-does-not-exist" : "inputs.reference.referenced-document-insufficient-permissions",
            { documentId: id2 }
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: insufficientPermissions ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) })
        }
      ) }),
      !(notFound || insufficientPermissions) && showStudioUrlIcon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Tooltip,
        {
          portal: !0,
          content: t2(
            hasStudioUrl ? "inputs.reference.document-opens-in-new-tab" : "input.reference.document-cannot-be-opened.failed-to-resolve-url"
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "default", muted: !hasStudioUrl, children: /* @__PURE__ */ jsxRuntime.jsx(icons.LaunchIcon, {}) })
        }
      ) })
    ] }) })
  ] });
}
const noop = () => {
}, INITIAL_LOADING_STATE$1 = {
  isLoading: !0,
  result: void 0,
  error: void 0,
  retry: noop
}, EMPTY_STATE = {
  isLoading: !1,
  result: void 0,
  error: void 0,
  retry: noop
};
function useReferenceInfo(doc, getReferenceInfo2) {
  const [retryAttempt, setRetryAttempt] = React.useState(0), retry = React.useCallback(() => {
    setRetryAttempt((current) => current + 1);
  }, []), docInfo = React.useMemo(() => ({ _id: doc._id, _type: doc._type }), [doc._id, doc._type]), referenceInfo = reactRx.useMemoObservable(
    () => docInfo._id ? getReferenceInfo2(docInfo).pipe(
      operators.map(
        (result) => ({
          isLoading: !1,
          result,
          error: void 0,
          retry,
          retryAttempt
        })
      ),
      operators.startWith(INITIAL_LOADING_STATE$1),
      operators.catchError((err) => (console.error(err), rxjs.of({
        isLoading: !1,
        result: void 0,
        error: err,
        retry,
        retryAttempt
      })))
    ) : rxjs.of(EMPTY_STATE),
    [docInfo, getReferenceInfo2, retry, retryAttempt],
    INITIAL_LOADING_STATE$1
  ), previousId = usePrevious(doc._id, doc._id);
  return doc._id && previousId !== doc._id ? INITIAL_LOADING_STATE$1 : referenceInfo;
}
function useProjectId$1() {
  return useClient(DEFAULT_STUDIO_CLIENT_OPTIONS).config().projectId;
}
function OptionPreview(props2) {
  var _a2;
  const {
    isLoading,
    result: referenceInfo,
    error
  } = useReferenceInfo(props2.document, props2.getReferenceInfo), { t: t2 } = useTranslation(), projectId = useProjectId$1();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !0 })
    ] });
  if (error)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Alert, { title: t2("inputs.reference.error.failed-to-load-document-title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: error.message }) }) });
  if (!referenceInfo)
    return null;
  if (((_a2 = referenceInfo.availability) == null ? void 0 : _a2.reason) === "PERMISSION_DENIED")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.missing-read-permissions-description") });
  const refType = props2.referenceType.to.find((toEntry) => toEntry.type === referenceInfo.type);
  return refType ? referenceInfo && refType && /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferencePreview,
    {
      id: referenceInfo.id,
      availability: referenceInfo.availability,
      preview: referenceInfo.preview,
      refType,
      dataset: props2.referenceType.dataset,
      projectId,
      showTypeLabel: props2.referenceType.to.length > 1
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.invalid-search-result-type-title", {
    returnedType: referenceInfo.type
  }) });
}
function PreviewReferenceValue(props2) {
  var _a2, _b;
  const { value, type, showStudioUrlIcon, hasStudioUrl, referenceInfo } = props2, { t: t2 } = useTranslation(), projectId = useProjectId$1();
  if (referenceInfo.isLoading || referenceInfo.error)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !referenceInfo.error }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !referenceInfo.error })
    ] });
  const showTypeLabel = type.to.length > 1, refTypeName = (_a2 = referenceInfo.result) == null ? void 0 : _a2.type, refType = type.to.find((toType) => toType.type === refTypeName);
  return (_b = referenceInfo.result.availability) != null && _b.available && !refType ? /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "inputs.reference.cross-dataset.invalid-type",
      values: { typeName: refTypeName || "unknown" },
      components: { JsonValue: () => /* @__PURE__ */ jsxRuntime.jsx("pre", { children: JSON.stringify(value, null, 2) }) }
    }
  ) }) }) : /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferencePreview,
    {
      availability: referenceInfo.result.availability,
      hasStudioUrl,
      showStudioUrlIcon,
      preview: referenceInfo.result.preview,
      refType,
      projectId,
      dataset: type.dataset,
      id: value._ref,
      showTypeLabel
    }
  );
}
const StyledPopover$2 = styled__default.default(getJsonStream.Popover)`
  & > div {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
`, StyledText$3 = styled__default.default(ui.Text)`
  word-break: break-word;
`, FALLBACK_PLACEMENTS$1 = ["top-start", "bottom-start"], ReferenceAutocomplete$1 = React.forwardRef(function(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2, { t: t2 } = useTranslation(), hasResults = props2.options && props2.options.length > 0, renderPopover = React.useCallback(
    ({
      content: content2,
      hidden,
      inputElement,
      onMouseEnter,
      onMouseLeave
    }, contentRef) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$2,
      {
        "data-testid": "autocomplete-popover",
        placement: "bottom-start",
        fallbackPlacements: FALLBACK_PLACEMENTS$1,
        arrow: !1,
        constrainSize: !0,
        onMouseEnter,
        onMouseLeave,
        content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$3, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.no-results-for-query",
            values: { searchTerm: searchString || "" }
          }
        ) }) }) }) }),
        open: !loading && !hidden,
        ref: portalRef,
        portal: !0,
        referenceElement: referenceElement || inputElement,
        matchReferenceWidth: !0
      }
    ),
    [hasResults, t2, searchString, loading, portalRef, referenceElement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Autocomplete, { ...restProps, ref, renderPopover });
}), INITIAL_SEARCH_STATE$1 = {
  hits: [],
  isLoading: !1
}, NO_FILTER$1 = () => !0, REF_PATH = ["_ref"], CROSS_DATASET_FEATUREKEY = "crossDatasetReferences";
function CrossDatasetReferenceInput(props2) {
  var _a2, _b;
  const {
    changed,
    focused,
    focusPath,
    getReferenceInfo: getReferenceInfo2,
    onChange,
    onPathFocus,
    onSearch,
    path,
    readOnly,
    schemaType,
    validation: validation2,
    value,
    elementProps
  } = props2, { t: t2 } = useTranslation(), projectId = useProjectId$1(), [searchState, setSearchState] = React.useState(INITIAL_SEARCH_STATE$1), handleChange = React.useCallback(
    (id2) => {
      if (!id2) {
        onChange(unset()), onPathFocus([]);
        return;
      }
      if (!searchState.hits.find((h) => h.id === id2))
        throw new Error("Selected an item that wasnt part of the result set");
      onChange(
        set({
          _type: schemaType.name,
          _ref: getPublishedId(id2),
          _projectId: projectId,
          _dataset: schemaType.dataset,
          _weak: schemaType.weak,
          // persist _key between mutations if the value is in an array
          _key: value == null ? void 0 : value._key
        })
      ), onPathFocus([]);
    },
    [
      value == null ? void 0 : value._key,
      searchState.hits,
      schemaType.name,
      schemaType.dataset,
      schemaType.weak,
      projectId,
      onChange,
      onPathFocus
    ]
  ), handleClear = React.useCallback(() => {
    onChange(unset());
  }, [onChange]), handleAutocompleteKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && (onPathFocus == null || onPathFocus([]));
    },
    [onPathFocus]
  ), getReferenceInfoMemo = React.useCallback(
    (doc) => getReferenceInfo2(doc, schemaType),
    [getReferenceInfo2, schemaType]
  ), refDoc = React.useMemo(() => ({ _id: value == null ? void 0 : value._ref }), [value == null ? void 0 : value._ref]), loadableReferenceInfo = useReferenceInfo(refDoc, getReferenceInfoMemo), featureInfo = useFeatureEnabled(CROSS_DATASET_FEATUREKEY), autocompletePopoverReferenceElementRef = React.useRef(null), hasFocusAtRef = focusPath.length === 1 && focusPath[0] === "_ref", focusElementRef = elementProps.ref;
  useDidUpdate({ hasFocusAt: hasFocusAtRef, ref: value == null ? void 0 : value._ref }, (prev, current) => {
    var _a22;
    const refUpdated = (prev == null ? void 0 : prev.ref) !== current.ref;
    ((prev == null ? void 0 : prev.hasFocusAt) !== current.hasFocusAt || refUpdated) && current.hasFocusAt && ((_a22 = focusElementRef.current) == null || _a22.focus());
  });
  const actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", hasRef = !!(value != null && value._ref), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), { push } = ui.useToast(), errors = React.useMemo(() => validation2.filter((item) => item.level === "error"), [validation2]), handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === elementProps.ref.current && (onPathFocus == null || onPathFocus([PathUtils.FOCUS_TERMINATOR]));
    },
    [elementProps.ref, onPathFocus]
  ), handleAutocompleteFocus = React.useCallback(
    (event) => {
      event.currentTarget === elementProps.ref.current && (onPathFocus == null || onPathFocus(REF_PATH));
    },
    [elementProps.ref, onPathFocus]
  ), handleReplace = React.useCallback(() => {
    onPathFocus == null || onPathFocus(REF_PATH);
  }, [onPathFocus]), inputId = React.useId(), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      operators.filter(isNonNullable$2),
      operators.distinctUntilChanged(),
      operators.switchMap(
        (searchString) => rxjs.concat(
          rxjs.of({ isLoading: !0 }),
          onSearch(searchString).pipe(
            operators.map((hits) => ({ hits, searchString, isLoading: !1 })),
            operators.catchError((error) => (push({
              title: "Reference search failed",
              description: error.message,
              status: "error",
              id: `reference-search-fail-${inputId}`
            }), console.error(error), rxjs.of({ hits: [] })))
          )
        )
      ),
      operators.scan(
        (prevState, nextState) => ({ ...prevState, ...nextState }),
        INITIAL_SEARCH_STATE$1
      ),
      operators.tap(setSearchState)
    ),
    [inputId, onSearch, push]
  ), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleQueryChange("");
  }, [handleQueryChange]), showWeakRefMismatch = !loadableReferenceInfo.isLoading && hasRef && actualStrength !== weakShouldBe, studioUrl = (value == null ? void 0 : value._ref) && ((_b = schemaType.studioUrl) == null ? void 0 : _b.call(schemaType, {
    id: value == null ? void 0 : value._ref,
    type: (_a2 = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _a2.type
  })) || null, renderOption = React.useCallback(
    (option) => /* @__PURE__ */ jsxRuntime.jsx(PreviewCard, { as: "button", type: "button", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 3, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      OptionPreview,
      {
        referenceType: schemaType,
        document: option.hit.published,
        getReferenceInfo: getReferenceInfoMemo
      }
    ) }) }),
    [schemaType, getReferenceInfoMemo]
  ), isEditing = hasFocusAtRef || !(value != null && value._ref), clickOutsideBoundaryRef = React.useRef(null), autocompletePortalRef = React.useRef(null), createButtonMenuPortalRef = React.useRef(null);
  return useOnClickOutside(
    [clickOutsideBoundaryRef, autocompletePortalRef, createButtonMenuPortalRef],
    () => {
      hasFocusAtRef && onPathFocus([]);
    }
  ), /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    !featureInfo.isLoading && !featureInfo.enabled && /* @__PURE__ */ jsxRuntime.jsx(DisabledFeatureWarning, { value, onClearValue: handleClear }),
    (featureInfo.isLoading || featureInfo.enabled) && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, ref: clickOutsideBoundaryRef, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: autocompletePopoverReferenceElementRef, children: /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceAutocomplete$1,
      {
        ...elementProps,
        "data-testid": "autocomplete",
        loading: searchState.isLoading,
        referenceElement: autocompletePopoverReferenceElementRef.current,
        portalRef: autocompletePortalRef,
        id: inputId || "",
        options: searchState.hits.map((hit) => ({
          value: hit.id,
          hit
        })),
        onFocus: handleAutocompleteFocus,
        radius: 2,
        placeholder: t2("inputs.reference.search-placeholder"),
        onKeyDown: handleAutocompleteKeyDown,
        readOnly,
        disabled: loadableReferenceInfo.isLoading,
        onQueryChange: handleQueryChange,
        searchString: searchState.searchString,
        onChange: handleChange,
        filterOption: NO_FILTER$1,
        renderOption,
        openButton: { onClick: handleAutocompleteOpenButtonClick }
      }
    ) }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Card,
      {
        padding: 0,
        border: !0,
        flex: 1,
        radius: 1,
        tone: readOnly ? "transparent" : loadableReferenceInfo.error || errors.length > 0 ? "critical" : "default",
        children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", padding: 1, children: [
            studioUrl ? /* @__PURE__ */ jsxRuntime.jsx(
              PreviewCard,
              {
                as: "a",
                target: "_blank",
                rel: "noopener noreferrer",
                href: studioUrl,
                "data-as": "a",
                flex: 1,
                padding: 1,
                paddingRight: 3,
                radius: 2,
                tone: "inherit",
                __unstable_focusRing: !0,
                tabIndex: 0,
                onFocus: handleFocus,
                ref: elementProps.ref,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  PreviewReferenceValue,
                  {
                    value,
                    referenceInfo: loadableReferenceInfo,
                    showStudioUrlIcon: !0,
                    hasStudioUrl: !!studioUrl,
                    type: schemaType
                  }
                )
              }
            ) : /* @__PURE__ */ jsxRuntime.jsx(
              PreviewCard,
              {
                flex: 1,
                padding: 1,
                paddingRight: 3,
                radius: 2,
                tone: "inherit",
                __unstable_focusRing: !0,
                tabIndex: 0,
                onFocus: handleFocus,
                ref: elementProps.ref,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  PreviewReferenceValue,
                  {
                    value,
                    referenceInfo: loadableReferenceInfo,
                    showStudioUrlIcon: !0,
                    type: schemaType
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuButton,
              {
                button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { "data-testid": "menu-button" }),
                id: `${inputId}-menuButton`,
                menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntime.jsx(
                    getJsonStream.MenuItem,
                    {
                      text: t2("inputs.reference.action.clear"),
                      tone: "critical",
                      icon: icons.ResetIcon,
                      "data-testid": "menu-item-clear",
                      onClick: handleClear
                    }
                  ),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    getJsonStream.MenuItem,
                    {
                      text: t2("inputs.reference.action.replace"),
                      icon: icons.SyncIcon,
                      "data-testid": "menu-item-replace",
                      onClick: handleReplace
                    }
                  )
                ] }) }),
                placement: "right",
                popover: { portal: !0, tone: "default" }
              }
            ) })
          ] }),
          showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
            ReferenceStrengthMismatchAlertStrip,
            {
              actualStrength,
              handleFixStrengthMismatch
            }
          ),
          loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
            ReferenceMetadataLoadErrorAlertStrip,
            {
              errorMessage: loadableReferenceInfo.error.message,
              onHandleRetry: loadableReferenceInfo.retry
            }
          )
        ]
      }
    ) }) })
  ] });
}
const REQUEST_TAG_BASE = "cross-dataset-refs", AVAILABILITY_READABLE$1 = {
  available: !0,
  reason: "READABLE"
}, AVAILABILITY_PERMISSION_DENIED$1 = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, AVAILABILITY_NOT_FOUND$1 = {
  available: !1,
  reason: "NOT_FOUND"
};
function createGetReferenceInfo(context) {
  const { client: client2, documentPreviewStore } = context, { dataset, projectId } = client2.config(), apiConfig = dataset && projectId ? { dataset, projectId } : void 0;
  return function(doc, referenceType) {
    return (doc._type ? rxjs.of(doc) : documentPreviewStore.observeDocumentTypeFromId(doc._id, apiConfig).pipe(operators.map((docType) => ({ _id: doc._id, _type: docType })))).pipe(
      operators.switchMap((resolvedDoc) => {
        if (!resolvedDoc._type)
          return fetchDocumentAvailability(client2, doc._id).pipe(
            operators.map((availability) => ({
              id: doc._id,
              type: void 0,
              availability,
              preview: { published: void 0 }
            }))
          );
        const refSchemaType = referenceType.to.find(
          (candidate) => candidate.type === resolvedDoc._type
        ), previewPaths = getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], publishedPreview$ = documentPreviewStore.observePaths(doc, previewPaths, apiConfig).pipe(
          operators.map((result) => result && prepareForPreview(result, refSchemaType))
        );
        return rxjs.combineLatest([publishedPreview$]).pipe(
          operators.map(([publishedPreview]) => ({
            type: resolvedDoc._type,
            id: doc._id,
            availability: AVAILABILITY_READABLE$1,
            preview: {
              published: isRecord$4(publishedPreview) ? publishedPreview : void 0
            }
          }))
        );
      })
    );
  };
}
function fetchDocumentAvailability(client2, id2) {
  const requestOptions = {
    uri: client2.getDataUrl("doc", id2),
    json: !0,
    query: { excludeContent: "true" },
    tag: `${REQUEST_TAG_BASE}.availability`
  };
  return client2.observable.request(requestOptions).pipe(
    operators.map((response) => {
      const omittedEntry = keyBy__default.default(response.omitted || [], (entry) => entry.id)[id2];
      return omittedEntry ? omittedEntry.reason === "existence" ? AVAILABILITY_NOT_FOUND$1 : omittedEntry.reason === "permission" ? AVAILABILITY_PERMISSION_DENIED$1 : null : AVAILABILITY_READABLE$1;
    })
  );
}
function search(client2, textTerm, type, options) {
  return createSearch(type.to, client2, {
    ...options,
    maxDepth: options.maxFieldDepth
  })(textTerm, {
    includeDrafts: !1,
    isCrossDataset: !0
  }).pipe(
    operators.map(({ hits }) => hits.map(({ hit }) => hit)),
    operators.map(collate),
    operators.map(
      (collated) => collated.map((entry) => ({
        id: entry.id,
        type: entry.type,
        published: entry.published
      }))
    )
  );
}
async function resolveUserDefinedFilter(options, document2, valuePath, getClient) {
  if (!options)
    return {};
  if (typeof options.filter == "function") {
    const parentPath = valuePath.slice(0, -1), parent = PathUtils.get(document2, parentPath);
    return await options.filter({ document: document2, parentPath, parent, getClient });
  }
  return {
    filter: options.filter,
    params: "filterParams" in options ? options.filterParams : void 0
  };
}
function useValueRef(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function StudioCrossDatasetReferenceInput(props2) {
  const { path, schemaType } = props2, source = useSource(), client2 = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentPreviewStore = useDocumentPreviewStore(), getClient = source.getClient, { unstable_enableNewSearch = !1 } = source.search, crossDatasetClient = React.useMemo(() => client2.withConfig({
    dataset: schemaType.dataset,
    apiVersion: "2023-11-13",
    ignoreBrowserTokenWarning: !0
  }).clone(), [client2, schemaType.dataset]), maxFieldDepth = useSearchMaxFieldDepth(crossDatasetClient), documentValue = useFormValue([]), documentRef = useValueRef(documentValue), handleSearch = React.useCallback(
    (searchString) => rxjs.from(resolveUserDefinedFilter(schemaType.options, documentRef.current, path, getClient)).pipe(
      operators.mergeMap(
        ({ filter, params }) => search(crossDatasetClient, searchString, schemaType, {
          ...schemaType.options,
          filter,
          params,
          tag: "search.cross-dataset-reference",
          maxFieldDepth,
          unstable_enableNewSearch
        })
      ),
      operators.catchError((err) => {
        var _a2;
        const isQueryError = err.details && err.details.type === "queryParseError";
        return (_a2 = schemaType.options) != null && _a2.filter && isQueryError && (err.message = 'Invalid reference filter, please check the custom "filter" option'), rxjs.throwError(err);
      })
    ),
    [
      schemaType,
      documentRef,
      path,
      getClient,
      crossDatasetClient,
      maxFieldDepth,
      unstable_enableNewSearch
    ]
  ), getReferenceInfo2 = React.useMemo(
    () => createGetReferenceInfo({ client: crossDatasetClient, documentPreviewStore }),
    [crossDatasetClient, documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferenceInput,
    {
      ...props2,
      getReferenceInfo: getReferenceInfo2,
      onSearch: handleSearch
    }
  );
}
function WithReferencedAsset(props2) {
  const { reference, children, observeAsset, waitPlaceholder } = props2, documentId = reference == null ? void 0 : reference._ref, asset = reactRx.useMemoObservable(() => observeAsset(documentId), [documentId, observeAsset]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: documentId && asset ? children(asset) : waitPlaceholder });
}
const FileMenuItem = styled__default.default(getJsonStream.MenuItem)`
  position: relative;

  & input {
    overflow: hidden;
    overflow: clip;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    position: absolute;
    min-width: 0;
    display: block;
    appearance: none;
    padding: 0;
    margin: 0;
    border: 0;
    opacity: 0;
  }
`, FileInputMenuItem = React.forwardRef(function(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, multiple, onSelect, text, disabled, ...rest } = props2, id2 = `${idProp || ""}-${React.useId()}`, handleChange = React.useCallback(
    (event) => {
      onSelect && event.target.files && onSelect(Array.from(event.target.files));
    },
    [onSelect]
  ), renderMenuItem = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
      item,
      /* @__PURE__ */ jsxRuntime.jsx(
        "input",
        {
          "data-testid": "file-menuitem-input",
          accept,
          capture,
          id: id2,
          multiple,
          onChange: handleChange,
          type: "file",
          value: "",
          disabled
        }
      )
    ] }),
    [accept, capture, disabled, handleChange, id2, multiple]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FileMenuItem,
    {
      ...rest,
      htmlFor: id2,
      disabled,
      ref: forwardedRef,
      icon,
      text,
      renderMenuItem
    }
  );
});
function ActionsMenu(props2) {
  const { onUpload, onReset, readOnly, accept, directUploads, browse, downloadUrl, copyUrl } = props2, { push: pushToast } = ui.useToast(), { t: t2 } = useTranslation(), handleCopyURL = React.useCallback(() => {
    navigator.clipboard.writeText(copyUrl || ""), pushToast({
      closable: !0,
      status: "success",
      title: t2("inputs.files.common.actions-menu.notification.url-copied")
    });
  }, [copyUrl, pushToast, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FileInputMenuItem,
      {
        icon: icons.UploadIcon,
        onSelect: onUpload,
        accept,
        text: t2("inputs.files.common.actions-menu.upload.label"),
        "data-testid": "file-input-upload-button",
        disabled: readOnly || !directUploads
      }
    ),
    browse,
    (downloadUrl || copyUrl) && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    downloadUrl && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        icon: icons.DownloadIcon,
        text: t2("inputs.files.common.actions-menu.download.label"),
        href: downloadUrl
      }
    ),
    copyUrl && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        icon: icons.CopyIcon,
        text: t2("inputs.files.common.actions-menu.copy-url.label"),
        onClick: handleCopyURL
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        tone: "critical",
        icon: icons.ResetIcon,
        text: t2("inputs.files.common.actions-menu.clear-field.label"),
        onClick: onReset,
        disabled: readOnly,
        "data-testid": "file-input-clear"
      }
    )
  ] });
}
function urlToFile(url, filename) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      const reader = new FileReader();
      reader.onloadend = () => {
        var _a2;
        const string = (_a2 = reader.result) == null ? void 0 : _a2.toString(), ext = string == null ? void 0 : string.substring(11, string.indexOf(";base64"));
        if (!ext && !filename) {
          reject(new Error("Could not find mime type for image"));
          return;
        }
        resolve(dataURLtoFile(reader.result, filename || `${uuid.uuid()}.${ext}`));
      }, reader.readAsDataURL(xhr.response);
    }, xhr.onerror = (error) => {
      reject(error);
    }, xhr.open("GET", url), xhr.responseType = "blob", xhr.send();
  });
}
function base64ToFile(base64Data, filename) {
  return new Promise((resolve, reject) => {
    const string = base64Data.toString(), ext = string.substring(11, string.indexOf(";base64"));
    if (!ext && !filename) {
      reject(new Error("Could not find mime type for image"));
      return;
    }
    resolve(dataURLtoFile(base64Data, filename || `${uuid.uuid()}.${ext}`));
  });
}
function dataURLtoFile(dataurl, filename) {
  var _a2;
  const arr = dataurl.split(","), mime = (_a2 = arr[0].match(/:(.*?);/)) == null ? void 0 : _a2[1], bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  for (; n--; )
    u8arr[n] = bstr.charCodeAt(n);
  return new File([u8arr], filename, { type: mime });
}
function handleSelectAssetFromSource({
  assetFromSource,
  onChange,
  type,
  resolveUploader: resolveUploader2,
  uploadWith,
  isImage
}) {
  if (!assetFromSource)
    throw new Error("No asset given");
  if (!Array.isArray(assetFromSource) || assetFromSource.length === 0)
    throw new Error("Returned value must be an array with at least one item (asset)");
  const firstAsset = assetFromSource[0], assetProps = firstAsset.assetDocumentProps, originalFilename = assetProps == null ? void 0 : assetProps.originalFilename, label = assetProps == null ? void 0 : assetProps.label, title = assetProps == null ? void 0 : assetProps.title, description = assetProps == null ? void 0 : assetProps.description, creditLine = assetProps == null ? void 0 : assetProps.creditLine, source = assetProps == null ? void 0 : assetProps.source, imagePatches = isImage ? [unset(["hotspot"]), unset(["crop"])] : [];
  switch (firstAsset.kind) {
    case "assetDocumentId":
      onChange([
        setIfMissing({
          _type: type.name
        }),
        ...imagePatches,
        set(
          {
            _type: "reference",
            _ref: firstAsset.value
          },
          ["asset"]
        )
      ]);
      break;
    case "file": {
      const uploader = resolveUploader2(type, firstAsset.value);
      uploader && uploadWith(uploader, firstAsset.value, {
        label,
        title,
        description,
        creditLine,
        source
      });
      break;
    }
    case "base64":
      base64ToFile(firstAsset.value, originalFilename).then((file) => {
        const uploader = resolveUploader2(type, file);
        uploader && uploadWith(uploader, file, { label, title, description, creditLine, source });
      });
      break;
    case "url":
      urlToFile(firstAsset.value, originalFilename).then((file) => {
        const uploader = resolveUploader2(type, file);
        uploader && uploadWith(uploader, file, { label, title, description, creditLine, source });
      });
      break;
    default:
      throw new Error("Invalid value returned from asset source plugin");
  }
}
const RootFlex$4 = styled__default.default(ui.Flex)`
  pointer-events: none;
`;
function PlaceholderText(props2) {
  const { hoveringFiles, type, readOnly, acceptedFiles, rejectedFilesCount, directUploads } = props2, isFileType = type === "file", { t: t2 } = useTranslation(), messageIcon = React.useMemo(() => readOnly ? /* @__PURE__ */ jsxRuntime.jsx(icons.ReadOnlyIcon, {}) : hoveringFiles && rejectedFilesCount > 0 || !directUploads ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : isFileType ? /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.ImageIcon, {}), [directUploads, hoveringFiles, isFileType, readOnly, rejectedFilesCount]), messageText = React.useMemo(() => {
    if (!directUploads)
      return t2("inputs.files.common.placeholder.upload-not-supported");
    if (readOnly)
      return t2("inputs.files.common.placeholder.read-only");
    if (hoveringFiles && directUploads && !readOnly) {
      if (acceptedFiles.length > 0)
        return t2("inputs.files.common.placeholder.drop-to-upload", { context: type });
      if (rejectedFilesCount > 0)
        return t2("inputs.files.common.placeholder.cannot-upload-some-files", {
          count: rejectedFilesCount
        });
    }
    return t2("inputs.files.common.placeholder.drag-or-paste-to-upload", { context: type });
  }, [acceptedFiles.length, directUploads, hoveringFiles, readOnly, rejectedFilesCount, t2, type]);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$4, { align: "center", gap: 3, justify: "center", paddingLeft: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: messageIcon }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: messageText })
  ] });
}
const FileTarget = withFocusRing(fileTarget(ui.Card)), FileButton = styled__default.default(getJsonStream.Button).attrs({ forwardedAs: "label" })(
  ({ theme: theme2 }) => {
    const { focusRing } = theme2.sanity, base = theme2.sanity.color.base;
    return styled.css`
      &:not([data-disabled='true']) {
        &:focus-within {
          box-shadow: ${focusRingStyle$1({ base, border: { width: 1, color: "var(--card-border-color)" }, focusRing })};
        }
      }

      // The underlying file input is rendered as children within a Sanity UI <Button> component.
      // The below visibly hides it by targeting the input's parent <span> element, which is
      // added by the <Button> component.
      // TODO: refactor, avoid nth-child selector usage
      & > span:nth-child(2) {
        overflow: hidden;
        overflow: clip;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        position: absolute;
        min-width: 0;
        display: block;
        appearance: none;
        padding: 0;
        margin: 0;
        border: 0;
        opacity: 0;
      }
    `;
  }
), FileInputButton = React.forwardRef(function(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, multiple, onSelect, text, disabled, ...rest } = props2, id2 = `${idProp || ""}-${React.useId()}`, handleChange = React.useCallback(
    (event) => {
      onSelect && event.target.files && onSelect(Array.from(event.target.files));
    },
    [onSelect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FileButton, { ...rest, icon, text, htmlFor: id2, disabled, children: /* @__PURE__ */ jsxRuntime.jsx(
    "input",
    {
      "data-testid": "file-button-input",
      accept,
      capture,
      id: id2,
      multiple,
      onChange: handleChange,
      ref: forwardedRef,
      type: "file",
      value: "",
      disabled
    }
  ) });
});
function UploadPlaceholderComponent(props2) {
  const {
    accept,
    acceptedFiles,
    browse,
    directUploads,
    hoveringFiles,
    onUpload,
    readOnly,
    rejectedFilesCount,
    type
  } = props2, [rootElement, setRootElement] = React.useState(null), rect = ui.useElementSize(rootElement), collapsed = (rect == null ? void 0 : rect.border) && rect.border.width < 440, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: collapsed ? void 0 : "center",
      direction: collapsed ? "column" : "row",
      gap: 4,
      justify: "space-between",
      paddingY: collapsed ? 1 : void 0,
      ref: setRootElement,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          PlaceholderText,
          {
            acceptedFiles,
            directUploads,
            hoveringFiles,
            readOnly,
            rejectedFilesCount,
            type
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "center", wrap: "wrap", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            FileInputButton,
            {
              accept,
              "data-testid": "file-input-upload-button",
              disabled: readOnly || !directUploads,
              icon: icons.UploadIcon,
              mode: "bleed",
              onSelect: onUpload,
              text: t2("input.files.common.upload-placeholder.file-input-button.text")
            }
          ),
          browse
        ] })
      ]
    }
  );
}
const UploadPlaceholder = React.memo(UploadPlaceholderComponent), STALE_UPLOAD_MS = 12e4, CardWrapper = styled__default.default(ui.Card)`
  min-height: 82px;
  box-sizing: border-box;
`, FlexWrapper = styled__default.default(ui.Flex)`
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, LeftSection = styled__default.default(ui.Stack)`
  position: relative;
  width: 60%;
`, CodeWrapper = styled__default.default(ui.Code)`
  position: relative;
  width: 100%;

  code {
    overflow: hidden;
    overflow: clip;
    text-overflow: ellipsis;
    position: relative;
    max-width: 200px;
  }
`, elapsedMs = (date) => (/* @__PURE__ */ new Date()).getTime() - new Date(date).getTime();
function UploadProgress({ uploadState, onCancel, onStale, height }) {
  const filename = uploadState.file.name;
  React.useEffect(() => {
    elapsedMs(uploadState.updatedAt) > STALE_UPLOAD_MS && (onStale == null || onStale());
  }, [uploadState.updatedAt, onStale]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(CardWrapper, { tone: "primary", padding: 4, border: !0, style: { height: `${height}px` }, children: /* @__PURE__ */ jsxRuntime.jsxs(FlexWrapper, { align: "center", justify: "space-between", height: "fill", direction: "row", gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(LeftSection, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", gap: [3, 3, 2, 2], direction: ["column", "column", "row"], children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        Translate,
        {
          t: t2,
          i18nKey: "input.files.common.upload-progress",
          components: {
            FileName: () => /* @__PURE__ */ jsxRuntime.jsx(CodeWrapper, { size: 1, children: filename || "\u2026" })
          }
        }
      ) }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, marginTop: 3, radius: 5, children: /* @__PURE__ */ jsxRuntime.jsx(LinearProgress, { value: uploadState.progress }) })
    ] }),
    onCancel ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        mode: "ghost",
        onClick: onCancel,
        text: t2("input.files.common.cancel-upload"),
        tone: "critical"
      }
    ) : null
  ] }) });
}
function UploadWarning({ onClearStale }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.files.common.stale-upload-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.files.common.stale-upload-warning.description", {
          staleThresholdMinutes: Math.ceil(STALE_UPLOAD_MS / 1e3 / 60)
        }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearStale,
        text: t2("inputs.files.common.stale-upload-warning.clear"),
        width: "fill"
      }
    )
  ] });
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024, dm = decimals < 0 ? 0 : decimals, sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
function FileActionsMenu(props2) {
  const {
    originalFilename,
    size,
    children,
    muted,
    disabled,
    onClick,
    isMenuOpen,
    onMenuOpen,
    setMenuButtonElement
  } = props2, [menuElement, setMenuElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), handleClick = React.useCallback(() => onMenuOpen(!0), [onMenuOpen]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        isMenuOpen && (event.key === "Escape" || event.key === "Tab") && (onMenuOpen(!1), buttonElement == null || buttonElement.focus());
      },
      [isMenuOpen, onMenuOpen, buttonElement]
    )
  ), ui.useClickOutside(
    React.useCallback(
      (event) => {
        buttonElement != null && buttonElement.contains(event.target) || onMenuOpen(!1);
      },
      [buttonElement, onMenuOpen]
    ),
    [menuElement]
  );
  const setOptionsButtonRef = React.useCallback(
    (el) => {
      setMenuButtonElement(el), setButtonElement(el);
    },
    [setMenuButtonElement]
  );
  React.useEffect(() => {
    isMenuOpen && (menuElement == null || menuElement.focus());
  }, [isMenuOpen, menuElement]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { wrap: "nowrap", justify: "space-between", align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        as: muted || disabled ? void 0 : "button",
        radius: 2,
        padding: 2,
        tone: "inherit",
        onClick,
        flex: 1,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { wrap: "nowrap", align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, tone: "transparent", shadow: 1, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted, children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ui.Text,
              {
                size: 1,
                textOverflow: "ellipsis",
                muted,
                "data-testid": "file-name",
                weight: "medium",
                children: originalFilename
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, "data-testid": "file-size", children: formatBytes(size) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Popover,
      {
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: setMenuElement, children }),
        id: "file-actions-menu",
        portal: !0,
        open: isMenuOpen,
        constrainSize: !0,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ContextMenuButton,
          {
            "aria-label": t2("inputs.file.actions-menu.file-options.aria-label"),
            "data-testid": "options-menu-button",
            onClick: handleClick,
            paddingY: 3,
            ref: setOptionsButtonRef
          }
        )
      }
    ) }) })
  ] });
}
function FileSkeleton$1() {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", padding: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { padding: 3, radius: 1, animated: !0 }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "100%" }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "100%" }, radius: 1, animated: !0 })
    ] })
  ] });
}
function InvalidFileWarning({ onClearValue }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.file.invalid-file-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.file.invalid-file-warning.description") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearValue,
        text: t2("inputs.file.invalid-file-warning.reset-button.text"),
        width: "fill"
      }
    )
  ] });
}
const CardOverlay = styled__default.default(ui.Card)`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
`, FlexContainer$1 = styled__default.default(ui.Flex)`
  height: 100%;
`;
function passThrough$1({ children }) {
  return children;
}
const ASSET_FIELD_PATH$1 = ["asset"];
class BaseFileInput extends React.PureComponent {
  constructor(props2) {
    super(props2), this.uploadSubscription = null, this.browseButtonElement = null, this.state = {
      isUploading: !1,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: !1,
      isMenuOpen: !1
    }, this.toast = null, this.handleRemoveButtonClick = () => {
      const { path, value } = this.props, isArrayElement = typeof path.slice(-1)[0] != "string", allKeys = Object.keys(value || {}), isEmpty2 = allKeys.filter(
        (key) => !["_type", "_key", "_upload", "asset"].includes(key)
      ).length === 0, removeKeys = ["asset"].concat(allKeys.filter((key) => ["_upload"].includes(key))).map((key) => unset([key]));
      this.props.onChange(PatchEvent.from(isEmpty2 && !isArrayElement ? unset() : removeKeys));
    }, this.handleCancelUpload = () => {
      this.cancelUpload();
    }, this.handleClearUploadState = () => {
      this.setState({ isStale: !1 }), this.clearUploadStatus();
    }, this.handleStaleUpload = () => {
      this.setState({ isStale: !0 });
    }, this.handleClearField = () => {
      this.props.onChange(unset(["asset"]));
    }, this.handleSelectFiles = (files) => {
      const { directUploads, readOnly } = this.props, { hoveringFiles } = this.state;
      directUploads && !readOnly ? this.uploadFirstAccepted(files) : hoveringFiles.length > 0 && this.handleFilesOut();
    }, this.handleSelectFileFromAssetSource = (source) => {
      this.setState({ selectedAssetSource: source });
    }, this.handleAssetSourceClosed = () => {
      var _a2;
      this.setState({ selectedAssetSource: null }), (_a2 = this.browseButtonElement) == null || _a2.focus();
    }, this.setBrowseButtonElement = (el) => {
      this.browseButtonElement = el;
    }, this.uploadWith = (uploader, file, assetDocumentProps = {}) => {
      const { schemaType, onChange, client: client2, t: t2 } = this.props, { source } = assetDocumentProps, options = {
        metadata: get__default.default(schemaType, "options.metadata"),
        storeOriginalFilename: get__default.default(schemaType, "options.storeOriginalFilename"),
        source
      };
      this.cancelUpload(), this.setState({ isUploading: !0 }), onChange(PatchEvent.from([setIfMissing({ _type: schemaType.name })])), this.uploadSubscription = uploader.upload(client2, file, schemaType, options).subscribe({
        next: (uploadEvent) => {
          uploadEvent.patches && onChange(PatchEvent.from(uploadEvent.patches));
        },
        error: (err) => {
          var _a2;
          console.error(err), (_a2 = this.toast) == null || _a2.push({
            status: "error",
            description: t2("inputs.file.upload-failed.description"),
            title: t2("inputs.file.upload-failed.title")
          }), this.clearUploadStatus();
        },
        complete: () => {
          this.setState({ isUploading: !1 });
        }
      });
    }, this.handleSelectAssetFromSource = (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({
        assetFromSource,
        onChange,
        type: schemaType,
        resolveUploader: resolveUploader2,
        uploadWith: this.uploadWith
      }), this.setState({ selectedAssetSource: null });
    }, this.handleFileTargetFocus = (event) => {
      var _a2;
      event.currentTarget === event.target && event.currentTarget === ((_a2 = this.props.elementProps.ref) == null ? void 0 : _a2.current) && this.props.elementProps.onFocus(event);
    }, this.handleFilesOver = (fileInfo) => {
      this.setState({
        hoveringFiles: fileInfo
      });
    }, this.handleFilesOut = () => {
      this.setState({
        hoveringFiles: []
      });
    }, this.handleUpload = ({ file, uploader }) => {
      this.uploadWith(uploader, file);
    }, this.setToast = (toast) => {
      this.toast = toast;
    }, this._assetFieldPath = props2.path.concat(ASSET_FIELD_PATH$1);
  }
  clearUploadStatus() {
    var _a2;
    (_a2 = this.props.value) != null && _a2._upload && this.props.onChange(PatchEvent.from([unset(["_upload"])]));
  }
  cancelUpload() {
    this.uploadSubscription && (this.uploadSubscription.unsubscribe(), this.clearUploadStatus());
  }
  uploadFirstAccepted(files) {
    const { schemaType } = this.props, match = files.map((file) => {
      var _a2, _b;
      return { file, uploader: (_b = (_a2 = this.props).resolveUploader) == null ? void 0 : _b.call(_a2, schemaType, file) };
    }).find((result) => result.uploader);
    match && this.uploadWith(match.uploader, match.file), this.setState({ isMenuOpen: !1 });
  }
  renderUploadState(uploadState) {
    const { isUploading } = this.state;
    return /* @__PURE__ */ jsxRuntime.jsx(
      UploadProgress,
      {
        uploadState,
        onCancel: isUploading ? this.handleCancelUpload : void 0,
        onStale: this.handleStaleUpload
      }
    );
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state, { value, schemaType, observeAsset, t: t2 } = this.props;
    if (!selectedAssetSource)
      return null;
    const accept = get__default.default(schemaType, "options.accept", ""), Component = selectedAssetSource.component;
    return value && value.asset ? /* @__PURE__ */ jsxRuntime.jsx(
      WithReferencedAsset,
      {
        observeAsset,
        reference: value.asset,
        waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton$1, {}),
        children: (fileAsset2) => /* @__PURE__ */ jsxRuntime.jsx(
          Component,
          {
            selectedAssets: [fileAsset2],
            selectionType: "single",
            assetType: "file",
            accept,
            dialogHeaderTitle: t2("inputs.file.dialog.title"),
            onClose: this.handleAssetSourceClosed,
            onSelect: this.handleSelectAssetFromSource
          }
        )
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [],
        selectionType: "single",
        assetType: "file",
        accept,
        dialogHeaderTitle: t2("inputs.file.dialog.title"),
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    );
  }
  renderAsset() {
    const { value, changed, readOnly, elementProps } = this.props, { hoveringFiles, isStale } = this.state, hasValueOrUpload = !!(value != null && value._upload || value != null && value.asset);
    return value && typeof value.asset < "u" && !(value != null && value._upload) && !assetUtils.isFileSource(value) ? () => /* @__PURE__ */ jsxRuntime.jsx(InvalidFileWarning, { onClearValue: this.handleClearField }) : (inputProps) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      isStale && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(UploadWarning, { onClearStale: this.handleClearUploadState }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        ChangeIndicator,
        {
          path: this._assetFieldPath,
          hasFocus: !!inputProps.focused,
          isChanged: changed,
          children: value != null && value._upload ? this.renderUploadState(value._upload) : /* @__PURE__ */ jsxRuntime.jsx(
            FileTarget,
            {
              ...elementProps,
              onFocus: this.handleFileTargetFocus,
              tabIndex: 0,
              disabled: !!readOnly,
              onFiles: this.handleSelectFiles,
              onFilesOver: this.handleFilesOver,
              onFilesOut: this.handleFilesOut,
              tone: this.getFileTone(),
              $border: hasValueOrUpload || hoveringFiles.length > 0,
              style: { padding: 1 },
              sizing: "border",
              radius: 2,
              children: /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { position: "relative" }, children: [
                !(value != null && value.asset) && this.renderUploadPlaceholder(),
                value != null && value.asset && hoveringFiles.length > 0 ? this.renderAssetMenu(this.getFileTone()) : null,
                !(value != null && value._upload) && (value == null ? void 0 : value.asset) && this.renderPreview()
              ] })
            }
          )
        }
      )
    ] });
  }
  renderPreview() {
    const { value, readOnly, assetSources, schemaType, directUploads, observeAsset, t: t2 } = this.props, { isMenuOpen } = this.state, asset = value == null ? void 0 : value.asset;
    if (!asset)
      return null;
    const accept = get__default.default(schemaType, "options.accept", "");
    let browseMenuItem = assetSources && (assetSources == null ? void 0 : assetSources.length) === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        icon: icons.SearchIcon,
        text: t2("inputs.file.browse-button.text"),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSources[0]);
        },
        disabled: readOnly,
        "data-testid": "file-input-browse-button"
      }
    );
    return assetSources.length > 1 && (browseMenuItem = assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSource);
        },
        icon: assetSource.icon || icons.ImageIcon,
        disabled: readOnly,
        "data-testid": `file-input-browse-button-${assetSource.name}`
      },
      assetSource.name
    ))), /* @__PURE__ */ jsxRuntime.jsx(
      WithReferencedAsset,
      {
        reference: asset,
        observeAsset,
        waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton$1, {}),
        children: ({ originalFilename, extension, url, size }) => {
          const filename = originalFilename || `download.${extension}`;
          let copyUrl, downloadUrl;
          return assetUtils.isFileSource(value) && (downloadUrl = `${url}?dl`, copyUrl = url), /* @__PURE__ */ jsxRuntime.jsx(
            FileActionsMenu,
            {
              size,
              originalFilename: filename,
              muted: !readOnly,
              onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }),
              isMenuOpen,
              setMenuButtonElement: this.setBrowseButtonElement,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                ActionsMenu,
                {
                  onUpload: this.handleSelectFiles,
                  browse: browseMenuItem,
                  onReset: this.handleRemoveButtonClick,
                  downloadUrl,
                  copyUrl,
                  readOnly,
                  accept,
                  directUploads
                }
              )
            }
          );
        }
      }
    );
  }
  renderAssetMenu(tone) {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return /* @__PURE__ */ jsxRuntime.jsx(CardOverlay, { radius: 2, tone, children: /* @__PURE__ */ jsxRuntime.jsx(FlexContainer$1, { align: "center", justify: "center", gap: 2, flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      PlaceholderText,
      {
        readOnly,
        hoveringFiles,
        acceptedFiles,
        rejectedFilesCount,
        directUploads,
        type: "file"
      }
    ) }) });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id2, t: t2 } = this.props;
    return assetSources.length === 0 ? null : assetSources.length > 1 && !readOnly && directUploads ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        id: `${id2}_assetFileButton`,
        ref: this.setBrowseButtonElement,
        button: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "bleed",
            text: t2("inputs.file.multi-browse-button.text"),
            "data-testid": "file-input-multi-browse-button",
            icon: icons.SearchIcon
          }
        ),
        "data-testid": "input-select-button",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: assetSource.title,
            onClick: () => {
              this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSource);
            },
            icon: assetSource.icon || icons.ImageIcon,
            disabled: readOnly,
            "data-testid": `file-input-browse-button-${assetSource.name}`
          },
          assetSource.name
        )) })
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        text: t2("inputs.file.browse-button.text"),
        icon: icons.SearchIcon,
        mode: "bleed",
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSources[0]);
        },
        "data-testid": "file-input-browse-button",
        disabled: readOnly,
        ref: this.setBrowseButtonElement
      }
    );
  }
  renderUploadPlaceholder() {
    const { readOnly, schemaType, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, accept = get__default.default(schemaType, "options.accept", "");
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        tone: readOnly ? "transparent" : "inherit",
        border: !0,
        paddingX: 3,
        paddingY: 2,
        radius: 2,
        style: hoveringFiles.length === 0 ? { borderStyle: "dashed" } : { borderStyle: "dashed", borderColor: "transparent" },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          UploadPlaceholder,
          {
            browse: this.renderBrowser(),
            onUpload: this.handleSelectFiles,
            readOnly,
            hoveringFiles,
            acceptedFiles,
            rejectedFilesCount,
            type: "file",
            accept,
            directUploads
          }
        )
      }
    ) });
  }
  getFileTone() {
    const { directUploads, schemaType, value, readOnly, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return hoveringFiles.length > 0 && (rejectedFilesCount > 0 || !directUploads) ? "critical" : !(value != null && value._upload) && !readOnly && hoveringFiles.length > 0 ? "primary" : value != null && value._upload && value != null && value.asset && readOnly ? "transparent" : "default";
  }
  render() {
    const {
      members,
      renderAnnotation,
      renderBlock,
      renderInlineBlock,
      renderItem,
      renderInput,
      renderField,
      renderPreview,
      t: t2
    } = this.props, { selectedAssetSource } = this.state;
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ImperativeToast, { ref: this.setToast }),
      members.map((member) => member.kind === "field" && (member.name === "crop" || member.name === "hotspot") ? null : member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
        MemberField,
        {
          member,
          renderAnnotation,
          renderInlineBlock,
          renderBlock,
          renderInput: member.name === "asset" ? this.renderAsset() : renderInput,
          renderField: member.name === "asset" ? passThrough$1 : renderField,
          renderItem,
          renderPreview
        },
        member.key
      ) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
        MemberFieldSet,
        {
          member,
          renderAnnotation,
          renderBlock,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderPreview
        },
        member.key
      ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.file.error.unknown-member-kind", { kind: member.kind }) })),
      selectedAssetSource && this.renderAssetSource()
    ] });
  }
}
function StudioFileInput(props2) {
  var _a2;
  const sourcesFromSchema = (_a2 = props2.schemaType.options) == null ? void 0 : _a2.sources, documentPreviewStore = useDocumentPreviewStore(), { file: fileConfig } = useFormBuilder().__internal, client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { t: t2 } = useTranslation(), resolveUploader$1 = React.useCallback(
    (type, file) => fileConfig.directUploads ? resolveUploader(type, file) : null,
    [fileConfig.directUploads]
  ), assetSources = React.useMemo(
    () => sourcesFromSchema || fileConfig.assetSources,
    [fileConfig, sourcesFromSchema]
  ), observeAsset = React.useCallback(
    (id2) => observeFileAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    BaseFileInput,
    {
      ...props2,
      t: t2,
      client: client2,
      assetSources,
      directUploads: fileConfig.directUploads,
      observeAsset,
      resolveUploader: resolveUploader$1
    }
  );
}
const RatioBox$1 = styled__default.default(ui.Box)`
  position: relative;
  padding-bottom: calc(${({ ratio = 3 / 2 }) => 1 / ratio} * 100%);

  & > div {
    position: absolute;
    top: ${({ padding = 0 }) => padding}px;
    left: ${({ padding = 0 }) => padding}px;
    right: ${({ padding = 0 }) => padding}px;
    bottom: ${({ padding = 0 }) => padding}px;
  }
`, DEFAULT_HOTSPOT = {
  x: 0.5,
  y: 0.5,
  height: 1,
  width: 1
}, DEFAULT_CROP = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
function calculateStyles(options = {}) {
  const imageAspect = readAspectRatio(options.image) || 1, hotspot = options.hotspot || DEFAULT_HOTSPOT, crop = options.crop || DEFAULT_CROP, containerAspect = readAspectRatio(options.container) || imageAspect * readCropAspect(crop), align2 = options.align || { x: "center", y: "center" }, result = calculateHotSpotCrop(
    imageAspect,
    { hotspot, crop },
    { aspect: containerAspect, align: align2 }
  ), containerHeight = styleFormat(round(100 / containerAspect));
  return {
    debug: {
      result
    },
    container: {
      //outline: '1px solid cyan',
      overflow: "hidden",
      position: "relative",
      width: "100%",
      height: containerHeight
    },
    padding: {
      marginTop: containerHeight
    },
    crop: {
      position: "absolute",
      overflow: "hidden",
      height: toStylePercentage(result.crop.height),
      width: toStylePercentage(result.crop.width),
      top: toStylePercentage(result.crop.top),
      left: toStylePercentage(result.crop.left)
    },
    image: {
      position: "absolute",
      height: toStylePercentage(result.image.height),
      width: toStylePercentage(result.image.width),
      top: toStylePercentage(result.image.top),
      left: toStylePercentage(result.image.left)
    }
  };
}
function readAspectRatio(opts) {
  if (!opts)
    return null;
  if ("aspectRatio" in opts)
    return opts.aspectRatio;
  if ("height" in opts || "width" in opts) {
    if (typeof opts.height != "number" && typeof opts.width != "number")
      throw new Error(`Height and width must be numbers, got ${JSON.stringify(opts)}`);
    return opts.width / opts.height;
  }
  return null;
}
function round(num, decimals = 2) {
  const multiplier = Math.pow(10, decimals);
  return Math.round(num * multiplier) / multiplier;
}
function calculateHotSpotCrop(sourceAspect, descriptor, spec) {
  const crop = descriptor.crop, viewportAspect = spec.aspect, alignment = spec.align, netWidth = 1 - crop.left - crop.right, netHeight = 1 - crop.top - crop.bottom, outImg = {
    top: -crop.top / netHeight,
    left: -crop.left / netWidth,
    width: 1 / netWidth,
    height: 1 / netHeight
  }, cropAspect = netWidth / netHeight * sourceAspect, hotspot = {
    x: (descriptor.hotspot.x - crop.left) / netWidth,
    y: (descriptor.hotspot.y - crop.top) / netHeight,
    height: descriptor.hotspot.height / netHeight,
    width: descriptor.hotspot.width / netWidth
  }, maxHotspotXScale = 1 / hotspot.width, maxHotspotYScale = 1 / hotspot.height * cropAspect / viewportAspect, maxScale = Math.min(maxHotspotXScale, maxHotspotYScale);
  let minFullBleedScale;
  const cropIsTaller = cropAspect <= viewportAspect;
  cropIsTaller ? minFullBleedScale = 1 : minFullBleedScale = cropAspect / viewportAspect;
  let method, outCrop;
  if (minFullBleedScale > maxScale) {
    method = "letterbox";
    let letterboxScale;
    const diff2 = minFullBleedScale - maxScale;
    cropIsTaller ? letterboxScale = 1 - diff2 : letterboxScale = maxScale, outCrop = {
      width: letterboxScale,
      height: letterboxScale / cropAspect * viewportAspect,
      // Gets overwritten further down
      left: 0,
      top: 0
    };
    const hotspotLeft = hotspot.x * outCrop.width - hotspot.width * outCrop.width / 2;
    switch (alignment.x) {
      case "left":
        outCrop.left = cropIsTaller ? 0 : -hotspotLeft;
        break;
      case "right":
        outCrop.left = cropIsTaller ? 1 - outCrop.width : hotspotLeft;
        break;
      case "center":
        outCrop.left = cropIsTaller ? (1 - outCrop.width) / 2 : -hotspotLeft;
        break;
      default:
        throw new Error(
          `Invalid x alignment: '${alignment.x}'. Must be either 'left', 'right' or 'center'`
        );
    }
    const hotspotTop = hotspot.y * outCrop.height - hotspot.height * outCrop.height / 2;
    switch (alignment.y) {
      case "top":
        outCrop.top = cropIsTaller ? -hotspotTop : 0;
        break;
      case "bottom":
        outCrop.top = hotspotTop;
        break;
      case "center":
        outCrop.top = cropIsTaller ? -hotspotTop : (1 - outCrop.height) / 2;
        break;
      default:
        throw new Error(
          `Invalid y alignment: '${alignment.y}'. Must be either 'top', 'bottom' or 'center'`
        );
    }
  } else if (cropIsTaller) {
    method = "full_width";
    let top = -hotspot.y / cropAspect * viewportAspect + 0.5;
    const height = minFullBleedScale / cropAspect * viewportAspect;
    top > 0 ? top = 0 : -top > height - 1 && (top = -(height - 1)), outCrop = {
      width: minFullBleedScale,
      height,
      left: 0,
      // Place the Y center of the hotspot near the center of the viewport
      top
    };
  } else {
    method = "full_height";
    const width = minFullBleedScale;
    let left = 0.5 - hotspot.x * minFullBleedScale;
    left > 0 ? left = 0 : -left > width - 1 && (left = -(width - 1)), outCrop = {
      width,
      height: minFullBleedScale / cropAspect * viewportAspect,
      top: 0,
      // Place the X center of the hotspot at the center of the viewport
      left
    };
  }
  return {
    method,
    crop: outCrop,
    image: outImg
  };
}
function readCropAspect(crop) {
  const height = 1 - crop.top - crop.bottom;
  return (1 - crop.left - crop.right) / height;
}
function styleFormat(num) {
  return num === 0 ? 0 : `${num}%`;
}
function toStylePercentage(num) {
  return styleFormat(round(num * 100));
}
const HotspotImageContainer = styled__default.default.div`
  position: relative;
  width: 100%;
`, debug$2 = debug__default.default("sanity-imagetool");
function getCropAspect(crop, srcAspect) {
  const origHeight = 1 / srcAspect, origWidth = srcAspect * origHeight, cropWidth = origWidth - (crop.left + crop.right) * origWidth, cropHeight = origHeight - (crop.top + crop.bottom) * origHeight;
  return cropWidth / cropHeight;
}
const HotspotImage = React.memo(function(props2) {
  const {
    alignX = "center",
    alignY = "center",
    alt,
    aspectRatio = "none",
    className = "",
    crop = DEFAULT_CROP,
    hotspot = DEFAULT_HOTSPOT,
    onError,
    onLoad,
    src,
    srcAspectRatio,
    srcSet,
    style
  } = props2, [containerAspect, setContainerAspect] = React.useState(null), containerElementRef = React.useRef(null), imageElementRef = React.useRef(null), updateContainerAspect = React.useCallback(() => {
    if (containerElementRef.current)
      if (aspectRatio === "auto") {
        const parentNode = containerElementRef.current.parentNode;
        React.startTransition(() => setContainerAspect(parentNode.offsetWidth / parentNode.offsetHeight));
      } else
        setContainerAspect(null);
  }, [aspectRatio]);
  React.useEffect(() => {
    const imageElement = imageElementRef.current;
    return imageElement && imageElement.src && imageElement.complete && imageElement.naturalWidth !== void 0 && (debug$2("Image '%s' already loaded, refreshing (from cache) to trigger onLoad / onError", src), imageElement.src = imageElement.src), updateContainerAspect(), window.addEventListener("resize", updateContainerAspect), () => {
      window.removeEventListener("resize", updateContainerAspect);
    };
  }, [src, updateContainerAspect]);
  const targetAspect = React.useMemo(() => aspectRatio === "none" ? crop ? getCropAspect(crop, srcAspectRatio) : srcAspectRatio : aspectRatio === "auto" ? containerAspect : aspectRatio || null, [aspectRatio, containerAspect, crop, srcAspectRatio]), targetStyles = React.useMemo(
    () => calculateStyles({
      container: { aspectRatio: targetAspect || srcAspectRatio },
      image: { aspectRatio: srcAspectRatio },
      hotspot,
      crop,
      align: {
        x: alignX,
        y: alignY
      }
    }),
    [alignX, alignY, crop, hotspot, srcAspectRatio, targetAspect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(HotspotImageContainer, { className: `${className}`, style, ref: containerElementRef, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { style: targetStyles.container, children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: targetStyles.padding }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: targetStyles.crop, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        ref: imageElementRef,
        src,
        alt,
        srcSet,
        onLoad,
        onError,
        style: targetStyles.image
      }
    ) })
  ] }) });
});
function ImageLoader(props2) {
  const { src, children } = props2, [isLoading, setIsLoading] = React.useState(!0), [image, setImage] = React.useState(null), [error, setError] = React.useState(null);
  return React.useEffect(() => {
    setImage(null), setError(null), setIsLoading(!0);
    const image2 = new Image();
    image2.onload = () => {
      setImage(image2), setError(null), setIsLoading(!1);
    }, image2.onerror = () => {
      setError(new Error(`Could not load image from ${JSON.stringify(src)}`)), setIsLoading(!1);
    }, image2.referrerPolicy = "strict-origin-when-cross-origin", image2.src = src;
  }, [src]), children({ image, error, isLoading });
}
function Resize(props2) {
  const { image, maxHeight, maxWidth, children } = props2, [canvas] = React.useState(() => {
    const canvasElement = document.createElement("canvas");
    return canvasElement.style.display = "none", canvasElement;
  });
  React.useEffect(() => (document.body.appendChild(canvas), () => {
    document.body.removeChild(canvas);
  }), [canvas]);
  const resize = React.useCallback(
    (image2, maxHeight2, maxWidth2) => {
      const ratio = image2.width / image2.height, width = Math.min(image2.width, maxWidth2), height = Math.min(image2.height, maxHeight2), landscape = image2.width > image2.height, targetWidth = landscape ? width : height * ratio, targetHeight = landscape ? width / ratio : height;
      canvas.width = targetWidth, canvas.height = targetHeight;
      const ctx = canvas.getContext("2d");
      return ctx && ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, targetWidth, targetHeight), canvas;
    },
    [canvas]
  );
  return children(resize(image, maxHeight, maxWidth));
}
class Point {
  constructor(x, y) {
    this.x = x, this.y = y;
  }
}
class HLine {
  constructor(y, left, right) {
    this.y = y, this._left = left, this._right = right;
  }
  get right() {
    return new Point(this._right, this.y);
  }
  get left() {
    return new Point(this._left, this.y);
  }
  get length() {
    return this._right - this._left;
  }
}
class Corners {
  constructor(rect) {
    this.rect = rect;
  }
  get top() {
    return new HLine(this.rect.top, this.rect.left, this.rect.right);
  }
  get bottom() {
    return new HLine(this.rect.bottom, this.rect.left, this.rect.right);
  }
}
class Rect {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static fromEdges({ left, right, top, bottom: bottom2 }) {
    return new Rect(left, top, 1 - left - right, 1 - top - bottom2);
  }
  constructor(left = 0, top = 0, width = 0, height = 0) {
    this.left = left, this.top = top, this.width = width, this.height = height;
  }
  setTopLeft(left, top) {
    return new Rect(left, top, this.width || 0, this.height || 0);
  }
  setSize(width, height) {
    return new Rect(this.left || 0, this.top || 0, width, height);
  }
  setCenter(x, y) {
    const width = this.width || 0, height = this.height || 0;
    return new Rect(x - width / 2, y - height / 2, width || 0, height || 0);
  }
  get center() {
    return new Point(this.left + this.width / 2, this.top + this.height / 2);
  }
  get corners() {
    return new Corners(this);
  }
  get right() {
    return this.left + this.width;
  }
  get bottom() {
    return this.top + this.height;
  }
  multiply(rect) {
    return new Rect(
      (this.left || 0) + this.width * rect.left,
      (this.top || 0) + this.height * rect.top,
      this.width * rect.width,
      this.height * rect.height
    );
  }
  grow(delta) {
    return new Rect(
      this.left - delta,
      this.top - delta,
      this.width + delta * 2,
      this.height + delta * 2
    );
  }
  shrink(delta) {
    return this.grow(-delta);
  }
  cropRelative(crop) {
    const top = this.top + crop.top * this.height, left = this.left + crop.left * this.width, height = this.height * crop.height, width = this.width * crop.width;
    return new Rect(left, top, width, height);
  }
  clamp(bounds) {
    let { left, top, width, height } = this;
    return bounds.width < width && (width = bounds.width, left = bounds.left), bounds.height < height && (height = bounds.height, top = bounds.top), left + width > bounds.left + bounds.width && (left = bounds.right - width), top + height > bounds.top + bounds.height && (top = bounds.bottom - height), new Rect(Math.max(left, bounds.left), Math.max(top, bounds.top), width, height);
  }
}
function isPointInEllipse(point, ellipse) {
  const center = { x: ellipse.center.x, y: ellipse.center.y }, xradius = ellipse.width / 2, yradius = ellipse.height / 2;
  if (xradius <= 0 || yradius <= 0)
    return !1;
  const normalized = { x: point.x - center.x, y: point.y - center.y };
  return Math.pow(normalized.x, 2) / Math.pow(xradius, 2) + Math.pow(normalized.y, 2) / Math.pow(yradius, 2) <= 1;
}
function isPointInCircle({ x, y }, circle) {
  return Math.pow(x - circle.x, 2) + Math.pow(y - circle.y, 2) < Math.pow(circle.radius, 2);
}
function isPointInRect(point, rect) {
  return point.x >= rect.left && point.x <= rect.left + rect.width && point.y >= rect.top && point.y <= rect.top + rect.height;
}
function getPointAtCircumference(radians, ellipse) {
  return {
    x: ellipse.center.x - ellipse.width / 2 * Math.cos(radians),
    y: ellipse.center.y - ellipse.height / 2 * Math.sin(radians)
  };
}
const OPEN_HAND = "data:image/png;base64,AAACAAEAICACAAcABQAwAQAAFgAAACgAAAAgAAAAQAAAAAEAAQAAAAAAAAEAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAfwAAAP+AAAH/gAAB/8AAA//AAAd/wAAGf+AAAH9gAADbYAAA2yAAAZsAAAGbAAAAGAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////gH///4B///8Af//+AD///AA///wAH//4AB//8AAf//AAD//5AA///gAP//4AD//8AF///AB///5A////5///8=", CLOSE_HAND = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAABdSURBVEjH7ZA7DsAwCEMN6v2vTCdESpLKQRl5gxfzMQDNRQyWlEK83QAIRh3cH/QbIhQwMDl8gORl7A16WD/xxAdq6N6SgycKUblf41+wbFBT44RiCi11NU3TLHgBxRUUD4ITqnIAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDEtMjFUMDA6MTM6NDMrMDE6MDC74T7AAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEyLTA0LTAyVDA0OjEzOjM3KzAyOjAwQJ35wQAAAABJRU5ErkJggg==", testProperties = ["", "webkit", "moz", "ms", "o"].map(
  (prefix) => `${prefix}backingStoreRatio`
);
let foundProperty = -1;
function getBackingStoreRatio(context) {
  return foundProperty === -1 && (foundProperty = testProperties.find((testProperty) => testProperty in context)), foundProperty && context[foundProperty];
}
const debug$1 = debug__default.default("sanity-imagetool");
function makeDragAware(Component) {
  return class extends React.PureComponent {
    constructor() {
      super(...arguments), this.domNode = null, this.currentPos = null, this.isDragging = !1, this.handleDragStart = (event) => {
        const { onDragStart, readOnly } = this.props;
        if (readOnly || !this.domNode)
          return;
        if (this.isDragging) {
          debug$1("Start cancelled, already a drag in progress");
          return;
        }
        this.isDragging = !0;
        const nextPos = getPos(event);
        debug$1("Drag started %o", nextPos), onDragStart(
          getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect())
        ), this.currentPos = nextPos;
      }, this.handleDrag = (event) => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos)
          return;
        const { onDrag } = this.props, nextPos = getPos(event), diff2 = diffPos(nextPos, this.currentPos);
        onDrag(diff2), debug$1("moving by %o", diff2), this.currentPos = nextPos;
      }, this.handleDragEnd = (event) => {
        const { onDragEnd, readOnly } = this.props;
        if (!this.isDragging || readOnly || !this.domNode)
          return;
        const nextPos = getPos(event);
        onDragEnd(
          getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect())
        ), this.isDragging = !1, this.currentPos = null, debug$1("Done moving %o", nextPos);
      }, this.handleDragCancel = () => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos || !this.domNode)
          return;
        const { onDragEnd } = this.props;
        this.isDragging = !1, onDragEnd(
          getPositionRelativeToRect(
            this.currentPos.x,
            this.currentPos.y,
            this.domNode.getBoundingClientRect()
          )
        ), this.currentPos = null;
      }, this.setDomNode = (node) => {
        this.domNode = node;
      };
    }
    componentDidMount() {
      document.body.addEventListener("pointermove", this.handleDrag), document.body.addEventListener("pointerup", this.handleDragEnd), document.body.addEventListener("pointerleave", this.handleDragCancel), document.body.addEventListener("pointercancel", this.handleDragCancel);
    }
    componentWillUnmount() {
      document.body.removeEventListener("pointermove", this.handleDrag), document.body.removeEventListener("pointerup", this.handleDragEnd), document.body.removeEventListener("pointerleave", this.handleDragCancel), document.body.removeEventListener("pointercancel", this.handleDragCancel);
    }
    render() {
      const { readOnly, onDragStart, onDragEnd, onDrag, ...rest } = this.props;
      return /* @__PURE__ */ jsxRuntime.jsx(
        Component,
        {
          ref: this.setDomNode,
          onPointerDown: readOnly ? void 0 : this.handleDragStart,
          onPointerMove: readOnly ? void 0 : this.handleDrag,
          ...rest
        }
      );
    }
  };
}
function getPositionRelativeToRect(x, y, rect) {
  return {
    x: x - rect.left,
    y: y - rect.top
  };
}
function getPos(event) {
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function diffPos(pos, otherPos) {
  return {
    x: pos.x - otherPos.x,
    y: pos.y - otherPos.y
  };
}
const DragAwareCanvas = makeDragAware("canvas"), RootContainer = styled__default.default.div`
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
`, CanvasContainer = styled__default.default(DragAwareCanvas)`
  display: block;
  position: relative;
  max-width: calc(100% - 0.5em); /* to prevent overlap with change bar */
  max-height: calc(100% + 1em);
  user-select: none;
  // Enable only multi-finger panning and zooming within this element.
  // This prevents single finger panning when manipulating drag handles,
  // which can cause unwanted scrolling in the underlying document body.
  touch-action: pinch-zoom;
`, MARGIN_PX = 8, CROP_HANDLE_SIZE = 12, HOTSPOT_HANDLE_SIZE = 10;
function normalizeRect(rect) {
  const flippedY = rect.top > rect.bottom, flippedX = rect.left > rect.right;
  return {
    top: flippedY ? rect.bottom : rect.top,
    bottom: flippedY ? rect.top : rect.bottom,
    left: flippedX ? rect.right : rect.left,
    right: flippedX ? rect.left : rect.right
  };
}
function checkCropBoundaries(value, delta) {
  return !(!value || !value.crop || value.crop.top + delta.top < 0 || value.crop.left + delta.left < 0 || value.crop.right + delta.right < 0 || value.crop.bottom + delta.bottom < 0);
}
function limitToBoundaries(value, delta) {
  const { top, right, bottom: bottom2, left } = value.crop || DEFAULT_CROP, newValue = {
    hotspot: value.hotspot,
    crop: {
      top: top + (delta.top || 0) > 0 ? top : 0,
      right: right + (delta.right || 0) > 0 ? right : 0,
      bottom: bottom2 + (delta.bottom || 0) > 0 ? bottom2 : 0,
      left: left + (delta.left || 0) > 0 ? left : 0
    }
  }, newDelta = {
    top: top + (delta.top || 0) > 0 && delta.top || 0,
    right: right + (delta.right || 0) > 0 && delta.right || 0,
    bottom: bottom2 + (delta.bottom || 0) > 0 && delta.bottom || 0,
    left: left + (delta.left || 0) > 0 && delta.left || 0
  };
  return { value: newValue, delta: newDelta };
}
function getCropCursorForHandle(handle) {
  switch (handle) {
    case "left":
    case "right":
      return "col-resize";
    case "top":
    case "bottom":
      return "row-resize";
    case "topRight":
    case "bottomLeft":
      return "nesw-resize";
    case "topLeft":
    case "bottomRight":
      return "nwse-resize";
    default:
      return null;
  }
}
const getDevicePixelRatio$1 = memoize__default.default(() => {
  const devicePixelRatio = window.devicePixelRatio || 1, ctx = document.createElement("canvas").getContext("2d"), backingStoreRatio = ctx && getBackingStoreRatio(ctx) || 1;
  return devicePixelRatio / backingStoreRatio;
}), cropHandleKeys = [
  "left",
  "right",
  "top",
  "topLeft",
  "topRight",
  "bottom",
  "bottomLeft",
  "bottomRight"
];
class ToolCanvas extends React.PureComponent {
  constructor() {
    super(...arguments), this.state = {
      cropping: !1,
      cropMoving: !1,
      moving: !1,
      resizing: !1,
      pointerPosition: null
    }, this.handleDragStart = ({ x, y }) => {
      const pointerPosition = { x: x * this.getScale(), y: y * this.getScale() }, inHotspot = isPointInEllipse(pointerPosition, this.getHotspotRect()), inDragHandle = isPointInCircle(pointerPosition, this.getDragHandleCoords()), activeCropHandle = this.getActiveCropHandleFor(pointerPosition), inCropRect = isPointInRect(pointerPosition, this.getCropRect());
      activeCropHandle ? this.setState({ cropping: activeCropHandle }) : inDragHandle ? this.setState({ resizing: !0 }) : inHotspot ? this.setState({ moving: !0 }) : inCropRect && this.setState({ cropMoving: !0 });
    }, this.handleDrag = (pos) => {
      this.state.cropping ? this.emitCrop(this.state.cropping, pos) : this.state.cropMoving ? this.emitCropMove(pos) : this.state.moving ? this.emitMove(pos) : this.state.resizing && this.emitResize(pos);
    }, this.handleDragEnd = () => {
      const { onChange, onChangeEnd } = this.props;
      this.setState({ moving: !1, resizing: !1, cropping: !1, cropMoving: !1 });
      const { hotspot, crop: rawCrop } = this.getClampedValue(), crop = normalizeRect(rawCrop), finalValue = {
        crop: {
          top: crop.top,
          bottom: 1 - crop.bottom,
          left: crop.left,
          right: 1 - crop.right
        },
        hotspot: {
          x: hotspot.center.x,
          y: hotspot.center.y,
          height: Math.abs(hotspot.height),
          width: Math.abs(hotspot.width)
        }
      };
      onChange(finalValue), onChangeEnd && onChangeEnd(finalValue);
    }, this.handlePointerOut = () => {
      this.setState({ pointerPosition: null });
    }, this.handlePointerMove = (event) => {
      const clientRect = event.currentTarget.getBoundingClientRect();
      this.setState({
        pointerPosition: {
          x: (event.clientX - clientRect.left) * this.getScale(),
          y: (event.clientY - clientRect.top) * this.getScale()
        }
      });
    }, this.setCanvas = (node) => {
      this.canvas = node;
    };
  }
  getHotspotRect() {
    const { value, image } = this.props, hotspot = value.hotspot || DEFAULT_HOTSPOT, hotspotRect = new Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);
    return new Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).multiply(hotspotRect);
  }
  getCropRect() {
    const { value, image } = this.props;
    return new Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).cropRelative(Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1)));
  }
  getCropHandles() {
    const inner = this.getCropRect(), handleSize = CROP_HANDLE_SIZE * this.getScale(), halfCropHandleSize = handleSize / 2, cropHandle = new Rect(0, 0, handleSize, handleSize);
    return {
      left: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.center.y - halfCropHandleSize
      ),
      right: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.center.y - halfCropHandleSize
      ),
      top: cropHandle.setTopLeft(
        inner.center.x - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      topLeft: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      topRight: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      bottom: cropHandle.setTopLeft(
        inner.center.x - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      ),
      bottomLeft: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      ),
      bottomRight: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      )
    };
  }
  getActiveCropHandleFor({ x, y }) {
    const cropHandles = this.getCropHandles();
    for (const position of cropHandleKeys)
      if (isPointInRect({ x, y }, cropHandles[position]))
        return position;
    return !1;
  }
  emitMove(pos) {
    const { image, value, onChange } = this.props, scale = this.getScale(), delta = {
      x: pos.x * scale / image.width,
      y: pos.y * scale / image.height
    };
    onChange(applyHotspotMoveBy(value, delta));
  }
  emitCropMove(pos) {
    const { image, onChange, value } = this.props, scale = this.getScale(), left = pos.x * scale / image.width, right = -pos.x * scale / image.width, top = pos.y * scale / image.height, bottom2 = -pos.y * scale / image.height, delta = { left, right, top, bottom: bottom2 };
    checkCropBoundaries(value, delta) && onChange(applyCropMoveBy(value, delta));
  }
  emitCrop(side, pos) {
    const { image, onChange, value } = this.props, scale = this.getScale();
    let left = 0, right = 0, top = 0, bottom2 = 0;
    side == "left" || side === "topLeft" || side === "bottomLeft" ? left = pos.x * scale / image.width : (side == "right" || side === "topRight" || side === "bottomRight") && (right = -pos.x * scale / image.width), side == "top" || side === "topLeft" || side === "topRight" ? top = pos.y * scale / image.height : (side == "bottom" || side === "bottomLeft" || side === "bottomRight") && (bottom2 = -pos.y * scale / image.height);
    const delta = { left, right, top, bottom: bottom2 }, newValue = limitToBoundaries(value, delta).value, newDelta = limitToBoundaries(value, delta).delta;
    onChange(applyCropMoveBy(newValue, newDelta));
  }
  emitResize(pos) {
    const { image, onChange, value } = this.props, scale = this.getScale(), delta = {
      x: pos.x * scale * 2 / image.width,
      y: pos.y * scale * 2 / image.height
    };
    onChange(applyHotspotResizeBy(value, { height: delta.y, width: delta.x }));
  }
  getClampedValue() {
    const value = this.props.value, crop = Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1)), hotspot = value.hotspot || DEFAULT_HOTSPOT, hotspotRect = new Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);
    return { crop, hotspot: hotspotRect };
  }
  paintHotspot(context, opacity) {
    const { image, readOnly } = this.props, imageRect = new Rect().setSize(image.width, image.height), { hotspot, crop } = this.getClampedValue(), scale = this.getScale(), margin = MARGIN_PX * scale;
    context.save(), drawBackdrop(), drawEllipse(), context.clip(), drawHole(), context.restore(), readOnly || drawDragHandle(Math.PI * 1.25);
    function drawEllipse() {
      context.save();
      const dest = imageRect.shrink(margin).multiply(hotspot), scaleY = dest.height / dest.width;
      context.scale(1, scaleY), context.beginPath(), context.globalAlpha = opacity, context.arc(
        dest.center.x,
        dest.center.y / scaleY,
        Math.abs(dest.width / 2),
        0,
        2 * Math.PI,
        !1
      ), context.strokeStyle = "white", context.lineWidth = 1.5 * scale, context.stroke(), context.closePath(), context.restore();
    }
    function drawImage(srcLeft, srcTop, srcWidth, srcHeight, destLeft, destTop, destWidth, destHeight) {
      context.save(), context.drawImage(
        image,
        srcLeft,
        srcTop,
        srcWidth,
        srcHeight,
        destLeft,
        destTop,
        destWidth,
        destHeight
      ), context.restore();
    }
    function drawHole() {
      const src = imageRect.multiply(hotspot), dest = imageRect.shrink(margin).multiply(hotspot);
      drawImage(
        src.left,
        src.top,
        src.width,
        src.height,
        dest.left,
        dest.top,
        dest.width,
        dest.height
      );
    }
    function drawBackdrop() {
      const src = imageRect.cropRelative(crop), dest = imageRect.shrink(margin).cropRelative(crop);
      context.save(), drawImage(
        src.left,
        src.top,
        src.width,
        src.height,
        dest.left,
        dest.top,
        dest.width,
        dest.height
      ), context.globalAlpha = 0.5, context.fillStyle = "black", context.fillRect(dest.left, dest.top, dest.width, dest.height), context.restore();
    }
    function drawDragHandle(radians) {
      context.save();
      const radius = HOTSPOT_HANDLE_SIZE * scale, dest = imageRect.shrink(margin).multiply(hotspot), point = getPointAtCircumference(radians, dest);
      context.beginPath(), context.arc(point.x, point.y, radius, 0, 2 * Math.PI, !1), context.fillStyle = "rgb(255,255,255)", context.fill(), context.closePath(), context.restore(), context.beginPath(), context.arc(point.x, point.y, radius, 0, 2 * Math.PI, !1), context.strokeStyle = "rgb(0, 0, 0)", context.lineWidth = 0.5 * scale, context.stroke(), context.closePath();
    }
  }
  getActualSize() {
    var _a2;
    const node = (_a2 = this.canvas) == null ? void 0 : _a2.domNode;
    return node ? { height: node.clientHeight, width: node.clientWidth } : { height: 0, width: 0 };
  }
  getDragHandleCoords() {
    const bbox = this.getHotspotRect(), point = getPointAtCircumference(Math.PI * 1.25, bbox);
    return {
      x: point.x,
      y: point.y,
      radius: 8 * this.getScale()
    };
  }
  debug(context) {
    context.save();
    const { image } = this.props, bbox = this.getHotspotRect(), scale = this.getScale(), margin = MARGIN_PX * scale;
    context.setLineDash && context.setLineDash([2 * scale, 2 * scale]), context.lineWidth = 0.5 * scale, context.strokeStyle = "rgba(200, 200, 200, 0.5)", vline(bbox.center.x), hline(bbox.center.y), context.strokeStyle = "rgba(150, 150, 150, 0.5)", hline(bbox.top), hline(bbox.bottom), vline(bbox.left), vline(bbox.right), context.restore();
    function vline(x) {
      line(x, margin, x, image.height - margin);
    }
    function hline(y) {
      line(margin, y, image.width - margin, y);
    }
    function line(x1, y1, x2, y2) {
      context.beginPath(), context.moveTo(x1, y1), context.lineTo(x2, y2), context.stroke(), context.closePath();
    }
  }
  paintBackground(context) {
    const { image } = this.props, inner = new Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale());
    context.save(), context.fillStyle = "white", context.clearRect(0, 0, image.width, image.height), context.globalAlpha = 0.3, context.drawImage(image, inner.left, inner.top, inner.width, inner.height), context.restore();
  }
  paint(context) {
    const { readOnly } = this.props;
    context.save();
    const pxratio = getDevicePixelRatio$1();
    context.scale(pxratio, pxratio);
    const opacity = !readOnly && this.state.pointerPosition ? 0.8 : 0.2;
    this.paintBackground(context), this.paintHotspot(context, opacity), this.debug(context), this.paintCropBorder(context), readOnly || this.highlightCropHandles(context, opacity), context.restore();
  }
  paintPointerPosition(context) {
    if (!this.state.pointerPosition)
      return;
    const { x, y } = this.state.pointerPosition;
    context.beginPath(), context.arc(x, y, 14 * this.getScale(), 0, 2 * Math.PI, !1), context.fillStyle = "lightblue", context.fill(), context.restore();
  }
  paintCropBorder(context) {
    const cropRect = this.getCropRect();
    context.save(), context.beginPath(), context.fillStyle = "rgba(66, 66, 66, 0.9)", context.lineWidth = 1, context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height), context.stroke(), context.closePath(), context.restore();
  }
  highlightCropHandles(context, opacity) {
    context.save();
    const cropHandles = this.getCropHandles();
    cropHandleKeys.forEach((handle) => {
      context.fillStyle = this.state.cropping === handle ? `rgba(202, 54, 53, ${opacity})` : `rgba(230, 230, 230, ${opacity + 0.4})`;
      const { left, top, height, width } = cropHandles[handle];
      context.fillRect(left, top, width, height), context.beginPath(), context.fillStyle = `rgba(66, 66, 66, ${opacity})`, context.rect(left, top, width, height), context.closePath(), context.stroke();
    }), context.restore();
  }
  getScale() {
    const actualSize = this.getActualSize();
    return this.props.image.width / actualSize.width;
  }
  getCursor() {
    const { pointerPosition } = this.state, { readOnly } = this.props;
    if (!pointerPosition || readOnly)
      return "auto";
    const activeCropArea = this.state.cropping || this.getActiveCropHandleFor(pointerPosition);
    if (activeCropArea)
      return getCropCursorForHandle(activeCropArea) || "auto";
    const pointerOverDragHandle = isPointInCircle(
      pointerPosition,
      this.getDragHandleCoords()
    );
    if (this.state.resizing || pointerOverDragHandle)
      return "move";
    if (this.state.moving || this.state.cropMoving)
      return `url(${CLOSE_HAND}), move`;
    const pointerOverHotspot = isPointInEllipse(pointerPosition, this.getHotspotRect()), pointerOverCropRect = isPointInRect(pointerPosition, this.getCropRect());
    return pointerOverHotspot || pointerOverCropRect ? `url(${OPEN_HAND}), move` : "auto";
  }
  componentDidMount() {
    this.draw();
  }
  componentDidUpdate() {
    this.draw();
  }
  draw() {
    if (!this.canvas)
      return;
    const domNode = this.canvas.domNode, context = domNode.getContext("2d");
    if (!context)
      return;
    this.paint(context);
    const currentCursor = domNode.style.cursor, newCursor = this.getCursor();
    currentCursor !== newCursor && (domNode.style.cursor = newCursor);
  }
  render() {
    const { image, readOnly } = this.props, ratio = getDevicePixelRatio$1();
    return /* @__PURE__ */ jsxRuntime.jsx(RootContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(
      CanvasContainer,
      {
        readOnly,
        ref: this.setCanvas,
        onDrag: this.handleDrag,
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd,
        onPointerMove: this.handlePointerMove,
        onPointerOut: this.handlePointerOut,
        height: image.height * ratio,
        width: image.width * ratio
      }
    ) });
  }
}
function applyHotspotMoveBy(value, delta) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return {
    ...value,
    hotspot: {
      ...currentHotspot,
      x: currentHotspot.x + delta.x,
      y: currentHotspot.y + delta.y
    }
  };
}
function applyHotspotResizeBy(value, delta) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return {
    ...value,
    hotspot: {
      ...currentHotspot,
      height: currentHotspot.height + delta.height,
      width: currentHotspot.width + delta.width
    }
  };
}
function applyCropMoveBy(value, delta) {
  const currentCrop = value && value.crop || DEFAULT_CROP;
  return {
    ...value,
    crop: {
      left: currentCrop.left + (delta.left || 0),
      right: currentCrop.right + (delta.right || 0),
      top: currentCrop.top + (delta.top || 0),
      bottom: currentCrop.bottom + (delta.bottom || 0)
    }
  };
}
function ImageTool(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ImageLoader, { src: props2.src, children: ({ isLoading, image, error }) => isLoading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : error ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: error.message }) : image ? /* @__PURE__ */ jsxRuntime.jsx(Resize, { image, maxHeight: ImageTool.maxHeight, maxWidth: ImageTool.maxWidth, children: (canvas) => /* @__PURE__ */ jsxRuntime.jsx(ToolCanvas, { image: canvas, ...props2 }) }) : null });
}
ImageTool.maxHeight = 500;
ImageTool.maxWidth = 1e3;
const PROBABLY_THE_TINIEST_GIF_EVER = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
function isBlob(src) {
  return src.startsWith("blob:");
}
function loadImage(src) {
  return new rxjs.Observable((subscriber) => {
    const image = document.createElement("img");
    let completed = !1;
    const onload = () => {
      completed = !0, subscriber.next(image), subscriber.complete();
    }, onerror = () => {
      completed = !0, subscriber.error(new Error(`Could not load image from ${isBlob(src) ? "blob" : src}`));
    };
    return image.onload = onload, image.onerror = onerror, image.src = src, () => {
      image.onload = null, image.onerror = null, completed || (image.src = PROBABLY_THE_TINIEST_GIF_EVER);
    };
  });
}
const INITIAL_STATE$2 = { isLoading: !0 };
function useLoadImage(url) {
  const [state, setState] = React.useState(INITIAL_STATE$2);
  return React.useEffect(() => {
    setState(INITIAL_STATE$2);
    const subscription = loadImage(url).subscribe({
      error: (err) => {
        setState({ isLoading: !1, error: err });
      },
      next: (image) => {
        setState({ image, isLoading: !1 });
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [url]), state;
}
const HOTSPOT_PATH = ["hotspot"], PREVIEW_ASPECT_RATIOS = [
  ["3:4", 3 / 4],
  ["Square", 1 / 1],
  ["16:9", 16 / 9],
  ["Panorama", 4 / 1]
], DEFAULT_VALUE = {
  crop: DEFAULT_CROP,
  hotspot: DEFAULT_HOTSPOT
}, Placeholder$1 = styled__default.default.div`
  min-height: 6em;
`;
function LoadStatus(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", padding: 4, style: { overflowWrap: "break-word" }, children: props2.children });
}
function ImageToolInput(props2) {
  const {
    imageUrl,
    value,
    changed,
    level,
    path,
    focusPath = EMPTY_ARRAY$b,
    presence,
    onChange,
    schemaType,
    onPathFocus,
    readOnly,
    elementProps
  } = props2, [localValue, setLocalValue] = React.useState(value || DEFAULT_VALUE), { image, isLoading: isImageLoading, error: imageLoadError } = useLoadImage(imageUrl), handleFocus = React.useCallback(() => {
    onPathFocus(HOTSPOT_PATH);
  }, [onPathFocus]);
  React.useEffect(() => {
    setLocalValue(value || DEFAULT_VALUE);
  }, [value]);
  const hasFocus = focusPath[0] === "hotspot";
  useDidUpdate(hasFocus, (hadFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = elementProps.ref.current) == null || _a2.focus());
  });
  const handleChangeEnd = React.useCallback(
    (finalValue) => {
      if (readOnly)
        return;
      const cropField = schemaType.fields.find(
        (field) => field.name === "crop" && field.type.name !== "object"
      ), hotspotField = schemaType.fields.find(
        (field) => field.type.name !== "object" && field.name === "hotspot"
      ), crop = cropField ? { _type: cropField.type.name, ...finalValue.crop || DEFAULT_CROP } : finalValue.crop, hotspot = hotspotField ? { _type: hotspotField.type.name, ...finalValue.hotspot || DEFAULT_HOTSPOT } : finalValue.hotspot;
      onChange([set(crop, ["crop"]), set(hotspot, ["hotspot"])]);
    },
    [onChange, readOnly, schemaType.fields]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormField,
    {
      title: t2("inputs.imagetool.title"),
      level,
      description: t2("inputs.imagetool.description"),
      deprecated: schemaType.deprecated,
      __unstable_presence: presence,
      children: /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            __unstable_checkered: !0,
            __unstable_focusRing: !0,
            tabIndex: 0,
            ref: elementProps.ref,
            onFocus: handleFocus,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ChangeIndicator,
              {
                path: path.concat(HOTSPOT_PATH),
                hasFocus: focusPath[0] === "hotspot",
                isChanged: changed,
                children: /* @__PURE__ */ jsxRuntime.jsxs(RatioBox$1, { ratio: 3 / 2, children: [
                  (isImageLoading || imageLoadError) && /* @__PURE__ */ jsxRuntime.jsx(LoadStatus, { children: imageLoadError ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, tone: "critical", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t2("inputs.imagetool.load-error", {
                    errorMessage: imageLoadError.message
                  }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }),
                  !isImageLoading && image && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                    ImageTool,
                    {
                      value: localValue,
                      src: image.src,
                      readOnly: !!readOnly,
                      onChangeEnd: handleChangeEnd,
                      onChange: setLocalValue
                    }
                  ) })
                ] })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { columns: PREVIEW_ASPECT_RATIOS.length, gap: 1, children: PREVIEW_ASPECT_RATIOS.map(([title, ratio]) => /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h4", size: 0, children: title }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(RatioBox$1, { ratio, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, children: !isImageLoading && image ? /* @__PURE__ */ jsxRuntime.jsx(
            HotspotImage,
            {
              aspectRatio: ratio,
              src: image.src,
              srcAspectRatio: image.width / image.height,
              hotspot: localValue.hotspot || DEFAULT_HOTSPOT,
              crop: localValue.crop || DEFAULT_CROP
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(Placeholder$1, {}) }) }) })
        ] }, ratio)) }) })
      ] })
    }
  );
}
const MenuActionsWrapper = styled__default.default(ui.Inline)`
  position: absolute;
  top: 0;
  right: 0;
`;
function ImageActionsMenu(props2) {
  const {
    onEdit,
    children,
    showEdit,
    setHotspotButtonElement,
    setMenuButtonElement,
    onMenuOpen,
    isMenuOpen
  } = props2, [menuElement, setMenuElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), handleClick = React.useCallback(() => onMenuOpen(!isMenuOpen), [onMenuOpen, isMenuOpen]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        isMenuOpen && (event.key === "Escape" || event.key === "Tab") && (onMenuOpen(!1), buttonElement == null || buttonElement.focus());
      },
      [isMenuOpen, onMenuOpen, buttonElement]
    )
  ), ui.useClickOutside(
    React.useCallback(
      (event) => {
        buttonElement != null && buttonElement.contains(event.target) || onMenuOpen(!1);
      },
      [buttonElement, onMenuOpen]
    ),
    [menuElement]
  );
  const setOptionsButtonRef = React.useCallback(
    (el) => {
      setMenuButtonElement(el), setButtonElement(el);
    },
    [setMenuButtonElement]
  );
  React.useEffect(() => {
    isMenuOpen && (menuElement == null || menuElement.focus());
  }, [isMenuOpen, menuElement]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(MenuActionsWrapper, { "data-buttons": !0, space: 1, padding: 2, children: [
    showEdit && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t2("inputs.image.actions-menu.edit-details.aria-label"),
        "data-testid": "options-menu-edit-details",
        icon: icons.CropIcon,
        mode: "ghost",
        onClick: onEdit,
        ref: setHotspotButtonElement,
        tooltipProps: { content: t2("inputs.image.actions-menu.crop-image-tooltip") }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Popover,
      {
        id: "image-actions-menu",
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: setMenuElement, children }),
        portal: !0,
        open: isMenuOpen,
        constrainSize: !0,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ContextMenuButton,
          {
            "aria-label": t2("inputs.image.actions-menu.options.aria-label"),
            "data-testid": "options-menu-button",
            mode: "ghost",
            onClick: handleClick,
            ref: setOptionsButtonRef
          }
        )
      }
    )
  ] }) });
}
const MAX_DEFAULT_HEIGHT = 30, RatioBox = styled__default.default(ui.Card)`
  position: relative;
  width: 100%;
  overflow: hidden;
  overflow: clip;
  min-height: 3.75rem;
  max-height: 20rem;

  & > div[data-container] {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex !important;
    align-items: center;
    justify-content: center;
  }

  & img {
    max-width: 100%;
    max-height: 100%;
  }
`, Overlay = styled__default.default(ui.Flex)(({ $drag, $tone }) => {
  const textColor = ui.studioTheme.color.light[$tone].card.enabled.fg, backgroundColor = ui.rgba(ui.studioTheme.color.light[$tone].card.enabled.bg, 0.8);
  return styled.css`
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    backdrop-filter: ${$drag ? "blur(10px)" : ""};
    color: ${$tone ? textColor : ""};
    background-color: ${$drag ? backgroundColor : "transparent"};
  `;
}), FlexOverlay = styled__default.default(ui.Flex)`
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
`, getImageSize = (src) => {
  const rect = new URLSearchParams(src.split("?")[1]).get("rect");
  return rect ? [rect.split(",")[2], rect.split(",")[3]].map(Number) : src.split("-")[1].split(".")[0].split("x").map(Number);
};
function ImagePreview$1(props2) {
  const { drag, readOnly, isRejected, src, ...rest } = props2, [isLoaded, setLoaded] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), rootRect = ui.useElementRect(rootElement), rootWidth = (rootRect == null ? void 0 : rootRect.width) || 0, tone = drag ? isRejected || readOnly ? "critical" : "primary" : "default", maxHeightToPx = MAX_DEFAULT_HEIGHT * document.documentElement.clientHeight / 100, [imageWidth, imageHeight] = getImageSize(src), imageRatio = imageWidth / imageHeight, rootHeight = (imageWidth > rootWidth ? rootWidth / imageRatio : imageHeight) < maxHeightToPx ? null : `${MAX_DEFAULT_HEIGHT}vh`;
  React.useEffect(() => {
    setLoaded(!1);
  }, [src]);
  const onLoadChange = React.useCallback(() => {
    setLoaded(!0);
  }, []), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(RatioBox, { ...rest, ref: setRootElement, style: { height: rootHeight }, tone: "transparent", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { "data-container": !0, tone: "inherit", children: [
      !isLoaded && /* @__PURE__ */ jsxRuntime.jsx(OverlayComponent, { cardTone: "transparent", drag: !0, content: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "img",
        {
          src,
          "data-testid": "hotspot-image-input",
          alt: props2.alt,
          onLoad: onLoadChange,
          referrerPolicy: "strict-origin-when-cross-origin"
        }
      )
    ] }),
    drag && /* @__PURE__ */ jsxRuntime.jsx(
      OverlayComponent,
      {
        cardTone: tone,
        drag,
        content: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { children: /* @__PURE__ */ jsxRuntime.jsx(HoverIcon, { isRejected, readOnly }) }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2(getHoverTextTranslationKey({ isRejected, readOnly })) })
        ] })
      }
    )
  ] });
}
function HoverIcon({ isRejected, readOnly }) {
  return isRejected ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : readOnly ? /* @__PURE__ */ jsxRuntime.jsx(icons.ReadOnlyIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.ImageIcon, {});
}
function getHoverTextTranslationKey({
  isRejected,
  readOnly
}) {
  return isRejected ? "inputs.image.drag-overlay.this-field-is-read-only" : readOnly ? "inputs.image.drag-overlay.cannot-upload-here" : "inputs.image.drag-overlay.drop-to-upload-image";
}
function OverlayComponent({
  cardTone,
  drag,
  content: content2
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(Overlay, { justify: "flex-end", padding: 3, $drag: drag, $tone: cardTone, children: /* @__PURE__ */ jsxRuntime.jsx(FlexOverlay, { direction: "column", align: "center", justify: "center", children: content2 }) });
}
function InvalidImageWarning({ onClearValue }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.image.invalid-image-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.image.invalid-image-warning.description") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearValue,
        text: t2("inputs.image.invalid-image-warning.reset-button.text"),
        width: "fill"
      }
    )
  ] });
}
const getDevicePixelRatio = () => typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(Math.max(1, window.devicePixelRatio));
function passThrough({ children }) {
  return children;
}
const ASSET_FIELD_PATH = ["asset"], ASSET_IMAGE_MENU_POPOVER = { portal: !0 };
class BaseImageInput extends React.PureComponent {
  constructor(props2) {
    super(props2), this._previewElement = null, this.uploadSubscription = null, this.state = {
      isUploading: !1,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: !1,
      hotspotButtonElement: null,
      menuButtonElement: null,
      isMenuOpen: !1
    }, this.toast = null, this.setPreviewElement = (el) => {
      this._previewElement = el;
    }, this.setHotspotButtonElement = (el) => {
      this.setState({ hotspotButtonElement: el });
    }, this.setMenuButtonElement = (el) => {
      this.setState({ menuButtonElement: el });
    }, this.getUploadOptions = (file) => {
      const { schemaType, resolveUploader: resolveUploader2 } = this.props, uploader = resolveUploader2 && resolveUploader2(schemaType, file);
      return uploader ? [{ type: schemaType, uploader }] : [];
    }, this.uploadWith = (uploader, file, assetDocumentProps = {}) => {
      const { schemaType, onChange, client: client2, t: t2 } = this.props, { label, title, description, creditLine, source } = assetDocumentProps, options = {
        metadata: get__default.default(schemaType, "options.metadata"),
        storeOriginalFilename: get__default.default(schemaType, "options.storeOriginalFilename"),
        label,
        title,
        description,
        creditLine,
        source
      };
      this.cancelUpload(), this.setState({ isUploading: !0 }), onChange(setIfMissing({ _type: schemaType.name })), this.uploadSubscription = uploader.upload(client2, file, schemaType, options).subscribe({
        next: (uploadEvent) => {
          uploadEvent.patches && onChange(uploadEvent.patches);
        },
        error: (err) => {
          var _a2;
          console.error(err), (_a2 = this.toast) == null || _a2.push({
            status: "error",
            description: t2("inputs.image.upload-error.description"),
            title: t2("inputs.image.upload-error.title")
          }), this.clearUploadStatus();
        },
        complete: () => {
          onChange([unset(["hotspot"]), unset(["crop"])]), this.setState({ isUploading: !1 });
        }
      });
    }, this.handleRemoveButtonClick = () => {
      const { value } = this.props, allKeys = Object.keys(value || {}), isEmpty2 = allKeys.filter(
        (key) => !["_type", "_key", "_upload", "asset", "crop", "hotspot"].includes(key)
      ).length === 0, removeKeys = ["asset"].concat(allKeys.filter((key) => ["crop", "hotspot", "_upload"].includes(key))).map((key) => unset([key]));
      this.props.onChange(isEmpty2 && !this.valueIsArrayElement() ? unset() : removeKeys);
    }, this.handleFieldChange = (event) => {
      const { onChange, schemaType } = this.props;
      if (!this.valueIsArrayElement() && this.eventIsUnsettingLastFilledField(event)) {
        onChange(unset());
        return;
      }
      onChange(
        event.prepend(
          setIfMissing({
            _type: schemaType.name
          })
        ).patches
      );
    }, this.eventIsUnsettingLastFilledField = (event) => {
      const patch2 = event.patches[0];
      if (event.patches.length !== 1 || patch2.type !== "unset")
        return !1;
      const remainingKeys = Object.keys(this.props.value || {}).filter(
        (key) => !["_type", "_key", "crop", "hotspot"].includes(key)
      );
      return event.patches[0].path.length === 1 && remainingKeys.length === 1 && remainingKeys[0] === event.patches[0].path[0];
    }, this.valueIsArrayElement = () => {
      const { path } = this.props;
      return typeof path.slice(-1)[0] != "string";
    }, this.handleOpenDialog = () => {
      this.props.onPathFocus(["hotspot"]);
    }, this.handleCloseDialog = () => {
      var _a2;
      this.props.onPathFocus([]), (_a2 = this.state.hotspotButtonElement) == null || _a2.focus();
    }, this.handleSelectAssetFromSource = (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({
        assetFromSource,
        onChange,
        type: schemaType,
        resolveUploader: resolveUploader2,
        uploadWith: this.uploadWith,
        isImage: !0
      }), this.setState({ selectedAssetSource: null });
    }, this.handleFileTargetFocus = (event) => {
      var _a2;
      event.currentTarget === event.target && event.currentTarget === ((_a2 = this.props.elementProps.ref) == null ? void 0 : _a2.current) && this.props.elementProps.onFocus(event);
    }, this.handleFilesOver = (hoveringFiles) => {
      this.setState({
        hoveringFiles: hoveringFiles.filter((file) => file.kind !== "string")
      });
    }, this.handleFilesOut = () => {
      this.setState({
        hoveringFiles: []
      });
    }, this.handleCancelUpload = () => {
      this.cancelUpload();
    }, this.handleClearUploadState = () => {
      this.setState({ isStale: !1 }), this.clearUploadStatus();
    }, this.handleStaleUpload = () => {
      this.setState({ isStale: !0 });
    }, this.handleClearField = () => {
      this.props.onChange([unset(["asset"]), unset(["crop"]), unset(["hotspot"])]);
    }, this.handleSelectFiles = (files) => {
      const { directUploads, readOnly } = this.props, { hoveringFiles } = this.state;
      directUploads && !readOnly ? this.uploadFirstAccepted(files) : hoveringFiles.length > 0 && this.handleFilesOut();
    }, this.handleSelectImageFromAssetSource = (source) => {
      this.setState({ selectedAssetSource: source });
    }, this.handleAssetSourceClosed = () => {
      var _a2;
      this.setState({ selectedAssetSource: null }), (_a2 = this.state.menuButtonElement) == null || _a2.focus();
    }, this.renderHotspotInput = (hotspotInputProps) => {
      const { value, changed, id: id2, imageUrlBuilder: imageUrlBuilder2, t: t2 } = this.props, withImageTool = this.isImageToolEnabled() && value && value.asset;
      return /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Dialog,
        {
          __unstable_autoFocus: !1,
          header: t2("inputs.image.hotspot-dialog.title"),
          id: `${id2}_dialog`,
          onClickOutside: this.handleCloseDialog,
          onClose: this.handleCloseDialog,
          width: 1,
          children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 5, children: withImageTool && (value == null ? void 0 : value.asset) && /* @__PURE__ */ jsxRuntime.jsx(
            ImageToolInput,
            {
              ...this.props,
              imageUrl: imageUrlBuilder2.image(value.asset).url(),
              value,
              presence: hotspotInputProps.presence,
              changed
            }
          ) }) })
        }
      );
    }, this.renderPreview = () => {
      const { value, schemaType, readOnly, directUploads, imageUrlBuilder: imageUrlBuilder2, t: t2, resolveUploader: resolveUploader2 } = this.props;
      if (!value || !assetUtils.isImageSource(value))
        return null;
      const { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, imageUrl = imageUrlBuilder2.width(2e3).fit("max").image(value).dpr(getDevicePixelRatio()).auto("format").url();
      return /* @__PURE__ */ jsxRuntime.jsx(
        ImagePreview$1,
        {
          onDoubleClick: this.handleOpenDialog,
          drag: !(value != null && value._upload) && hoveringFiles.length > 0,
          isRejected: rejectedFilesCount > 0 || !directUploads,
          readOnly,
          src: imageUrl,
          alt: t2("inputs.image.preview-uploaded-image")
        }
      );
    }, this.setToast = (toast) => {
      this.toast = toast;
    }, this._assetPath = props2.path.concat(ASSET_FIELD_PATH);
  }
  isImageToolEnabled() {
    return get__default.default(this.props.schemaType, "options.hotspot") === !0;
  }
  clearUploadStatus() {
    var _a2;
    (_a2 = this.props.value) != null && _a2._upload && this.props.onChange(unset(["_upload"]));
  }
  cancelUpload() {
    this.uploadSubscription && (this.uploadSubscription.unsubscribe(), this.clearUploadStatus());
  }
  uploadFirstAccepted(files) {
    const { schemaType, resolveUploader: resolveUploader2 } = this.props, match = files.map((file) => ({ file, uploader: resolveUploader2(schemaType, file) })).find((result) => result.uploader);
    match && this.uploadWith(match.uploader, match.file), this.setState({ isMenuOpen: !1 });
  }
  renderAssetMenu() {
    const {
      value,
      assetSources,
      schemaType,
      readOnly,
      directUploads,
      imageUrlBuilder: imageUrlBuilder2,
      observeAsset,
      t: t2
    } = this.props, asset = value == null ? void 0 : value.asset;
    if (!asset)
      return null;
    const accept = get__default.default(schemaType, "options.accept", "image/*"), showAdvancedEditButton = value && asset && this.isImageToolEnabled();
    let browseMenuItem = assetSources && assetSources.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        icon: icons.SearchIcon,
        text: t2("inputs.image.browse-menu.text"),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSources[0]);
        },
        disabled: readOnly,
        "data-testid": "file-input-browse-button"
      }
    );
    return assetSources && assetSources.length > 1 && (browseMenuItem = assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSource);
        },
        icon: assetSource.icon || icons.ImageIcon,
        "data-testid": `file-input-browse-button-${assetSource.name}`,
        disabled: readOnly
      },
      assetSource.name
    ))), /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference: asset, children: ({ _id, originalFilename, extension }) => {
      let copyUrl, downloadUrl;
      if (assetUtils.isImageSource(value)) {
        const filename = originalFilename || `download.${extension}`;
        downloadUrl = imageUrlBuilder2.image(_id).forceDownload(filename).url(), copyUrl = imageUrlBuilder2.image(_id).url();
      }
      return /* @__PURE__ */ jsxRuntime.jsx(
        ImageActionsMenu,
        {
          isMenuOpen: this.state.isMenuOpen,
          onEdit: this.handleOpenDialog,
          onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }),
          setHotspotButtonElement: this.setHotspotButtonElement,
          setMenuButtonElement: this.setMenuButtonElement,
          showEdit: showAdvancedEditButton,
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ActionsMenu,
            {
              onUpload: this.handleSelectFiles,
              browse: browseMenuItem,
              onReset: this.handleRemoveButtonClick,
              downloadUrl,
              copyUrl,
              readOnly,
              directUploads,
              accept
            }
          )
        }
      );
    } });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id2, t: t2 } = this.props;
    return assetSources && assetSources.length === 0 ? null : assetSources && assetSources.length > 1 && !readOnly && directUploads ? /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        id: `${id2}_assetImageButton`,
        ref: this.setMenuButtonElement,
        button: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            "data-testid": "file-input-multi-browse-button",
            icon: icons.SearchIcon,
            iconRight: icons.ChevronDownIcon,
            mode: "bleed",
            text: t2("inputs.image.browse-menu.text")
          }
        ),
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
            onClick: () => {
              this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSource);
            },
            icon: assetSource.icon || icons.ImageIcon,
            disabled: readOnly,
            "data-testid": `file-input-browse-button-${assetSource.name}`
          },
          assetSource.name
        )) }),
        popover: ASSET_IMAGE_MENU_POPOVER
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        text: t2("inputs.image.browse-menu.text"),
        icon: icons.SearchIcon,
        mode: "bleed",
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSources[0]);
        },
        "data-testid": "file-input-browse-button",
        disabled: readOnly
      }
    );
  }
  renderUploadPlaceholder() {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, accept = get__default.default(schemaType, "options.accept", "image/*");
    return /* @__PURE__ */ jsxRuntime.jsx("div", { style: { padding: 1 }, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        tone: readOnly ? "transparent" : "inherit",
        border: !0,
        paddingX: 3,
        paddingY: 2,
        radius: 2,
        style: hoveringFiles.length === 0 ? {} : { borderColor: "transparent" },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          UploadPlaceholder,
          {
            browse: this.renderBrowser(),
            onUpload: this.handleSelectFiles,
            readOnly,
            hoveringFiles,
            acceptedFiles,
            rejectedFilesCount,
            type: "image",
            accept,
            directUploads
          }
        )
      }
    ) });
  }
  renderUploadState(uploadState) {
    var _a2;
    const { isUploading } = this.state, height = (_a2 = this._previewElement) == null ? void 0 : _a2.offsetHeight;
    return /* @__PURE__ */ jsxRuntime.jsx(
      UploadProgress,
      {
        uploadState,
        onCancel: isUploading ? this.handleCancelUpload : void 0,
        onStale: this.handleStaleUpload,
        height
      }
    );
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state, { value, schemaType, observeAsset } = this.props, accept = get__default.default(schemaType, "options.accept", "image/*");
    if (!selectedAssetSource)
      return null;
    const Component = selectedAssetSource.component;
    return value && value.asset ? /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference: value.asset, children: (imageAsset2) => /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [imageAsset2],
        assetType: "image",
        accept,
        selectionType: "single",
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    ) }) : /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [],
        selectionType: "single",
        assetType: "image",
        accept,
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    );
  }
  getFileTone() {
    const { schemaType, value, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return hoveringFiles.length > 0 && (rejectedFilesCount > 0 || !directUploads) ? "critical" : !(value != null && value._upload) && !readOnly && hoveringFiles.length > 0 ? "primary" : readOnly || value != null && value._upload && value != null && value.asset ? "transparent" : "default";
  }
  renderAsset() {
    const { value, readOnly, elementProps } = this.props, { hoveringFiles, isStale } = this.state, hasValueOrUpload = !!(value != null && value._upload || value != null && value.asset);
    return value && typeof value.asset < "u" && !(value != null && value._upload) && !assetUtils.isImageSource(value) ? () => /* @__PURE__ */ jsxRuntime.jsx(InvalidImageWarning, { onClearValue: this.handleClearField }) : (inputProps) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      isStale && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(UploadWarning, { onClearStale: this.handleClearUploadState }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        ChangeIndicator,
        {
          path: inputProps.path.concat(ASSET_FIELD_PATH),
          hasFocus: !!inputProps.focused,
          isChanged: inputProps.changed,
          children: value != null && value._upload ? this.renderUploadState(value._upload) : /* @__PURE__ */ jsxRuntime.jsxs(
            FileTarget,
            {
              ...elementProps,
              onFocus: this.handleFileTargetFocus,
              tabIndex: 0,
              disabled: !!readOnly,
              onFiles: this.handleSelectFiles,
              onFilesOver: this.handleFilesOver,
              onFilesOut: this.handleFilesOut,
              tone: this.getFileTone(),
              $border: hasValueOrUpload || hoveringFiles.length > 0,
              sizing: "border",
              radius: 2,
              children: [
                !(value != null && value.asset) && this.renderUploadPlaceholder(),
                !(value != null && value._upload) && (value == null ? void 0 : value.asset) && /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { position: "relative" }, ref: this.setPreviewElement, children: [
                  this.renderPreview(),
                  this.renderAssetMenu()
                ] })
              ]
            }
          )
        }
      )
    ] });
  }
  render() {
    const {
      focusPath,
      members,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    } = this.props, { selectedAssetSource } = this.state, hotspotField = members.find(
      (member) => member.kind === "field" && member.name === "hotspot"
    );
    return (
      // The Stack space should match the space in ObjectInput
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, "data-testid": "image-input", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ImperativeToast, { ref: this.setToast }),
        members.map((member) => member.kind === "field" && (member.name === "crop" || member.name === "hotspot") ? null : member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
          MemberField,
          {
            member,
            renderAnnotation,
            renderBlock,
            renderInlineBlock,
            renderInput: member.name === "asset" ? this.renderAsset() : renderInput,
            renderField: member.name === "asset" ? passThrough : renderField,
            renderItem,
            renderPreview
          },
          member.key
        ) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
          MemberFieldSet,
          {
            member,
            renderAnnotation,
            renderBlock,
            renderField,
            renderInlineBlock,
            renderInput,
            renderItem,
            renderPreview
          },
          member.key
        ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t("inputs.image.error.unknown-member-kind", { kind: member.kind }) })),
        hotspotField && focusPath[0] === "hotspot" && /* @__PURE__ */ jsxRuntime.jsx(
          FormInput,
          {
            ...this.props,
            absolutePath: hotspotField.field.path,
            renderInput: this.renderHotspotInput
          }
        ),
        selectedAssetSource && this.renderAssetSource()
      ] })
    );
  }
}
function StudioImageInput(props2) {
  var _a2;
  const sourcesFromSchema = (_a2 = props2.schemaType.options) == null ? void 0 : _a2.sources, { image } = useFormBuilder().__internal, documentPreviewStore = useDocumentPreviewStore(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), supportsImageUploads = image.directUploads, resolveUploader$1 = React.useCallback(
    (type, file) => supportsImageUploads ? resolveUploader(type, file) : null,
    [supportsImageUploads]
  ), assetSources = React.useMemo(
    () => sourcesFromSchema || image.assetSources,
    [image, sourcesFromSchema]
  ), builder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), observeAsset = React.useCallback(
    (id2) => observeImageAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    BaseImageInput,
    {
      ...props2,
      t: t2,
      client: client2,
      assetSources,
      directUploads: supportsImageUploads,
      imageUrlBuilder: builder,
      observeAsset,
      resolveUploader: resolveUploader$1
    }
  );
}
const defaultInputs = {
  document: ObjectInput,
  object: ObjectInput,
  array: UniversalArrayInput,
  boolean: BooleanInput,
  number: NumberInput,
  text: TextInput,
  email: EmailInput,
  datetime: DateTimeInput,
  date: DateInput,
  url: UrlInput,
  image: StudioImageInput,
  file: StudioFileInput,
  string: StringInput,
  slug: SlugInput,
  crossDatasetReference: StudioCrossDatasetReferenceInput
}, PortableTextInputExpanded = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Expanded",
  description: "The portable text editor was expanded"
}), PortableTextInputCollapsed = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Collapsed",
  description: "The portable text editor was collapsed"
}), PortableTextInvalidValueIgnore = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Invalid Value Ignored",
  description: "The portable text got an invalid value from the form and pressed button to ignore it"
}), PortableTextInvalidValueResolve = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Invalid Value Resolved",
  description: "The portable text got an invalid value from the form and pressed button to resolve it."
}), OverlayContainer = styled__default.default.div`
  position: relative;
`, ContentContainer = styled__default.default.div`
  z-index: 13;
  opacity: 0;
  transition: opacity 300ms linear;
`, CardContainer = styled__default.default(ui.Card)`
  border: 1px solid var(--card-border-color);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 12;
  transition: opacity 150ms ease-in-out;
  opacity: 0;
  box-sizing: border-box;
`, FlexContainer = styled__default.default(ui.Flex)`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  &:hover,
  &:focus {
    & ${CardContainer} {
      opacity: 0.9;
    }

    & ${ContentContainer} {
      opacity: 1;
    }
  }
`, isTouchDevice = () => typeof window < "u" && "ontouchstart" in window || typeof navigator < "u" && navigator.maxTouchPoints > 0;
function ActivateOnFocus(props2) {
  const { children, message, onActivate, isOverlayActive } = props2, [focused, setFocused] = React.useState(!1), { t: t2 } = useTranslation(), handleClick = React.useCallback(() => {
    onActivate && onActivate();
  }, [onActivate]), handleKeyDown = React.useCallback(
    (event) => {
      isOverlayActive && event.code === "Space" && onActivate && (event.preventDefault(), onActivate());
    },
    [isOverlayActive, onActivate]
  ), handleOnFocus = React.useCallback(() => {
    setFocused(!0);
  }, []), handleBlur = React.useCallback(() => {
    setFocused(!1);
  }, []), msg = React.useMemo(() => {
    const isTouch = isTouchDevice();
    let messageContext;
    isTouch ? messageContext = "tap" : focused ? messageContext = "click-focused" : messageContext = "click";
    const text = message || t2("inputs.portable-text.activate-on-focus-message", {
      context: messageContext
    });
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: text });
  }, [focused, message, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    OverlayContainer,
    {
      onBlur: handleBlur,
      onClick: handleClick,
      onFocus: handleOnFocus,
      onKeyDown: handleKeyDown,
      children: [
        isOverlayActive && /* @__PURE__ */ jsxRuntime.jsxs(FlexContainer, { "data-testid": "activate-overlay", tabIndex: 0, align: "center", justify: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            CardContainer,
            {
              radius: 2
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ContentContainer, { children: msg })
        ] }),
        children
      ]
    }
  );
}
const Root$e = styled__default.default.div((props2) => {
  const { color: color2, input, radius } = theme.getTheme_v2(props2.theme), border = {
    color: color2.input.default.enabled.border,
    width: input.border.width
  };
  return styled.css`
    --input-box-shadow: ${focusRingBorderStyle$1(border)};

    position: relative;

    & [data-wrapper] {
      overflow: hidden;
      overflow: clip;
      position: relative;
      z-index: 1;
      padding: ${input.border.width}px;
    }

    & [data-border] {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      box-shadow: var(--input-box-shadow);
      z-index: 2;
      border-radius: ${radius[2]}px;
      pointer-events: none;
    }

    &:not([data-read-only])[data-focused] [data-border] {
      --input-box-shadow: ${focusRingStyle$1({
    base: color2,
    border,
    focusRing: input.text.focusRing
  })};
    }
  `;
}), ExpandedLayer = styled__default.default(ui.Layer)`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`, TEXT_LEVELS = [1, 2, 3, 4, 5, 6, 7, 8, 9], TEXT_BULLET_MARKERS = ["\u25CF", "\u25CB", "\u25A0"], TEXT_NUMBER_FORMATS = ["number", "lower-alpha", "lower-roman"], TEXT_DECORATOR_TAGS = {
  em: "em",
  "strike-through": "s",
  underline: "u",
  strong: "strong",
  code: "code"
}, TEXT_STYLE_PADDING = {
  h1: {
    paddingTop: 5,
    paddingBottom: 4
  },
  h2: {
    paddingTop: 4,
    paddingBottom: 4
  },
  h3: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h4: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h5: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h6: {
    paddingTop: 4,
    paddingBottom: 2
  },
  normal: {
    paddingTop: 2,
    paddingBottom: 3
  },
  blockquote: {
    paddingTop: 2,
    paddingBottom: 3
  }
}, Root$d = styled__default.default.span`
  /* Make sure the annotation styling is visible */
  &[data-mark='code'] {
    mix-blend-mode: multiply;
    color: inherit;
  }
`;
function Decorator(props2) {
  const { value, focused, selected, children, schemaType } = props2, tag = TEXT_DECORATOR_TAGS[value], CustomComponent = schemaType.component, DefaultComponent2 = React.useCallback(
    (defaultComponentProps) => /* @__PURE__ */ jsxRuntime.jsx(Root$d, { as: tag, "data-mark": value, children: defaultComponentProps.children }),
    [tag, value]
  );
  return React.useMemo(() => {
    const componentProps = {
      focused,
      renderDefault: DefaultComponent2,
      schemaType,
      selected,
      title: schemaType.title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent2, { ...componentProps, children });
  }, [CustomComponent, DefaultComponent2, children, focused, schemaType, selected, value]);
}
function createListName(level) {
  return `list-level-${level}`;
}
const ReviewChangesHighlightBlock = styled__default.default.div(({ theme: theme2 }) => {
  const { radius, space, color: color2 } = theme2.sanity, bg = ui.rgba(color2.spot.yellow, 0.2);
  return styled.css`
    position: absolute;
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    bottom: -${space[1] + space[1]}px;
    left: ${space[4] + space[1]}px;
    right: 0;
    background-color: ${bg};
  `;
}), StyledChangeIndicatorWithProvidedFullPath = styled__default.default(ChangeIndicator)(() => styled.css`
    width: 1px;
    height: 100%;

    & > div {
      height: 100%;
    }
  `);
function createInsertCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  let toInsert;
  return (givenBlock) => {
    toInsert = Array.isArray(givenBlock) ? givenBlock : [givenBlock], toInsert = toInsert.map(
      (blk) => blockTools.normalizeBlock(blk, {
        allowedDecorators
      })
    );
    const patches = [insert(toInsert, "after", [{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
function createSetCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  return (givenBlock) => {
    const patches = [
      set(
        blockTools.normalizeBlock(givenBlock, {
          allowedDecorators
        }),
        [{ _key: block._key }]
      )
    ];
    return onChange(PatchEvent.from(patches));
  };
}
function createUnsetCallback(options) {
  const { block, onChange } = options;
  return () => {
    const patches = [unset([{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
const Root$c = styled__default.default.div`
  display: flex;
  pointer-events: all;
`;
function BlockActions(props2) {
  const editor2 = portableTextEditor.usePortableTextEditor(), { block, onChange, renderBlockActions } = props2, decoratorValues = React.useMemo(() => editor2.schemaTypes.decorators.map((d) => d.value), [editor2]), blockActions = React.useMemo(() => {
    if (renderBlockActions) {
      const blockActionProps = {
        block,
        value: portableTextEditor.PortableTextEditor.getValue(editor2),
        set: createSetCallback({ allowedDecorators: decoratorValues, block, onChange }),
        unset: createUnsetCallback({ block, onChange }),
        insert: createInsertCallback({ allowedDecorators: decoratorValues, block, onChange })
      };
      return renderBlockActions(blockActionProps);
    }
  }, [renderBlockActions, block, editor2, onChange, decoratorValues]);
  return blockActions ? /* @__PURE__ */ jsxRuntime.jsx(Root$c, { contentEditable: !1, children: blockActions }) : null;
}
function textBlockStyle(props2) {
  const { $level } = props2, { color: color$1, font, radius, space } = theme.getTheme_v2(props2.theme), numberMarker = TEXT_NUMBER_FORMATS[($level - 1) % TEXT_NUMBER_FORMATS.length], bulletMarker = TEXT_BULLET_MARKERS[($level - 1) % TEXT_BULLET_MARKERS.length];
  return styled.css`
    --marker-bg-color: transparent;

    mix-blend-mode: ${color$1._dark ? "screen" : "multiply"};
    position: relative;

    & > [data-ui='TextBlock_inner'] {
      position: relative;
      flex: 1;
    }

    & > div:before {
      content: '';
      position: absolute;
      top: -${space[1]}px;
      bottom: -${space[1]}px;
      left: -${space[1]}px;
      right: -${space[1]}px;
      border-radius: ${radius[2]}px;
      background-color: var(--marker-bg-color);
      // This is to make sure the marker is always behind the text
      z-index: -1;
    }

    &[data-markers] {
      --marker-bg-color: ${color$1._dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
    }

    &[data-warning] {
      --card-border-color: ${color$1.button.ghost.caution.enabled.border};
      --marker-bg-color: ${color$1.button.ghost.caution.hovered.bg};
    }

    &[data-error] {
      --card-border-color: ${color$1.button.ghost.critical.enabled.border};
      --marker-bg-color: ${color$1.button.ghost.critical.hovered.bg};
    }

    & [data-list-prefix] {
      position: absolute;
      margin-left: -4.5rem;
      width: 3.75rem;
      text-align: right;
      box-sizing: border-box;
    }

    &[data-list-item='number'] [data-list-prefix] {
      font-variant-numeric: tabular-nums;

      & > span:before {
        content: counter(${createListName($level)}) '.';
        content: counter(${createListName($level)}, ${numberMarker}) '.';
      }
    }

    &[data-list-item='bullet'] [data-list-prefix] {
      & > span {
        position: relative;
        top: -0.1875em;

        &:before {
          content: '${bulletMarker}';
          font-size: 0.46666em;
        }
      }
    }

    & [data-text] {
      overflow-wrap: anywhere;
      text-transform: none;
      white-space: pre-wrap;
      font-family: ${font.text.family};
      flex: 1;

      *::selection {
        background-color: ${theme.rgba(color$1.focusRing, 0.3)};
      }
    }
  `;
}
const TextRoot = styled__default.default.div(textBlockStyle), TextBlockFlexWrapper = styled__default.default(ui.Box)`
  position: relative;
  display: flex;
`, ListPrefixWrapper = styled__default.default.div`
  user-select: none;
  white-space: nowrap;
`, BlockExtrasContainer = styled__default.default(ui.Box)`
  user-select: none;
`, BlockActionsOuter$1 = styled__default.default(ui.Box)`
  line-height: 0;
  width: 25px;
  position: relative;
`, BlockActionsInner$1 = styled__default.default(ui.Flex)(({ theme: theme2 }) => {
  const { fonts, space } = theme2.sanity, textSize1 = fonts.text.sizes[1], textSize2 = fonts.text.sizes[2], capHeight1 = textSize1.lineHeight - textSize1.ascenderHeight - textSize1.descenderHeight, capHeight2 = textSize2.lineHeight - textSize2.ascenderHeight - textSize2.descenderHeight, negativeTop = 0 - (capHeight1 + space[2] + space[2] - capHeight2) / 2;
  return styled.css`
    user-select: none;
    position: absolute;
    right: 0;
    top: ${negativeTop}px;
  `;
}), TooltipBox$2 = styled__default.default(ui.Box)`
  max-width: 250px;
`, TextFlex = styled__default.default(ui.Flex)`
  position: relative;
  padding-left: ${({ $level }) => $level ? $level * 32 : 0}px;
`, ChangeIndicatorWrapper$1 = styled__default.default.div(
  ({ theme: theme2, $hasChanges }) => {
    const { space } = theme2.sanity;
    return styled.css`
      position: absolute;
      width: ${space[2]}px;
      right: 0;
      top: 0;
      bottom: 0;
      padding-left: ${space[1]}px;
      user-select: none;

      ${!$hasChanges && styled.css`
        display: none;
      `}
    `;
  }
), TextContainer = styled__default.default.div`
  display: block;
`, Normal = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { "data-testid": "text-style--normal", ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading1 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", "data-testid": "text-style--h1", size: 5, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading2 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h2", "data-testid": "text-style--h2", size: 4, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading3 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h3", "data-testid": "text-style--h3", size: 3, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading4 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h4", "data-testid": "text-style--h4", size: 2, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading5 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h5", "data-testid": "text-style--h5", size: 1, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading6 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h6", "data-testid": "text-style--h6", size: 0, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), BlockQuoteRoot = styled__default.default.blockquote`
  position: relative;
  display: block;
  margin: 0;
  padding-left: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: -4px;
    bottom: -4px;
    width: 3px;
    background: var(--card-border-color);
  }
`, BlockQuote = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(BlockQuoteRoot, { "data-testid": "text-style--blockquote", ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children }) }), TEXT_STYLES = {
  normal: Normal,
  h1: Heading1,
  h2: Heading2,
  h3: Heading3,
  h4: Heading4,
  h5: Heading5,
  h6: Heading6,
  blockquote: BlockQuote
};
function TextBlock(props2) {
  const {
    children,
    floatingBoundary,
    focused,
    isFullscreen,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    renderBlock,
    renderAnnotation,
    renderBlockActions,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    selected,
    spellCheck,
    value
  } = props2, { Markers } = useFormBuilder().__internal.components, [reviewChangesHovered, setReviewChangesHovered] = React.useState(!1), markers = usePortableTextMarkers(path), memberItem = usePortableTextMemberItem(pathToString$1(path)), editor2 = portableTextEditor.usePortableTextEditor(), { onChange } = useFormCallbacks(), presence = useChildPresence(path, !0), textPresence = React.useMemo(() => presence.filter(
    (p) => PathUtils.isEqual(p.path, path) || p.path.slice(-3)[1] === "children" && p.path.length - path.length === 2
  ), [path, presence]), handleChangeIndicatorMouseEnter = React.useCallback(() => setReviewChangesHovered(!0), []), handleChangeIndicatorMouseLeave = React.useCallback(() => setReviewChangesHovered(!1), []), { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), hasMarkers = !!renderCustomMarkers && markers.length > 0, tooltipEnabled = hasError || hasWarning || hasMarkers || hasInfo, onOpen = React.useCallback(() => {
    memberItem && onItemOpen(memberItem.node.path);
  }, [onItemOpen, memberItem]), onRemove = React.useCallback(() => {
    const point = { path: path.slice(-1), offset: 0 }, sel = {
      focus: point,
      anchor: point
    };
    portableTextEditor.PortableTextEditor.delete(editor2, sel, { mode: "blocks" }), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [path, editor2]), text = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsxs(TextFlex, { align: "flex-start", $level: value == null ? void 0 : value.level, children: [
    value.listItem && /* @__PURE__ */ jsxRuntime.jsx(ListPrefixWrapper, { contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { "data-list-prefix": "", children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { "data-text": "", style: void 0, children })
  ] }), [value.listItem, value.level, children]), innerPaddingProps = React.useMemo(() => isFullscreen && !renderBlockActions ? { paddingX: 5 } : isFullscreen && renderBlockActions ? { paddingLeft: 5, paddingRight: 2 } : renderBlockActions ? {
    paddingLeft: 3,
    paddingRight: 2
  } : { paddingX: 3 }, [isFullscreen, renderBlockActions]), outerPaddingProps = React.useMemo(() => value.listItem ? { paddingY: 2 } : TEXT_STYLE_PADDING[value.style || "normal"] || { paddingY: 2 }, [value]), isOpen = !!(memberItem != null && memberItem.member.open), parentSchemaType = editor2.schemaTypes.portableText, componentProps = React.useMemo(
    () => {
      var _a2;
      return {
        __unstable_floatingBoundary: floatingBoundary,
        __unstable_referenceBoundary: referenceBoundary,
        __unstable_referenceElement: ((_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current) || null,
        children: text,
        focused,
        markers,
        onClose: onItemClose,
        onOpen,
        onPathFocus,
        onRemove,
        open: isOpen,
        parentSchemaType,
        path: (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b,
        presence: textPresence,
        readOnly: !!readOnly,
        renderAnnotation,
        renderBlock,
        renderDefault: DefaultComponent$1,
        renderField,
        renderInput,
        renderInlineBlock,
        renderItem,
        renderPreview,
        schemaType,
        selected,
        validation: validation2,
        value
      };
    },
    [
      floatingBoundary,
      focused,
      isOpen,
      markers,
      memberItem == null ? void 0 : memberItem.elementRef,
      memberItem == null ? void 0 : memberItem.node.path,
      onItemClose,
      onOpen,
      onPathFocus,
      onRemove,
      parentSchemaType,
      readOnly,
      referenceBoundary,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      selected,
      text,
      textPresence,
      validation2,
      value
    ]
  ), toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$2, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        renderCustomMarkers,
        validation: validation2
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ui.Box,
      {
        "data-testid": "text-block",
        ...outerPaddingProps,
        style: void 0,
        ref: memberItem == null ? void 0 : memberItem.elementRef,
        children: /* @__PURE__ */ jsxRuntime.jsx(TextBlockFlexWrapper, { "data-testid": "text-block__wrapper", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, ...innerPaddingProps, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Tooltip,
            {
              content: toolTipContent,
              disabled: !tooltipEnabled,
              placement: "top",
              portal: "editor",
              children: /* @__PURE__ */ jsxRuntime.jsx(
                TextRoot,
                {
                  $level: value.level || 1,
                  "data-error": hasError ? "" : void 0,
                  "data-list-item": value.listItem,
                  "data-markers": hasMarkers ? "" : void 0,
                  "data-read-only": readOnly,
                  "data-testid": "text-block__text",
                  "data-warning": hasWarning ? "" : void 0,
                  spellCheck,
                  children: renderBlock && renderBlock(componentProps)
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsxs(BlockExtrasContainer, { contentEditable: !1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(BlockActionsOuter$1, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockActionsInner$1, { children: renderBlockActions && focused && !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
              BlockActions,
              {
                onChange,
                block: value,
                renderBlockActions
              }
            ) }) }),
            isFullscreen && memberItem && /* @__PURE__ */ jsxRuntime.jsx(
              ChangeIndicatorWrapper$1,
              {
                $hasChanges: memberItem.member.item.changed,
                onMouseEnter: handleChangeIndicatorMouseEnter,
                onMouseLeave: handleChangeIndicatorMouseLeave,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  StyledChangeIndicatorWithProvidedFullPath,
                  {
                    hasFocus: focused,
                    isChanged: memberItem.member.item.changed,
                    path: memberItem.member.item.path,
                    withHoverEffect: !1
                  }
                )
              }
            )
          ] }),
          reviewChangesHovered && /* @__PURE__ */ jsxRuntime.jsx(ReviewChangesHighlightBlock, {})
        ] }) })
      }
    ),
    [
      componentProps,
      focused,
      handleChangeIndicatorMouseEnter,
      handleChangeIndicatorMouseLeave,
      hasError,
      hasMarkers,
      hasWarning,
      innerPaddingProps,
      isFullscreen,
      memberItem,
      onChange,
      outerPaddingProps,
      readOnly,
      renderBlock,
      renderBlockActions,
      reviewChangesHovered,
      spellCheck,
      toolTipContent,
      tooltipEnabled,
      value
    ]
  );
}
const DefaultComponent$1 = (props2) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: props2.children }), Root$b = styled__default.default(ui.Card)`
  height: ${({ $fullscreen }) => $fullscreen ? "100%" : "15em"};

  &:not([hidden]) {
    display: flex;
  }

  flex-direction: column;
`, ToolbarCard = styled__default.default(ui.Card)`
  z-index: 10;
  line-height: 0;
`, EditableCard = styled__default.default(ui.Card)`
  position: relative;
  overflow: hidden;
  overflow: clip;

  & > [data-portal] {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;

    & > * {
      pointer-events: initial;
    }
  }

  &::selection,
  *::selection {
    background-color: transparent;
  }
`, Scroller = styled__default.default(ScrollContainer)`
  position: relative;
  overflow: auto;
  height: 100%;
  display: flex;
  flex-direction: column;

  & > * {
    flex: 1;
    min-height: auto;
  }
`, EditableContainer = styled__default.default(ui.Container)`
  /* @todo: calculate from theme */
  /* max-width: 728px; */
`, EditableWrapper = styled__default.default(ui.Card)`
  height: 100%;
  width: 100%;
  counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
  overflow: hidden;
  overflow: clip;

  & > div {
    height: 100%;
  }

  & .pt-editable {
    display: block;
    width: 100%;
    height: 100%;

    ${TEXT_LEVELS.map((l) => styled.css`
        & > .pt-list-item-number[class~='pt-list-item-level-${l}'] {
          counter-increment: ${createListName(l)};
        }
      `)}

    & > .pt-list-item-bullet + .pt-list-item-number,
    & > .pt-list-item-number + .pt-list-item-bullet {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;
      counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
    }

    & > :not(.pt-list-item) + .pt-list-item {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[2]}px;
    }

    /* Reset the list count if the element is not a numbered list item */
    & > :not(.pt-list-item-number) {
      counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
    }

    ${TEXT_LEVELS.slice(1).map((l) => styled.css`
        & > .pt-list-item-level-${l} + .pt-list-item-level-${l - 1} {
          counter-reset: ${createListName(l)};
        }
      `)}

    & > .pt-list-item + :not(.pt-list-item) {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;
    }

    & > :first-child {
      padding-top: ${({ $isFullscreen, theme: theme2 }) => theme2.sanity.space[$isFullscreen ? 5 : 3]}px;
    }

    & > :last-child {
      padding-bottom: ${({ $isFullscreen, theme: theme2 }) => theme2.sanity.space[$isFullscreen ? 9 : 5]}px;
    }

    /* & > .pt-block {
      & .pt-inline-object {
      }
    } */

    & .pt-drop-indicator {
      pointer-events: none;
      border: 1px solid var(--card-focus-ring-color) !important;
      height: 0px !important;
      border-radius: ${(props2) => theme.getTheme_v2(props2.theme).radius[2]}px;
      margin-top: -3px;
      left: calc(
        ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5]) : ui.rem(theme2.sanity.space[3])} - 1px
      );
      right: calc(
        ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5]) : ui.rem(theme2.sanity.space[3])} - 1px
      );
      width: calc(
        100% -
          ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5] * 2) : ui.rem(theme2.sanity.space[3] * 2)} + 2px
      ) !important;
    }
  }
`;
function useScrollSelectionIntoView(scrollElement) {
  return React.useMemo(
    () => (editor2, domRange) => {
      if (portableTextEditor.PortableTextEditor.getSelection(editor2)) {
        const leafEl = domRange.startContainer.parentElement;
        if (!leafEl)
          return;
        scrollIntoView__default.default(leafEl, {
          scrollMode: "if-needed",
          boundary: scrollElement,
          block: "start",
          inline: "nearest"
        });
      }
    },
    [scrollElement]
  );
}
function useSpellcheck() {
  const editor2 = portableTextEditor.usePortableTextEditor();
  return React.useMemo(() => {
    var _a2;
    const spellCheckOption = (_a2 = editor2.schemaTypes.block.options) == null ? void 0 : _a2.spellCheck, isChrome96 = typeof navigator > "u" ? !1 : /Chrome\/96/.test(navigator.userAgent);
    return spellCheckOption === void 0 && isChrome96 === !0 ? !1 : spellCheckOption;
  }, [editor2]);
}
const DefaultComponent = (dProps) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: dProps.children }), ListItem$1 = (props2) => {
  const { block, children, schemaType, selected, focused, level, value } = props2, { title, component: CustomComponent } = schemaType;
  return React.useMemo(() => {
    const componentProps = {
      block,
      focused,
      level,
      renderDefault: DefaultComponent,
      schemaType,
      selected,
      title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent, { ...componentProps, children });
  }, [CustomComponent, block, children, focused, level, schemaType, selected, title, value]);
}, Style = (props2) => {
  const { block, focused, children, selected, schemaType } = props2, DefaultComponentWithFallback = React.useMemo(
    () => (block.style && TEXT_STYLES[block.style] ? TEXT_STYLES[block.style] : TEXT_STYLES[0]) || Normal,
    [block.style]
  ), DefaultComponent2 = React.useCallback(
    (defaultComponentProps) => /* @__PURE__ */ jsxRuntime.jsx(DefaultComponentWithFallback, { children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { "data-testid": `text-style--${block.style}`, children: defaultComponentProps.children }) }),
    [DefaultComponentWithFallback, block.style]
  );
  return React.useMemo(() => {
    const CustomComponent = schemaType.component, { title, value } = schemaType, componentProps = {
      block,
      focused,
      renderDefault: DefaultComponent2,
      schemaType,
      selected,
      title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent2, { ...componentProps, children });
  }, [DefaultComponent2, block, children, focused, schemaType, selected]);
}, DividerDiv = styled__default.default.div`
  border-right: 1px solid var(--card-border-color);
  height: auto;

  &[data-hidden] {
    opacity: 0;
  }
`;
function CollapseMenuDivider(props2) {
  const { hidden, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(DividerDiv, { "data-ui": "CollapseMenuDivider", "data-hidden": hidden ? "" : void 0, ...rest });
}
const MENU_BUTTON_POPOVER_PROPS = {
  portal: !0,
  constrainSize: !0
}, CollapseOverflowMenu = React.forwardRef(function(props2, forwardedRef) {
  const { disableRestoreFocusOnClose, menuButton, menuButtonProps, menuOptions, onMenuClose } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose,
      id: "menu-button",
      ref: forwardedRef,
      onClose: onMenuClose,
      popover: MENU_BUTTON_POPOVER_PROPS,
      ...menuButtonProps,
      button: menuButton,
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: menuOptions.map((c, index) => {
        const {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          collapsedProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          expandedProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          tooltipProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          tooltipText,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          dividerBefore,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          fontSize,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          padding,
          text,
          icon,
          selected,
          ...rest
        } = c.props;
        return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
          dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuItem, { text, icon, pressed: selected, ...rest })
        ] }, c.key);
      }) })
    }
  );
});
function ObserveElement(props2) {
  const { onIntersectionChange, children, options, ...rest } = props2, [el, setEl] = React.useState(null);
  return React.useEffect(() => {
    if (!el)
      return;
    const io = new IntersectionObserver(onIntersectionChange, options);
    return io.observe(el), () => {
      io.unobserve(el), io.disconnect();
    };
  }, [el, onIntersectionChange, options]), /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { ref: setEl, ...rest, children });
}
const FOCUS_RING_PADDING = 3, OPTION_STYLE = styled.css`
  list-style: none;
  display: flex;
  white-space: nowrap;

  &[data-hidden='true'] {
    opacity: 0;
    visibility: hidden;
  }
`, OuterFlex = styled__default.default(ui.Flex)`
  padding: ${FOCUS_RING_PADDING}px;
  margin: -${FOCUS_RING_PADDING}px;
  box-sizing: border-box;
`, RootFlex$3 = styled__default.default(ui.Flex)`
  border-radius: inherit;
  position: relative;
`, RowFlex = styled__default.default(ui.Flex)`
  width: max-content;
  &[data-hidden='true'] {
    visibility: hidden;
    position: relative;
    margin-top: -1px;
    height: 1px;
  }
`, OptionObserveElement$1 = styled__default.default(ObserveElement)`
  ${OPTION_STYLE}
`;
function _isReactElement$1(node) {
  return !!node;
}
const CollapseMenu = React.forwardRef(function(props2, ref) {
  const { children, collapsed, disableRestoreFocusOnClose, onMenuClose, menuButtonProps, ...rest } = props2, menuOptions = React.useMemo(() => React.Children.toArray(children).filter(_isReactElement$1), [children]), menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  );
  return collapsed ? /* @__PURE__ */ jsxRuntime.jsx(
    CollapseOverflowMenu,
    {
      ref,
      disableRestoreFocusOnClose,
      menuButton,
      menuButtonProps,
      menuOptions,
      onMenuClose
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    AutoCollapseMenu,
    {
      ...rest,
      ref,
      disableRestoreFocusOnClose,
      menuButtonProps,
      menuOptions,
      onMenuClose
    }
  );
}), AutoCollapseMenu = React.forwardRef(function(props2, ref) {
  const {
    collapseText = !0,
    disableRestoreFocusOnClose,
    gap,
    menuOptions,
    menuButtonProps,
    onMenuClose,
    ...rest
  } = props2, [rootEl, setRootEl] = React.useState(null), [expandedIntersections, setExpandedIntersections] = React.useState({}), [collapsedIntersections, setCollapsedIntersections] = React.useState({}), intersectionOptions = React.useMemo(
    () => ({
      root: rootEl,
      // safari needs threshold to be < 1
      threshold: 0.99,
      rootMargin: "2px"
    }),
    [rootEl]
  ), menuOptionKeys = React.useMemo(() => menuOptions.map((child) => child.key), [menuOptions]), pendingIntersections = React.useMemo(
    () => [
      ...difference__default.default(menuOptionKeys, Object.keys(expandedIntersections)),
      ...difference__default.default(menuOptionKeys, Object.keys(collapsedIntersections))
    ],
    [menuOptionKeys, expandedIntersections, collapsedIntersections]
  ), overflowingExpandedElements = React.useMemo(
    () => menuOptions.filter((optionElement) => {
      const entry = expandedIntersections[optionElement.key];
      return entry && !entry.intersects;
    }),
    [expandedIntersections, menuOptions]
  ), handleExpandedIntersection = React.useCallback(
    (e, element) => {
      setExpandedIntersections((current) => {
        const key = element.key;
        if (key === null)
          throw new Error("Expected element to have a non-null key");
        const nextState = {
          intersects: e.isIntersecting,
          element
        }, currentState = current[key];
        return !currentState || currentState.intersects !== nextState.intersects ? {
          ...current,
          [key]: nextState
        } : current;
      });
    },
    []
  ), handleCollapsedIntersection = React.useCallback(
    (e, element) => {
      setCollapsedIntersections((current) => {
        const key = element.key;
        if (key === null)
          throw new Error("Expected child element to have a non-null key");
        const currentElementIntersection = current[key], nextElementIntersection = {
          intersects: e.isIntersecting,
          element
        };
        return (currentElementIntersection == null ? void 0 : currentElementIntersection.intersects) === nextElementIntersection.intersects ? current : {
          ...current,
          [key]: nextElementIntersection
        };
      });
    },
    []
  ), collapsedElements = React.useMemo(
    () => menuOptions.map((optionElement) => {
      const { collapsedProps } = optionElement.props, modeProps = collapsedProps, text = collapseText ? void 0 : optionElement.props.text;
      return React.cloneElement(optionElement, {
        ...modeProps,
        text
      });
    }),
    [menuOptions, collapseText]
  ), overflowingCollapsedOptionElements = React.useMemo(
    () => menuOptions.filter((optionElement) => {
      const intersection2 = collapsedIntersections[optionElement.key];
      return (intersection2 == null ? void 0 : intersection2.intersects) === !1;
    }),
    [menuOptions, collapsedIntersections]
  ), visibleMenuOptions = overflowingExpandedElements.length > 0 ? collapsedElements.filter((optionElement) => {
    const intersection2 = collapsedIntersections[optionElement.key];
    return (intersection2 == null ? void 0 : intersection2.intersects) === !0;
  }) : menuOptions, menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    OuterFlex,
    {
      align: "center",
      "data-ui": "CollapseMenu",
      overflow: "hidden",
      sizing: "border",
      ref,
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$3, { direction: "column", flex: 1, justify: "center", ref: setRootEl, children: [
          /* @__PURE__ */ jsxRuntime.jsx(RowFlex, { gap, children: pendingIntersections.length === 0 && visibleMenuOptions.map((optionElement, index) => {
            const { dividerBefore, tooltipText = "", tooltipProps = {} } = optionElement.props, hidden = !optionElement.key || !(optionElement.key in expandedIntersections) || overflowingCollapsedOptionElements.includes(optionElement);
            return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
              dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(CollapseMenuDivider, { hidden }),
              /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { portal: !0, disabled: !tooltipText, content: tooltipText, ...tooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: React.cloneElement(optionElement, {
                disabled: optionElement.props.disabled || hidden,
                "aria-hidden": hidden
              }) }) })
            ] }, optionElement.key);
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            RenderHidden,
            {
              gap,
              elements: menuOptions,
              intersectionOptions,
              onIntersectionChange: handleExpandedIntersection
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            RenderHidden,
            {
              gap,
              elements: collapsedElements,
              intersectionOptions,
              onIntersectionChange: handleCollapsedIntersection
            }
          )
        ] }),
        overflowingCollapsedOptionElements.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { marginLeft: gap, children: /* @__PURE__ */ jsxRuntime.jsx(
          CollapseOverflowMenu,
          {
            disableRestoreFocusOnClose,
            menuButton,
            menuButtonProps,
            menuOptions: overflowingCollapsedOptionElements,
            onMenuClose
          }
        ) })
      ]
    }
  );
}), RenderHidden = React.memo(function(props2) {
  const { elements, gap, intersectionOptions, onIntersectionChange } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(RowFlex, { "data-hidden": !0, "aria-hidden": "true", gap, overflow: "hidden", children: elements.map((element, index) => {
    const { dividerBefore } = element.props;
    return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(CollapseMenuDivider, { hidden: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(
        OptionObserveElement$1,
        {
          options: intersectionOptions,
          onIntersectionChange: (e) => onIntersectionChange(e[0], element),
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: React.cloneElement(element, {
            disabled: !0,
            "aria-hidden": !0
          }) })
        }
      )
    ] }, element.key);
  }) });
}), CollapseMenuButton = React.forwardRef(function(props2, ref) {
  const {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapsedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    expandedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipText,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dividerBefore,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ...rest
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { "data-ui": "CollapseMenuButton", ...rest, ref });
}), CustomIconDiv = styled__default.default.div`
  width: 1em;
  height: 1em;
  border-radius: inherit;
  background-origin: content-box;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  transform: scale(0.7);
`;
function CustomIcon(props2) {
  const { icon, active } = props2, inlineStyle = React.useMemo(
    () => ({
      backgroundImage: `url(${icon})`,
      filter: active ? "invert(100%)" : "invert(0%)"
    }),
    [active, icon]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CustomIconDiv, { style: inlineStyle });
}
function getPTEFormatActions(editor2, disabled, hotkeyOpts, t2) {
  return editor2.schemaTypes.decorators.map((decorator) => {
    const shortCutKey = Object.keys(hotkeyOpts.marks || {}).find(
      (key) => {
        var _a2;
        return ((_a2 = hotkeyOpts.marks) == null ? void 0 : _a2[key]) === decorator.value;
      }
    );
    let hotkeys = [];
    return shortCutKey && (hotkeys = [shortCutKey]), {
      type: "format",
      disabled,
      icon: decorator == null ? void 0 : decorator.icon,
      key: decorator.value,
      handle: () => {
        portableTextEditor.PortableTextEditor.toggleMark(editor2, decorator.value), portableTextEditor.PortableTextEditor.focus(editor2);
      },
      hotkeys,
      title: decorator.i18nTitleKey && t2 ? t2(decorator.i18nTitleKey) : decorator.title
    };
  });
}
function getPTEListActions(editor2, disabled, t2) {
  return editor2.schemaTypes.lists.map((listItem) => ({
    type: "listStyle",
    key: listItem.value,
    disabled,
    icon: listItem == null ? void 0 : listItem.icon,
    handle: () => {
      portableTextEditor.PortableTextEditor.toggleList(editor2, listItem.value);
    },
    title: listItem.i18nTitleKey && t2 ? t2(listItem.i18nTitleKey) : listItem.title
  }));
}
function getAnnotationIcon(type) {
  return get__default.default(type, "icon") || get__default.default(type, "type.icon") || get__default.default(type, "type.to.icon") || get__default.default(type, "type.to[0].icon");
}
function getPTEAnnotationActions(editor2, disabled, onInsert, t2) {
  const types2 = editor2.schemaTypes, focusChild = portableTextEditor.PortableTextEditor.focusChild(editor2), hasText = focusChild && focusChild.text;
  return types2.annotations.map((aType) => ({
    type: "annotation",
    disabled: !hasText || disabled,
    icon: getAnnotationIcon(aType),
    key: aType.name,
    handle: (active) => {
      active ? (portableTextEditor.PortableTextEditor.removeAnnotation(editor2, aType), portableTextEditor.PortableTextEditor.focus(editor2)) : onInsert(aType);
    },
    title: aType.i18nTitleKey && t2 ? t2(aType.i18nTitleKey) : aType.title || capitalize__default.default(aType.name)
  }));
}
function getPTEToolbarActionGroups(editor2, disabled, onInsertAnnotation, hotkeyOpts, t2) {
  return [
    { name: "format", actions: getPTEFormatActions(editor2, disabled, hotkeyOpts, t2) },
    { name: "list", actions: getPTEListActions(editor2, disabled, t2) },
    { name: "annotation", actions: getPTEAnnotationActions(editor2, disabled, onInsertAnnotation, t2) }
  ];
}
function getBlockStyles(types2) {
  return types2.styles.map((style) => ({
    key: `style-${style.value}`,
    style: style.value,
    styleComponent: style && style.component,
    title: style.title,
    i18nTitleKey: style.i18nTitleKey
  }));
}
function getInsertMenuIcon(type, fallbackIcon) {
  const referenceIcon = get__default.default(type, "to[0].icon");
  return type.icon || type.type && type.type.icon || referenceIcon || fallbackIcon;
}
function getInsertMenuItems(types2, disabled, onInsertBlock, onInsertInline) {
  const blockItems = types2.blockObjects.map(
    (type, index) => ({
      handle: () => onInsertBlock(type),
      icon: getInsertMenuIcon(type, icons.BlockElementIcon),
      inline: !1,
      key: `block-${index}`,
      type
    })
  ), inlineItems = types2.inlineObjects.map(
    (type, index) => ({
      handle: () => onInsertInline(type),
      icon: getInsertMenuIcon(type, icons.InlineElementIcon),
      inline: !0,
      key: `inline-${index}`,
      type
    })
  );
  return blockItems.concat(inlineItems).filter((item) => {
    var _a2;
    return !((_a2 = item.type) != null && _a2.hidden);
  });
}
const annotationIcons = {
  link: icons.LinkIcon
}, formatIcons = {
  strong: icons.BoldIcon,
  em: icons.ItalicIcon,
  "strike-through": icons.StrikethroughIcon,
  underline: icons.UnderlineIcon,
  code: icons.CodeIcon
}, listStyleIcons = {
  number: icons.OlistIcon,
  bullet: icons.UlistIcon
};
function getActionIcon(action, active) {
  return action.icon ? typeof action.icon == "string" ? /* @__PURE__ */ jsxRuntime.jsx(CustomIcon, { active, icon: action.icon }) : action.icon : action.type === "annotation" ? annotationIcons[action.key] || icons.UnknownIcon : action.type === "listStyle" ? listStyleIcons[action.key] || icons.UnknownIcon : formatIcons[action.key] || icons.UnknownIcon;
}
function useFocusBlock() {
  const editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  return React.useMemo(() => portableTextEditor.PortableTextEditor.focusBlock(editor2), [editor2, selection]);
}
function useActionGroups({
  hotkeys,
  onMemberOpen,
  resolveInitialValue: resolveInitialValue2,
  disabled
}) {
  const editor2 = portableTextEditor.usePortableTextEditor(), { t: t2 } = useTranslation(), handleInsertAnnotation = React.useCallback(
    async (schemaType) => {
      const initialValue = await resolveInitialValue2(schemaType), paths = portableTextEditor.PortableTextEditor.addAnnotation(editor2, schemaType, initialValue);
      paths && paths.markDefPath && onMemberOpen(paths.markDefPath);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  );
  return React.useMemo(
    () => editor2 ? getPTEToolbarActionGroups(editor2, disabled, handleInsertAnnotation, hotkeys, t2) : [],
    [disabled, editor2, handleInsertAnnotation, hotkeys, t2]
  );
}
function useActiveActionKeys({
  actions
}) {
  const editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  return useUnique(
    React.useMemo(
      () => {
        const activeAnnotationKeys = portableTextEditor.PortableTextEditor.activeAnnotations(editor2).map(
          (a) => a._type
        );
        return actions.filter((a) => a.type === "annotation" ? activeAnnotationKeys.includes(a.key) : a.type === "listStyle" ? portableTextEditor.PortableTextEditor.hasListStyle(editor2, a.key) : portableTextEditor.PortableTextEditor.isMarkActive(editor2, a.key)).map((a) => a.key);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        editor2,
        // This is needed so that active actions update as `selection` changes
        selection
      ]
    )
  );
}
function useActiveStyleKeys({ items }) {
  const editor2 = portableTextEditor.usePortableTextEditor(), focusBlock = useFocusBlock(), selection = portableTextEditor.usePortableTextEditorSelection();
  return useUnique(
    React.useMemo(
      () => items.filter((i) => portableTextEditor.PortableTextEditor.hasBlockStyle(editor2, i.style)).map((i) => i.style),
      //  eslint-disable-next-line react-hooks/exhaustive-deps
      [
        focusBlock,
        // This is needed so that active styles update as `selection` changes
        selection
      ]
    )
  );
}
const CollapseMenuMemo$1 = React.memo(CollapseMenu), MENU_POPOVER_PROPS$5 = { constrainSize: !0, portal: !0 }, ActionMenu = React.memo(function(props2) {
  const { disabled: disabledProp, groups, isFullscreen, collapsed } = props2, focusBlock = useFocusBlock(), editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection(), { t: t2 } = reactI18next.useTranslation(), isSelectingMultipleBlocks = (
    // Path at 0 is the block level, by comparing those we can detect if the user is selecting multiple blocks
    selection && types.isKeySegment(selection.anchor.path[0]) && types.isKeySegment(selection.focus.path[0]) ? (
      // In case of keyed segments
      selection.anchor.path[0]._key !== (selection == null ? void 0 : selection.focus.path[0]._key)
    ) : (
      // In case of non-keyed segments
      (selection == null ? void 0 : selection.anchor.path[0]) !== (selection == null ? void 0 : selection.focus.path[0])
    )
  ), isVoidBlock = (focusBlock == null ? void 0 : focusBlock._type) !== editor2.schemaTypes.block.name, isEmptyTextBlock = !isVoidBlock && Array.isArray(focusBlock.children) && focusBlock.children.length === 1 && (focusBlock == null ? void 0 : focusBlock.children[0].text) === "", disabled = disabledProp || isVoidBlock, actions = React.useMemo(
    () => groups.reduce((acc, group2) => acc.concat(
      group2.actions.map(
        // eslint-disable-next-line max-nested-callbacks
        (action, actionIndex) => actionIndex === 0 ? { ...action, firstInGroup: !0 } : action
      )
    ), []),
    [groups]
  ), activeKeys = useActiveActionKeys({ actions }), handleMenuClose = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2]), tooltipPlacement = isFullscreen ? "bottom" : "top", children = React.useMemo(
    () => actions.map((action) => {
      const annotationDisabled = action.type === "annotation" && (isEmptyTextBlock || isSelectingMultipleBlocks), annotationDisabledText = isEmptyTextBlock ? t2("user-menu.action.portable-text.annotation-disabled_empty-block", {
        name: action.title || action.key
      }) : t2("user-menu.action.portable-text.annotation-disabled_multiple-blocks", {
        name: action.title || action.key
      }), active = activeKeys.includes(action.key);
      return /* @__PURE__ */ jsxRuntime.jsx(
        CollapseMenuButton,
        {
          "aria-label": t2("toolbar.portable-text.action-button-aria-label", {
            action: action.title || action.key
          }),
          "data-testid": `action-button-${action.key}`,
          disabled: disabled || annotationDisabled,
          mode: "bleed",
          dividerBefore: action.firstInGroup,
          icon: getActionIcon(action, active),
          onClick: () => action.handle(active),
          selected: active,
          text: action.title || action.key,
          tooltipText: annotationDisabled ? annotationDisabledText : action.title || action.key,
          tooltipProps: {
            disabled,
            placement: tooltipPlacement,
            portal: "default"
          }
        },
        action.key
      );
    }),
    [
      actions,
      activeKeys,
      disabled,
      isEmptyTextBlock,
      isSelectingMultipleBlocks,
      t2,
      tooltipPlacement
    ]
  ), menuButtonProps = React.useMemo(
    () => ({
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          "data-testid": "action-menu-button",
          disabled,
          tooltipProps: { placement: tooltipPlacement }
        }
      ),
      popover: MENU_POPOVER_PROPS$5
    }),
    [disabled, tooltipPlacement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CollapseMenuMemo$1,
    {
      "data-testid": "action-menu-auto-collapse-menu",
      collapsed,
      disableRestoreFocusOnClose: !0,
      gap: 1,
      menuButtonProps,
      onMenuClose: handleMenuClose,
      children
    }
  );
}), MenuButtonMemo = React.memo(getJsonStream.MenuButton), StyledMenuItem = styled__default.default(ui.MenuItem)`
  // Change the border color variable used by BlockQuote
  // to make the border visible when the MenuItem is selected
  &[data-selected] {
    [data-option='blockquote'] {
      --card-border-color: var(--card-muted-fg-color);
    }
  }
`, MENU_POPOVER_PROPS$4 = {
  constrainSize: !0,
  placement: "bottom-start",
  portal: "default"
}, TEXT_STYLE_OPTIONS = {
  h1: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading1, { children: title }),
  h2: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading2, { children: title }),
  h3: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading3, { children: title }),
  h4: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading4, { children: title }),
  h5: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading5, { children: title }),
  h6: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading6, { children: title }),
  normal: (title) => /* @__PURE__ */ jsxRuntime.jsx(Normal, { children: title }),
  blockquote: (title) => /* @__PURE__ */ jsxRuntime.jsx(BlockQuote, { "data-option": "blockquote", children: title })
}, TEXT_STYLE_KEYS = Object.keys(TEXT_STYLE_OPTIONS), preventDefault = (event) => event.preventDefault(), emptyStyle = {
  key: "style-none",
  style: "",
  title: "No style",
  i18nTitleKey: "inputs.portable-text.style.none"
}, BlockStyleSelect = React.memo(function(props2) {
  const { disabled, items: itemsProp } = props2, editor2 = portableTextEditor.usePortableTextEditor(), focusBlock = useFocusBlock(), { t: t2 } = useTranslation(), _disabled = disabled || (focusBlock ? editor2.schemaTypes.block.name !== focusBlock._type : !1), activeKeys = useActiveStyleKeys({ items: itemsProp }), { activeItems, items } = React.useMemo(() => {
    const _activeItems = itemsProp.filter((item) => activeKeys.includes(item.style));
    let _items = itemsProp;
    return _activeItems.length === 0 && _items.length > 1 && (_items = _items.concat([emptyStyle]), _activeItems.push(emptyStyle)), { activeItems: _activeItems, items: _items };
  }, [activeKeys, itemsProp]), menuButtonText = React.useMemo(() => activeItems.length > 1 ? t2("inputs.portable-text.style.multiple") : activeItems.length !== 1 ? emptyStyle.i18nTitleKey ? t2(emptyStyle.i18nTitleKey) : emptyStyle.title : activeItems[0].i18nTitleKey ? t2(activeItems[0].i18nTitleKey) : activeItems[0].title, [activeItems, t2]), handleChange = React.useCallback(
    (item) => {
      focusBlock && item.style !== focusBlock.style && (portableTextEditor.PortableTextEditor.toggleBlockStyle(editor2, item.style), portableTextEditor.PortableTextEditor.focus(editor2));
    },
    [editor2, focusBlock]
  ), renderOption = React.useCallback((style, title) => {
    const hasTextStyle = TEXT_STYLE_KEYS.includes(style), renderStyle2 = TEXT_STYLE_OPTIONS[style];
    return hasTextStyle ? renderStyle2(title) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: title });
  }, []), button = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        disabled: _disabled,
        iconRight: icons.ChevronDownIcon,
        justify: "space-between",
        mode: "bleed",
        onClick: preventDefault,
        text: menuButtonText,
        width: "fill"
      }
    ),
    [_disabled, menuButtonText]
  ), menu = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { disabled: _disabled, children: items.map((item) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledMenuItem,
      {
        pressed: activeItems.includes(item),
        onClick: _disabled ? void 0 : () => handleChange(item),
        children: renderOption(
          item.style,
          item.i18nTitleKey ? t2(item.i18nTitleKey) : (item == null ? void 0 : item.title) || item.style
        )
      },
      item.key
    )) }),
    [_disabled, activeItems, handleChange, items, renderOption, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    MenuButtonMemo,
    {
      popover: MENU_POPOVER_PROPS$4,
      id: "block-style-select",
      button,
      menu
    }
  );
}), CollapseMenuMemo = React.memo(CollapseMenu), MENU_POPOVER_PROPS$3 = { constrainSize: !0, portal: !0 }, InsertMenu = React.memo(function(props2) {
  const { disabled, items, isFullscreen, collapsed } = props2, { t: t2 } = useTranslation(), focusBlock = useFocusBlock(), editor2 = portableTextEditor.usePortableTextEditor(), isVoidFocus = focusBlock && focusBlock._type !== editor2.schemaTypes.block.name, handleMenuClose = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2]), tooltipPlacement = isFullscreen ? "bottom" : "top", children = React.useMemo(() => items.map((item) => {
    const title = item.type.title || upperFirst__default.default(item.type.name);
    return /* @__PURE__ */ jsxRuntime.jsx(
      CollapseMenuButton,
      {
        "aria-label": t2(
          item.inline ? "inputs.portable-text.action.insert-inline-object-aria-label" : "inputs.portable-text.action.insert-block-aria-label",
          { typeName: title }
        ),
        mode: "bleed",
        disabled: disabled || isVoidFocus && item.inline === !0,
        icon: item.icon,
        onClick: item.handle,
        text: title,
        tooltipText: t2(
          item.inline ? "inputs.portable-text.action.insert-inline-object" : "inputs.portable-text.action.insert-block",
          { typeName: title }
        ),
        tooltipProps: {
          disabled,
          placement: tooltipPlacement,
          portal: "default"
        }
      },
      item.key
    );
  }), [disabled, isVoidFocus, items, t2, tooltipPlacement]), menuButtonProps = React.useMemo(
    () => ({
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          "data-testid": "insert-menu-button",
          disabled,
          tooltipProps: { placement: tooltipPlacement }
        }
      ),
      popover: MENU_POPOVER_PROPS$3
    }),
    [disabled, tooltipPlacement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CollapseMenuMemo,
    {
      "data-testid": "insert-menu-auto-collapse-menu",
      collapsed,
      collapseText: !1,
      disableRestoreFocusOnClose: !0,
      gap: 1,
      menuButtonProps,
      onMenuClose: handleMenuClose,
      children
    }
  );
}), RootFlex$2 = styled__default.default(ui.Flex)`
  width: 100%;
`, StyleSelectBox = styled__default.default(ui.Box)`
  width: 8em;
`, StyleSelectFlex = styled__default.default(ui.Flex)`
  border-right: 1px solid var(--card-border-color);
`, ActionMenuBox = styled__default.default(ui.Box)`
  ${({ $withInsertMenu }) => $withInsertMenu && styled.css`
      max-width: max-content;
      border-right: 1px solid var(--card-border-color);
    `}
`, FullscreenButtonBox = styled__default.default(ui.Box)`
  border-left: 1px solid var(--card-border-color);
`, SLOW_INITIAL_VALUE_LIMIT = 300, IS_MAC$1 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), InnerToolbar = React.memo(function({
  actionGroups,
  blockStyles,
  collapsible,
  disabled,
  insertMenuItems,
  isFullscreen,
  onToggleFullscreen
}) {
  const { t: t2 } = useTranslation(), showActionMenu = actionGroups.reduce((acc, x) => acc + x.actions.length, 0) > 0, showInsertMenu = insertMenuItems.length > 0, [rootElement, setRootElement] = React.useState(null), rootElementRect = ui.useElementRect(rootElement), collapsed = collapsible && rootElementRect ? (rootElementRect == null ? void 0 : rootElementRect.width) < 400 : !1, showBlockStyleSelect = blockStyles.length > 1;
  useRovingFocus({
    rootElement
  });
  const preventEditorBlurOnToolbarMouseDown = React.useCallback((e) => {
    e.preventDefault();
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$2, { align: "center", ref: setRootElement, onMouseDown: preventEditorBlurOnToolbarMouseDown, children: [
    showBlockStyleSelect && /* @__PURE__ */ jsxRuntime.jsx(StyleSelectFlex, { flex: collapsed ? 1 : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(StyleSelectBox, { padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockStyleSelect, { disabled, items: blockStyles }) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, children: [
      showActionMenu && /* @__PURE__ */ jsxRuntime.jsx(
        ActionMenuBox,
        {
          flex: collapsed ? void 0 : 1,
          padding: isFullscreen ? 2 : 1,
          $withInsertMenu: showInsertMenu,
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ActionMenu,
            {
              disabled,
              collapsed,
              groups: actionGroups,
              isFullscreen
            }
          )
        }
      ),
      showInsertMenu && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: collapsed ? void 0 : 1, padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        InsertMenu,
        {
          disabled,
          collapsed,
          items: insertMenuItems,
          isFullscreen
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(FullscreenButtonBox, { padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t2("inputs.portable-text.action.expand-editor"),
        icon: isFullscreen ? icons.CollapseIcon : icons.ExpandIcon,
        mode: "bleed",
        onClick: onToggleFullscreen,
        tooltipProps: {
          content: t2(
            isFullscreen ? "inputs.portable-text.action.collapse-editor" : "inputs.portable-text.action.expand-editor"
          ),
          hotkeys: [`${IS_MAC$1 ? "Cmd" : "Ctrl"}`, "Enter"],
          placement: isFullscreen ? "bottom" : "top",
          portal: "default"
        }
      }
    ) })
  ] });
});
function Toolbar(props2) {
  const { collapsible, hotkeys, isFullscreen, readOnly, onMemberOpen, onToggleFullscreen } = props2, editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection(), resolveInitialValueForType2 = useResolveInitialValueForType(), disabled = readOnly || !selection, { push } = ui.useToast(), resolveInitialValue2 = React.useCallback(
    (type) => {
      let isSlow = !1;
      const slowTimer = setTimeout(() => {
        isSlow = !0, push({
          id: "resolving-initial-value",
          status: "info",
          title: "Resolving initial value\u2026"
        });
      }, SLOW_INITIAL_VALUE_LIMIT);
      return resolveInitialValueForType2(type, {}).then((value) => (isSlow && push({
        id: "resolving-initial-value",
        status: "info",
        duration: 500,
        title: "Initial value resolved"
      }), value)).catch((error) => {
        push({
          title: "Could not resolve initial value",
          id: "resolving-initial-value",
          description: `Unable to resolve initial value for type: ${type.name}: ${error.message}.`,
          status: "error"
        });
      }).finally(() => clearTimeout(slowTimer));
    },
    [push, resolveInitialValueForType2]
  ), handleInsertBlock = React.useCallback(
    async (type) => {
      const initialValue = await resolveInitialValue2(type), path = portableTextEditor.PortableTextEditor.insertBlock(editor2, type, initialValue);
      path && onMemberOpen(path);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  ), handleInsertInline = React.useCallback(
    async (type) => {
      const initialValue = await resolveInitialValue2(type), path = portableTextEditor.PortableTextEditor.insertChild(editor2, type, initialValue);
      path && onMemberOpen(path);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  ), actionGroups = useActionGroups({
    hotkeys,
    onMemberOpen,
    resolveInitialValue: resolveInitialValue2,
    disabled: !0
  }), blockStyles = React.useMemo(() => getBlockStyles(editor2.schemaTypes), [editor2]), insertMenuItems = React.useMemo(
    () => getInsertMenuItems(editor2.schemaTypes, disabled, handleInsertBlock, handleInsertInline),
    [disabled, editor2, handleInsertBlock, handleInsertInline]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    InnerToolbar,
    {
      actionGroups,
      blockStyles,
      collapsible,
      disabled,
      insertMenuItems,
      isFullscreen,
      onToggleFullscreen
    }
  );
}
const noOutlineStyle = { outline: "none" }, FORM_BUILDER_DEFAULT_ID = "root", PlaceholderWrapper = styled__default.default.span((props2) => {
  const { color: color2 } = theme.getTheme_v2(props2.theme);
  return styled.css`
    color: ${color2.input.default.enabled.placeholder};
  `;
}), renderDecorator = (props2) => /* @__PURE__ */ jsxRuntime.jsx(Decorator, { ...props2 }), renderStyle = (props2) => /* @__PURE__ */ jsxRuntime.jsx(Style, { ...props2 }), renderListItem = (props2) => /* @__PURE__ */ jsxRuntime.jsx(ListItem$1, { ...props2 });
function Editor(props2) {
  const {
    hotkeys,
    initialSelection,
    isActive,
    isFullscreen,
    onCopy,
    onItemOpen,
    onPaste,
    onToggleFullscreen,
    path,
    readOnly,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderChild,
    scrollElement,
    setPortalElement,
    setScrollElement,
    ariaDescribedBy
  } = props2, { id: id2 } = useFormBuilder(), { t: t2 } = useTranslation(), { isTopLayer } = ui.useLayer(), editableRef = React.useRef(null), { element: boundaryElement } = ui.useBoundaryElement();
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        !isTopLayer || !isFullscreen || event.key === "Escape" && onToggleFullscreen();
      },
      [onToggleFullscreen, isFullscreen, isTopLayer]
    )
  );
  const renderPlaceholder = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(PlaceholderWrapper, { "data-testid": "pt-input-placeholder", children: t2("inputs.portable-text.empty-placeholder") }),
    [t2]
  ), spellcheck = useSpellcheck(), scrollSelectionIntoView = useScrollSelectionIntoView(scrollElement), editable = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      portableTextEditor.PortableTextEditable,
      {
        "aria-describedby": ariaDescribedBy,
        hotkeys,
        onCopy,
        onPaste,
        ref: editableRef,
        rangeDecorations,
        renderAnnotation,
        renderBlock,
        renderChild,
        renderDecorator,
        renderListItem,
        renderPlaceholder,
        renderStyle,
        scrollSelectionIntoView,
        selection: initialSelection,
        spellCheck: spellcheck,
        style: noOutlineStyle
      }
    ),
    [
      ariaDescribedBy,
      hotkeys,
      initialSelection,
      onCopy,
      onPaste,
      rangeDecorations,
      renderAnnotation,
      renderBlock,
      renderChild,
      renderPlaceholder,
      scrollSelectionIntoView,
      spellcheck
    ]
  ), handleToolBarOnMemberOpen = React.useCallback(
    (relativePath) => {
      onItemOpen(path.concat(relativePath));
    },
    [onItemOpen, path]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$b, { $fullscreen: isFullscreen, "data-testid": "pt-editor", children: [
    isActive && /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ToolbarCard, { "data-testid": "pt-editor__toolbar-card", shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      Toolbar,
      {
        collapsible: id2 === FORM_BUILDER_DEFAULT_ID,
        hotkeys,
        isFullscreen,
        onMemberOpen: handleToolBarOnMemberOpen,
        onToggleFullscreen,
        readOnly
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(EditableCard, { flex: 1, tone: readOnly ? "transparent" : "default", children: [
      /* @__PURE__ */ jsxRuntime.jsx(Scroller, { ref: setScrollElement, children: /* @__PURE__ */ jsxRuntime.jsx(EditableContainer, { padding: isFullscreen ? 2 : 0, sizing: "border", width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        EditableWrapper,
        {
          $isFullscreen: isFullscreen,
          tone: readOnly ? "transparent" : "default",
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: isFullscreen ? scrollElement : boundaryElement, children: editable })
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntime.jsx("div", { "data-portal": "", ref: setPortalElement })
    ] })
  ] });
}
function useHotkeys(hotkeys) {
  const editor2 = portableTextEditor.usePortableTextEditor(), [initialHotkeys] = React.useState(() => hotkeys);
  return initialHotkeys !== hotkeys && console.warn(
    "Make sure that hotkeys are a stable object across renders, or there will be issues with key handling in the Portable Text Editor."
  ), React.useMemo(() => {
    const defaultHotkeys = { marks: {} };
    return editor2.schemaTypes.decorators.forEach((dec2) => {
      switch (dec2.value) {
        case "strong":
          defaultHotkeys.marks["mod+b"] = dec2.value;
          break;
        case "em":
          defaultHotkeys.marks["mod+i"] = dec2.value;
          break;
        case "underline":
          defaultHotkeys.marks["mod+u"] = dec2.value;
          break;
        case "code":
          defaultHotkeys.marks["mod+'"] = dec2.value;
          break;
      }
    }), {
      marks: { ...defaultHotkeys.marks, ...(initialHotkeys || {}).marks },
      custom: initialHotkeys.custom
    };
  }, [editor2, initialHotkeys]);
}
function useTrackFocusPath(props2) {
  const { focusPath, boundaryElement, onItemClose } = props2, portableTextMemberItems = usePortableTextMemberItems(), editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  React.useLayoutEffect(() => {
    var _a2, _b, _c, _d, _e;
    if (focusPath.length === 0)
      return;
    const openItem = portableTextMemberItems.find((m) => m.member.open);
    if (openItem && (_a2 = openItem.elementRef) != null && _a2.current) {
      if (boundaryElement && (scrollIntoView__default.default(boundaryElement, {
        scrollMode: "if-needed",
        block: "start",
        inline: "start"
      }), scrollIntoView__default.default(openItem.elementRef.current, {
        scrollMode: "if-needed",
        boundary: boundaryElement,
        block: "start",
        inline: "start"
      })), selection != null && selection.focus.path && PathUtils.isEqual(selection.focus.path, focusPath.slice(0, selection.focus.path.length)))
        return;
      const isTextBlock = openItem.kind === "textBlock", isBlockFocusPath = focusPath.length === 1;
      if (isTextBlock || isBlockFocusPath) {
        const textBlockChildKey = isTextBlock && types.isKeyedObject(focusPath[2]) ? focusPath[2]._key : void 0, child = textBlockChildKey && Array.isArray((_b = openItem.node.value) == null ? void 0 : _b.children) ? (_c = openItem.node.value) == null ? void 0 : _c.children.find((c) => c._key === textBlockChildKey) : void 0, isSpanTextFocusPath = child && child._type === "span" && focusPath.length === 4 && focusPath[1] === "children" && focusPath[3] === "text" || !1, isTextChildFocusPath = isTextBlock && (focusPath.length === 3 && focusPath[1] === "children" || isSpanTextFocusPath);
        let path = [];
        isTextChildFocusPath ? path = focusPath.slice(0, 3) : (
          /* Known text block, but unknown child. Select first child in that block. */
          isTextBlock && isBlockFocusPath && Array.isArray((_d = openItem.node.value) == null ? void 0 : _d.children) ? path = [focusPath[0], "children", { _key: (_e = openItem.node.value) == null ? void 0 : _e.children[0]._key }] : isBlockFocusPath && (path = [{ _key: openItem.key }])
        ), path.length && (portableTextEditor.PortableTextEditor.select(editor2, {
          anchor: { path, offset: 0 },
          focus: { path, offset: 0 }
        }), isTextBlock && portableTextEditor.PortableTextEditor.focus(editor2));
      }
    }
  }, [
    boundaryElement,
    editor2,
    focusPath,
    onItemClose,
    portableTextMemberItems,
    selection == null ? void 0 : selection.focus.path
  ]);
}
const Root$a = styled__default.default(ui.Card)(rootStyle), PreviewSpan = styled__default.default.span`
  display: block;
  max-width: calc(5em + 80px);
  position: relative;
`, TooltipBox$1 = styled__default.default(ui.Box)`
  max-width: 250px;
`;
function rootStyle({ theme: theme2 }) {
  var _a2, _b, _c;
  const { color: color$1, radius } = theme2.sanity;
  return styled.css`
    line-height: 0;
    border-radius: ${radius[2]}px;
    padding: 2px;
    box-shadow: inset 0 0 0 1px var(--card-border-color);
    height: calc(1em - 1px);
    margin-top: 0.0625em;
    cursor: default;

    &:not([hidden]) {
      display: inline-flex;
      align-items: center;
      vertical-align: top;
    }

    &[data-ready-only] {
      cursor: default;
    }

    &[data-focused] {
      box-shadow: inset 0 0 0 1px ${(_a2 = color$1.selectable) == null ? void 0 : _a2.primary.selected.border};
      color: ${(_b = color$1.selectable) == null ? void 0 : _b.primary.pressed.fg};
    }

    &[data-selected] {
      background-color: ${(_c = color$1.selectable) == null ? void 0 : _c.primary.pressed.bg};
    }

    &:not([data-focused]):not([data-selected]) {
      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.default.hovered.border};
        }
      }
    }

    &[data-markers] {
      --card-bg-color: ${color$1.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
    }

    &[data-warning] {
      --card-bg-color: ${color$1.muted.caution.hovered.bg};

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.muted.caution.hovered.border};
        }
      }
    }

    &[data-invalid] {
      --card-bg-color: ${color$1.input.invalid.enabled.bg};
      --card-border-color: ${color$1.input.invalid.enabled.border};

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.invalid.hovered.border};
        }
      }
    }
  `;
}
const POPOVER_FALLBACK_PLACEMENTS = ["top", "bottom"];
function InlineObjectToolbarPopover(props2) {
  const {
    floatingBoundary,
    onClosePopover,
    onEdit,
    onDelete,
    referenceBoundary,
    referenceElement,
    title,
    open
  } = props2, { sanity } = ui.useTheme(), { t: t2 } = useTranslation(), editButtonRef = React.useRef(null), deleteButtonRef = React.useRef(null), popoverScheme = sanity.color.dark ? "light" : "dark";
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClosePopover());
      },
      [onClosePopover]
    )
  );
  const handleDelete = React.useCallback(
    (event) => {
      var _a2;
      if (!((_a2 = deleteButtonRef.current) != null && _a2.disabled)) {
        event.preventDefault(), event.stopPropagation();
        try {
          onDelete(event);
        } catch (err) {
          console.error(err);
        } finally {
          deleteButtonRef.current && (deleteButtonRef.current.disabled = !0);
        }
      }
    },
    [onDelete]
  ), popoverContent = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t2("inputs.portable-text.inline-object.edit-aria-label"),
          icon: icons.EditIcon,
          mode: "bleed",
          onClick: onEdit,
          ref: editButtonRef,
          tooltipProps: { content: t2("inputs.portable-text.inline-object.edit") }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t2("inputs.portable-text.inline-object.remove-aria-label"),
          ref: deleteButtonRef,
          icon: icons.TrashIcon,
          mode: "bleed",
          onClick: handleDelete,
          tone: "critical",
          tooltipProps: { content: t2("inputs.portable-text.inline-object.remove") }
        }
      )
    ] }) }),
    [handleDelete, onEdit, title, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      constrainSize: !0,
      content: popoverContent,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      floatingBoundary,
      open,
      placement: "top",
      portal: !0,
      referenceBoundary,
      referenceElement,
      scheme: popoverScheme
    }
  );
}
const InlineObject = (props2) => {
  var _a2;
  const {
    floatingBoundary,
    focused,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    relativePath,
    renderAnnotation,
    renderBlock,
    renderCustomMarkers,
    renderField,
    renderItem,
    renderInlineBlock,
    renderInput,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { Markers } = useFormBuilder().__internal.components, editor2 = portableTextEditor.usePortableTextEditor(), markers = usePortableTextMarkers(path), memberItem = usePortableTextMemberItem(pathToString$1(path)), { validation: validation2, hasError, hasInfo, hasWarning } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), parentSchemaType = editor2.schemaTypes.block, hasMarkers = markers.length > 0, selfSelection = React.useMemo(
    () => ({
      anchor: { path: relativePath, offset: 0 },
      focus: { path: relativePath, offset: 0 }
    }),
    [relativePath]
  ), onRemove = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.delete(editor2, selfSelection, { mode: "children" }), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [selfSelection, editor2]), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onItemOpen(memberItem.node.path));
  }, [editor2, onItemOpen, memberItem]), onClose = React.useCallback(() => {
    onItemClose(), portableTextEditor.PortableTextEditor.select(editor2, selfSelection), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b, referenceElement = (_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current, presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement,
      children: input,
      focused,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      markers,
      member: memberItem == null ? void 0 : memberItem.member,
      parentSchemaType,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock,
      renderDefault: DefaultInlineObjectComponent,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      selected,
      value,
      validation: validation2
    }),
    [
      floatingBoundary,
      focused,
      input,
      isOpen,
      markers,
      memberItem == null ? void 0 : memberItem.member,
      nodePath,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      parentSchemaType,
      readOnly,
      referenceBoundary,
      referenceElement,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      rootPresence,
      schemaType,
      selected,
      validation2,
      value
    ]
  ), tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers, toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        validation: validation2,
        renderCustomMarkers
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx("span", { ref: memberItem == null ? void 0 : memberItem.elementRef, contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Tooltip,
      {
        placement: "bottom",
        portal: "editor",
        disabled: isOpen ? !0 : !tooltipEnabled,
        content: toolTipContent,
        children: renderInlineBlock && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { position: "relative" }, children: renderInlineBlock(componentProps) })
      }
    ) }),
    [
      componentProps,
      memberItem == null ? void 0 : memberItem.elementRef,
      renderInlineBlock,
      toolTipContent,
      tooltipEnabled,
      isOpen
    ]
  );
}, DefaultInlineObjectComponent = (props2) => {
  const {
    __unstable_floatingBoundary: floatingBoundary,
    __unstable_referenceBoundary: referenceBoundary,
    __unstable_referenceElement: referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    renderPreview,
    schemaType,
    selected,
    validation: validation2,
    value
  } = props2, { t: t2 } = useTranslation(), hasMarkers = markers.length > 0, [popoverOpen, setPopoverOpen] = React.useState(!1), popoverTitle = (schemaType == null ? void 0 : schemaType.title) || schemaType.name, hasError = validation2.filter((v) => v.level === "error").length > 0, hasWarning = validation2.filter((v) => v.level === "warning").length > 0, openItem = React.useCallback(() => {
    setPopoverOpen(!1), onOpen();
  }, [onOpen]);
  React.useEffect(() => {
    setPopoverOpen(open ? !1 : !!focused);
  }, [focused, open]);
  const tone = React.useMemo(() => {
    if (hasError)
      return "critical";
    if (hasWarning)
      return "caution";
    if (selected || focused)
      return "primary";
  }, [focused, hasError, hasWarning, selected]), onClosePopover = React.useCallback(() => {
    setPopoverOpen(!1);
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Root$a,
      {
        "aria-label": t2("inputs.portable-text.inline-block.aria-label"),
        "data-focused": focused || void 0,
        "data-invalid": hasError || void 0,
        "data-markers": hasMarkers || void 0,
        "data-read-only": readOnly || void 0,
        "data-selected": selected || void 0,
        "data-warning": hasWarning || void 0,
        forwardedAs: "span",
        onClick: readOnly ? openItem : void 0,
        onDoubleClick: openItem,
        tone,
        children: /* @__PURE__ */ jsxRuntime.jsx(PreviewSpan, { children: renderPreview({
          layout: "inline",
          schemaType,
          skipVisibilityCheck: !0,
          value,
          fallbackTitle: "Click to edit"
        }) })
      }
    ),
    referenceElement && /* @__PURE__ */ jsxRuntime.jsx(
      InlineObjectToolbarPopover,
      {
        floatingBoundary,
        onClosePopover,
        onDelete: onRemove,
        onEdit: openItem,
        open: popoverOpen,
        referenceBoundary,
        referenceElement,
        title: popoverTitle
      }
    ),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      ObjectEditModal,
      {
        defaultType: "popover",
        onClose,
        autoFocus: focused,
        floatingBoundary,
        referenceBoundary,
        referenceElement,
        schemaType,
        children
      }
    )
  ] });
};
function Compositor(props2) {
  const {
    changed,
    focused,
    focusPath = EMPTY_ARRAY$b,
    hasFocusWithin,
    hotkeys,
    isActive,
    isFullscreen,
    onActivate,
    onCopy,
    onItemClose,
    onItemOpen,
    onItemRemove,
    onPaste,
    onPathFocus,
    onToggleFullscreen,
    path,
    readOnly,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderBlockActions,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    value
  } = props2, editor2 = portableTextEditor.usePortableTextEditor(), boundaryElement = ui.useBoundaryElement().element, [wrapperElement, setWrapperElement] = React.useState(null), [scrollElement, setScrollElement] = React.useState(null), handleToggleFullscreen = React.useCallback(() => {
    onToggleFullscreen();
  }, [onToggleFullscreen]), hotkeysWithFullscreenToggle = React.useMemo(
    () => ({
      ...hotkeys,
      custom: {
        "mod+enter": onToggleFullscreen,
        ...(hotkeys == null ? void 0 : hotkeys.custom) || {}
      }
    }),
    [hotkeys, onToggleFullscreen]
  ), editorHotkeys = useHotkeys(hotkeysWithFullscreenToggle), _renderBlockActions = value && renderBlockActions ? renderBlockActions : void 0, _renderCustomMarkers = value && renderCustomMarkers ? renderCustomMarkers : void 0, [portalElement, setPortalElement] = React.useState(null), renderTextBlock = React.useCallback(
    (blockProps) => {
      const {
        children,
        focused: blockFocused,
        path: blockPath,
        selected,
        schemaType: blockSchemaType,
        value: block
      } = blockProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        TextBlock,
        {
          floatingBoundary: boundaryElement,
          focused: blockFocused,
          isFullscreen,
          onItemClose,
          onItemOpen,
          onItemRemove,
          onPathFocus,
          path: path.concat(blockPath),
          readOnly,
          referenceBoundary: scrollElement,
          renderAnnotation,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderBlockActions: _renderBlockActions,
          renderCustomMarkers: _renderCustomMarkers,
          renderPreview,
          renderBlock,
          schemaType: blockSchemaType,
          selected,
          value: block,
          children
        }
      );
    },
    [
      _renderBlockActions,
      _renderCustomMarkers,
      boundaryElement,
      isFullscreen,
      onItemClose,
      onItemOpen,
      onItemRemove,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      scrollElement
    ]
  ), renderObjectBlock = React.useCallback(
    (blockProps) => {
      const {
        focused: blockFocused,
        path: blockPath,
        selected: blockSelected,
        schemaType: blockSchemaType,
        value: blockValue
      } = blockProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        BlockObject,
        {
          floatingBoundary: boundaryElement,
          focused: blockFocused,
          isFullscreen,
          onItemClose,
          onItemOpen,
          onItemRemove,
          onPathFocus,
          path: path.concat(blockPath),
          readOnly,
          referenceBoundary: scrollElement,
          relativePath: blockPath,
          renderAnnotation,
          renderBlock,
          renderBlockActions: _renderBlockActions,
          renderCustomMarkers: _renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderPreview,
          schemaType: blockSchemaType,
          selected: blockSelected,
          value: blockValue
        }
      );
    },
    [
      boundaryElement,
      scrollElement,
      isFullscreen,
      onItemClose,
      onItemOpen,
      onItemRemove,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock,
      _renderBlockActions,
      _renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    ]
  ), editorRenderBlock = React.useCallback(
    (blockProps) => {
      const { value: block } = blockProps;
      return block._type === editor2.schemaTypes.block.name ? renderTextBlock(blockProps) : renderObjectBlock(blockProps);
    },
    [editor2.schemaTypes.block.name, renderObjectBlock, renderTextBlock]
  ), editorRenderChild = React.useCallback(
    (childProps) => {
      const {
        children,
        focused: childFocused,
        path: childPath,
        selected,
        schemaType: childSchemaType,
        value: child
      } = childProps;
      return child._type === editor2.schemaTypes.span.name ? children : /* @__PURE__ */ jsxRuntime.jsx(
        InlineObject,
        {
          floatingBoundary: boundaryElement,
          focused: childFocused,
          onItemClose,
          onItemOpen,
          onPathFocus,
          path: path.concat(childPath),
          readOnly,
          referenceBoundary: scrollElement,
          relativePath: childPath,
          renderAnnotation,
          renderBlock,
          renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderPreview,
          schemaType: childSchemaType,
          selected,
          value: child
        }
      );
    },
    [
      editor2.schemaTypes.span.name,
      boundaryElement,
      onItemClose,
      onItemOpen,
      onPathFocus,
      path,
      readOnly,
      scrollElement,
      renderAnnotation,
      renderBlock,
      renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    ]
  ), editorRenderAnnotation = React.useCallback(
    (annotationProps) => {
      const {
        children,
        focused: editorNodeFocused,
        path: aPath,
        selected,
        schemaType: aSchemaType,
        value: aValue
      } = annotationProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        Annotation,
        {
          editorNodeFocused,
          floatingBoundary: boundaryElement,
          focused: !!focused,
          onItemClose,
          onItemOpen,
          onPathFocus,
          path: path.concat(aPath),
          readOnly,
          referenceBoundary: scrollElement,
          renderAnnotation,
          renderBlock,
          renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem,
          renderPreview,
          schemaType: aSchemaType,
          selected,
          value: aValue,
          children
        }
      );
    },
    [
      boundaryElement,
      scrollElement,
      focused,
      onItemClose,
      onItemOpen,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    ]
  ), ariaDescribedBy = props2.elementProps["aria-describedby"], initialSelection = React.useMemo(() => {
    if (hasFocusWithin)
      return {
        anchor: {
          path: focusPath,
          offset: 0
        },
        focus: {
          path: focusPath,
          offset: 0
        }
      };
  }, []), editorNode = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      Editor,
      {
        ariaDescribedBy,
        initialSelection,
        hotkeys: editorHotkeys,
        isActive,
        isFullscreen,
        onItemOpen,
        onCopy,
        onPaste,
        onToggleFullscreen: handleToggleFullscreen,
        path,
        rangeDecorations,
        readOnly,
        renderAnnotation: editorRenderAnnotation,
        renderBlock: editorRenderBlock,
        renderChild: editorRenderChild,
        setPortalElement,
        scrollElement,
        setScrollElement
      }
    ),
    // Keep only stable ones here!
    [
      ariaDescribedBy,
      editorHotkeys,
      isActive,
      isFullscreen,
      onItemOpen,
      onCopy,
      onPaste,
      handleToggleFullscreen,
      path,
      rangeDecorations,
      readOnly,
      editorRenderAnnotation,
      editorRenderBlock,
      editorRenderChild,
      initialSelection,
      scrollElement
    ]
  ), portal = ui.usePortal(), portalElements = React.useMemo(
    () => ({
      collapsed: wrapperElement,
      default: portal.element,
      editor: portalElement,
      expanded: portal.element
    }),
    [portal.element, portalElement, wrapperElement]
  );
  useTrackFocusPath({
    focusPath,
    boundaryElement: scrollElement,
    onItemClose
  });
  const editorFocused = focused || hasFocusWithin;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.PortalProvider, { __unstable_elements: portalElements, element: portal.element, children: /* @__PURE__ */ jsxRuntime.jsx(ActivateOnFocus, { onActivate, isOverlayActive: !isActive, children: /* @__PURE__ */ jsxRuntime.jsx(
    ChangeIndicator,
    {
      disabled: isFullscreen,
      hasFocus: !!focused,
      isChanged: changed,
      path,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        Root$e,
        {
          "data-focused": editorFocused ? "" : void 0,
          "data-read-only": readOnly ? "" : void 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-wrapper": "", ref: setWrapperElement, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { __unstable_name: isFullscreen ? "expanded" : "collapsed", children: isFullscreen ? /* @__PURE__ */ jsxRuntime.jsx(ExpandedLayer, { children: editorNode }) : editorNode }) }),
            /* @__PURE__ */ jsxRuntime.jsx("div", { "data-border": "" })
          ]
        }
      )
    }
  ) }) });
}
function InvalidValue(props2) {
  const { onChange, onIgnore, resolution, readOnly } = props2, telemetry2 = react.useTelemetry(), { t: t2 } = useTranslation(), handleAction = React.useCallback(() => {
    resolution && (onChange({ type: "mutation", patches: resolution.patches }), telemetry2.log(PortableTextInvalidValueResolve, {
      PTEInvalidValueId: resolution.i18n.description,
      PTEInvalidValueDescription: resolution.description
    }));
  }, [onChange, resolution, telemetry2]), handleOnIgnore = React.useCallback(() => {
    telemetry2.log(PortableTextInvalidValueIgnore), onIgnore();
  }, [onIgnore, telemetry2]);
  return resolution ? /* @__PURE__ */ jsxRuntime.jsx(
    Alert,
    {
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.portable-text.invalid-value.title") }),
      suffix: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 2, children: [
        resolution.action && /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: [1, 2], gap: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              mode: "ghost",
              onClick: handleOnIgnore,
              text: t2("inputs.portable-text.invalid-value.ignore-button.text")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              onClick: handleAction,
              text: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: resolution.i18n.action,
                  values: resolution.i18n.values
                }
              ),
              tone: "caution"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: resolution.action && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.portable-text.invalid-value.action-disclaimer") }) })
      ] }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: resolution.i18n.description, values: resolution.i18n.values }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", children: JSON.stringify(resolution.item, null, 2) }) })
      ] })
    }
  ) : null;
}
function usePatches(props2) {
  const { path } = props2, { patchChannel } = useFormBuilder().__internal;
  return { subscribe: React.useCallback(
    (subscriber) => patchChannel.subscribe(({ snapshot, patches }) => {
      const filteredPatches = patches.filter((patch2) => _startsWith(patch2.path, path)).map((patch2) => ({
        ...patch2,
        path: patch2.path.slice(path.length)
      }));
      filteredPatches.length && subscriber({
        shouldReset: _shouldReset(path, patches),
        snapshot: isRecord$4(snapshot) ? _getValueAtPath(snapshot, path) : {},
        patches: filteredPatches
      });
    }),
    [path, patchChannel]
  ) };
}
function _isSegmentEqual(segment1, segment2) {
  const segment1Type = typeof segment1;
  return segment1Type !== typeof segment2 ? !1 : segment1Type === "object" ? shallowEquals__default.default(segment1, segment2) : segment1 === segment2;
}
function _startsWith(subjectPath, checkPath) {
  if (subjectPath === checkPath)
    return !0;
  if (!Array.isArray(subjectPath) || !Array.isArray(checkPath) || subjectPath.length < checkPath.length)
    return !1;
  for (let i = 0, len = checkPath.length; i < len; i++)
    if (!_isSegmentEqual(checkPath[i], subjectPath[i]))
      return !1;
  return !0;
}
function _isAncestor(path1, path2) {
  return path1.length === 0 || _startsWith(path2, path1) && !_startsWith(path1, path2);
}
function _shouldReset(path, patches) {
  return patches.some(
    (patch2) => _isAncestor(patch2.path, path) && (patch2.type === "set" || patch2.type === "unset")
  );
}
function _getValueAtPath(value, path) {
  return path.reduce((result, segment) => typeof segment == "object" ? find__default.default(result, segment) : get__default.default(result, segment), value);
}
function PortableTextInput(props2) {
  const {
    editorRef: editorRefProp,
    elementProps,
    hotkeys,
    markers = EMPTY_ARRAY$b,
    onChange,
    onCopy,
    onEditorChange,
    onFullScreenChange,
    onInsert,
    onItemRemove,
    onPaste,
    onPathFocus,
    path,
    readOnly,
    rangeDecorations,
    renderBlockActions,
    renderCustomMarkers,
    schemaType,
    value
  } = props2, { onBlur } = elementProps, defaultEditorRef = React.useRef(null), editorRef = editorRefProp || defaultEditorRef;
  React.useImperativeHandle(elementProps.ref, () => ({
    focus() {
      editorRef.current && portableTextEditor.PortableTextEditor.focus(editorRef.current);
    }
  }));
  const { subscribe } = usePatches({ path }), [ignoreValidationError, setIgnoreValidationError] = React.useState(!1), [invalidValue, setInvalidValue] = React.useState(null), [isFullscreen, setIsFullscreen] = React.useState(!1), [isActive, setIsActive] = React.useState(!1), [isOffline, setIsOffline] = React.useState(!1), [hasFocusWithin, setHasFocusWithin] = React.useState(!1), telemetry2 = react.useTelemetry(), toast = ui.useToast(), patchSubject = React.useMemo(() => new rxjs.Subject(), []), patches$ = React.useMemo(() => patchSubject.asObservable(), [patchSubject]), innerElementRef = React.useRef(null), handleToggleFullscreen = React.useCallback(() => {
    setIsFullscreen((v) => {
      const next = !v;
      return next ? telemetry2.log(PortableTextInputExpanded) : telemetry2.log(PortableTextInputCollapsed), onFullScreenChange == null || onFullScreenChange(next), next;
    });
  }, [onFullScreenChange, telemetry2]);
  React.useEffect(() => {
    invalidValue && value !== invalidValue.value && setInvalidValue(null);
  }, [invalidValue, value]), React.useEffect(() => subscribe(({ patches, snapshot }) => {
    patchSubject.next({ patches, snapshot });
  }), [patchSubject, subscribe]);
  const portableTextMemberItems = usePortableTextMemberItemsFromProps(props2);
  React.useEffect(() => {
    hasFocusWithin && setIsActive(!0);
  }, [hasFocusWithin]);
  const setFocusPathFromEditorSelection = React.useCallback(
    (focusPath) => {
      const isSpanPath = focusPath.length === 3 && // A span path is always 3 segments long
      focusPath[1] === "children" && // Is a child of a block
      types.isKeySegment(focusPath[2]) && // Contains the key of the child
      !portableTextMemberItems.some(
        (item) => types.isKeySegment(focusPath[2]) && item.member.key === focusPath[2]._key
      );
      onPathFocus(isSpanPath ? focusPath.concat("text") : focusPath);
    },
    [onPathFocus, portableTextMemberItems]
  ), handleEditorChange = React.useCallback(
    (change) => {
      switch (change.type) {
        case "mutation":
          onChange(toFormPatches(change.patches));
          break;
        case "connection":
          change.value === "offline" ? setIsOffline(!0) : change.value === "online" && setIsOffline(!1);
          break;
        case "selection":
          React.startTransition(() => {
            change.selection && setFocusPathFromEditorSelection(change.selection.focus.path);
          });
          break;
        case "focus":
          setIsActive(!0), setHasFocusWithin(!0);
          break;
        case "blur":
          onBlur(change.event), setHasFocusWithin(!1);
          break;
        case "undo":
        case "redo":
          onChange(toFormPatches(change.patches));
          break;
        case "invalidValue":
          setInvalidValue(change);
          break;
        case "error":
          toast.push({
            status: change.level,
            description: change.description
          });
          break;
      }
      editorRef.current && onEditorChange && onEditorChange(change, editorRef.current);
    },
    [editorRef, onBlur, onChange, onEditorChange, setFocusPathFromEditorSelection, toast]
  );
  React.useEffect(() => {
    setIgnoreValidationError(!1);
  }, [value]);
  const handleIgnoreInvalidValue = React.useCallback(() => {
    setIgnoreValidationError(!0);
  }, []), respondToInvalidContent = React.useMemo(() => invalidValue && invalidValue.resolution ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    InvalidValue,
    {
      onChange: handleEditorChange,
      onIgnore: handleIgnoreInvalidValue,
      resolution: invalidValue.resolution,
      readOnly: isOffline || readOnly
    }
  ) }) : null, [handleEditorChange, handleIgnoreInvalidValue, invalidValue, isOffline, readOnly]), handleActivate = React.useCallback(() => {
    isActive || (setIsActive(!0), editorRef.current && portableTextEditor.PortableTextEditor.focus(editorRef.current));
  }, [editorRef, isActive]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { ref: innerElementRef, children: [
    !ignoreValidationError && respondToInvalidContent,
    (!invalidValue || ignoreValidationError) && /* @__PURE__ */ jsxRuntime.jsx(PortableTextMarkersProvider, { markers, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextMemberItemsProvider, { memberItems: portableTextMemberItems, children: /* @__PURE__ */ jsxRuntime.jsx(
      portableTextEditor.PortableTextEditor,
      {
        patches$,
        onChange: handleEditorChange,
        maxBlocks: void 0,
        ref: editorRef,
        readOnly: isOffline || readOnly,
        schemaType,
        value,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          Compositor,
          {
            ...props2,
            hasFocusWithin,
            hotkeys,
            isActive,
            isFullscreen,
            onActivate: handleActivate,
            onItemRemove,
            onCopy,
            onInsert,
            onPaste,
            onToggleFullscreen: handleToggleFullscreen,
            rangeDecorations,
            renderBlockActions,
            renderCustomMarkers
          }
        )
      }
    ) }) })
  ] });
}
function toFormPatches(patches) {
  return patches.map((p) => ({ ...p, patchType: SANITY_PATCH_TYPE }));
}
function focusRingBorderStyle(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
function focusRingStyle(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const Root$9 = styled__default.default(ui.Card)((props2) => {
  const { theme: theme2 } = props2, { focusRing, input, radius } = theme2.sanity, color2 = theme2.sanity.color.input, space = ui.rem(theme2.sanity.space[1]);
  return {
    position: "relative",
    borderRadius: `${radius[1]}px`,
    color: color2.default.enabled.fg,
    boxShadow: focusRingBorderStyle({
      color: color2.default.enabled.border,
      width: input.border.width
    }),
    "& > .content": {
      position: "relative",
      lineHeight: 0,
      margin: `-${space} 0 0 -${space}`
    },
    "& > .content > div": {
      display: "inline-block",
      verticalAlign: "top",
      padding: `${space} 0 0 ${space}`
    },
    // enabled
    "&:not([data-read-only])": {
      cursor: "text"
    },
    // hovered
    "@media(hover:hover):not([data-disabled]):not([data-read-only]):hover": {
      borderColor: color2.default.hovered.border
    },
    // focused
    "&:not([data-disabled]):not([data-read-only])[data-focused]": {
      boxShadow: focusRingStyle({
        border: {
          color: color2.default.enabled.border,
          width: input.border.width
        },
        focusRing
      })
    },
    // disabled
    "*:disabled + &": {
      color: color2.default.disabled.fg,
      backgroundColor: color2.default.disabled.bg,
      boxShadow: focusRingBorderStyle({
        color: color2.default.disabled.border,
        width: input.border.width
      })
    }
  };
}), Input = styled__default.default.input((props2) => {
  const { theme: theme2 } = props2, font = theme2.sanity.fonts.text, color2 = theme2.sanity.color.input, p = theme2.sanity.space[2], size = theme2.sanity.fonts.text.sizes[2];
  return {
    appearance: "none",
    background: "none",
    border: 0,
    borderRadius: 0,
    outline: "none",
    fontSize: ui.rem(size.fontSize),
    lineHeight: size.lineHeight / size.fontSize,
    fontFamily: font.family,
    fontWeight: font.weights.regular,
    margin: 0,
    display: "block",
    minWidth: "1px",
    maxWidth: "100%",
    boxSizing: "border-box",
    paddingTop: ui.rem(p - size.ascenderHeight),
    paddingRight: ui.rem(p),
    paddingBottom: ui.rem(p - size.descenderHeight),
    paddingLeft: ui.rem(p),
    // enabled
    "&:not(:invalid):not(:disabled)": {
      color: color2.default.enabled.fg
    },
    // disabled
    "&:not(:invalid):disabled": {
      color: color2.default.disabled.fg
    }
  };
}), Placeholder = styled__default.default(ui.Box)((props2) => {
  const { theme: theme2 } = props2, color2 = theme2.sanity.color.input;
  return styled.css`
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    pointer-events: none;
    --card-fg-color: ${color2.default.enabled.placeholder};
  `;
}), TagBox = styled__default.default(ui.Box)`
  // This is needed to make textOverflow="ellipsis" work properly for the Text primitive
  max-width: 100%;
`, TagInput = React.forwardRef(
  (props2, ref) => {
    const {
      disabled,
      onChange,
      onFocus,
      placeholder: placeholderProp,
      readOnly,
      value = [],
      ...restProps
    } = props2, { t: t2 } = useTranslation(studioLocaleNamespace), [inputValue, setInputValue] = React.useState(""), enabled = !disabled && !readOnly, [focused, setFocused] = React.useState(!1), forwardedRef = ui.useForwardedRef(ref), rootRef = React.useRef(null), handleRootPointerDown = React.useCallback(
      (event) => {
        if (ui.isHTMLElement(event.target) && event.target.closest('[data-ui="Tag"]'))
          return;
        const inputElement = forwardedRef.current;
        inputElement && setTimeout(() => inputElement.focus(), 0);
      },
      [forwardedRef]
    ), handleInputBlur = React.useCallback(() => {
      setFocused(!1);
    }, []), handleInputChange = React.useCallback((event) => {
      setInputValue(event.currentTarget.value);
    }, []), handleInputFocus = React.useCallback(
      (event) => {
        setFocused(!0), onFocus && onFocus(event);
      },
      [onFocus]
    ), handleInputKeyDown = React.useCallback(
      (event) => {
        if (event.key === "Enter" && (event.preventDefault(), event.stopPropagation(), onChange && inputValue)) {
          const newValue = value.concat([{ value: inputValue }]);
          setInputValue(""), onChange && onChange(newValue);
        }
      },
      [inputValue, onChange, value]
    ), handleTagRemove = React.useCallback(
      (index) => {
        if (!onChange)
          return;
        const newValue = value.slice(0);
        newValue.splice(index, 1), onChange(newValue);
      },
      [onChange, value]
    );
    return React.useEffect(() => {
      const inputElement = forwardedRef.current;
      inputElement && (inputElement.style.width = "0", inputElement.style.width = `${inputElement.scrollWidth}px`);
    }, [forwardedRef, inputValue]), /* @__PURE__ */ jsxRuntime.jsxs(
      Root$9,
      {
        "data-disabled": disabled ? "" : void 0,
        "data-focused": focused ? "" : void 0,
        "data-read-only": readOnly ? "" : void 0,
        "data-ui": "TagInput",
        onPointerDown: handleRootPointerDown,
        overflow: "auto",
        padding: 1,
        ref: rootRef,
        children: [
          enabled && /* @__PURE__ */ jsxRuntime.jsx(Placeholder, { hidden: !!(inputValue || value.length), padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: placeholderProp || t2("inputs.tags.placeholder", {
            context: typeof window < "u" && "ontouchstart" in window ? "touch" : void 0
          }) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "content", children: [
            value.map((tag, tagIndex) => (
              // eslint-disable-next-line react/no-array-index-key
              /* @__PURE__ */ jsxRuntime.jsx(TagBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
                Tag,
                {
                  enabled,
                  index: tagIndex,
                  muted: !enabled,
                  onRemove: handleTagRemove,
                  tag
                }
              ) }, `tag-${tagIndex}`)
            )),
            /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
              Input,
              {
                ...restProps,
                disabled: !enabled,
                onBlur: handleInputBlur,
                onChange: handleInputChange,
                onFocus: handleInputFocus,
                onKeyDown: handleInputKeyDown,
                ref: forwardedRef,
                type: "text",
                value: inputValue
              }
            ) }, "tag-input")
          ] })
        ]
      }
    );
  }
);
TagInput.displayName = "TagInput";
function Tag(props2) {
  const { enabled, index, muted, onRemove, tag } = props2, handleRemoveClick = React.useCallback(() => {
    onRemove(index);
  }, [index, onRemove]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { "data-ui": "Tag", radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted, textOverflow: "ellipsis", children: tag.value }) }),
    enabled && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.CloseIcon,
        mode: "bleed",
        onClick: handleRemoveClick,
        tooltipProps: { content: "Remove" }
      }
    )
  ] }) });
}
function TagsArrayInput(props2) {
  const { onChange, readOnly, value = [], elementProps, path, changed } = props2, tagInputValue = React.useMemo(() => value == null ? void 0 : value.map((v) => ({ value: v })), [value]), handleChange = React.useCallback(
    (nextValue) => {
      onChange(nextValue.length === 0 ? unset() : set(nextValue.map((v) => v.value)));
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
    TagInput,
    {
      onChange: handleChange,
      readOnly,
      value: tagInputValue,
      ...elementProps
    }
  ) });
}
const PRIMITIVES = ["string", "number", "boolean"];
function isArrayOfPrimitives$1(type) {
  return type.of.every((ofType) => PRIMITIVES.includes(ofType.jsonType));
}
function isStringArray(type) {
  return type.of.length === 1 && is$1("string", type.of[0]);
}
function isTagsArray(type) {
  var _a2;
  return ((_a2 = type.options) == null ? void 0 : _a2.layout) === "tags";
}
function isPortableText(type) {
  return type.of.some((memberType) => is$1("block", memberType));
}
function hasListOptions(type) {
  var _a2;
  return !!((_a2 = type.options) != null && _a2.list);
}
function resolveArrayInput(type) {
  return isStringArray(type) && isTagsArray(type) ? TagsArrayInput : hasListOptions(type) ? ArrayOfOptionsInput : isArrayOfPrimitives$1(type) ? ArrayOfPrimitivesInput : isPortableText(type) ? PortableTextInput : ArrayOfObjectsInput;
}
function toSelectItem$1(option) {
  return types.isTitledListValue(option) ? option : { title: capitalize__default.default(`${option}`), value: option };
}
const EMPTY_ITEM = { title: "", value: void 0 };
function SelectInput(props2) {
  var _a2, _b;
  const {
    value,
    readOnly,
    validationError,
    schemaType,
    onChange,
    path,
    changed,
    focused,
    elementProps
  } = props2, items = React.useMemo(
    () => {
      var _a22;
      return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []).map(toSelectItem$1);
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), currentItem = items.find((item) => item.value === value), isRadio = schemaType.options && schemaType.options.layout === "radio", itemFromOptionValue = React.useCallback(
    (optionValue) => {
      const index = Number(optionValue);
      return items[index];
    },
    [items]
  ), optionValueFromItem = React.useCallback(
    (item) => String(items.indexOf(item)),
    [items]
  ), inputId = React.useId(), handleChange = React.useCallback(
    (nextItem) => {
      onChange(
        PatchEvent.from(typeof (nextItem == null ? void 0 : nextItem.value) > "u" ? unset() : set(nextItem.value))
      );
    },
    [onChange]
  ), handleSelectChange = React.useCallback(
    (event) => {
      const nextItem = itemFromOptionValue(event.currentTarget.value);
      if (!nextItem) {
        handleChange(EMPTY_ITEM);
        return;
      }
      handleChange(nextItem);
    },
    [handleChange, itemFromOptionValue]
  ), content2 = isRadio ? /* @__PURE__ */ jsxRuntime.jsx(
    RadioSelect,
    {
      ...elementProps,
      value: currentItem,
      inputId,
      items,
      direction: ((_b = schemaType.options) == null ? void 0 : _b.direction) || "vertical",
      customValidity: validationError,
      onChange: handleChange,
      readOnly
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ui.Select,
    {
      ...elementProps,
      customValidity: validationError,
      value: optionValueFromItem(currentItem),
      readOnly,
      onChange: handleSelectChange,
      children: [EMPTY_ITEM, ...items].map((item, i) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: i - 1, children: item.title }, `${i - 1}`))
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: content2 });
}
const RadioSelect = React.forwardRef(function(props2, ref) {
  const { items, value, onChange, onFocus, readOnly, customValidity, direction, inputId } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 3, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(direction === "horizontal" ? ui.Inline : ui.Stack, { space: 3, role: "group", children: items.map((item, index) => /* @__PURE__ */ jsxRuntime.jsx(
    RadioSelectItem,
    {
      customValidity,
      inputId,
      item,
      onChange,
      onFocus,
      readOnly,
      ref: index === 0 ? ref : null,
      value
    },
    index
  )) }) });
}), RadioSelectItem = React.forwardRef(function(props2, ref) {
  const { customValidity, inputId, item, onChange, onFocus, readOnly, value } = props2, handleChange = React.useCallback(() => {
    onChange(item);
  }, [item, onChange]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { as: "label", align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Radio,
      {
        ref,
        checked: value === item,
        onChange: handleChange,
        onFocus,
        readOnly,
        customValidity,
        name: inputId
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: item.title }) })
  ] });
});
function resolveNumberInput(type) {
  return getOption(type, "list") ? SelectInput : NumberInput;
}
function resolveStringInput(type) {
  return getOption(type, "list") ? SelectInput : StringInput;
}
function resolveComponentFromTypeVariants(type) {
  if (is$1("array", type))
    return resolveArrayInput(type);
  if (is$1("reference", type))
    return StudioReferenceInput;
  if (is$1("string", type))
    return resolveStringInput(type);
  if (is$1("number", type))
    return resolveNumberInput(type);
}
function defaultResolveInputComponent(schemaType) {
  var _a2;
  if ((_a2 = schemaType.components) != null && _a2.input)
    return schemaType.components.input;
  const componentFromTypeVariants = resolveComponentFromTypeVariants(schemaType);
  if (componentFromTypeVariants)
    return componentFromTypeVariants;
  const deduped = getTypeChain$1(schemaType, /* @__PURE__ */ new Set()).reduce(
    (acc, type) => (acc[type.name] = type, acc),
    {}
  ), subType = Object.values(deduped).find((t2) => defaultInputs[t2.name]);
  if (subType)
    return defaultInputs[subType.name];
  throw new Error(`Could not find input component for schema type \`${schemaType.name}\``);
}
function defaultResolvePreviewComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.preview ? schemaType.components.preview : SanityDefaultPreview;
}
function getTone$1({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$2 = { portal: !0, tone: "default" }, BUTTON_CARD_STYLE = { position: "relative" };
function PreviewItem(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    onFocus,
    onOpen,
    onClose,
    changed,
    focused,
    children,
    inputProps: { renderPreview }
  } = props2, { t: t2 } = useTranslation(), sortable2 = !readOnly && ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, previewCardRef = React.useRef(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && previewCardRef.current && ((_a22 = previewCardRef.current) == null || _a22.focus());
  });
  const resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [createProtoArrayValue(insertType)],
        position: pos
      });
    },
    [onInsert]
  ), childPresence = useChildPresence(path, !0), presence = React.useMemo(() => childPresence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence: childPresence, maxAvatars: 1 }), [childPresence]), childValidation = useChildValidation(path, !0), validation2 = React.useMemo(() => childValidation.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: !0 }) }), [childValidation]), hasErrors = childValidation.some((v) => v.level === "error"), hasWarnings = childValidation.some((v) => v.level === "warning"), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
        id: `${props2.inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.remove"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t2("inputs.array.action.duplicate"),
              icon: icons.CopyIcon,
              onClick: handleDuplicate
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
        ] }),
        popover: MENU_POPOVER_PROPS$2
      }
    ),
    [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t2]
  ), tone = getTone$1({ readOnly, hasErrors, hasWarnings }), item = /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      menu,
      presence,
      validation: validation2,
      tone,
      focused,
      dragHandle: sortable2,
      selected: open,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Card,
        {
          as: "button",
          type: "button",
          tone: "inherit",
          radius: 1,
          disabled: resolvingInitialValue,
          onClick: onOpen,
          ref: previewCardRef,
          onFocus,
          __unstable_focusRing: !0,
          style: BUTTON_CARD_STYLE,
          children: [
            renderPreview({
              schemaType: props2.schemaType,
              value: props2.value,
              layout: "default",
              // Don't do visibility check for virtualized items as the calculation will be incorrect causing it to scroll
              skipVisibilityCheck: !0
            }),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ), itemTypeTitle = getSchemaTypeTitle(schemaType);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: item }) }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      EditPortal,
      {
        header: readOnly ? t2("inputs.array.action.view", { itemTypeTitle }) : t2("inputs.array.action.edit", { itemTypeTitle }),
        type: ((_c = (_b = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b.modal) == null ? void 0 : _c.type) || "dialog",
        width: (_f = (_e = (_d = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d.modal) == null ? void 0 : _e.width) != null ? _f : 1,
        id: value._key,
        onClose,
        autofocus: focused,
        legacy_referenceElement: previewCardRef.current,
        children
      }
    )
  ] });
}
function ReferenceItemRefProvider(props2) {
  const { menuRef, containerRef } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ReferenceItemRefContext.Provider, { value: { menuRef, containerRef }, children: props2.children });
}
function getTone({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$1 = { portal: !0, tone: "default" };
function ReferenceItem(props2) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    presence,
    validation: validation2,
    inputId,
    changed,
    focused,
    children,
    inputProps: { onChange, focusPath, onPathFocus, renderPreview, elementProps }
  } = props2, sortable2 = !readOnly && ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, elementRef = React.useRef(null), menuRef = React.useRef(null), containerRef = React.useRef(null), { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({
    path,
    schemaType,
    value
  });
  useScrollIntoViewOnFocusWithin(elementRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && elementRef.current && ((_a22 = elementRef.current) == null || _a22.focus());
  });
  const hasErrors = props2.validation.some((v) => v.level === "error"), hasWarnings = props2.validation.some((v) => v.level === "warning"), resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [{ ...createProtoArrayValue(insertType), _key: randomKey() }],
        position: pos
      });
    },
    [onInsert]
  ), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), hasRef = value._ref, refTypeName = ((_b = loadableReferenceInfo.result) == null ? void 0 : _b.type) || ((_c = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _c.type), publishedReferenceExists = hasRef && ((_f = (_e = (_d = loadableReferenceInfo.result) == null ? void 0 : _d.preview) == null ? void 0 : _e.published) == null ? void 0 : _f._id), handleRemoveStrengthenOnPublish = React.useCallback(() => {
    onChange([
      schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]),
      unset(["_strengthenOnPublish"])
    ]);
  }, [onChange, schemaType.weak]), refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0, pressed = selectedState === "pressed", selected = selectedState === "selected", tone = getTone({ readOnly, hasErrors, hasWarnings }), isEditing = !hasRef || focusPath[0] === "_ref", { t: t2 } = useTranslation(), OpenLink = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(restProps, _ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...restProps,
            intent: "edit",
            params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name },
            target: "_blank",
            rel: "noopener noreferrer",
            ref: _ref
          }
        );
      })
    ),
    [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]
  ), handleReplace = React.useCallback(() => {
    onPathFocus(hasRef && isEditing ? [] : ["_ref"]);
  }, [hasRef, isEditing, onPathFocus]), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { paddingY: 3 }),
        id: `${inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { ref: menuRef, children: [
          !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                text: t2("inputs.reference.action.remove"),
                tone: "critical",
                icon: icons.TrashIcon,
                onClick: onRemove
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                text: t2(
                  hasRef && isEditing ? "inputs.reference.action.replace-cancel" : "inputs.reference.action.replace"
                ),
                icon: hasRef && isEditing ? icons.CloseIcon : icons.SyncIcon,
                onClick: handleReplace
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                text: t2("inputs.reference.action.duplicate"),
                icon: icons.CopyIcon,
                onClick: handleDuplicate
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { onInsert: handleInsert, types: insertableTypes })
          ] }),
          !readOnly && !isEditing && hasRef && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          !isEditing && hasRef && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              as: OpenLink,
              "data-as": "a",
              text: t2("inputs.reference.action.open-in-new-tab"),
              icon: icons.LaunchIcon
            }
          )
        ] }),
        popover: MENU_POPOVER_PROPS$1
      }
    ),
    [
      handleDuplicate,
      handleInsert,
      handleReplace,
      hasRef,
      inputId,
      insertableTypes,
      isEditing,
      onRemove,
      OpenLink,
      readOnly,
      t2
    ]
  ), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish), showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_g = loadableReferenceInfo.result) == null ? void 0 : _g.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride, issues = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceFinalizeAlertStrip,
      {
        schemaType,
        handleRemoveStrengthenOnPublish
      }
    ),
    showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceStrengthMismatchAlertStrip,
      {
        actualStrength,
        handleFixStrengthMismatch
      }
    ),
    loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceMetadataLoadErrorAlertStrip,
      {
        errorMessage: loadableReferenceInfo.error.message,
        onHandleRetry: loadableReferenceInfo.retry
      }
    )
  ] }), item = /* @__PURE__ */ jsxRuntime.jsx(ReferenceItemRefProvider, { menuRef, containerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      dragHandle: sortable2,
      presence: !isEditing && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence, maxAvatars: 1 }),
      validation: !isEditing && validation2.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: validation2 }),
      menu,
      footer: isEditing ? void 0 : issues,
      tone: isEditing ? void 0 : tone,
      focused,
      children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, ref: containerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
        FormFieldSet,
        {
          title: schemaType.title,
          description: schemaType.description,
          __unstable_presence: presence,
          validation: validation2,
          inputId,
          deprecated: schemaType.deprecated,
          children
        }
      ) }) : /* @__PURE__ */ jsxRuntime.jsxs(
        ReferenceLinkCard,
        {
          as: EditReferenceLink,
          tone: "inherit",
          radius: 2,
          documentId: value == null ? void 0 : value._ref,
          documentType: refType == null ? void 0 : refType.name,
          disabled: resolvingInitialValue,
          __unstable_focusRing: !0,
          selected,
          pressed,
          "data-selected": selected ? !0 : void 0,
          "data-pressed": pressed ? !0 : void 0,
          ...elementProps,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              PreviewReferenceValue$1,
              {
                value,
                referenceInfo: loadableReferenceInfo,
                renderPreview,
                type: schemaType
              }
            ),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: item }) });
}
function defaultResolveItemComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.item ? schemaType.components.item : types.isReferenceSchemaType(schemaType) ? ReferenceItem : PreviewItem;
}
const INITIAL_STATE$1 = {
  isLoading: !0
}, PENDING_STATE = {
  isLoading: !1
};
function useDocumentPreview(props2) {
  const { enabled = !0, ordering, schemaType, value: previewValue } = props2 || {}, { observeForPreview } = useDocumentPreviewStore();
  return reactRx.useMemoObservable(
    () => !enabled || !previewValue || !schemaType ? rxjs.of(PENDING_STATE) : observeForPreview(previewValue, schemaType, { ordering }).pipe(
      operators.map((event) => ({ isLoading: !1, value: event.snapshot || void 0 })),
      operators.catchError((error) => rxjs.of({ isLoading: !1, error }))
    ),
    [enabled, observeForPreview, ordering, schemaType, previewValue],
    INITIAL_STATE$1
  );
}
const orientationChange$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "orientationchange").pipe(operators.shareReplay(1)), resize$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "resize").pipe(operators.shareReplay(1)), scroll$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "scroll", { passive: !0, capture: !0 }).pipe(operators.shareReplay(1)), ROOT_MARGIN_PX = 150;
function isIntersectionObserverSupported() {
  return typeof window < "u" && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in IntersectionObserverEntry.prototype ? ("isIntersecting" in IntersectionObserverEntry.prototype || Object.defineProperty(IntersectionObserverEntry.prototype, "isIntersecting", {
    get() {
      return this.intersectionRatio > 0;
    }
  }), !0) : !1;
}
const intersectionObservableFor = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();
function createIntersectionObserverBased() {
  const intersectionObserverEntriesSubject = new rxjs.Subject(), intersectionObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        intersectionObserverEntriesSubject.next(entry);
      });
    },
    {
      threshold: 0,
      rootMargin: `${ROOT_MARGIN_PX}px`
    }
  );
  return function(element) {
    return new rxjs.Observable((observer) => (intersectionObserver.observe(element), observer.next(), () => intersectionObserver.unobserve(element))).pipe(
      operators.mergeMap(() => intersectionObserverEntriesSubject.asObservable()),
      operators.filter((entry) => entry.target === element),
      operators.map((ev) => ({
        isIntersecting: ev.isIntersecting
      }))
    );
  };
}
function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }
  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }
  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  }
  return function(element) {
    const isElementInViewport = inViewport(element);
    return rxjs.merge(rxjs.of(isElementInViewport()), resize$, scroll$, orientationChange$).pipe(
      // @todo: consider "faking" more of the IntersectionObserverEntry api if possible
      operators.map(isElementInViewport),
      operators.map((isIntersecting) => ({ isIntersecting }))
    );
  };
}
const visibilityChange$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(document, "visibilitychange").pipe(operators.shareReplay(1));
function useVisibility(props2) {
  const { element, hideDelay = 0 } = props2, [visible, setVisible] = React.useState(!1);
  return React.useEffect(() => {
    if (!element)
      return;
    const isDocumentVisible$ = rxjs.concat(
      rxjs.of(!document.hidden),
      visibilityChange$.pipe(
        operators.map((event) => {
          var _a2;
          return event.target instanceof Document ? !((_a2 = event == null ? void 0 : event.target) != null && _a2.hidden) : !1;
        })
      )
    ).pipe(operators.distinctUntilChanged()), inViewport$ = intersectionObservableFor(element).pipe(
      operators.map((event) => event.isIntersecting)
    ), sub = isDocumentVisible$.pipe(
      operators.switchMap((isDocumentVisible) => isDocumentVisible ? inViewport$ : rxjs.of(!1)),
      operators.switchMap((isVisible) => isVisible ? rxjs.of(!0) : rxjs.of(!1).pipe(operators.delay(hideDelay))),
      operators.distinctUntilChanged()
    ).subscribe(setVisible);
    return () => sub.unsubscribe();
  }, [element, hideDelay]), visible;
}
const _HIDE_DELAY = 2e3;
function _extractUploadState(value) {
  return _resolveUploadValue(value == null ? void 0 : value._upload);
}
function getStringOrUndefined(value) {
  return isString(value) ? value : void 0;
}
function _resolveUploadValue(value) {
  var _a2, _b;
  if (!isRecord$4(value))
    return;
  const progress = typeof value.progress == "number" ? value.progress : 0, createdAt = getStringOrUndefined(value.initiated || value.createdAt), updatedAt = getStringOrUndefined(value.updated || value.updatedAt), fileName = getStringOrUndefined((_a2 = value == null ? void 0 : value.file) == null ? void 0 : _a2.name), fileType = getStringOrUndefined((_b = value == null ? void 0 : value.file) == null ? void 0 : _b.type), previewImage = getStringOrUndefined(value.previewImage);
  if (createdAt && updatedAt && fileName && fileType)
    return {
      progress,
      createdAt,
      updatedAt,
      file: { name: fileName, type: fileType },
      previewImage
    };
}
function PreviewLoader(props2) {
  const {
    layout,
    value,
    component,
    style: styleProp,
    schemaType,
    skipVisibilityCheck,
    ...restProps
  } = props2, { t: t2 } = useTranslation(), [element, setElement] = React.useState(null), isVisible = useVisibility({
    element: skipVisibilityCheck ? null : element,
    hideDelay: _HIDE_DELAY
  }), preview = useDocumentPreview({
    enabled: skipVisibilityCheck || isVisible,
    schemaType,
    value
  }), style = React.useMemo(
    () => ({
      ...styleProp,
      minWidth: (styleProp == null ? void 0 : styleProp.minWidth) || 1,
      minHeight: (styleProp == null ? void 0 : styleProp.minHeight) || 1
    }),
    [styleProp]
  ), uploadState = React.useMemo(() => _extractUploadState(value), [value]), media = React.useMemo(() => {
    var _a2, _b;
    return uploadState != null && uploadState.previewImage ? /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        alt: t2("preview.image.file-is-being-uploaded.alt-text"),
        src: uploadState.previewImage
      }
    ) : (_a2 = preview == null ? void 0 : preview.value) != null && _a2.media ? (_b = preview == null ? void 0 : preview.value) == null ? void 0 : _b.media : schemaType.icon;
  }, [preview, schemaType, uploadState, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref: setElement, style, children: React.createElement(component, {
    ...restProps,
    ...(preview == null ? void 0 : preview.value) || {},
    media,
    error: preview == null ? void 0 : preview.error,
    isPlaceholder: preview == null ? void 0 : preview.isLoading,
    layout,
    schemaType
  }) });
}
const Root$8 = styled__default.default(ui.Card)((props2) => {
  const { color: color$1, radius, space } = props2.theme.sanity, overlay = styled.css`
    pointer-events: none;
    content: '';
    position: absolute;
    top: -${space[1]}px;
    bottom: -${space[1]}px;
    left: -${space[1]}px;
    right: -${space[1]}px;
    border-radius: ${radius[2]}px;
    mix-blend-mode: ${color$1.dark ? "screen" : "multiply"};
  `;
  return styled.css`
    box-shadow: 0 0 0 1px var(--card-border-color);
    border-radius: ${radius[1]}px;
    pointer-events: all;
    position: relative;

    &[data-focused] {
      --card-border-color: var(--card-focus-ring-color);
    }

    &:not([data-focused]):not([data-selected]) {
      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.default.hovered.border};
        }
      }
    }

    &[data-markers] {
      &:after {
        ${overlay}
        background-color: ${color$1.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
      }
    }

    &[data-warning] {
      &:after {
        ${overlay}
        background-color: ${color$1.muted.caution.hovered.bg};
      }

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.muted.caution.hovered.border};
        }
      }
    }

    &[data-invalid] {
      &:after {
        ${overlay}
        background-color: ${color$1.input.invalid.enabled.bg};
      }

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.invalid.hovered.border};
        }
      }
    }
  `;
}), PreviewContainer = styled__default.default(ui.Box)`
  display: block;
  width: 100%;
  user-select: none;
  pointer-events: all;
`, ChangeIndicatorWrapper = styled__default.default.div(
  ({ theme: theme2, $hasChanges }) => {
    const { space } = theme2.sanity;
    return styled.css`
      position: absolute;
      width: ${space[2]}px;
      right: 0;
      top: 0;
      bottom: 0;
      padding-left: ${space[1]}px;
      user-select: none;

      ${!$hasChanges && styled.css`
        display: none;
      `}

      [data-dragged] & {
        visibility: hidden;
      }
    `;
  }
), InnerFlex = styled__default.default(ui.Flex)`
  position: relative;

  [data-dragged] > & {
    opacity: 0.5;
  }
`, BlockActionsOuter = styled__default.default(ui.Box)`
  width: 25px;
  position: relative;

  [data-dragged] & {
    visibility: hidden;
  }
`, BlockActionsInner = styled__default.default(ui.Flex)`
  position: absolute;
  right: 0;
  [data-dragged] & {
    visibility: hidden;
  }
`, TooltipBox = styled__default.default(ui.Box)`
  max-width: 250px;
`, POPOVER_PROPS$1 = {
  constrainSize: !0,
  placement: "bottom",
  portal: "default",
  tone: "default"
};
function BlockObjectActionsMenu(props2) {
  const { children, focused, isOpen, onOpen, onRemove, readOnly, value } = props2, { t: t2 } = useTranslation(), menuButtonId = React.useId(), menuButton = React.useRef(null), isTabbing = React.useRef(!1), referenceLink = React.useMemo(
    () => types.isReference(value) ? React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { ...linkProps, intent: "edit", params: { id: value._ref }, ref });
    }) : void 0,
    [value]
  );
  React.useEffect(() => {
    isOpen && (isTabbing.current = !1);
  }, [isOpen]), ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        focused && event.key === "Tab" && menuButton.current && !isTabbing.current && !isOpen && (event.preventDefault(), event.stopPropagation(), menuButton.current.focus(), isTabbing.current = !0);
      },
      [focused, isOpen]
    )
  );
  const handleDelete = React.useCallback(
    (event) => {
      event.preventDefault(), event.stopPropagation(), onRemove();
    },
    [onRemove]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            "aria-label": t2("inputs.portable-text.block.open-menu-aria-label"),
            icon: icons.EllipsisHorizontalIcon,
            mode: "bleed",
            paddingY: 3,
            tabIndex: focused ? 0 : 1,
            tooltipProps: { content: "Open menu" }
          }
        ),
        ref: menuButton,
        id: menuButtonId,
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          "_ref" in value && value._ref && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              as: referenceLink,
              "data-as": "a",
              icon: icons.LinkIcon,
              text: t2("inputs.portable-text.block.open-reference")
            }
          ),
          readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              icon: icons.EyeOpenIcon,
              onClick: onOpen,
              text: t2("inputs.portable-text.block.view")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              icon: icons.EditIcon,
              onClick: onOpen,
              text: t2("inputs.portable-text.block.edit")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              icon: icons.TrashIcon,
              onClick: handleDelete,
              text: t2("inputs.portable-text.block.remove"),
              tone: "critical"
            }
          )
        ] }) }),
        popover: POPOVER_PROPS$1
      }
    ) })
  ] });
}
function BlockObject(props2) {
  var _a2;
  const {
    floatingBoundary,
    focused,
    isFullscreen,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    relativePath,
    renderAnnotation,
    renderBlock,
    renderBlockActions,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { onChange } = useFormCallbacks(), { Markers } = useFormBuilder().__internal.components, [reviewChangesHovered, setReviewChangesHovered] = React.useState(!1), markers = usePortableTextMarkers(path), editor2 = portableTextEditor.usePortableTextEditor(), memberItem = usePortableTextMemberItem(pathToString$1(path)), isDeleting = React.useRef(!1), selfSelection = React.useMemo(
    () => ({
      anchor: { path: relativePath, offset: 0 },
      focus: { path: relativePath, offset: 0 }
    }),
    [relativePath]
  ), handleMouseOver = React.useCallback(() => setReviewChangesHovered(!0), []), handleMouseOut = React.useCallback(() => setReviewChangesHovered(!1), []), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onItemOpen(memberItem.node.path));
  }, [editor2, memberItem, onItemOpen]), onClose = React.useCallback(() => {
    onItemClose(), portableTextEditor.PortableTextEditor.select(editor2, selfSelection), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]), onRemove = React.useCallback(() => {
    if (!isDeleting.current)
      try {
        portableTextEditor.PortableTextEditor.delete(editor2, selfSelection, { mode: "blocks" });
      } catch (err) {
        console.error(err);
      } finally {
        isDeleting.current = !0;
      }
  }, [editor2, selfSelection]);
  React.useEffect(
    () => () => {
      isDeleting.current && portableTextEditor.PortableTextEditor.focus(editor2);
    },
    [editor2]
  );
  const innerPaddingProps = React.useMemo(() => isFullscreen && !renderBlockActions ? { paddingX: 5 } : isFullscreen && renderBlockActions ? { paddingLeft: 5, paddingRight: 2 } : renderBlockActions ? {
    paddingLeft: 3,
    paddingRight: 2
  } : { paddingX: 3 }, [isFullscreen, renderBlockActions]), { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), parentSchemaType = editor2.schemaTypes.portableText, hasMarkers = markers.length > 0, presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers, toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        validation: validation2,
        renderCustomMarkers
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  ), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b, referenceElement = (_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current, componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement || null,
      children: input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      parentSchemaType,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock,
      renderDefault: DefaultBlockObjectComponent,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      selected,
      validation: validation2,
      value
    }),
    [
      floatingBoundary,
      referenceElement,
      input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      isOpen,
      parentSchemaType,
      nodePath,
      rootPresence,
      readOnly,
      referenceBoundary,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      selected,
      validation2,
      value
    ]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ui.Box,
      {
        ref: memberItem == null ? void 0 : memberItem.elementRef,
        contentEditable: !1,
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { paddingBottom: 1, marginY: 3, style: void 0, children: /* @__PURE__ */ jsxRuntime.jsxs(InnerFlex, { flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Tooltip,
            {
              placement: "top",
              portal: "editor",
              disabled: isOpen ? !0 : !tooltipEnabled,
              content: toolTipContent,
              children: /* @__PURE__ */ jsxRuntime.jsx(PreviewContainer, { ...innerPaddingProps, children: renderBlock && renderBlock(componentProps) })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(BlockActionsOuter, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockActionsInner, { children: renderBlockActions && value && focused && !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            BlockActions,
            {
              block: value,
              onChange,
              renderBlockActions
            }
          ) }) }),
          isFullscreen && memberItem && /* @__PURE__ */ jsxRuntime.jsx(
            ChangeIndicatorWrapper,
            {
              $hasChanges: memberItem.member.item.changed,
              onMouseOut: handleMouseOut,
              onMouseOver: handleMouseOver,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                StyledChangeIndicatorWithProvidedFullPath,
                {
                  hasFocus: focused,
                  isChanged: memberItem.member.item.changed,
                  path: memberItem.member.item.path,
                  withHoverEffect: !1
                }
              )
            }
          ),
          reviewChangesHovered && /* @__PURE__ */ jsxRuntime.jsx(ReviewChangesHighlightBlock, {})
        ] }) })
      }
    ),
    [
      componentProps,
      focused,
      handleMouseOut,
      handleMouseOver,
      innerPaddingProps,
      isFullscreen,
      memberItem,
      onChange,
      readOnly,
      renderBlock,
      renderBlockActions,
      reviewChangesHovered,
      toolTipContent,
      tooltipEnabled,
      value,
      isOpen
    ]
  );
}
const DefaultBlockObjectComponent = (props2) => {
  const {
    __unstable_floatingBoundary,
    __unstable_referenceBoundary,
    __unstable_referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    renderPreview,
    schemaType,
    selected,
    value,
    validation: validation2
  } = props2, { t: t2 } = useTranslation(), isImagePreview = types.isImage(value), hasError = validation2.filter((v) => v.level === "error").length > 0, hasWarning = validation2.filter((v) => v.level === "warning").length > 0, hasMarkers = markers.length > 0, tone = selected || focused ? "primary" : "default", handleDoubleClickToOpen = React.useCallback(
    (e) => {
      e.preventDefault(), e.stopPropagation(), onOpen();
    },
    [onOpen]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Root$8,
      {
        "aria-label": t2("inputs.portable-text.block.aria-label"),
        "data-focused": focused ? "" : void 0,
        "data-image-preview": isImagePreview ? "" : void 0,
        "data-invalid": hasError ? "" : void 0,
        "data-markers": hasMarkers ? "" : void 0,
        "data-read-only": readOnly ? "" : void 0,
        "data-selected": selected ? "" : void 0,
        "data-testid": "pte-block-object",
        "data-warning": hasWarning ? "" : void 0,
        flex: 1,
        onDoubleClick: handleDoubleClickToOpen,
        padding: isImagePreview ? 0 : 1,
        tone,
        children: renderPreview({
          actions: /* @__PURE__ */ jsxRuntime.jsx(
            BlockObjectActionsMenu,
            {
              isOpen: open,
              focused,
              onOpen,
              onRemove,
              readOnly,
              value
            }
          ),
          layout: isImagePreview ? "blockImage" : "block",
          schemaType,
          skipVisibilityCheck: !0,
          value
        })
      }
    ),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      ObjectEditModal,
      {
        floatingBoundary: __unstable_floatingBoundary,
        defaultType: "dialog",
        onClose,
        autoFocus: focused,
        schemaType,
        referenceBoundary: __unstable_referenceBoundary,
        referenceElement: __unstable_referenceElement,
        children
      }
    )
  ] });
};
function defaultResolveBlockComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.block ? schemaType.components.block : isBlockType(schemaType) ? DefaultComponent$1 : DefaultBlockObjectComponent;
}
function defaultResolveInlineBlockComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.inlineBlock ? schemaType.components.inlineBlock : DefaultInlineObjectComponent;
}
function defaultResolveAnnotationComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.annotation ? schemaType.components.annotation : DefaultAnnotationComponent;
}
function useResolveDefaultComponent(props2) {
  const { componentResolver, componentProps } = props2;
  if (!componentProps.schemaType)
    throw new Error("the `schemaType` property must be defined");
  const defaultResolvedComponent = componentResolver(componentProps.schemaType), renderDefault = React.useCallback(
    (parentTypeProps) => {
      var _a2;
      if (!((_a2 = parentTypeProps.schemaType) != null && _a2.type))
        throw new Error("Attempted to render form component of non-existent parent type");
      const { components: components2, ...restSchemaType } = parentTypeProps.schemaType, parentTypeResolvedComponent = componentResolver(restSchemaType);
      return React.createElement(parentTypeResolvedComponent, parentTypeProps);
    },
    [componentResolver]
  );
  return React.createElement(defaultResolvedComponent, {
    ...componentProps,
    renderDefault
  });
}
function DefaultInput(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveInputComponent
  });
}
function DefaultField(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveFieldComponent
  });
}
function DefaultItem(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveItemComponent
  });
}
function DefaultPreview$1(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolvePreviewComponent
  });
}
function DefaultBlock(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveBlockComponent
  });
}
function DefaultInlineBlock(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveInlineBlockComponent
  });
}
function DefaultAnnotation(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveAnnotationComponent
  });
}
function pickInputComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.input;
}
function pickFieldComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.field;
}
function pickPreviewComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.preview;
}
function pickItemComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.item;
}
function pickBlockComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.block;
}
function pickInlineBlockComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.inlineBlock;
}
function pickAnnotationComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.annotation;
}
function useInputComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultInput,
    pick: pickInputComponent
  });
}
function useFieldComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultField,
    pick: pickFieldComponent
  });
}
function usePreviewComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultPreview$1,
    pick: pickPreviewComponent
  });
}
function useItemComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultItem,
    pick: pickItemComponent
  });
}
function useBlockComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultBlock,
    pick: pickBlockComponent
  });
}
function useInlineBlockComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultInlineBlock,
    pick: pickInlineBlockComponent
  });
}
function useAnnotationComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultAnnotation,
    pick: pickAnnotationComponent
  });
}
function Preview(props2) {
  const PreviewComponent = usePreviewComponent();
  return /* @__PURE__ */ jsxRuntime.jsx(PreviewLoader, { ...props2, component: PreviewComponent });
}
const _previewComponents = {
  block: BlockPreview,
  blockImage: BlockImagePreview,
  compact: CompactPreview,
  default: DefaultPreview,
  detail: DetailPreview,
  inline: InlinePreview,
  media: MediaPreview
};
function FallbackIcon() {
  return /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, { className: "sanity-studio__preview-fallback-icon" });
}
function SanityDefaultPreview(props2) {
  const { icon, layout, media: mediaProp, imageUrl, title, tooltip, ...restProps } = props2, client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), renderMedia2 = React.useCallback(
    (options) => {
      const { dimensions } = options;
      return /* @__PURE__ */ jsxRuntime.jsx(
        "img",
        {
          alt: isString(title) ? title : void 0,
          referrerPolicy: "strict-origin-when-cross-origin",
          src: imageBuilder.image(
            mediaProp
          ).width(dimensions.width || 100).height(dimensions.height || 100).fit(dimensions.fit).dpr(dimensions.dpr || 1).url() || ""
        }
      );
    },
    [imageBuilder, mediaProp, title]
  ), renderIcon = React.useCallback(() => React.createElement(icon || FallbackIcon), [icon]), media = React.useMemo(() => icon === !1 ? !1 : reactIs.isValidElementType(mediaProp) || React.isValidElement(mediaProp) ? mediaProp : assetUtils.isImageSource(mediaProp) ? renderMedia2 : isString(imageUrl) ? /* @__PURE__ */ jsxRuntime.jsx(
    "img",
    {
      src: imageUrl,
      alt: isString(title) ? title : void 0,
      referrerPolicy: "strict-origin-when-cross-origin"
    }
  ) : renderIcon, [icon, imageUrl, mediaProp, renderIcon, renderMedia2, title]), previewProps = React.useMemo(
    () => ({
      ...restProps,
      // @todo: fix `TS2769: No overload matches this call.`
      media,
      title
    }),
    [media, restProps, title]
  ), layoutComponent = _previewComponents[layout || "default"], children = React.createElement(
    layoutComponent,
    previewProps
  );
  return tooltip ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: tooltip,
      disabled: !tooltip,
      fallbackPlacements: ["top-end"],
      placement: "bottom-end",
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children })
    }
  ) : children;
}
const INCLUDE_FIELDS_QUERY = ["_id", "_rev", "_type"], INCLUDE_FIELDS = [...INCLUDE_FIELDS_QUERY, "_key"], AVAILABILITY_READABLE = {
  available: !0,
  reason: "READABLE"
}, AVAILABILITY_PERMISSION_DENIED = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, AVAILABILITY_NOT_FOUND = {
  available: !1,
  reason: "NOT_FOUND"
}, INVALID_PREVIEW_FALLBACK = {
  title: "Invalid preview config",
  subtitle: "Check the error log in the console",
  media: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
};
function debounceCollect(fn, wait) {
  let timer, queue = {}, idx = 0;
  return function(...args) {
    return new rxjs.Observable((obs) => {
      clearTimeout(timer), timer = setTimeout(flush, wait);
      const queueItem = {
        args,
        observer: obs,
        completed: !1
      }, id2 = idx++;
      return queue[id2] = queueItem, () => {
        queueItem.completed = !0;
      };
    });
  };
  function flush() {
    const currentlyFlushingQueue = queue;
    queue = {};
    const queueItemIds = Object.keys(currentlyFlushingQueue).filter((id2) => {
      const queueItem = currentlyFlushingQueue[id2];
      return queueItem && !queueItem.completed;
    });
    if (queueItemIds.length === 0)
      return;
    const collectedArgs = queueItemIds.map((id2) => {
      const queueItem = currentlyFlushingQueue[id2];
      return queueItem && queueItem.args;
    }).filter(isNonNullable$2);
    fn(collectedArgs).subscribe({
      next(results) {
        results.forEach((result, i) => {
          const queueItem = currentlyFlushingQueue[queueItemIds[i]];
          queueItem && !queueItem.completed && queueItem.observer.next(results[i]);
        });
      },
      complete() {
        queueItemIds.forEach((id2) => {
          const entry = currentlyFlushingQueue[id2];
          entry && !entry.completed && entry.observer.complete();
        });
      },
      error(err) {
        queueItemIds.forEach((id2) => {
          const entry = currentlyFlushingQueue[id2];
          entry && !entry.completed && entry.observer.error(err);
        });
      }
    });
  }
}
const MAX_DOCUMENT_ID_CHUNK_SIZE = 11164;
function chunkDocumentIds(documentIds) {
  let chunk = [], chunkSize = 0;
  const chunks = [];
  for (const documentId of documentIds)
    chunkSize + documentId.length + 1 >= MAX_DOCUMENT_ID_CHUNK_SIZE && (chunks.push(chunk), chunk = [], chunkSize = 0), chunkSize += documentId.length + 1, chunk.push(documentId);
  return chunks.includes(chunk) || chunks.push(chunk), chunks;
}
function mutConcat(array, chunks) {
  return array.push(...chunks), array;
}
function create_preview_availability(versionedClient, observePaths2) {
  function observeDocumentPairAvailability(id2) {
    const draftId = getDraftId(id2), publishedId = getPublishedId(id2);
    return rxjs.combineLatest([
      observeDocumentAvailability(draftId),
      observeDocumentAvailability(publishedId)
    ]).pipe(
      operators.distinctUntilChanged(shallowEquals__default.default),
      operators.map(([draftReadability, publishedReadability]) => ({
        draft: draftReadability,
        published: publishedReadability
      }))
    );
  }
  function observeDocumentAvailability(id2) {
    return observePaths2({ _ref: id2 }, [["_rev"]]).pipe(
      operators.map((res) => isRecord$4(res) && !!("_rev" in res && res != null && res._rev)),
      operators.distinctUntilChanged(),
      operators.switchMap((hasRev) => hasRev ? (
        // short circuit: if we can read the _rev field we know it both exists and is readable
        rxjs.of(AVAILABILITY_READABLE)
      ) : (
        // we can't read the _rev field for two possible reasons: 1) the document isn't readable or 2) the document doesn't exist
        fetchDocumentReadability(id2)
      ))
    );
  }
  const fetchDocumentReadability = debounceCollect(function(args) {
    const uniqueIds = [...new Set(flatten__default.default(args))];
    return rxjs.from(chunkDocumentIds(uniqueIds)).pipe(
      operators.mergeMap(fetchDocumentReadabilityChunked, 10),
      operators.reduce(mutConcat, []),
      operators.map((res) => args.map(([id2]) => res[uniqueIds.indexOf(id2)]))
    );
  }, 1);
  function fetchDocumentReadabilityChunked(ids) {
    return rxjs.defer(() => {
      const requestOptions = {
        uri: versionedClient.getDataUrl("doc", ids.join(",")),
        json: !0,
        query: { excludeContent: "true" },
        tag: "preview.documents-availability"
      };
      return versionedClient.observable.request(requestOptions).pipe(
        operators.map((response) => {
          const omitted = keyBy__default.default(response.omitted || [], (entry) => entry.id);
          return ids.map((id2) => {
            const omittedEntry = omitted[id2];
            if (!omittedEntry)
              return AVAILABILITY_READABLE;
            if (omittedEntry.reason === "existence")
              return AVAILABILITY_NOT_FOUND;
            if (omittedEntry.reason === "permission")
              return AVAILABILITY_PERMISSION_DENIED;
            throw new Error(`Unexpected reason for omission: "${omittedEntry.reason}"`);
          });
        })
      );
    });
  }
  return { observeDocumentPairAvailability };
}
function keysOf(value) {
  return Object.keys(value);
}
function setKey(source, key, value) {
  return {
    ...source,
    [key]: value
  };
}
function props(options = {}) {
  return (source) => new rxjs.Observable((observer) => source.subscribe(observer)).pipe(
    operators.switchMap((object) => {
      const keyObservables = keysOf(object).map((key) => {
        const value = object[key];
        return rxjs.isObservable(value) ? rxjs.from(value).pipe(operators.map((val) => [key, val])) : rxjs.of([key, value]);
      });
      return options.wait ? rxjs.combineLatest(keyObservables).pipe(
        operators.map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {}))
      ) : rxjs.from(keyObservables).pipe(
        operators.mergeAll(),
        operators.scan((acc, [key, value]) => setKey(acc, key, value), {})
      );
    })
  );
}
function createEmpty(fields) {
  return fields.reduce((result, field) => (result[field] = void 0, result), {});
}
function resolveMissingHeads(value, paths) {
  return paths.filter((path) => !(path[0] in value));
}
function getDocumentId(value) {
  return types.isReference(value) ? value._ref : "_id" in value ? value._id : void 0;
}
function observePaths(value, paths, observeFields, apiConfig) {
  if (!value || typeof value != "object")
    return rxjs.of(value);
  const id2 = getDocumentId(value), currentValue = id2 ? { ...value, _id: id2 } : { ...value };
  currentValue._type === "reference" && (delete currentValue._type, delete currentValue._ref, delete currentValue._weak, delete currentValue._dataset, delete currentValue._projectId, delete currentValue._strengthenOnPublish);
  const pathsWithMissingHeads = resolveMissingHeads(currentValue, paths);
  if (id2 && pathsWithMissingHeads.length > 0) {
    const nextHeads = uniq__default.default(pathsWithMissingHeads.map((path) => path[0])), refApiConfig = types.isCrossDatasetReference(value) ? { projectId: value._projectId, dataset: value._dataset } : apiConfig;
    return observeFields(id2, nextHeads, refApiConfig).pipe(
      operators.switchMap((snapshot) => snapshot === null ? rxjs.of(null) : observePaths(
        {
          ...createEmpty(nextHeads),
          ...types.isReference(value) ? { ...value, ...refApiConfig } : value,
          ...snapshot
        },
        paths,
        observeFields,
        refApiConfig
      ))
    );
  }
  const leads = {};
  paths.forEach((path) => {
    const [head, ...tail] = path;
    leads[head] || (leads[head] = []), leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter((tail) => tail.length > 0);
    return tails.length === 0 ? res[head] = isRecord$4(value) ? value[head] : void 0 : res[head] = observePaths(value[head], tails, observeFields, apiConfig), res;
  }, currentValue);
  return rxjs.of(next).pipe(props({ wait: !0 }));
}
function normalizePaths(path) {
  return path.map(
    (segment) => typeof segment == "string" ? segment.split(".") : segment
  );
}
function createPathObserver(context) {
  const { observeFields } = context;
  return {
    observePaths(value, paths, apiConfig) {
      return observePaths(value, normalizePaths(paths), observeFields, apiConfig);
    }
  };
}
const DEFAULT_PREVIEW_PATHS = [["_createdAt"], ["_updatedAt"]];
function getPreviewPaths(preview) {
  const selection = preview == null ? void 0 : preview.select;
  return selection ? (Object.values(selection).map((value) => String(value).split(".")) || []).concat(DEFAULT_PREVIEW_PATHS) : void 0;
}
function isPortableTextPreviewValue(value) {
  return Array.isArray(value) && (value.length === 0 || value.some(types.isPortableTextTextBlock));
}
function extractTextFromBlocks(blocks) {
  const firstBlock = Array.isArray(blocks) && blocks.find(types.isPortableTextTextBlock);
  return !firstBlock || !firstBlock.children ? "" : firstBlock.children.filter(types.isPortableTextSpan).map((span) => span.text).join("");
}
const PRESERVE_KEYS = ["_id", "_type", "_upload", "_createdAt", "_updatedAt"], EMPTY = [], errorCollector = /* @__PURE__ */ (() => {
  let errorsByType = {};
  return {
    add: (type, value, error) => {
      errorsByType[type.name] || (errorsByType[type.name] = []), errorsByType[type.name].push({ error, type, value });
    },
    getAll() {
      return errorsByType;
    },
    clear() {
      errorsByType = {};
    }
  };
})(), reportErrors = debounce__default.default(() => {
  const errorsByType = errorCollector.getAll(), errorCount = flatten__default.default(
    Object.keys(errorsByType).map((typeName) => {
      const entries = errorsByType[typeName];
      return uniqBy__default.default(entries, (entry) => entry.error.message);
    })
  ).length;
  errorCount !== 0 && (console.groupCollapsed(
    `%cHeads up! Got ${errorCount === 1 ? "error" : `${errorCount} errors`} while preparing data for preview. Click for details.`,
    "color: #ff7e7c"
  ), Object.keys(errorsByType).forEach((typeName) => {
    const entries = errorsByType[typeName], first = entries[0];
    console.group(`Check the preview config for schema type "${typeName}": %o`, first.type.preview), uniqBy__default.default(entries, (entry) => entry.error.message).forEach((entry) => {
      var _a2;
      if (entry.error.type === "returnValueError") {
        const hasPrepare = typeof ((_a2 = entry.type.preview) == null ? void 0 : _a2.prepare) == "function", { value, error } = entry;
        console.log(
          `Encountered an invalid ${hasPrepare ? "return value when calling prepare(%o)" : "value targeted by preview.select"}:`,
          value
        ), console.error(error);
      }
      if (entry.error.type === "prepareError") {
        const { value, error } = entry;
        console.log("Encountered an error when calling prepare(%o):", value), console.error(error);
      }
    }), console.groupEnd();
  }), console.groupEnd(), errorCollector.clear());
}, 1e3), isRenderable = (fieldName) => (value) => {
  const type = typeof value;
  return value === null || type === "undefined" || type === "string" || type === "number" || type === "boolean" ? EMPTY : [
    assignType(
      "returnValueError",
      new Error(
        `The "${fieldName}" field should be a string, number, boolean, undefined or null, instead saw ${inspect(
          value
        )}`
      )
    )
  ];
}, FIELD_NAME_VALIDATORS = {
  media: () => EMPTY,
  title: isRenderable("title"),
  subtitle: isRenderable("subtitle"),
  description: isRenderable("description"),
  imageUrl: isRenderable("imageUrl"),
  date: isRenderable("date")
};
function inspect(val, prefixType = !0) {
  if (isRecord$4(val)) {
    const keys = Object.keys(val), ellipse = keys.length > 3 ? "..." : "";
    return `${prefixType ? "object with keys " : ""}{${keys.slice(0, 3).join(", ")}${ellipse}}`;
  }
  if (Array.isArray(val)) {
    const ellipse = val.length > 3 ? "..." : "";
    return `${prefixType ? "array with " : ""}[${val.map((v) => inspect(v, !1))}${ellipse}]`;
  }
  return `the ${typeof val} ${val}`;
}
function validateFieldValue(fieldName, fieldValue) {
  if (typeof fieldValue > "u")
    return EMPTY;
  const validator = FIELD_NAME_VALIDATORS[fieldName];
  return validator && validator(fieldValue) || EMPTY;
}
function assignType(type, error) {
  return Object.assign(error, { type });
}
function validatePreparedValue(preparedValue) {
  return !isPlainObject__default.default(preparedValue) || preparedValue === null ? [
    assignType(
      "returnValueError",
      new Error(
        `Invalid return value. Expected a plain object with at least a 'title' field, instead saw ${inspect(
          preparedValue
        )}`
      )
    )
  ] : Object.entries(preparedValue).reduce((acc, [fieldName, fieldValue]) => [...acc, ...validateFieldValue(fieldName, fieldValue)], EMPTY);
}
function validateReturnedPreview(result) {
  return {
    ...result,
    errors: [...result.errors || [], ...validatePreparedValue(result.returnValue)]
  };
}
function defaultPrepare(value) {
  return keysOf(value).reduce((acc, fieldName) => {
    const val = value[fieldName];
    return {
      ...acc,
      [fieldName]: isPortableTextPreviewValue(val) ? extractTextFromBlocks(val) : val
    };
  }, {});
}
function invokePrepare(type, value, viewOptions = {}) {
  var _a2;
  const prepare2 = (_a2 = type.preview) == null ? void 0 : _a2.prepare;
  try {
    return {
      returnValue: prepare2 ? prepare2(value, viewOptions) : defaultPrepare(value),
      errors: EMPTY
    };
  } catch (error) {
    return {
      returnValue: null,
      errors: [assignType("prepareError", error)]
    };
  }
}
function withErrors(result, type, selectedValue) {
  return result.errors.forEach((error) => errorCollector.add(type, selectedValue, error)), reportErrors(), INVALID_PREVIEW_FALLBACK;
}
function hasEnumListOptions(type) {
  const options = type.options && typeof type.options == "object" ? type.options : !1;
  if (!options || !("list" in options))
    return !1;
  const listOptions = options.list;
  return Array.isArray(listOptions);
}
function getListOptions(type) {
  return hasEnumListOptions(type) ? type.options.list.map(
    (option) => types.isTitledListValue(option) ? option : { title: option, value: option }
  ) : void 0;
}
function prepareForPreview(rawValue, type, viewOptions = {}) {
  var _a2, _b;
  const hasCustomPrepare = typeof ((_a2 = type.preview) == null ? void 0 : _a2.prepare) == "function", selection = ((_b = type.preview) == null ? void 0 : _b.select) || {}, selectedValue = Object.keys(selection).reduce((acc, key) => {
    var _a22;
    const typeWithFields = "fields" in type ? type : null, targetFieldName = selection[key], valueField = (_a22 = typeWithFields == null ? void 0 : typeWithFields.fields) == null ? void 0 : _a22.find((f) => f.name === targetFieldName), listOptions = valueField && getListOptions(valueField.type);
    if (!hasCustomPrepare && listOptions) {
      const selectedOption = listOptions && listOptions.find((opt) => opt.value === get__default.default(rawValue, selection[key]));
      acc[key] = selectedOption ? selectedOption.value : get__default.default(rawValue, selection[key]);
    } else
      acc[key] = get__default.default(rawValue, selection[key]);
    return acc;
  }, {}), prepareResult = invokePrepare(type, selectedValue, viewOptions);
  if (prepareResult.errors.length > 0)
    return withErrors(prepareResult, type, selectedValue);
  const returnValueResult = validateReturnedPreview(invokePrepare(type, selectedValue, viewOptions));
  return returnValueResult.errors.length > 0 ? withErrors(returnValueResult, type, selectedValue) : { ...pick__default.default(rawValue, PRESERVE_KEYS), ...prepareResult.returnValue };
}
function isRecord$1(value) {
  return isPlainObject__default.default(value);
}
function isReference(value) {
  return isPlainObject__default.default(value);
}
function createPreviewObserver(context) {
  const { observeDocumentTypeFromId, observePaths: observePaths2 } = context;
  return function observeForPreview(value, type, viewOptions, apiConfig) {
    if (types.isCrossDatasetReferenceSchemaType(type)) {
      if (!types.isCrossDatasetReference(value))
        return rxjs.of({ snapshot: void 0 });
      const refApiConfig = { projectId: value._projectId, dataset: value._dataset };
      return observeDocumentTypeFromId(value._ref, refApiConfig).pipe(
        operators.switchMap((typeName) => {
          if (typeName) {
            const refType = type.to.find((toType) => toType.type === typeName);
            return observeForPreview(value, refType, {}, refApiConfig);
          }
          return rxjs.of({ snapshot: void 0 });
        })
      );
    }
    if (types.isReferenceSchemaType(type))
      return isReference(value) ? observeDocumentTypeFromId(value._ref).pipe(
        operators.switchMap((typeName) => {
          if (typeName) {
            const refType = type.to.find((toType) => toType.name === typeName);
            return observeForPreview(value, refType);
          }
          return rxjs.of({ snapshot: void 0 });
        })
      ) : rxjs.of({ snapshot: void 0 });
    const paths = getPreviewPaths(type.preview);
    return paths ? observePaths2(value, paths, apiConfig).pipe(
      operators.map((snapshot) => ({
        type,
        snapshot: snapshot && prepareForPreview(snapshot, type, viewOptions)
      }))
    ) : rxjs.of({
      type,
      snapshot: value && isRecord$1(value) ? invokePrepare(type, value, viewOptions).returnValue : null
    });
  };
}
function create_preview_documentPair(versionedClient, observePaths2) {
  const { observeDocumentPairAvailability } = create_preview_availability(
    versionedClient,
    observePaths2
  ), ALWAYS_INCLUDED_SNAPSHOT_PATHS = [["_updatedAt"], ["_createdAt"], ["_type"]];
  return { observePathsDocumentPair };
  function observePathsDocumentPair(id2, paths) {
    const { draftId, publishedId } = getIdPair(id2);
    return observeDocumentPairAvailability(draftId).pipe(
      operators.switchMap((availability) => {
        if (!availability.draft.available && !availability.published.available)
          return rxjs.of({
            id: publishedId,
            type: null,
            draft: {
              availability: availability.draft,
              snapshot: void 0
            },
            published: {
              availability: availability.published,
              snapshot: void 0
            }
          });
        const snapshotPaths = [...paths, ...ALWAYS_INCLUDED_SNAPSHOT_PATHS];
        return rxjs.combineLatest([
          observePaths2({ _type: "reference", _ref: draftId }, snapshotPaths),
          observePaths2({ _type: "reference", _ref: publishedId }, snapshotPaths)
        ]).pipe(
          operators.map(([draftSnapshot, publishedSnapshot]) => {
            const type = isRecord$4(draftSnapshot) && "_type" in draftSnapshot && draftSnapshot._type || isRecord$4(publishedSnapshot) && "_type" in publishedSnapshot && publishedSnapshot._type || null;
            return {
              id: publishedId,
              type: typeof type == "string" ? type : null,
              draft: {
                availability: availability.draft,
                snapshot: draftSnapshot
              },
              published: {
                availability: availability.published,
                snapshot: publishedSnapshot
              }
            };
          })
        );
      })
    );
  }
}
function hasEqualFields(fields) {
  return (object, otherObject) => object === otherObject ? !0 : !object || !otherObject || typeof object != "object" || typeof otherObject != "object" ? !1 : fields.every((field) => object[field] === otherObject[field]);
}
const id = (value) => value;
function isUniqueBy(array, itemSelector = id) {
  let prevItem, currItem;
  for (let i = 0; i < array.length; i++) {
    if (i === 0) {
      prevItem = itemSelector(array[i]);
      continue;
    }
    if (currItem = itemSelector(array[i]), prevItem !== currItem)
      return !1;
    prevItem = currItem;
  }
  return !0;
}
function combineSelections(selections) {
  return values__default.default(
    selections.reduce((output, [id2, fields], index) => {
      const key = sortBy__default.default(fields.join(","), identity__default.default).join(".");
      output[key] || (output[key] = { fields, ids: [], map: [] });
      const idx = output[key].ids.length;
      return output[key].ids[idx] = id2, output[key].map[idx] = index, output;
    }, {})
  );
}
function stringifyId(id2) {
  return JSON.stringify(id2);
}
const maybeEscape = (fieldName) => fieldNeedsEscape(fieldName) ? `"${fieldName}": @${escapeField(fieldName)}` : fieldName;
function toSubQuery({ ids, fields }) {
  const allFields = [...INCLUDE_FIELDS_QUERY, ...fields];
  return `*[_id in [${ids.map(stringifyId).join(",")}]][0...${ids.length}]{${allFields.map(maybeEscape).join(",")}}`;
}
function toQuery(combinedSelections) {
  return `[${combinedSelections.map(toSubQuery).join(",")}][0...${combinedSelections.length}]`;
}
function reassemble(queryResult, combinedSelections) {
  return queryResult.reduce((reprojected, subResult, index) => (combinedSelections[index].map.forEach((resultIdx, i) => {
    const id2 = combinedSelections[index].ids[i], found = subResult.find((doc) => doc._id === id2);
    reprojected[resultIdx] = found || null;
  }), reprojected), []);
}
function create_preview_observeFields(context) {
  const { observePaths: observePaths2, versionedClient } = context;
  let _globalListener;
  const getGlobalEvents = () => {
    if (!_globalListener) {
      const allEvents$ = rxjs.from(
        versionedClient.listen(
          '*[!(_id in path("_.**"))]',
          {},
          {
            events: ["welcome", "mutation"],
            includeResult: !1,
            visibility: "query",
            tag: "preview.global"
          }
        )
      ).pipe(operators.share()), welcome$ = allEvents$.pipe(
        operators.filter((event) => event.type === "welcome"),
        operators.shareReplay({ refCount: !0, bufferSize: 1 })
      );
      welcome$.subscribe();
      const mutations$ = allEvents$.pipe(operators.filter((event) => event.type === "mutation"));
      _globalListener = {
        welcome$,
        mutations$
      };
    }
    return _globalListener;
  };
  function listen2(id2) {
    const globalEvents = getGlobalEvents();
    return rxjs.merge(
      globalEvents.welcome$,
      globalEvents.mutations$.pipe(operators.filter((event) => event.documentId === id2))
    );
  }
  function fetchAllDocumentPathsWith(client2) {
    return function(selections) {
      const combinedSelections = combineSelections(selections);
      return client2.observable.fetch(toQuery(combinedSelections), {}, { tag: "preview.document-paths" }).pipe(operators.map((result) => reassemble(result, combinedSelections)));
    };
  }
  const fetchDocumentPathsFast = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 100), fetchDocumentPathsSlow = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 1e3);
  function currentDatasetListenFields(id2, fields) {
    return listen2(id2).pipe(
      operators.switchMap((event) => event.type === "welcome" || event.visibility === "query" ? fetchDocumentPathsFast(id2, fields).pipe(
        operators.mergeMap((result) => rxjs.concat(
          rxjs.of(result),
          result === void 0 ? (
            // just been created and is not yet indexed. We therefore need to wait a bit
            // and then re-fetch.
            fetchDocumentPathsSlow(id2, fields)
          ) : []
        ))
      ) : fetchDocumentPathsSlow(id2, fields))
    );
  }
  const CACHE2 = {}, getBatchFetcherForDataset = memoize__default.default(
    function(apiConfig) {
      const client2 = versionedClient.withConfig(apiConfig), fetchAll = fetchAllDocumentPathsWith(client2);
      return debounceCollect(fetchAll, 10);
    },
    (apiConfig) => apiConfig.dataset + apiConfig.projectId
  ), CROSS_DATASET_PREVIEW_POLL_INTERVAL = 1e4, visiblePoll$ = rxjs.fromEvent(document, "visibilitychange").pipe(
    operators.startWith(0),
    operators.map(() => document.visibilityState === "visible"),
    operators.switchMap((visible) => visible ? rxjs.timer(0, CROSS_DATASET_PREVIEW_POLL_INTERVAL) : rxjs.EMPTY),
    operators.share()
  );
  function crossDatasetListenFields(id2, fields, apiConfig) {
    return visiblePoll$.pipe(operators.startWith(0)).pipe(
      operators.switchMap(() => getBatchFetcherForDataset(apiConfig)(id2, fields))
    );
  }
  function createCachedFieldObserver(id2, fields, apiConfig) {
    let latest = null;
    const changes$ = rxjs.merge(
      rxjs.defer(() => latest === null ? rxjs.EMPTY : rxjs.of(latest)),
      apiConfig ? crossDatasetListenFields(id2, fields, apiConfig) : currentDatasetListenFields(id2, fields)
    ).pipe(
      operators.tap((v) => latest = v),
      operators.shareReplay({ refCount: !0, bufferSize: 1 })
    );
    return { id: id2, fields, changes$ };
  }
  function cachedObserveFields(id2, fields, apiConfig) {
    const cacheKey = apiConfig ? `${apiConfig.projectId}:${apiConfig.dataset}:${id2}` : `$current$-${id2}`;
    cacheKey in CACHE2 || (CACHE2[cacheKey] = []);
    const existingObservers = CACHE2[cacheKey];
    difference__default.default(
      fields,
      flatten__default.default(existingObservers.map((cachedFieldObserver) => cachedFieldObserver.fields))
    ).length > 0 && existingObservers.push(createCachedFieldObserver(id2, fields, apiConfig));
    const cachedFieldObservers = existingObservers.filter((observer) => observer.fields.some((fieldName) => fields.includes(fieldName))).map((cached) => cached.changes$);
    return rxjs.combineLatest(cachedFieldObservers).pipe(
      // in the event that a document gets deleted, the cached values will be updated to store `undefined`
      // if this happens, we should not pick any fields from it, but rather just return null
      operators.map((snapshots) => snapshots.filter(Boolean)),
      // make sure all snapshots agree on same revision
      operators.filter((snapshots) => isUniqueBy(snapshots, (snapshot) => snapshot._rev)),
      // pass on value with the requested fields (or null if value is deleted)
      operators.map((snapshots) => snapshots.length === 0 ? null : pickFrom(snapshots, fields)),
      // emit values only if changed
      operators.distinctUntilChanged(hasEqualFields(fields))
    );
  }
  return { observeFields: cachedObserveFields };
  function pickFrom(objects, fields) {
    return [...INCLUDE_FIELDS, ...fields].reduce((result, fieldName) => {
      const value = getFirstFieldValue(objects, fieldName);
      return value !== void 0 && (result[fieldName] = value), result;
    }, {});
  }
  function getFirstFieldValue(objects, fieldName) {
    let value;
    return objects.some((object) => fieldName in object ? (value = object[fieldName], !0) : !1), value;
  }
}
function createDocumentPreviewStore({
  client: client2
}) {
  const versionedClient = client2.withConfig({ apiVersion: "1" }), __proxy_observePaths = (value, paths, apiConfig) => observePaths2(value, paths, apiConfig), { observeFields } = create_preview_observeFields({
    observePaths: __proxy_observePaths,
    versionedClient
  }), { observePaths: observePaths2 } = createPathObserver({ observeFields });
  function observeDocumentTypeFromId(id2, apiConfig) {
    return observePaths2({ _type: "reference", _ref: id2 }, ["_type"], apiConfig).pipe(
      operators.map((res) => isRecord$4(res) && typeof res._type == "string" ? res._type : void 0),
      operators.distinctUntilChanged()
    );
  }
  const observeForPreview = createPreviewObserver({ observeDocumentTypeFromId, observePaths: observePaths2 }), { observeDocumentPairAvailability } = create_preview_availability(
    versionedClient,
    observePaths2
  ), { observePathsDocumentPair } = create_preview_documentPair(versionedClient, observePaths2);
  return {
    observePaths: observePaths2,
    observeForPreview,
    observeDocumentTypeFromId,
    // eslint-disable-next-line camelcase
    unstable_observeDocumentPairAvailability: observeDocumentPairAvailability,
    unstable_observePathsDocumentPair: observePathsDocumentPair
  };
}
const isLiveEditEnabled$1 = (schemaType) => schemaType.liveEdit === !0;
function getPreviewStateObservable(documentPreviewStore, schemaType, documentId, title) {
  const draft$ = isLiveEditEnabled$1(schemaType) ? rxjs.of({ snapshot: null }) : documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getDraftId(documentId) },
    schemaType
  ), published$ = documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getPublishedId(documentId) },
    schemaType
  );
  return rxjs.combineLatest([draft$, published$]).pipe(
    operators.map(([draft, published]) => ({
      draft: draft.snapshot ? { title, ...draft.snapshot || {} } : null,
      isLoading: !1,
      published: published.snapshot ? { title, ...published.snapshot || {} } : null
    })),
    operators.startWith({ draft: null, isLoading: !0, published: null })
  );
}
const getMissingDocumentFallback = (item) => ({
  title: /* @__PURE__ */ jsxRuntime.jsx("em", { children: item.title ? String(item.title) : "Missing document" }),
  subtitle: /* @__PURE__ */ jsxRuntime.jsx("em", { children: item.title ? `Missing document ID: ${item._id}` : `Document ID: ${item._id}` }),
  media: () => /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
}), getPreviewValueWithFallback = ({
  value,
  draft,
  published
}) => {
  const snapshot = draft || published;
  return snapshot ? assignWith__default.default({}, snapshot, value, (objValue, srcValue) => typeof srcValue > "u" ? objValue : srcValue) : getMissingDocumentFallback(value);
}, useUserViaUserStore = createHookFromObservableFactory(
  ([userStore, userId]) => rxjs.from(
    userStore.getUser(userId).catch((err) => (console.error(err), null))
  )
);
function useUser(userId) {
  const userStore = useUserStore();
  return useUserViaUserStore(React.useMemo(() => [userStore, userId], [userId, userStore]));
}
function useCurrentUser() {
  const { currentUser } = useSource();
  return currentUser;
}
const getUpdatedSnapshot = (bufferedDocument) => {
  const LOCAL = bufferedDocument.LOCAL, HEAD = bufferedDocument.document.HEAD;
  return LOCAL && {
    ...LOCAL,
    _type: (HEAD || LOCAL)._type,
    _rev: (HEAD || LOCAL)._rev,
    _updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}, toSnapshotEvent = (document2) => ({ type: "snapshot", document: document2 }), getDocument = (event) => event.document, createObservableBufferedDocument = (listenerEvent$) => {
  const actions$ = new rxjs.Subject(), consistency$ = new rxjs.BehaviorSubject(!0), mutations$ = new rxjs.Subject(), rebase$ = new rxjs.Subject(), remoteMutations = new rxjs.Subject(), commitRequests = new rxjs.Subject(), createInitialBufferedDocument = (initialSnapshot) => {
    const bufferedDocument = new mutator.BufferedDocument(initialSnapshot);
    return bufferedDocument.onMutation = ({ mutation, remote }) => {
      mutations$.next({
        type: "mutation",
        document: getUpdatedSnapshot(bufferedDocument),
        mutations: mutation.mutations,
        origin: remote ? "remote" : "local"
      });
    }, bufferedDocument.onRemoteMutation = (mutation) => {
      remoteMutations.next({
        type: "remoteMutation",
        head: bufferedDocument.document.HEAD,
        transactionId: mutation.transactionId,
        timestamp: mutation.timestamp,
        author: mutation.identity,
        effects: mutation.effects
      });
    }, bufferedDocument.onRebase = (edge, nextRemoteMutations, localMutations) => {
      rebase$.next({
        type: "rebase",
        document: edge,
        remoteMutations: nextRemoteMutations,
        localMutations
      });
    }, bufferedDocument.onConsistencyChanged = (isConsistent) => {
      consistency$.next(isConsistent);
    }, bufferedDocument.commitHandler = (commitArg) => commitRequests.next(commitArg), bufferedDocument;
  }, currentBufferedDocument$ = listenerEvent$.pipe(
    operators.scan((bufferedDocument, listenerEvent) => listenerEvent.type === "snapshot" ? (bufferedDocument && bufferedDocument.commit(), createInitialBufferedDocument(listenerEvent.document || null)) : bufferedDocument === null ? (console.warn(
      'Ignoring event of type "%s" since buffered document has not yet been set up with snapshot',
      listenerEvent.type
    ), null) : bufferedDocument, null),
    operators.filter(
      (bufferedDocument) => bufferedDocument !== null
    ),
    operators.distinctUntilChanged(),
    operators.publishReplay(1),
    operators.refCount()
  ), snapshotAfterSync$ = listenerEvent$.pipe(
    operators.filter((ev) => ev.type === "mutation"),
    operators.withLatestFrom(currentBufferedDocument$),
    operators.map(([mutationEvent, bufferedDocument]) => (bufferedDocument.arrive(new mutator.Mutation(mutationEvent)), getUpdatedSnapshot(bufferedDocument)))
  ), actionHandler$ = actions$.pipe(
    operators.withLatestFrom(currentBufferedDocument$),
    operators.tap(([action, bufferedDocument]) => {
      action.type === "mutation" && bufferedDocument.add(new mutator.Mutation({ mutations: action.mutations })), action.type === "commit" && bufferedDocument.commit();
    }),
    // We subscribe to this only for the side effects
    operators.mergeMapTo(rxjs.EMPTY),
    operators.share()
  ), emitAction = (action) => actions$.next(action), addMutations = (mutations) => emitAction({ type: "mutation", mutations }), addMutation = (mutation) => addMutations([mutation]), commit2 = () => {
    currentBufferedDocument$.pipe(
      operators.take(1),
      operators.tap((bufferedDocument) => bufferedDocument.commit())
    ).subscribe();
  }, snapshot$ = rxjs.merge(
    currentBufferedDocument$.pipe(operators.map((bufferedDocument) => bufferedDocument.LOCAL)),
    mutations$.pipe(operators.map(getDocument)),
    rebase$.pipe(operators.map(getDocument)),
    snapshotAfterSync$
  ).pipe(operators.map(toSnapshotEvent), operators.publishReplay(1), operators.refCount()), remoteSnapshot$ = rxjs.merge(
    currentBufferedDocument$.pipe(
      operators.map((bufferedDocument) => bufferedDocument.document.HEAD),
      operators.map(toSnapshotEvent)
    ),
    remoteMutations
  ).pipe(operators.publishReplay(1), operators.refCount());
  return {
    updates$: rxjs.merge(snapshot$, actionHandler$, mutations$, rebase$),
    consistency$: consistency$.pipe(operators.distinctUntilChanged(), operators.publishReplay(1), operators.refCount()),
    remoteSnapshot$,
    commitRequest$: commitRequests,
    addMutation,
    addMutations,
    commit: commit2
  };
}, prepare = (id2) => (document2) => {
  const { _id, _rev, _updatedAt, ...rest } = document2;
  return { _id: id2, ...rest };
}, createBufferedDocument = (documentId, listenerEvent$) => {
  const bufferedDocument = createObservableBufferedDocument(listenerEvent$), prepareDoc = prepare(documentId), DELETE = { delete: { id: documentId } };
  return {
    events: bufferedDocument.updates$,
    consistency$: bufferedDocument.consistency$,
    remoteSnapshot$: bufferedDocument.remoteSnapshot$,
    commitRequest$: bufferedDocument.commitRequest$,
    patch: (patches) => patches.map((patch2) => ({ patch: { ...patch2, id: documentId } })),
    create: (document2) => ({ create: prepareDoc(document2) }),
    createIfNotExists: (document2) => ({ createIfNotExists: prepareDoc(document2) }),
    createOrReplace: (document2) => ({ createOrReplace: prepareDoc(document2) }),
    delete: () => DELETE,
    mutate: (mutations) => bufferedDocument.addMutations(mutations),
    commit: () => bufferedDocument.commit()
  };
}, PENDING_START = { type: "pending", phase: "begin" }, PENDING_END = { type: "pending", phase: "end" };
function isMutationEvent(msg) {
  return msg.type === "mutation";
}
function isMultiTransactionEvent(msg) {
  return msg.transactionTotalEvents > 1;
}
function allPendingTransactionEventsReceived(listenerEvents) {
  const groupedMutations = groupBy__default.default(
    listenerEvents.filter((ev) => ev.type === "mutation"),
    (e) => e.transactionId
  );
  return Object.values(groupedMutations).every(
    (mutations) => mutations.length === mutations[0].transactionTotalEvents
  );
}
function getPairListener(client2, idPair, options = {}) {
  const { publishedId, draftId } = idPair;
  return rxjs.defer(
    () => client2.observable.listen(
      "*[_id == $publishedId || _id == $draftId]",
      {
        publishedId,
        draftId
      },
      {
        includeResult: !1,
        events: ["welcome", "mutation", "reconnect"],
        effectFormat: "mendoza",
        tag: options.tag || "document.pair-listener"
      }
    )
  ).pipe(
    operators.concatMap(
      (event) => event.type === "welcome" ? fetchInitialDocumentSnapshots().pipe(
        operators.concatMap((snapshots) => [
          createSnapshotEvent(draftId, snapshots.draft),
          createSnapshotEvent(publishedId, snapshots.published)
        ])
      ) : rxjs.of(event)
    ),
    operators.scan(
      (acc, msg) => {
        if (!isMutationEvent(msg))
          return { next: [msg], buffer: [] };
        const isBuffering = acc.buffer.length > 0, isMulti = isMultiTransactionEvent(msg);
        if (!isMulti && !isBuffering)
          return { next: [msg], buffer: [] };
        if (!isMulti)
          return { next: [], buffer: acc.buffer.concat(msg) };
        const nextBuffer = acc.buffer.concat(msg);
        return allPendingTransactionEventsReceived(nextBuffer) ? { next: nextBuffer.concat(PENDING_END), buffer: [] } : { next: nextBuffer.length === 1 ? [PENDING_START] : [], buffer: nextBuffer };
      },
      { next: [], buffer: [] }
    ),
    // note: this flattens the array, and in the case of an empty array, no event will be pushed downstream
    operators.mergeMap((v) => v.next)
  );
  function fetchInitialDocumentSnapshots() {
    return client2.observable.getDocuments([draftId, publishedId], { tag: "document.snapshots" }).pipe(
      operators.map(([draft, published]) => ({
        draft,
        published
      }))
    );
  }
}
function createSnapshotEvent(documentId, document2) {
  return {
    type: "snapshot",
    documentId,
    document: document2
  };
}
const isMutationEventForDocId = (id2) => (event) => event.type !== "reconnect" && event.type !== "pending" && event.documentId === id2;
function setVersion(version) {
  return (ev) => ({ ...ev, version });
}
function commitMutations(client2, mutationParams) {
  const { resultRev, ...mutation } = mutationParams;
  return client2.dataRequest("mutate", mutation, {
    visibility: "async",
    returnDocuments: !1,
    tag: "document.commit",
    // This makes sure the studio doesn't crash when a draft is crated
    // because someone deleted a referenced document in the target dataset
    skipCrossDatasetReferenceValidation: !0
  });
}
function submitCommitRequest(client2, request) {
  return rxjs.from(commitMutations(client2, request.mutation.params)).pipe(
    operators.tap({
      error: (error) => {
        "statusCode" in error && typeof error.statusCode == "number" && error.statusCode >= 400 && error.statusCode <= 500 ? request.cancel(error) : request.failure(error);
      },
      next: () => request.success()
    })
  );
}
function checkoutPair(client2, idPair) {
  const { publishedId, draftId } = idPair, listenerEventsConnector = new rxjs.Subject(), listenerEvents$ = getPairListener(client2, idPair).pipe(
    operators.share({ connector: () => listenerEventsConnector })
  ), reconnect$ = listenerEvents$.pipe(
    operators.filter((ev) => ev.type === "reconnect")
  ), draft = createBufferedDocument(
    draftId,
    listenerEvents$.pipe(operators.filter(isMutationEventForDocId(draftId)))
  ), published = createBufferedDocument(
    publishedId,
    listenerEvents$.pipe(operators.filter(isMutationEventForDocId(publishedId)))
  ), transactionsPendingEvents$ = listenerEvents$.pipe(
    operators.filter((ev) => ev.type === "pending")
  ), commits$ = rxjs.merge(draft.commitRequest$, published.commitRequest$).pipe(
    operators.mergeMap((commitRequest) => submitCommitRequest(client2, commitRequest)),
    operators.mergeMapTo(rxjs.EMPTY),
    operators.share()
  );
  return {
    transactionsPendingEvents$,
    draft: {
      ...draft,
      events: rxjs.merge(commits$, reconnect$, draft.events).pipe(operators.map(setVersion("draft"))),
      consistency$: draft.consistency$,
      remoteSnapshot$: draft.remoteSnapshot$.pipe(operators.map(setVersion("draft")))
    },
    published: {
      ...published,
      events: rxjs.merge(commits$, reconnect$, published.events).pipe(operators.map(setVersion("published"))),
      consistency$: published.consistency$,
      remoteSnapshot$: published.remoteSnapshot$.pipe(operators.map(setVersion("published")))
    },
    complete: () => listenerEventsConnector.complete()
  };
}
function memoize(fn, keyGen) {
  const MEMO = /* @__PURE__ */ Object.create(null);
  return (...args) => {
    const key = keyGen(...args);
    return key in MEMO || (MEMO[key] = fn(...args)), MEMO[key];
  };
}
function memoizeKeyGen(client2, idPair, typeName) {
  var _a2, _b;
  const config = client2.config();
  return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
}
const memoizedPair = memoize(
  (client2, idPair, _typeName) => new rxjs.Observable((subscriber) => {
    const pair = checkoutPair(client2, idPair);
    return subscriber.next(pair), pair.complete;
  }).pipe(operators.publishReplay(1), operators.refCount()),
  memoizeKeyGen
);
function isSnapshotEvent(event) {
  return event.type === "snapshot";
}
function withSnapshots(pair) {
  return {
    snapshots$: pair.events.pipe(
      operators.filter(isSnapshotEvent),
      operators.map((event) => event.document),
      operators.publishReplay(1),
      operators.refCount()
    ),
    patch: pair.patch,
    create: pair.create,
    createIfNotExists: pair.createIfNotExists,
    createOrReplace: pair.createOrReplace,
    delete: pair.delete,
    mutate: pair.mutate,
    commit: pair.commit
  };
}
const snapshotPair = memoize(
  (client2, idPair, typeName) => memoizedPair(client2, idPair, typeName).pipe(
    operators.map(({ published, draft, transactionsPendingEvents$ }) => ({
      transactionsPendingEvents$,
      published: withSnapshots(published),
      draft: withSnapshots(draft)
    })),
    operators.publishReplay(1),
    operators.refCount()
  ),
  (client2, idPair, typeName) => {
    var _a2, _b;
    const config = client2.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
  }
), isLiveEditEnabled = (schema2, typeName) => {
  var _a2;
  return ((_a2 = schema2.get(typeName)) == null ? void 0 : _a2.liveEdit) === !0;
}, LOCKED = { enabled: !0 }, NOT_LOCKED = { enabled: !1 }, editState = memoize(
  (ctx, idPair, typeName) => {
    const liveEdit = isLiveEditEnabled(ctx.schema, typeName);
    return snapshotPair(ctx.client, idPair, typeName).pipe(
      operators.switchMap(
        (versions) => rxjs.combineLatest([
          versions.draft.snapshots$,
          versions.published.snapshots$,
          versions.transactionsPendingEvents$.pipe(
            operators.map((ev) => ev.phase === "begin" ? LOCKED : NOT_LOCKED),
            operators.startWith(NOT_LOCKED)
          )
        ])
      ),
      operators.map(([draftSnapshot, publishedSnapshot, transactionSyncLock]) => ({
        id: idPair.publishedId,
        type: typeName,
        draft: draftSnapshot,
        published: publishedSnapshot,
        liveEdit,
        ready: !0,
        transactionSyncLock
      })),
      operators.startWith({
        id: idPair.publishedId,
        type: typeName,
        draft: null,
        published: null,
        liveEdit,
        ready: !1,
        transactionSyncLock: null
      }),
      operators.publishReplay(1),
      operators.refCount()
    );
  },
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
), consistencyStatus = memoize(
  (client2, idPair, typeName) => memoizedPair(client2, idPair, typeName).pipe(
    operators.switchMap(
      ({ draft, published }) => rxjs.combineLatest([draft.consistency$, published.consistency$])
    ),
    operators.map(
      ([draftIsConsistent, publishedIsConsistent]) => draftIsConsistent && publishedIsConsistent
    ),
    operators.distinctUntilChanged(),
    operators.publishReplay(1),
    operators.refCount()
  ),
  (client2, idPair, typeName) => {
    var _a2, _b;
    const config = client2.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
  }
), operationArgs = memoize(
  (ctx, idPair, typeName) => snapshotPair(ctx.client, idPair, typeName).pipe(
    operators.switchMap(
      (versions) => rxjs.combineLatest([versions.draft.snapshots$, versions.published.snapshots$]).pipe(
        operators.map(
          ([draft, published]) => ({
            ...ctx,
            idPair,
            typeName,
            snapshots: { draft, published },
            draft: versions.draft,
            published: versions.published
          })
        )
      )
    ),
    operators.publishReplay(1),
    operators.refCount()
  ),
  (ctx, idPair, typeName) => {
    var _a2, _b;
    const config = ctx.client.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
  }
), commit = {
  disabled: () => !1,
  execute: ({ draft, published }) => (draft.commit(), published.commit(), rxjs.EMPTY)
}, del = {
  disabled: ({ snapshots }) => snapshots.draft || snapshots.published ? !1 : "NOTHING_TO_DELETE",
  execute: ({ client: client2, schema: schema2, idPair, typeName }) => {
    const tx = client2.observable.transaction().delete(idPair.publishedId);
    return isLiveEditEnabled(schema2, typeName) ? tx.commit({ tag: "document.delete" }) : tx.delete(idPair.draftId).commit({
      tag: "document.delete",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against deletes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "delete anyway" is clicked
      skipCrossDatasetReferenceValidation: !0
    });
  }
}, discardChanges = {
  disabled: ({ snapshots }) => snapshots.draft ? snapshots.published ? !1 : "NOT_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: client2, idPair }) => client2.observable.transaction().delete(idPair.draftId).commit({ tag: "document.discard-changes" })
}, omitProps = ["_createdAt", "_updatedAt"], duplicate = {
  disabled: ({ snapshots }) => snapshots.published || snapshots.draft ? !1 : "NOTHING_TO_DUPLICATE",
  execute: ({ schema: schema2, client: client2, snapshots, typeName }, dupeId) => {
    const source = snapshots.draft || snapshots.published;
    if (!source)
      throw new Error("cannot execute on empty document");
    return client2.observable.create(
      {
        ...omit__default.default(source, omitProps),
        _id: isLiveEditEnabled(schema2, typeName) ? dupeId : getDraftId(dupeId),
        _type: source._type
      },
      {
        tag: "document.duplicate"
      }
    );
  }
}, patch = {
  disabled: () => !1,
  execute: ({ schema: schema2, snapshots, idPair, draft, published, typeName }, patches = [], initialDocument) => {
    isLiveEditEnabled(schema2, typeName) ? published.mutate([
      published.createIfNotExists({
        _type: typeName,
        ...initialDocument
      }),
      ...published.patch(patches)
    ]) : draft.mutate([
      draft.createIfNotExists({
        ...initialDocument,
        ...snapshots.published,
        _id: idPair.draftId,
        _type: typeName
      }),
      ...draft.patch(patches)
    ]);
  }
};
function strengthenOnPublish(obj) {
  return types.isReference(obj) ? obj._strengthenOnPublish ? omit__default.default(
    obj,
    ["_strengthenOnPublish"].concat(obj._strengthenOnPublish.weak ? [] : ["_weak"])
  ) : obj : typeof obj != "object" || !obj ? obj : Array.isArray(obj) ? obj.map(strengthenOnPublish) : Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [key, strengthenOnPublish(value)])
  );
}
const publish = {
  disabled: ({ schema: schema2, typeName, snapshots }) => isLiveEditEnabled(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.draft ? !1 : snapshots.published ? "ALREADY_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: client2, idPair, snapshots }) => {
    if (!snapshots.draft)
      throw new Error('cannot execute "publish" when draft is missing');
    const value = strengthenOnPublish(omit__default.default(snapshots.draft, "_updatedAt")), tx = client2.observable.transaction();
    if (!snapshots.draft)
      throw new Error('cannot execute "publish" when draft is missing');
    return snapshots.published ? (tx.patch(idPair.publishedId, {
      // Hack until other mutations support revision locking
      unset: ["_revision_lock_pseudo_field_"],
      ifRevisionID: snapshots.published._rev
    }), tx.createOrReplace({
      ...value,
      _id: idPair.publishedId,
      _type: snapshots.draft._type
    })) : tx.create({
      ...value,
      _id: idPair.publishedId,
      _type: snapshots.draft._type
    }), tx.delete(idPair.draftId), tx.commit({ tag: "document.publish", visibility: "async" });
  }
}, restore$1 = {
  disabled: () => !1,
  execute: ({ historyStore, schema: schema2, idPair, typeName }, fromRevision) => {
    const targetId = isLiveEditEnabled(schema2, typeName) ? idPair.publishedId : idPair.draftId;
    return historyStore.restore(idPair.publishedId, targetId, fromRevision);
  }
}, unpublish = {
  disabled: ({ schema: schema2, snapshots, typeName }) => isLiveEditEnabled(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.published ? !1 : "NOT_PUBLISHED",
  execute: ({ client: client2, idPair, snapshots }) => {
    let tx = client2.observable.transaction().delete(idPair.publishedId);
    return snapshots.published && (tx = tx.createIfNotExists({
      ...omit__default.default(snapshots.published, "_updatedAt"),
      _id: idPair.draftId,
      _type: snapshots.published._type
    })), tx.commit({
      tag: "document.unpublish",
      visibility: "async",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against unpublishes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "unpublish anyway" is clicked
      skipCrossDatasetReferenceValidation: !0
    });
  }
};
function maybeObservable(v) {
  return typeof v > "u" ? rxjs.of(null) : v;
}
const operationImpls = {
  del,
  delete: del,
  publish,
  patch,
  commit,
  discardChanges,
  unpublish,
  duplicate,
  restore: restore$1
}, execute = (operationName, operationArguments, extraArgs) => {
  const operation = operationImpls[operationName];
  return rxjs.defer(
    () => rxjs.merge(rxjs.of(null), maybeObservable(operation.execute(operationArguments, ...extraArgs)))
  ).pipe(operators.last());
}, operationCalls$ = new rxjs.Subject();
function emitOperation(operationName, idPair, typeName, extraArgs) {
  operationCalls$.next({ operationName, idPair, typeName, extraArgs });
}
const REQUIRES_CONSISTENCY = ["publish", "unpublish", "discardChanges", "delete"], operationEvents = memoize(
  (ctx) => {
    const result$ = operationCalls$.pipe(
      operators.groupBy((op) => op.idPair.publishedId),
      operators.mergeMap(
        (groups$) => groups$.pipe(
          // although it might look like a bug, dropping pending async operations here is actually a feature
          // E.g. if the user types `publish` which is async and then starts patching (sync) then the publish
          // should be cancelled
          operators.switchMap(
            (args) => operationArgs(ctx, args.idPair, args.typeName).pipe(
              operators.take(1),
              operators.switchMap((operationArguments) => {
                const requiresConsistency = REQUIRES_CONSISTENCY.includes(args.operationName);
                requiresConsistency && (operationArguments.published.commit(), operationArguments.draft.commit());
                const isConsistent$ = consistencyStatus(
                  ctx.client,
                  args.idPair,
                  args.typeName
                ).pipe(operators.filter(Boolean));
                return (requiresConsistency ? isConsistent$.pipe(operators.take(1)) : rxjs.of(!0)).pipe(
                  operators.switchMap(() => execute(args.operationName, operationArguments, args.extraArgs))
                );
              }),
              operators.map(() => ({ type: "success", args })),
              operators.catchError(
                (err) => rxjs.of({ type: "error", args, error: err })
              )
            )
          )
        )
      ),
      operators.share()
    ), autoCommit$ = result$.pipe(
      operators.filter((result) => result.type === "success" && result.args.operationName === "patch"),
      operators.throttleTime(1e3, rxjs.asyncScheduler, { leading: !0, trailing: !0 }),
      operators.tap((result) => {
        emitOperation("commit", result.args.idPair, result.args.typeName, []);
      })
    );
    return rxjs.merge(result$, autoCommit$.pipe(operators.mergeMapTo(rxjs.EMPTY)));
  },
  (ctx) => {
    var _a2, _b;
    const config = ctx.client.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}`;
  }
), INITIAL_VALIDATION_STATUS = {
  isValidating: !0,
  validation: []
};
function findReferenceIds(obj) {
  return jsonReduce.reduce(
    obj,
    (acc, node) => (types.isReference(node) && acc.add(node._ref), acc),
    /* @__PURE__ */ new Set()
  );
}
const EMPTY_VALIDATION = [], listenDocumentExists = (observeDocumentAvailability, id2) => observeDocumentAvailability(id2).pipe(operators.map(({ published }) => published.available)), DOC_UPDATE_DELAY = 200, REF_UPDATE_DELAY = 1e3;
function shareLatestWithRefCount() {
  return operators.shareReplay({ bufferSize: 1, refCount: !0 });
}
const validation = memoize(
  (ctx, { draftId, publishedId }, typeName) => {
    const document$ = editState(ctx, { draftId, publishedId }, typeName).pipe(
      operators.map(({ draft, published }) => draft || published),
      operators.throttleTime(DOC_UPDATE_DELAY, rxjs.asyncScheduler, { trailing: !0 }),
      operators.distinctUntilChanged((prev, next) => (prev == null ? void 0 : prev._rev) === (next == null ? void 0 : next._rev) ? !0 : shallowEquals__default.default(omit__default.default(prev, "_rev", "_updatedAt"), omit__default.default(next, "_rev", "_updatedAt"))),
      shareLatestWithRefCount()
    ), referenceExistence$ = document$.pipe(
      operators.map((document2) => findReferenceIds(document2)),
      operators.mergeMap((ids) => rxjs.from(ids))
    ).pipe(
      operators.groupBy((id2) => id2, { duration: () => rxjs.timer(1e3 * 60 * 30) }),
      operators.mergeMap(
        (id$) => id$.pipe(
          operators.distinct(),
          operators.mergeMap(
            (id2) => listenDocumentExists(ctx.observeDocumentPairAvailability, id2).pipe(
              operators.map(
                // eslint-disable-next-line max-nested-callbacks
                (result) => [id2, result]
              )
            )
          )
        )
      ),
      operators.scan((acc, [id2, result]) => acc[id2] === result ? acc : { ...acc, [id2]: result }, {}),
      operators.distinctUntilChanged(shallowEquals__default.default),
      shareLatestWithRefCount()
    ), getDocumentExists = ({ id: id2 }) => rxjs.lastValueFrom(
      referenceExistence$.pipe(
        // If the id is not present as key in the `referenceExistence` map it means it's existence status
        // isn't yet loaded, so we want to wait until it is
        operators.first((referenceExistence) => id2 in referenceExistence),
        operators.map((referenceExistence) => referenceExistence[id2])
      )
    ), referenceDocumentUpdates$ = referenceExistence$.pipe(
      // we'll skip the first emission since the document already gets an initial validation pass
      // we're only interested in updates in referenced documents after that
      operators.skip(1),
      operators.throttleTime(REF_UPDATE_DELAY, rxjs.asyncScheduler, { leading: !0, trailing: !0 })
    );
    return rxjs.combineLatest([document$, rxjs.concat(rxjs.of(null), referenceDocumentUpdates$)]).pipe(
      operators.map(([document2]) => document2),
      rxjsExhaustmapWithTrailing.exhaustMapWithTrailing((document2) => rxjs.defer(() => document2 != null && document2._type ? rxjs.concat(
        rxjs.of({ isValidating: !0, revision: document2._rev }),
        validateDocumentObservable({
          document: document2,
          getClient: ctx.getClient,
          getDocumentExists,
          i18n: ctx.i18n,
          schema: ctx.schema,
          environment: "studio"
        }).pipe(
          operators.map((validationMarkers) => ({ validation: validationMarkers, isValidating: !1 }))
        )
      ) : rxjs.of({ validation: EMPTY_VALIDATION, isValidating: !1 }))),
      operators.scan((acc, next) => ({ ...acc, ...next }), INITIAL_VALIDATION_STATUS),
      shareLatestWithRefCount()
    );
  },
  (ctx, idPair, typeName) => {
    var _a2, _b;
    const config = ctx.client.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
  }
), documentEvents = memoize(
  (client2, idPair, typeName) => memoizedPair(client2, idPair, typeName).pipe(
    operators.switchMap(({ draft, published }) => rxjs.merge(draft.events, published.events))
  ),
  memoizeKeyGen
);
function createOperationGuard(opName) {
  return {
    disabled: "NOT_READY",
    execute: () => {
      throw new Error(`Called ${opName} before it was ready.`);
    }
  };
}
const GUARDED = {
  commit: createOperationGuard("commit"),
  delete: createOperationGuard("delete"),
  del: createOperationGuard("del"),
  publish: createOperationGuard("publish"),
  patch: createOperationGuard("patch"),
  discardChanges: createOperationGuard("discardChanges"),
  unpublish: createOperationGuard("unpublish"),
  duplicate: createOperationGuard("duplicate"),
  restore: createOperationGuard("restore")
}, createEmitter = (operationName, idPair, typeName) => (...executeArgs) => emitOperation(operationName, idPair, typeName, executeArgs);
function wrap(opName, op, operationArgs2) {
  return {
    disabled: op.disabled(operationArgs2),
    execute: createEmitter(opName, operationArgs2.idPair, operationArgs2.typeName)
  };
}
function createOperationsAPI(args) {
  return {
    commit: wrap("commit", commit, args),
    delete: wrap("delete", del, args),
    del: wrap("delete", del, args),
    publish: wrap("publish", publish, args),
    patch: wrap("patch", patch, args),
    discardChanges: wrap("discardChanges", discardChanges, args),
    unpublish: wrap("unpublish", unpublish, args),
    duplicate: wrap("duplicate", duplicate, args),
    restore: wrap("restore", restore$1, args)
  };
}
const editOperations = memoize(
  (ctx, idPair, typeName) => {
    const operationEvents$ = operationEvents(ctx), operations$ = operationArgs(ctx, idPair, typeName).pipe(operators.map(createOperationsAPI));
    return rxjs.concat(
      rxjs.of(GUARDED),
      rxjs.merge(operationEvents$.pipe(operators.mergeMap(() => rxjs.EMPTY)), operations$)
    ).pipe(operators.shareReplay({ refCount: !0, bufferSize: 1 }));
  },
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
);
function isRecord(value) {
  return isPlainObject__default.default(value);
}
function deepAssign(target, source) {
  const result = { ...target, ...source };
  return Object.keys(result).forEach((key) => {
    const sourceVal = source[key], targetVal = target[key];
    isRecord(sourceVal) && isRecord(targetVal) && (result[key] = deepAssign(targetVal, sourceVal));
  }), result;
}
const ALLOWED_REF_PROPS = [
  "_dataset",
  "_projectId",
  "_strengthenOnPublish",
  "_key",
  "_ref",
  "_type",
  "_weak"
], REQUIRED_TEMPLATE_PROPS = ["id", "title", "schemaType", "value"];
function templateId(template, i) {
  return quote(template.id || template.title) || typeof i == "number" && `at index ${i}` || "";
}
function quote(str) {
  return str && str.length > 0 ? `"${str}"` : str;
}
function validateTemplates(schema2, templates) {
  const idMap = /* @__PURE__ */ new Map();
  return templates.forEach((template, i) => {
    const id2 = templateId(template, i);
    if (typeof template.values < "u" && !template.value)
      throw new Error(`Template ${id2} is missing "value" property, but contained "values". Typo?`);
    const missing = REQUIRED_TEMPLATE_PROPS.filter((prop) => !template[prop]);
    if (missing.length > 0)
      throw new Error(`Template ${id2} is missing required properties: ${missing.join(", ")}`);
    if (typeof template.value != "function" && !isRecord(template.value))
      throw new Error(
        `Template ${id2} has an invalid "value" property; should be a function or an object`
      );
    if (typeof template.parameters < "u")
      if (Array.isArray(template.parameters))
        template.parameters.forEach((param, j) => validateParameter(schema2, param, template, j));
      else
        throw new Error(`Template ${id2} has an invalid "parameters" property; must be an array`);
    if (idMap.has(template.id)) {
      const dupeIndex = idMap.get(template.id), dupe = `${quote(templates[dupeIndex].title)} at index ${dupeIndex}`;
      throw new Error(
        `Template "${template.title}" at index ${i} has the same ID ("${template.id}") as template ${dupe}`
      );
    }
    idMap.set(template.id, i);
  }), templates;
}
function validateInitialObjectValue(value, template) {
  const contextError = (msg) => `Template "${template.id}" initial value: ${msg}`;
  if (!isRecord(value))
    throw new Error(contextError("resolved to a non-object"));
  if (value._type && template.schemaType !== value._type)
    throw new Error(
      contextError(
        `includes "_type"-property (${value._type}) that does not match template (${template.schemaType})`
      )
    );
  try {
    return validateValue(value);
  } catch (err) {
    throw err.message = contextError(err.message), err;
  }
}
function validateValue(value, path = [], parentIsArray = !1) {
  if (Array.isArray(value))
    return value.map((item, i) => {
      if (Array.isArray(item))
        throw new Error(
          `multidimensional arrays are not supported (at path "${PathUtils.toString(path)}")`
        );
      return validateValue(item, path.concat(i), !0);
    });
  if (!isRecord(value))
    return value;
  const initial = parentIsArray && !value._key ? { _key: content.randomKey() } : {};
  return path.length > 0 && !value._type && value._ref && (initial._type = "reference"), value._ref && validateReference(value, path), Object.keys(value).reduce((acc, key) => (acc[key] = validateValue(value[key], path.concat([key])), acc), initial);
}
function validateParameter(schema2, parameter, template, index) {
  if (!parameter.name)
    throw new Error(
      `Template ${template.id} has a parameter at index ${index} that is missing its "name"-property`
    );
  if (parameter.name === "template")
    throw new Error(
      `Template parameters cannot be named "template", see parameter #${index} for template ${template.id}`
    );
  if (!schema2.get(parameter.type))
    throw new Error(
      `Template parameter "${parameter.name}" has an invalid/unknown type: "${parameter.type}"`
    );
}
function validateReference(value, path = []) {
  if (!value._type && value.type)
    throw new Error(
      `Reference is missing "_type", but has a "type" property at path "${PathUtils.toString(path)}"`
    );
  const disallowed = Object.keys(value).filter((key) => !ALLOWED_REF_PROPS.includes(key));
  if (disallowed.length > 0) {
    const plural = disallowed.length > 1 ? "properties" : "property";
    throw new Error(
      `Disallowed ${plural} found in reference: ${disallowed.map(quote).join(", ")} at path "${PathUtils.toString(path)}"`
    );
  }
}
function isBuilder(template) {
  return isRecord(template) && typeof template.serialize == "function";
}
async function resolveValue(initialValueOpt, params, context) {
  return typeof initialValueOpt == "function" ? initialValueOpt(params, context) : initialValueOpt;
}
async function resolveInitialValue(schema2, template, params = {}, context) {
  if (isBuilder(template))
    return resolveInitialValue(schema2, template.serialize(), params, context);
  const { id: id2, schemaType: schemaTypeName, value } = template;
  if (!value)
    throw new Error(`Template "${id2}" has invalid "value" property`);
  let resolvedValue = await resolveValue(value, params, context);
  if (!isRecord(resolvedValue))
    throw new Error(
      `Template "${id2}" has invalid "value" property - must be a plain object or a resolver function returning a plain object`
    );
  isRecord(resolvedValue) && !Object.keys(resolvedValue).length && (resolvedValue = { _type: schemaTypeName }), resolvedValue = validateInitialObjectValue(resolvedValue, template);
  const schemaType = schema2.get(schemaTypeName);
  if (!schemaType)
    throw new Error(`Could not find schema type with name "${schemaTypeName}".`);
  const newValue = deepAssign(
    await resolveInitialValueForType(schemaType, params, DEFAULT_MAX_RECURSION_DEPTH, context) || {},
    resolvedValue
  );
  return validateInitialObjectValue(newValue, template);
}
function getItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
const DEFAULT_MAX_RECURSION_DEPTH = 10;
function resolveInitialValueForType(type, params, maxDepth = DEFAULT_MAX_RECURSION_DEPTH, context) {
  return maxDepth <= 0 ? Promise.resolve(void 0) : types.isObjectSchemaType(type) ? resolveInitialObjectValue(type, params, maxDepth, context) : types.isArraySchemaType(type) ? resolveInitialArrayValue(type, params, maxDepth, context) : resolveValue(type.initialValue, params, context);
}
async function resolveInitialArrayValue(type, params, maxDepth, context) {
  const initialArray = await resolveValue(type.initialValue, void 0, context);
  if (Array.isArray(initialArray))
    return Promise.all(
      initialArray.map(async (initialItem) => {
        const itemType = getItemType(type, initialItem);
        return types.isObjectSchemaType(itemType) ? {
          ...initialItem,
          ...await resolveInitialValueForType(itemType, params, maxDepth - 1, context),
          _key: content.randomKey()
        } : initialItem;
      })
    );
}
async function resolveInitialObjectValue(type, params, maxDepth, context) {
  const initialObject = {
    ...await resolveValue(type.initialValue, params, context) || {}
  }, fieldValues = {};
  await Promise.all(
    type.fields.map(async (field) => {
      const initialFieldValue = await resolveInitialValueForType(
        field.type,
        params,
        maxDepth - 1,
        context
      );
      initialFieldValue != null && (fieldValues[field.name] = initialFieldValue);
    })
  );
  const merged = deepAssign(fieldValues, initialObject);
  if (!content.isDeepEmpty(merged))
    return type.name !== "object" && (merged._type = type.name), merged;
}
const LOADING_MSG = { type: "loading" };
function getInitialValueStream(schema2, initialValueTemplates, documentPreviewStore, opts, context) {
  const draft$ = documentPreviewStore.observePaths(
    { _type: "reference", _ref: getDraftId(opts.documentId) },
    ["_type"]
  ), published$ = documentPreviewStore.observePaths(
    { _type: "reference", _ref: getPublishedId(opts.documentId) },
    ["_type"]
  );
  return rxjs.merge(
    draft$.pipe(operators.map((draft) => ({ draft }))),
    published$.pipe(operators.map((published) => ({ published })))
  ).pipe(
    operators.scan((prev, res) => ({ ...prev, ...res }), {}),
    // Wait until we know the state of both draft and published
    operators.filter((res) => "draft" in res && "published" in res),
    operators.map((res) => res.draft || res.published),
    // Only update if we didn't previously have a document but we now do
    operators.distinctUntilChanged((prev, next) => !!prev != !!next),
    // Prevent rapid re-resolving when transitioning between different templates
    operators.debounceTime(25)
  ).pipe(
    operators.switchMap((document2) => {
      if (document2)
        return rxjs.of({ type: "success", value: null });
      if (!opts.templateName)
        return rxjs.of({ isResolving: !1, initialValue: void 0 });
      const template = initialValueTemplates.find((t2) => t2.id === opts.templateName);
      if (!template)
        return console.warn('Template "%s" not defined, using empty initial value', opts.templateName), rxjs.of({ isResolving: !1, initialValue: void 0 });
      const initialValueWithParams$ = rxjs.from(
        resolveInitialValue(schema2, template, opts.templateParams, context)
      ).pipe(operators.map((initialValue) => ({ isResolving: !1, initialValue }))).pipe(
        operators.catchError((resolveError) => (console.group("Failed to resolve initial value"), console.error(resolveError), console.error("Template ID: %s", opts.templateName), console.error("Parameters: %o", opts.templateParams), console.groupEnd(), rxjs.of({ type: "error", error: resolveError })))
      );
      return rxjs.merge(rxjs.of({ isResolving: !0 }), initialValueWithParams$).pipe(
        operators.switchMap(({ isResolving, initialValue, resolveError }) => resolveError ? rxjs.of({ type: "error", message: "Failed to resolve initial value" }) : isResolving ? rxjs.of(LOADING_MSG) : rxjs.of({ type: "success", value: initialValue }))
      );
    }),
    operators.startWith(LOADING_MSG),
    operators.distinctUntilChanged()
  );
}
const fetch$1 = (client2, query, params, options) => rxjs.defer(
  () => client2.observable.fetch(query, params, {
    tag: options.tag,
    filterResponse: !0,
    perspective: options.perspective
  })
), listen = (client2, query, params, options) => rxjs.defer(
  () => client2.listen(query, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: !1,
    visibility: "query",
    tag: options.tag
  })
);
function isWelcomeEvent(event) {
  return event.type === "welcome";
}
function listenQuery(client2, query, params = {}, options = {}) {
  const fetchQuery = typeof query == "string" ? query : query.fetch, listenerQuery = typeof query == "string" ? query : query.listen, events$ = listen(client2, listenerQuery, params, options).pipe(
    operators.mergeMap((ev, i) => i === 0 && !isWelcomeEvent(ev) ? rxjs.throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : rxjs.of(ev)),
    operators.share()
  ), [welcome$, mutationAndReconnect$] = rxjs.partition(events$, isWelcomeEvent), isRelevantEvent = (event) => !options.transitions || event.type !== "mutation" ? !0 : options.transitions.includes(event.transition), doFetch = () => fetch$1(client2, fetchQuery, params, options);
  return rxjs.merge(
    welcome$.pipe(operators.take(1)),
    mutationAndReconnect$.pipe(
      operators.filter(isRelevantEvent),
      operators.throttleTime(options.throttleTime || 1e3, rxjs.asyncScheduler, { leading: !0, trailing: !0 })
    )
  ).pipe(
    rxjsExhaustmapWithTrailing.exhaustMapWithTrailing((event) => event.type === "mutation" && event.visibility !== "query" ? rxjs.timer(1200).pipe(operators.mergeMap(doFetch)) : doFetch())
  );
}
function resolveTypeForDocument(client2, id2, specifiedType = "*") {
  if (specifiedType && specifiedType !== "*")
    return rxjs.of(specifiedType);
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = getPublishedId(id2), draftId = getDraftId(documentId);
  return client2.observable.fetch(query, { documentId, draftId }).pipe(operators.map((types2) => types2[0]));
}
function getIdPairFromPublished(publishedId) {
  if (isDraftId(publishedId))
    throw new Error("editOpsOf does not expect a draft id.");
  return { publishedId, draftId: getDraftId(publishedId) };
}
function createDocumentStore({
  getClient,
  documentPreviewStore,
  historyStore,
  initialValueTemplates,
  schema: schema2,
  i18n
}) {
  const observeDocumentPairAvailability = documentPreviewStore.unstable_observeDocumentPairAvailability, client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), ctx = { client: client2, getClient, observeDocumentPairAvailability, historyStore, schema: schema2, i18n };
  return {
    // Public API
    checkoutPair(idPair) {
      return checkoutPair(client2, idPair);
    },
    initialValue(opts, context) {
      return getInitialValueStream(
        schema2,
        initialValueTemplates,
        documentPreviewStore,
        opts,
        context
      );
    },
    listenQuery(query, params, options) {
      return listenQuery(client2, query, params, options);
    },
    resolveTypeForDocument(id2, specifiedType) {
      return resolveTypeForDocument(client2, id2, specifiedType);
    },
    pair: {
      consistencyStatus(publishedId, type) {
        return consistencyStatus(ctx.client, getIdPairFromPublished(publishedId), type);
      },
      documentEvents(publishedId, type) {
        return documentEvents(ctx.client, getIdPairFromPublished(publishedId), type);
      },
      editOperations(publishedId, type) {
        return editOperations(ctx, getIdPairFromPublished(publishedId), type);
      },
      editState(publishedId, type) {
        return editState(ctx, getIdPairFromPublished(publishedId), type);
      },
      operationEvents(publishedId, type) {
        return operationEvents({ client: client2, historyStore, schema: schema2 }).pipe(
          operators.filter(
            (result) => result.args.idPair.publishedId === publishedId && result.args.typeName === type
          ),
          operators.map((result) => {
            const { operationName, idPair: documentIds } = result.args;
            return result.type === "success" ? { type: "success", op: operationName, id: documentIds.publishedId } : { type: "error", op: operationName, id: documentIds.publishedId, error: result.error };
          })
        );
      },
      validation(publishedId, type) {
        return validation(ctx, getIdPairFromPublished(publishedId), type);
      }
    }
  };
}
function useDocumentValues(documentId, paths) {
  const documentPreviewStore = useDocumentPreviewStore(), documentValues$ = React.useMemo(
    () => documentId ? documentPreviewStore.observePaths(
      { _type: "reference", _ref: documentId },
      paths
    ) : rxjs.of(void 0),
    [documentId, documentPreviewStore, paths]
  );
  return useLoadable(documentValues$);
}
function useInitialValue(props2) {
  const { documentId, documentType, templateName, templateParams: templateParamsRaw } = props2, templateParams = useUnique(templateParamsRaw), documentStore = useDocumentStore(), context = useInitialValueResolverContext(), defaultValue2 = React.useMemo(
    () => ({ _id: documentId, _type: documentType }),
    [documentId, documentType]
  ), [state, setState] = React.useState({
    loading: !1,
    error: null,
    value: defaultValue2
  });
  return React.useEffect(() => {
    const initialValueOptions = { documentId, documentType, templateName, templateParams };
    if (!templateName) {
      setState({ loading: !0, error: null, value: defaultValue2 });
      return;
    }
    const sub = documentStore.initialValue(initialValueOptions, context).subscribe((msg) => {
      msg.type === "loading" && setState({ loading: !0, error: null, value: defaultValue2 }), msg.type === "success" && setState({
        loading: !1,
        error: null,
        value: msg.value ? { ...defaultValue2, ...msg.value } : defaultValue2
      }), msg.type === "error" && setState({ loading: !1, error: msg.error, value: defaultValue2 });
    });
    return setState({ loading: !0, error: null, value: defaultValue2 }), () => sub.unsubscribe();
  }, [defaultValue2, documentId, documentStore, documentType, templateName, templateParams, context]), state;
}
function useInitialValueResolverContext() {
  const source = useSource(), schema2 = useSchema(), currentUser = useCurrentUser(), projectId = useProjectId(), dataset = useDataset(), getClient = source.getClient;
  return React.useMemo(() => ({
    projectId,
    dataset,
    getClient,
    schema: schema2,
    currentUser
  }), [getClient, schema2, currentUser, projectId, dataset]);
}
function useResolveInitialValueForType() {
  const initialValueContext = useInitialValueResolverContext();
  return React.useCallback(
    (type, params) => resolveInitialValueForType(
      type,
      params,
      DEFAULT_MAX_RECURSION_DEPTH,
      initialValueContext
    ),
    [initialValueContext]
  );
}
function getSchemaType(schema2, typeName) {
  const type = schema2.get(typeName);
  if (!type)
    throw new Error(`No such schema type: ${typeName}`);
  return type;
}
function getPairPermissions({
  grantsStore,
  permission,
  draft,
  published,
  liveEdit
}) {
  const effectiveVersion = draft || published, effectiveVersionType = effectiveVersion === draft ? "draft" : "published", { checkDocumentPermission } = grantsStore;
  switch (permission) {
    case "delete":
      return liveEdit ? [
        ["delete published document (live-edit)", checkDocumentPermission("update", published)]
      ] : [
        ["delete draft document", checkDocumentPermission("update", draft)],
        ["delete published document", checkDocumentPermission("update", published)]
      ];
    case "discardDraft":
      return liveEdit ? [] : [["delete draft document", checkDocumentPermission("update", draft)]];
    case "publish":
      return liveEdit ? [] : [
        // precondition
        [
          "update published document at its current state",
          checkDocumentPermission("update", published)
        ],
        // post condition
        ["delete draft document", checkDocumentPermission("update", draft)],
        [
          "create published document from draft",
          checkDocumentPermission("create", draft && { ...draft, _id: getPublishedId(draft._id) })
        ]
      ];
    case "unpublish":
      return liveEdit ? [] : [
        // precondition
        ["update draft document at its current state", checkDocumentPermission("create", draft)],
        // post condition
        ["delete published document", checkDocumentPermission("update", published)],
        [
          "create draft document from published version",
          checkDocumentPermission(
            "create",
            published && { ...published, _id: getDraftId(published._id) }
          )
        ]
      ];
    case "update":
      return liveEdit ? [
        ["update published document (live-edit)", checkDocumentPermission("update", published)]
      ] : [
        [
          `update ${effectiveVersionType} document`,
          checkDocumentPermission("update", effectiveVersion)
        ]
      ];
    case "duplicate":
      return liveEdit ? [
        [
          "create new published document from existing document (live-edit)",
          checkDocumentPermission("create", { ...published, _id: "dummy-id" })
        ]
      ] : [
        [
          `create new draft document from existing ${effectiveVersionType} document`,
          checkDocumentPermission("create", { ...effectiveVersion, _id: getDraftId("dummy-id") })
        ]
      ];
    default:
      throw new Error(`Could not match permission: ${permission}`);
  }
}
function getDocumentPairPermissions({
  client: client2,
  grantsStore,
  schema: schema2,
  id: id2,
  permission,
  type
}) {
  if (type === "*")
    return rxjs.of({ granted: !1, reason: "Type specified was `*`" });
  const liveEdit = !!getSchemaType(schema2, type).liveEdit;
  return snapshotPair(
    client2,
    { draftId: getDraftId(id2), publishedId: getPublishedId(id2) },
    type
  ).pipe(
    operators.switchMap(
      (pair) => rxjs.combineLatest([pair.draft.snapshots$, pair.published.snapshots$]).pipe(
        operators.map(([draft, published]) => ({ draft, published }))
      )
    ),
    operators.switchMap(({ draft, published }) => {
      const pairPermissions = getPairPermissions({
        grantsStore,
        permission,
        draft,
        published,
        liveEdit
      }).map(
        ([label, observable]) => observable.pipe(
          operators.map(({ granted, reason }) => ({
            granted,
            reason: granted ? "" : `not allowed to ${label}: ${reason}`,
            label,
            permission
          }))
        )
      );
      return pairPermissions.length ? rxjs.combineLatest(pairPermissions).pipe(
        operators.map((permissionResults) => {
          const granted = permissionResults.every((permissionResult) => permissionResult.granted), reason = granted ? "" : `Unable to ${permission}:
	${permissionResults.filter((permissionResult) => !permissionResult.granted).map((permissionResult) => permissionResult.reason).join(`
	`)}`;
          return { granted, reason };
        })
      ) : rxjs.of({ granted: !0, reason: "" });
    })
  );
}
const useDocumentPairPermissionsFromHookFactory = createHookFromObservableFactory(
  getDocumentPairPermissions
);
function useDocumentPairPermissions({
  id: id2,
  type,
  permission,
  client: overrideClient,
  schema: overrideSchema,
  grantsStore: overrideGrantsStore
}) {
  const defaultClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), defaultSchema = useSchema(), defaultGrantsStore = useGrantsStore(), client2 = React.useMemo(() => overrideClient || defaultClient, [defaultClient, overrideClient]), schema2 = React.useMemo(() => overrideSchema || defaultSchema, [defaultSchema, overrideSchema]), grantsStore = React.useMemo(
    () => overrideGrantsStore || defaultGrantsStore,
    [defaultGrantsStore, overrideGrantsStore]
  );
  return useDocumentPairPermissionsFromHookFactory(
    React.useMemo(
      () => ({ client: client2, schema: schema2, grantsStore, id: id2, permission, type }),
      [client2, grantsStore, id2, permission, schema2, type]
    )
  );
}
function getDocumentValuePermissions({
  grantsStore,
  document: document2,
  permission
}) {
  const { checkDocumentPermission } = grantsStore;
  return checkDocumentPermission(permission, document2);
}
const useDocumentValuePermissionsFromHookFactory = createHookFromObservableFactory(
  getDocumentValuePermissions
);
function useDocumentValuePermissions({
  document: document2,
  permission,
  ...rest
}) {
  const grantsStore = useGrantsStore();
  return useDocumentValuePermissionsFromHookFactory({
    grantsStore: rest.grantsStore || grantsStore,
    document: document2,
    permission
  });
}
const DEBUG_PREFIX = "_debug_", hashchange$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "hashchange"), debugParams$ = rxjs.concat(rxjs.of(0), hashchange$).pipe(
  operators.map(() => typeof document > "u" ? "#" : document.location.hash),
  operators.distinctUntilChanged(),
  operators.map(
    (hash2) => hash2.substring(1).split(";").filter((p) => p.toLowerCase().startsWith(DEBUG_PREFIX)).map((param) => param.substring(DEBUG_PREFIX.length))
  )
), debugRolesParam$ = debugParams$.pipe(
  operators.map((args) => args.find((arg) => arg.startsWith("roles="))),
  operators.map(
    (arg) => (arg == null ? void 0 : arg.split("roles=")[1].split(",").map((r) => r.trim())) || []
  )
), administrator = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], editor = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], developer = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], contributor = [
  {
    filter: '_id in path("**")',
    permissions: ["read"]
  },
  {
    filter: '_id in path("drafts.**")',
    permissions: ["create", "history", "update"]
  }
], viewer = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "history"]
  }
], requiresApproval = [
  {
    filter: "!locked",
    permissions: ["read", "create", "update"]
  }
], restricted = [
  {
    filter: '_id in path("drafts.**") && _type in ["stringsTest", "book", "author", "referenceTest"]',
    permissions: ["read", "create", "history", "update"]
  },
  {
    filter: '_id in path("**")',
    permissions: ["read"]
  }
], DEBUG_ROLE_GRANTS_MAP = {
  // basic
  administrator,
  editor,
  developer,
  contributor,
  viewer,
  // custom
  restricted,
  requiresApproval,
  // legacy
  read: viewer,
  write: editor
}, debugGrants$ = debugRolesParam$.pipe(
  operators.map((roles) => roles.length ? roles.filter((value) => !!value && value in DEBUG_ROLE_GRANTS_MAP).flatMap((roleName) => DEBUG_ROLE_GRANTS_MAP[roleName] || []) : null)
);
async function getDatasetGrants(client2, projectId, dataset) {
  return await client2.request({
    uri: `/projects/${projectId}/datasets/${dataset}/acl`,
    tag: "acl.get",
    withCredentials: !0
  });
}
function getParams(userId) {
  const params = {};
  return userId !== null && (params.identity = userId), params;
}
const PARSED_FILTERS_MEMO = /* @__PURE__ */ new Map();
async function matchesFilter(userId, filter, document2) {
  PARSED_FILTERS_MEMO.has(filter) || PARSED_FILTERS_MEMO.set(filter, groqJs.parse(`*[${filter}]`));
  const parsed = PARSED_FILTERS_MEMO.get(filter), evalParams = getParams(userId), { identity: identity2 } = evalParams, params = { ...evalParams }, data = await (await groqJs.evaluate(parsed, { dataset: [document2], identity: identity2, params })).get();
  return (data == null ? void 0 : data.length) === 1;
}
function createGrantsStore(opts) {
  var _a2;
  const { client: client2 } = opts, versionedClient = client2.withConfig({ apiVersion: "2021-06-07" }), userId = "userId" in opts ? opts.userId : ((_a2 = opts == null ? void 0 : opts.currentUser) == null ? void 0 : _a2.id) || null, datasetGrants$ = rxjs.defer(() => rxjs.of(versionedClient.config())).pipe(
    operators.switchMap(({ projectId, dataset }) => {
      if (!projectId || !dataset)
        throw new Error("Missing projectId or dataset");
      return getDatasetGrants(versionedClient, projectId, dataset);
    })
  ), currentUserDatasetGrants = debugGrants$.pipe(
    operators.switchMap((debugGrants) => debugGrants ? rxjs.of(debugGrants) : datasetGrants$),
    operators.publishReplay(1),
    operators$1.refCountDelay(1e3)
  );
  return {
    checkDocumentPermission(permission, document2) {
      return currentUserDatasetGrants.pipe(
        operators.switchMap((grants) => grantsPermissionOn(userId, grants, permission, document2)),
        operators.distinctUntilChanged(shallowEquals__default.default)
      );
    }
  };
}
async function grantsPermissionOn(userId, grants, permission, document2) {
  if (!document2)
    return { granted: !0, reason: "Null document, nothing to check" };
  if (!grants.length)
    return { granted: !1, reason: "No document grants" };
  const matchingGrants = [];
  for (const grant of grants)
    await matchesFilter(userId, grant.filter, document2) && matchingGrants.push(grant);
  const foundMatch = matchingGrants.some((grant) => grant.permissions.some((p) => p === permission));
  return {
    granted: foundMatch,
    reason: foundMatch ? "Matching grant" : "No matching grants found"
  };
}
function serialize(item) {
  return typeof item == "object" && item !== null && "serialize" in item ? serialize(item.serialize()) : item;
}
function getTemplatePermissions({
  grantsStore,
  templateItems,
  templates,
  schema: schema2,
  context
}) {
  return templateItems != null && templateItems.length ? rxjs.combineLatest(
    templateItems.map(serialize).map(async (item) => {
      const template = templates.find((t2) => t2.id === item.templateId);
      if (!template)
        throw new Error(`template not found: "${item.templateId}"`);
      const resolvedInitialValue = await resolveInitialValue(
        schema2,
        template,
        item.parameters,
        context
      );
      return { template, item, resolvedInitialValue };
    }).map(
      (promise) => rxjs.from(promise).pipe(
        operators.switchMap(({ item, resolvedInitialValue, template }) => {
          const schemaType = schema2.get(template.schemaType);
          if (!schemaType)
            throw new Error(`schema type not found: "${template.schemaType}"`);
          const liveEdit = schemaType == null ? void 0 : schemaType.liveEdit, { initialDocumentId = "dummy-id" } = item;
          return getDocumentValuePermissions({
            grantsStore,
            permission: "create",
            document: {
              _id: liveEdit ? getPublishedId(initialDocumentId) : getDraftId(initialDocumentId),
              ...resolvedInitialValue
            }
          }).pipe(
            operators.map(({ granted, reason }) => {
              const title = item.title || template.title;
              return {
                ...item,
                i18n: item.i18n || template.i18n,
                granted,
                reason,
                resolvedInitialValue,
                template,
                title,
                subtitle: schemaType.title === title ? void 0 : schemaType.title,
                description: item.description || template.description,
                icon: item.icon || template.icon
              };
            })
          );
        })
      )
    )
  ) : rxjs.of([]);
}
const useTemplatePermissionsFromHookFactory = createHookFromObservableFactory(getTemplatePermissions);
function useTemplatePermissions({
  templateItems,
  ...rest
}) {
  const schema2 = useSchema(), templates = useTemplates(), grantsStore = useGrantsStore(), initialValueContext = useInitialValueResolverContext();
  return useTemplatePermissionsFromHookFactory({
    templateItems,
    grantsStore: rest.grantsStore || grantsStore,
    schema: rest.schema || schema2,
    templates: rest.templates || templates,
    context: initialValueContext
  });
}
function canMergeEdit(type) {
  return type === "create" || type === "editDraft";
}
const CHUNK_WINDOW = 5 * 60 * 1e3;
function isWithinMergeWindow(a, b) {
  return Date.parse(b) - Date.parse(a) < CHUNK_WINDOW;
}
function mergeChunk(left, right) {
  if (left.end !== right.start)
    throw new Error("chunks are not next to each other");
  const draftState = combineState(left.draftState, right.draftState), publishedState = combineState(left.publishedState, right.publishedState);
  if (left.type === "delete" && right.type === "editDraft")
    return [left, { ...right, type: "create", draftState, publishedState }];
  if (right.type === "delete") {
    if (draftState === "missing" && publishedState === "present")
      return [left, { ...right, type: "discardDraft", draftState, publishedState }];
    if (draftState === "present" && publishedState === "missing")
      return [left, { ...right, type: "unpublish", draftState, publishedState }];
  }
  if (canMergeEdit(left.type) && right.type === "editDraft" && isWithinMergeWindow(left.endTimestamp, right.startTimestamp)) {
    const authors = /* @__PURE__ */ new Set();
    for (const author of left.authors)
      authors.add(author);
    for (const author of right.authors)
      authors.add(author);
    return {
      index: 0,
      id: right.id,
      type: left.type,
      start: left.start,
      end: right.end,
      startTimestamp: left.startTimestamp,
      endTimestamp: right.endTimestamp,
      authors,
      draftState,
      publishedState
    };
  }
  return [left, { ...right, draftState, publishedState }];
}
function getChunkState(effect) {
  const modified = !!effect;
  return effect && isDeletePatch(effect == null ? void 0 : effect.apply) ? "deleted" : modified ? "upsert" : "unedited";
}
function getChunkType(transaction) {
  const draftState = getChunkState(transaction.draftEffect), publishedState = getChunkState(transaction.publishedEffect);
  if (publishedState === "unedited") {
    if (draftState === "deleted")
      return "delete";
    if (draftState === "upsert")
      return "editDraft";
  }
  if (publishedState === "deleted")
    return "delete";
  if (publishedState === "upsert") {
    if (draftState === "unedited")
      return "editLive";
    if (draftState === "deleted")
      return "publish";
    if (draftState === "upsert")
      return "editLive";
  }
  return "editLive";
}
function chunkFromTransaction(transaction) {
  const modifiedDraft = !!transaction.draftEffect, modifiedPublished = !!transaction.publishedEffect, draftDeleted = transaction.draftEffect && isDeletePatch(transaction.draftEffect.apply), publishedDeleted = transaction.publishedEffect && isDeletePatch(transaction.publishedEffect.apply), type = getChunkType(transaction);
  return {
    index: 0,
    id: transaction.id,
    type,
    start: transaction.index,
    end: transaction.index + 1,
    startTimestamp: transaction.timestamp,
    endTimestamp: transaction.timestamp,
    authors: /* @__PURE__ */ new Set([transaction.author]),
    draftState: modifiedDraft ? draftDeleted ? "missing" : "present" : "unknown",
    publishedState: modifiedPublished ? publishedDeleted ? "missing" : "present" : "unknown"
  };
}
function combineState(left, right) {
  return right === "unknown" ? left : right;
}
function isDeletePatch(patch2) {
  return patch2[0] === 0 && patch2[1] === null;
}
function isSameAnnotation(a, b) {
  return a && b ? a.author === b.author && a.chunk === b.chunk : !a && !b;
}
function getAttrs$1(doc) {
  return doc.draft || doc.published;
}
class ArrayContentWrapper {
  constructor(content2, value, annotation, extractor) {
    this.type = "array", this.elements = [], this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor, this.length = content2.elements.length;
  }
  at(idx) {
    if (idx >= this.length)
      throw new Error("out of bounds");
    return this.elements[idx] || (this.elements[idx] = wrapValue(
      this.content.elements[idx],
      this.value[idx],
      this.extractor
    ));
  }
  annotationAt(idx) {
    const meta = this.content.metas[idx];
    return this.extractor.fromMeta(meta);
  }
}
class ObjectContentWrapper {
  constructor(content2, value, annotation, extractor) {
    this.type = "object", this.fields = {}, this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor, this.keys = Object.keys(content2.fields);
  }
  get(key) {
    const input = this.fields[key];
    if (input)
      return input;
    const value = this.content.fields[key];
    if (value)
      return this.fields[key] = wrapValue(value, this.value[key], this.extractor);
  }
}
class StringContentWrapper {
  constructor(content2, value, annotation, extractor) {
    this.type = "string", this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor;
  }
  sliceAnnotation(start, end) {
    const result = [];
    let idx = 0;
    function push(text, annotation) {
      if (result.length > 0) {
        const lst = result[result.length - 1];
        if (isSameAnnotation(lst.annotation, annotation)) {
          lst.text += text;
          return;
        }
      }
      result.push({ text, annotation });
    }
    for (const part of this.content.parts) {
      const length = part.value.length, subStart = Math.max(0, start - idx);
      if (subStart < length) {
        const subEnd = Math.min(length, end - idx);
        if (subEnd <= 0)
          break;
        push(part.value.slice(subStart, subEnd), this.extractor.fromValue(part));
      }
      idx += length;
    }
    return result;
  }
}
function wrapValue(value, raw, extractor) {
  const annotation = extractor.fromValue(value);
  if (value.content)
    switch (value.content.type) {
      case "array":
        return new ArrayContentWrapper(value.content, raw, annotation, extractor);
      case "object":
        return new ObjectContentWrapper(
          value.content,
          raw,
          annotation,
          extractor
        );
      case "string":
        return new StringContentWrapper(value.content, raw, annotation, extractor);
    }
  return diff.wrap(raw, annotation);
}
function extractAnnotationForFromInput(timeline, firstChunk, meta) {
  return meta ? annotationForTransactionIndex(timeline, meta.transactionIndex + 1, meta.chunk.index) : firstChunk ? annotationForTransactionIndex(timeline, firstChunk.start, firstChunk.index) : null;
}
function extractAnnotationForToInput(timeline, meta) {
  return meta ? annotationForTransactionIndex(timeline, meta.transactionIndex, meta.chunk.index) : null;
}
function annotationForTransactionIndex(timeline, idx, chunkIdx) {
  const tx = timeline.transactionByIndex(idx);
  if (!tx)
    return null;
  const chunk = timeline.chunkByTransactionIndex(idx, chunkIdx);
  return chunk ? {
    chunk,
    timestamp: tx.timestamp,
    author: tx.author
  } : null;
}
function diffValue(timeline, firstChunk, from, fromRaw, to, toRaw) {
  const fromInput = wrapValue(from, fromRaw, {
    fromValue(value) {
      return extractAnnotationForFromInput(timeline, firstChunk, value.endMeta);
    },
    fromMeta(meta) {
      return extractAnnotationForFromInput(timeline, firstChunk, meta);
    }
  }), toInput = wrapValue(to, toRaw, {
    fromValue(value) {
      return extractAnnotationForToInput(timeline, value.startMeta);
    },
    fromMeta(meta) {
      return extractAnnotationForToInput(timeline, meta);
    }
  });
  return diff.diffInput(fromInput, toInput);
}
class TwoEndedArray {
  constructor() {
    this._postive = [], this._negative = [];
  }
  addToEnd(elem) {
    elem.index = this._postive.length, this._postive.push(elem);
  }
  addToBeginning(elem) {
    if (this.length == 0) {
      this.addToEnd(elem);
      return;
    }
    elem.index = -(this._negative.length + 1), this._negative.push(elem);
  }
  mergeAtEnd(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.lastIdx, result = merger(this.get(idx), value);
    Array.isArray(result) ? (this.set(idx, result[0]), this.addToEnd(result[1])) : this.set(idx, result);
  }
  mergeAtBeginning(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.firstIdx, result = merger(value, this.get(idx));
    Array.isArray(result) ? (this.set(idx, result[1]), this.addToBeginning(result[0])) : this.set(idx, result);
  }
  removeFromEnd() {
    this._postive.length === 0 ? this._negative.shift() : this._postive.pop();
  }
  has(idx) {
    return idx >= 0 ? idx < this._postive.length : -(idx + 1) < this._negative.length;
  }
  get(idx) {
    return idx >= 0 ? this._postive[idx] : this._negative[-(idx + 1)];
  }
  set(idx, value) {
    idx >= 0 ? (value.index = idx, this._postive[idx] = value) : (value.index = idx, this._negative[-(idx + 1)] = value);
  }
  get lastIdx() {
    return this._postive.length - 1;
  }
  get last() {
    return this.get(this.lastIdx);
  }
  get firstIdx() {
    return -this._negative.length;
  }
  get first() {
    return this.get(this.firstIdx);
  }
  get length() {
    return this._postive.length + this._negative.length;
  }
}
class Timeline {
  constructor(opts) {
    this.reachedEarliestEntry = !1, this._transactions = new TwoEndedArray(), this._chunks = new TwoEndedArray(), this._possiblePendingTransactions = /* @__PURE__ */ new Map(), this.publishedId = opts.publishedId, this.draftId = `drafts.${opts.publishedId}`, opts.enableTrace && (this._trace = [], this._trace.push({
      type: "initial",
      publishedId: opts.publishedId
    }), window.__sanityTimelineTrace = this._trace);
  }
  get chunkCount() {
    return this._chunks.length;
  }
  /** Maps over the chunk from newest to oldest. */
  mapChunks(mapper) {
    const result = [], firstIdx = this._chunks.firstIdx, lastIdx = this._chunks.lastIdx;
    for (let idx = lastIdx; idx >= firstIdx; idx--)
      result.push(mapper(this._chunks.get(idx), idx));
    return result;
  }
  reset() {
    this._transactions = new TwoEndedArray(), this._chunks = new TwoEndedArray(), this._possiblePendingTransactions = /* @__PURE__ */ new Map(), this._recreateTransactionsFrom = void 0, this.reachedEarliestEntry = !1;
  }
  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry) {
    this._trace && this._trace.push({ type: "addRemoteMutation", event: entry });
    const pending = this._possiblePendingTransactions.get(entry.transactionId), transaction = pending ? pending.transaction : {
      index: 0,
      id: entry.transactionId,
      timestamp: entry.timestamp.toISOString(),
      author: entry.author
    };
    entry.version === "draft" ? transaction.draftEffect = entry.effects : transaction.publishedEffect = entry.effects, pending ? (this._possiblePendingTransactions.delete(entry.transactionId), this._invalidateTransactionFrom(pending.idx)) : (this._transactions.addToEnd(transaction), this._possiblePendingTransactions.set(entry.transactionId, {
      transaction,
      idx: this._transactions.lastIdx
    }));
  }
  addTranslogEntry(event) {
    this._trace && this._trace.push({ type: "addTranslogEntry", event }), this._transactions.addToBeginning({
      index: 0,
      id: event.id,
      author: event.author,
      timestamp: event.timestamp,
      draftEffect: event.effects[this.draftId],
      publishedEffect: event.effects[this.publishedId]
    });
  }
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry() {
    this._trace && this._trace.push({ type: "didReachEarliestEntry" }), this.reachedEarliestEntry = !0;
  }
  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks() {
    this._trace && this._trace.push({ type: "updateChunks" }), this._removeInvalidatedChunks(), this._addChunksFromTransactions(), this._createInitialChunk();
  }
  _removeInvalidatedChunks() {
    if (this._recreateTransactionsFrom) {
      for (; this._chunks.length > 0; ) {
        const chunk = this._chunks.last;
        if (this._recreateTransactionsFrom < chunk.end)
          this._chunks.removeFromEnd();
        else
          break;
      }
      this._recreateTransactionsFrom = void 0;
    }
  }
  _addChunksFromTransactions() {
    const firstIdx = this._transactions.firstIdx, lastIdx = this._transactions.lastIdx, nextTransactionToChunk = this._chunks.length > 0 ? this._chunks.last.end : firstIdx;
    for (let idx = nextTransactionToChunk; idx <= lastIdx; idx++) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtEnd(chunkFromTransaction(transaction), mergeChunk);
    }
    if (this._chunks.length == 0)
      return;
    const firstTransactionChunked = this._chunks.first.start;
    for (let idx = firstTransactionChunked - 1; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtBeginning(chunkFromTransaction(transaction), mergeChunk);
    }
  }
  _invalidateTransactionFrom(idx) {
    (this._recreateTransactionsFrom === void 0 || idx < this._recreateTransactionsFrom) && (this._recreateTransactionsFrom = idx);
  }
  _createInitialChunk() {
    var _a2;
    if (this.reachedEarliestEntry) {
      if (((_a2 = this._chunks.first) == null ? void 0 : _a2.type) === "initial")
        return;
      const firstTx = this._transactions.first;
      if (!firstTx)
        return;
      const initialChunk = chunkFromTransaction(firstTx);
      initialChunk.type = "initial", initialChunk.id = "@initial", initialChunk.end = initialChunk.start, this._chunks.addToBeginning(initialChunk);
    }
  }
  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id2) {
    if (this._chunks.length === 0)
      return this.reachedEarliestEntry ? "invalid" : "loading";
    const idSegments = id2.split("/", 3), timestampStr = idSegments.shift(), chunkId = idSegments.shift(), timestamp = Number(timestampStr);
    for (let idx = this._chunks.lastIdx; idx >= this._chunks.firstIdx; idx--) {
      const chunk = this._chunks.get(idx);
      if (chunk.id === chunkId)
        return chunk;
      if (Date.parse(chunk.endTimestamp) + 60 * 60 * 1e3 < timestamp)
        return "invalid";
    }
    return this.reachedEarliestEntry ? "invalid" : "loading";
  }
  findLastPublishedBefore(chunk) {
    for (let chunkIdx = chunk ? chunk.index - 1 : this._chunks.lastIdx; chunkIdx >= this._chunks.firstIdx; chunkIdx--) {
      const currentChunk = this._chunks.get(chunkIdx);
      if (currentChunk.type === "publish" || currentChunk.type === "initial")
        return currentChunk;
    }
    return this.reachedEarliestEntry ? this._chunks.first : "loading";
  }
  isLatestChunk(chunk) {
    return chunk === this._chunks.last;
  }
  // eslint-disable-next-line class-methods-use-this
  createTimeId(chunk) {
    return `${chunk.endTimestamp.valueOf()}/${chunk.id}`;
  }
  lastChunk() {
    return this._chunks.last;
  }
  transactionByIndex(idx) {
    return this._transactions.has(idx) ? this._transactions.get(idx) : null;
  }
  chunkByTransactionIndex(idx, startChunkIdx = 0) {
    let chunkIdx = startChunkIdx;
    for (; ; ) {
      const chunk = this._chunks.get(chunkIdx);
      if (!chunk)
        throw new Error("transaction does not belong in any chunk");
      if (idx >= chunk.end)
        chunkIdx++;
      else if (idx < chunk.start)
        chunkIdx--;
      else
        return chunk;
    }
  }
  replayBackwardsBetween(firstIdx, lastIdx, doc) {
    let draft = doc.draft, published = doc.published;
    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      transaction.draftEffect && (draft = mendoza.applyPatch(draft, transaction.draftEffect.revert)), transaction.publishedEffect && (published = mendoza.applyPatch(published, transaction.publishedEffect.revert));
    }
    return { draft, published };
  }
  replayBackwardsUntil(firstIdx, doc) {
    return this.replayBackwardsBetween(firstIdx, this._transactions.lastIdx, doc);
  }
  calculateDiff(initialDoc, finalDoc, firstIdx, lastIdx) {
    let draftValue = mendoza.incremental.wrap(initialDoc.draft, null), publishedValue = mendoza.incremental.wrap(initialDoc.published, null);
    const initialValue = getValue(draftValue, publishedValue), initialAttributes = getAttrs$1(initialDoc);
    let firstChunk = null;
    for (let chunkIdx = firstIdx; chunkIdx <= lastIdx; chunkIdx++) {
      const chunk = this._chunks.get(chunkIdx);
      firstChunk || (firstChunk = chunk);
      for (let idx = chunk.start; idx < chunk.end; idx++) {
        const transaction = this._transactions.get(idx), meta = {
          chunk,
          transactionIndex: idx
        }, preDraftValue = draftValue, prePublishedValue = publishedValue;
        transaction.draftEffect && (draftValue = mendoza.incremental.applyPatch(draftValue, transaction.draftEffect.apply, meta)), transaction.publishedEffect && (publishedValue = mendoza.incremental.applyPatch(
          publishedValue,
          transaction.publishedEffect.apply,
          meta
        ));
        const didHaveDriaft = mendoza.incremental.getType(preDraftValue) !== "null", haveDraft = mendoza.incremental.getType(draftValue) !== "null";
        mendoza.incremental.getType(publishedValue) !== "null" && !haveDraft && (publishedValue = mendoza.incremental.rebaseValue(preDraftValue, publishedValue)), haveDraft && !didHaveDriaft && (draftValue = mendoza.incremental.rebaseValue(prePublishedValue, draftValue));
      }
    }
    const finalValue = mendoza.incremental.getType(draftValue) === "null" ? publishedValue : draftValue, finalAttributes = getAttrs$1(finalDoc);
    return diffValue(this, firstChunk, initialValue, initialAttributes, finalValue, finalAttributes);
  }
}
function getValue(draftValue, publishedValue) {
  return mendoza.incremental.getType(draftValue) === "null" ? publishedValue : draftValue;
}
function emptyVersionState(id2) {
  return {
    id: id2,
    hasAttrs: !1,
    attrs: null,
    rev: null,
    events: [],
    aligned: !1
  };
}
function align(history2, state) {
  const idx = state.events.findIndex((evt) => history2.id === evt.transactionId);
  return idx >= 0 ? idx + 1 : state.rev ? state.rev === history2.id ? 0 : -1 : 0;
}
function startFromSnapshot(state, doc) {
  if (state.hasAttrs = !0, doc) {
    if (state.attrs = { ...doc }, typeof state.attrs._rev != "string")
      throw new Error("snapshot has no _rev");
    state.rev = state.attrs._rev, delete state.attrs._rev;
  } else
    state.attrs = null, state.rev = null;
  state.events = [];
}
class Aligner {
  constructor(timeline) {
    this.earliestTransactionId = null, this.timeline = timeline, this._states = {
      draft: emptyVersionState(timeline.draftId),
      published: emptyVersionState(timeline.publishedId)
    };
  }
  appendRemoteSnapshotEvent(evt) {
    const state = this._states[evt.version];
    if (evt.type === "snapshot") {
      this._maybeInvalidateHistory(), startFromSnapshot(state, evt.document);
      return;
    }
    evt.type === "remoteMutation" && (state.aligned ? (this._apply(state, evt), this.timeline.addRemoteMutation(evt)) : state.hasAttrs ? state.events.push(evt) : startFromSnapshot(state, evt.head));
  }
  prependHistoryEvent(evt) {
    if (!this.acceptsHistory)
      throw new Error("cannot prepend history at this point");
    for (const state of Object.values(this._states))
      if (!state.aligned) {
        const idx = align(evt, state);
        idx >= 0 && this._alignAtIndex(state, idx);
      }
    this.timeline.addTranslogEntry(evt), this.earliestTransactionId = evt.id;
  }
  didReachEarliestEntry() {
    for (const state of Object.values(this._states))
      if (!state.aligned) {
        if (state.attrs !== null)
          throw new Error("unable to find translog entry to align to");
        this._alignAtIndex(state, 0);
      }
    this.timeline.didReachEarliestEntry();
  }
  get isAligned() {
    return Object.values(this._states).every((state) => state.aligned);
  }
  get acceptsHistory() {
    return this._isComplete;
  }
  get currentDocument() {
    return { draft: this._states.draft.attrs, published: this._states.published.attrs };
  }
  _alignAtIndex(state, idx) {
    for (const mutEvt of state.events.slice(0, idx))
      this._apply(state, mutEvt);
    for (const mutEvt of state.events.slice(idx))
      this._apply(state, mutEvt), this.timeline.addRemoteMutation(mutEvt);
    state.events = [], state.aligned = !0;
  }
  get _isComplete() {
    return Object.values(this._states).every((state) => state.hasAttrs);
  }
  // eslint-disable-next-line class-methods-use-this
  _apply(state, evt) {
    state.attrs = mendoza.applyPatch(state.attrs, evt.effects.apply), state.rev = evt.transactionId;
  }
  _maybeInvalidateHistory() {
    if (this._isComplete) {
      for (const state of Object.values(this._states))
        state.aligned = !1;
      this.earliestTransactionId = null, this.timeline.reset();
    }
  }
}
class Reconstruction {
  constructor(timeline, doc, start, end) {
    this.timeline = timeline, this.start = start, this.end = end, this.doc = doc;
  }
  same(start, end) {
    return this.start === start && this.end === end;
  }
  /** Returns the attributes as seen at the end of the range. */
  endAttributes() {
    return getAttrs(this.endDocument());
  }
  endDocument() {
    return this._endDocument || (this._endDocument = this.timeline.replayBackwardsUntil(this.end.end, this.doc)), this._endDocument;
  }
  /** Returns the attributes as seen at the end of the range. */
  startAttributes() {
    return getAttrs(this.startDocument());
  }
  startDocument() {
    if (!this.start)
      throw new Error("start required");
    return this._startDocument || (this._startDocument = this.timeline.replayBackwardsBetween(
      this.start.end,
      this.end.end - 1,
      this.endDocument()
    )), this._startDocument;
  }
  diff() {
    if (!this._diff) {
      if (!this.start)
        throw new Error("start required");
      this._diff = this.timeline.calculateDiff(
        this.startDocument(),
        this.endDocument(),
        this.start.index + 1,
        this.end.index
      );
    }
    return this._diff;
  }
}
function getAttrs(doc) {
  return doc.draft || doc.published;
}
const TRANSLOG_ENTRY_LIMIT = 50;
class TimelineController {
  constructor(options) {
    this.version = 0, this.selectionState = "inactive", this._fetchMore = !1, this._fetchAtLeast = 0, this._isRunning = !1, this._isSuspended = !1, this._didErr = !1, this._since = null, this._sinceTime = null, this._rev = null, this._revTime = null, this.timeline = options.timeline, this.client = options.client, this.handler = options.handler, this._aligner = new Aligner(this.timeline), this.markChange();
  }
  clearRange() {
    this.setRange(null, null);
  }
  setRange(since, rev) {
    rev !== this._rev && this.setRevTime(rev), since !== this._since && this.setSinceTime(since);
    let _fetchAtLeast = 10;
    if (this._sinceTime === "loading" || this._revTime === "loading" || !this._aligner.isAligned)
      this.selectionState = "loading";
    else if (this._sinceTime === "invalid" || this._revTime === "invalid")
      this.selectionState = "invalid";
    else if (this._sinceTime) {
      this.selectionState = "range";
      const targetRev = this._revTime || this.timeline.lastChunk();
      this._sinceTime.index > targetRev.index ? (this._revTime = "invalid", this.selectionState = "invalid") : this.setReconstruction(this._sinceTime, targetRev);
    } else
      this._revTime ? (this.selectionState = "rev", this.setReconstruction(null, this._revTime)) : (this.selectionState = "inactive", _fetchAtLeast = 0);
    this._fetchAtLeast = _fetchAtLeast, this.start();
  }
  setLoadMore(flag) {
    this._fetchMore = flag, this.start();
  }
  get sinceTime() {
    return this._sinceTime && typeof this._sinceTime == "object" ? this._sinceTime : null;
  }
  get revTime() {
    return this._revTime && typeof this._revTime == "object" ? this._revTime : null;
  }
  get realRevChunk() {
    return this.revTime || this.timeline.lastChunk();
  }
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision() {
    return !!this._rev && (this.selectionState === "range" || this.selectionState === "rev");
  }
  findRangeForNewRev(rev) {
    const revTimeId = this.timeline.isLatestChunk(rev) ? null : this.timeline.createTimeId(rev);
    if (!this._since)
      return [null, revTimeId];
    const sinceChunk = this.sinceTime;
    return sinceChunk && sinceChunk.index < rev.index ? [this._since, revTimeId] : ["@lastPublished", revTimeId];
  }
  findRangeForNewSince(since) {
    const revChunk = this.revTime;
    return revChunk && since.index < revChunk.index ? [this.timeline.createTimeId(since), this._rev] : [this.timeline.createTimeId(since), null];
  }
  setRevTime(rev) {
    this._rev = rev, this._revTime = rev ? this.timeline.parseTimeId(rev) : null, this._since === "@lastPublished" && (this._since = null, this._sinceTime = null);
  }
  setSinceTime(since) {
    since === "@lastPublished" ? typeof this._revTime == "string" ? this._sinceTime = this._revTime : this._sinceTime = this.timeline.findLastPublishedBefore(this._revTime) : this._sinceTime = since ? this.timeline.parseTimeId(since) : null, this._since = since;
  }
  sinceAttributes() {
    return this._sinceTime && this._reconstruction ? this._reconstruction.startAttributes() : null;
  }
  displayed() {
    return this._revTime && this._reconstruction ? this._reconstruction.endAttributes() : null;
  }
  setReconstruction(since, rev) {
    this._reconstruction && this._reconstruction.same(since, rev) || (this._reconstruction = new Reconstruction(
      this.timeline,
      this._aligner.currentDocument,
      since,
      rev
    ));
  }
  currentDiff() {
    return this._reconstruction ? this._reconstruction.diff() : null;
  }
  currentObjectDiff() {
    const diff2 = this.currentDiff();
    if (diff2) {
      if (diff2.type === "null")
        return null;
      if (diff2.type !== "object")
        throw new Error(`ObjectDiff expected, got ${diff2.type}`);
    }
    return diff2;
  }
  handleRemoteMutation(ev) {
    this._aligner.appendRemoteSnapshotEvent(ev), this.markChange(), this._aligner.acceptsHistory && this.start();
  }
  start() {
    this._didErr || this._isRunning || (this._isRunning = !0, this.tick().then(() => {
      this._isRunning = !1;
    }));
  }
  resume() {
    this._isSuspended = !1;
  }
  suspend() {
    this._isSuspended = !0;
  }
  async tick() {
    var _a2;
    if (this._aligner.acceptsHistory && !this.timeline.reachedEarliestEntry && (this.selectionState === "loading" || this._fetchMore || this.timeline.chunkCount <= this._fetchAtLeast) && !this._isSuspended) {
      try {
        await this.fetchMoreTransactions();
      } catch (err) {
        this._didErr = !0, (_a2 = this.handler) == null || _a2.call(this, err, this);
        return;
      }
      await this.tick();
    }
  }
  async fetchMoreTransactions() {
    const publishedId = this.timeline.publishedId, draftId = this.timeline.draftId, clientConfig = this.client.config(), limit = TRANSLOG_ENTRY_LIMIT;
    let queryParams = `tag=sanity.studio.structure.history&effectFormat=mendoza&excludeContent=true&excludeMutations=true&includeIdentifiedDocumentsOnly=true&reverse=true&limit=${limit}`, tid = this._aligner.earliestTransactionId;
    tid && (queryParams += `&toTransaction=${tid}`);
    const transactionsUrl = this.client.getUrl(
      `/data/history/${clientConfig.dataset}/transactions/${publishedId},${draftId}?${queryParams}`
    ), reader = (await getJsonStream.getJsonStream(transactionsUrl, clientConfig.token)).getReader();
    let count = 0;
    for (; ; ) {
      const result = await reader.read();
      if (result.done)
        break;
      if ("error" in result.value)
        throw new Error(result.value.error.description || result.value.error.type);
      if (count++, result.value.id !== tid) {
        if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory)
          return;
        this._aligner.prependHistoryEvent(result.value), tid = this._aligner.earliestTransactionId;
      }
    }
    this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory || (count < limit && this._aligner.didReachEarliestEntry(), this.markChange());
  }
  markChange() {
    var _a2;
    this.timeline.updateChunks(), this.setRevTime(this._rev), this.setSinceTime(this._rev), this.version++, (_a2 = this.handler) == null || _a2.call(this, null, this);
  }
}
const documentRevisionCache = /* @__PURE__ */ Object.create(null), getHistory = (client2, documentIds, options = {}) => {
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds], { time, revision } = options;
  if (time && revision)
    throw new Error("getHistory can't handle both time and revision parameters");
  let url = `/data/history/${client2.config().dataset}/documents/${ids.join(",")}`;
  if (revision)
    url = `${url}?revision=${revision}`;
  else {
    const timestamp = time || (/* @__PURE__ */ new Date()).toISOString();
    url = `${url}?time=${timestamp}`;
  }
  return client2.request({ url });
}, getDocumentAtRevision = (client2, documentId, revision) => {
  const publishedId = getPublishedId(documentId), draftId = getDraftId(documentId), cacheKey = `${publishedId}@${revision}`, cached = documentRevisionCache[cacheKey];
  if (cached)
    return cached;
  const url = `/data/history/${client2.config().dataset}/documents/${publishedId},${draftId}?revision=${revision}`, entry = client2.request({ url }).then((result) => {
    const documents = result.documents || [], published = documents.find((res) => res._id === publishedId);
    return documents.find((res) => res._id === draftId) || published;
  });
  return documentRevisionCache[cacheKey] = entry, entry;
}, getTimelineController = ({
  client: client2,
  documentId,
  documentType
}) => {
  const timeline = new Timeline({
    enableTrace: isDev,
    publishedId: documentId
  });
  return new TimelineController({
    client: client2,
    documentId,
    documentType,
    timeline
  });
}, getTransactions = async (client2, documentIds) => {
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds], dataset = client2.config().dataset, query = { excludeContent: "true", includeIdentifiedDocumentsOnly: "true" }, url = `/data/history/${dataset}/transactions/${ids.join(",")}`;
  return (await client2.request({ url, query })).toString("utf8").split(`
`).filter(Boolean).map((line) => JSON.parse(line));
}, getAllRefIds = (doc) => jsonReduce.reduce(
  doc,
  (acc, node) => types.isReference(node) && !acc.includes(node._ref) ? [...acc, node._ref] : acc,
  []
);
function jsonMap(value, mapFn) {
  return Array.isArray(value) ? mapFn(
    value.map((item) => jsonMap(item, mapFn)).filter((item) => typeof item < "u")
  ) : isRecord$4(value) ? mapFn(
    Object.keys(value).reduce((res, key) => {
      const mappedValue = jsonMap(value[key], mapFn);
      return typeof mappedValue < "u" && (res[key] = mappedValue), res;
    }, {})
  ) : mapFn(value);
}
const mapRefNodes = (doc, mapFn) => jsonMap(doc, (node) => types.isReference(node) ? mapFn(node) : node), removeMissingReferences = (doc, existingIds) => mapRefNodes(doc, (refNode) => existingIds[refNode._ref] ? refNode : void 0);
function restore(client2, documentId, targetDocumentId, rev) {
  return rxjs.from(getDocumentAtRevision(client2, documentId, rev)).pipe(
    operators.mergeMap((documentAtRevision) => {
      if (!documentAtRevision)
        throw new Error(`Unable to find document with ID ${documentId} at revision ${rev}`);
      const existingIdsQuery = getAllRefIds(documentAtRevision).map((refId) => `"${refId}": defined(*[_id=="${refId}"]._id)`).join(",");
      return client2.observable.fetch(`{${existingIdsQuery}}`).pipe(operators.map((existingIds) => removeMissingReferences(documentAtRevision, existingIds)));
    }),
    operators.map((documentAtRevision) => {
      const { _updatedAt, ...document2 } = documentAtRevision;
      return { ...document2, _id: targetDocumentId };
    }),
    operators.mergeMap(
      (restoredDraft) => client2.observable.createOrReplace(restoredDraft, { visibility: "async" })
    )
  );
}
function createHistoryStore({ client: client2 }) {
  return {
    getDocumentAtRevision: (documentId, revision) => getDocumentAtRevision(client2, documentId, revision),
    getHistory: (documentIds, options) => getHistory(client2, documentIds, options),
    getTransactions: (documentIds) => getTransactions(client2, documentIds),
    restore: (id2, targetId, rev) => restore(client2, id2, targetId, rev),
    getTimelineController
  };
}
const handleIncomingMessage = (event) => {
  if (event.type === "rollCall")
    return {
      type: "rollCall",
      userId: event.i,
      sessionId: event.session
    };
  if (event.type === "state") {
    const { sessionId: sessionId2, locations } = event.m;
    return {
      type: "state",
      userId: event.i,
      sessionId: sessionId2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      locations
    };
  }
  if (event.type === "disconnect")
    return {
      type: "disconnect",
      userId: event.i,
      sessionId: event.m.session,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  throw new Error(`Got unknown presence event: ${JSON.stringify(event)}`);
}, createBifurTransport = (bifur, sessionId2) => {
  const incomingEvents$ = bifur.request("presence").pipe(operators.map(handleIncomingMessage)), dispatchMessage = (message) => message.type === "rollCall" ? bifur.request("presence_rollcall", { session: sessionId2 }) : message.type === "state" ? bifur.request("presence_announce", {
    data: { locations: message.locations, sessionId: sessionId2 }
  }) : message.type === "disconnect" ? bifur.request("presence_disconnect", { session: sessionId2 }) : rxjs.EMPTY;
  return [incomingEvents$.pipe(operators.share()), dispatchMessage];
}, USERIDS = [
  "pqSMwf6hH",
  "pnLYqNfv5",
  "priDVVmy8",
  "p0NFOU0j8",
  "pTDl2jw8d",
  "pHMeQnTse",
  "pDQYzJbyS",
  "pZyoPHKUs",
  "p4Tyi2Be5",
  "pb9vii060",
  "pE8yhOisw",
  "p7Fd2C6Cj",
  "p3exSgYCx",
  "pbIQRYViC",
  "p8GJaTEhN",
  "p27ewL8aM",
  "pYg97z75S",
  "pdLr4quHv",
  "pkJXiDgg6",
  "pkl4UAKcA",
  // Included to ensure we handle the case when a user profile cannot
  // be fetched due to insufficient privileges or similar
  "pNoExists"
], PATHS = [
  ["nested", "first"],
  ["nested", "second"],
  [
    "nestedArray",
    { _key: "565c867c8dac" },
    "arrayNo1",
    { _key: "a645548a8f01" },
    "arrayNo1",
    { _key: "1685e372c40f" },
    "fieldNo0"
  ],
  ["nestedArray", { _key: "565c867c8dac" }, "fieldNo0"],
  ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo0"],
  ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo19"],
  ["address", "country"],
  ["address", "street"],
  ["customInputWithDefaultPresence", "row3", "cell3"]
], mock$ = rxjs.defer(() => rxjs.timer(0, 1e4)).pipe(
  operators.mergeMapTo(USERIDS),
  operators.map(
    (id2, n) => ({
      type: "state",
      userId: id2,
      sessionId: id2 + n,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      locations: [
        {
          type: "document",
          documentId: "presence-debug",
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString(),
          path: sample__default.default(PATHS)
        }
      ]
    })
  ),
  operators.shareReplay()
), KEY = "presence_session_id", generate = () => nanoid.nanoid(16);
function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch {
  }
  return null;
}
function setSessionId(id2) {
  try {
    window.sessionStorage.setItem(KEY, id2);
  } catch {
  }
  return id2;
}
const SESSION_ID = getSessionId() || setSessionId(generate());
function __tmp_wrap_presenceStore(context) {
  const { bifur, connectionStatusStore, userStore } = context, [presenceEvents$, sendMessage] = createBifurTransport(bifur, SESSION_ID), currentLocation$ = new rxjs.BehaviorSubject([]), locationChange$ = currentLocation$.pipe(operators.distinctUntilChanged()), setLocation = (nextLocation) => {
    currentLocation$.next(nextLocation);
  }, reportLocations = (locations) => sendMessage({ type: "state", locations }), requestRollCall = () => sendMessage({ type: "rollCall" }), rollCallRequests$ = presenceEvents$.pipe(
    operators.filter((event) => event.type === "rollCall"),
    // do not respond to my own rollcall requests
    operators.filter((event) => event.sessionId !== SESSION_ID)
  ), reportLocationInterval$ = rxjs.timer(0, 3e4), reportLocation$ = rxjs.defer(() => rxjs.merge(locationChange$, rollCallRequests$)).pipe(
    operators.switchMap(() => reportLocationInterval$),
    operators.withLatestFrom(currentLocation$),
    operators.map(([, locations]) => locations),
    operators.auditTime(200),
    operators.switchMap((locations) => reportLocations(locations)),
    operators.mergeMapTo(rxjs.EMPTY),
    operators.share()
  ), myRollCall$ = rxjs.defer(() => requestRollCall()).pipe(operators.mergeMapTo(rxjs.EMPTY)), connectionChange$ = connectionStatusStore.connectionStatus$.pipe(
    operators.map((status) => status.type),
    operators.filter((statusType) => statusType === "connected" || statusType === "error"),
    operators.distinctUntilChanged()
  ), debugPresenceParam$ = debugParams$.pipe(
    operators.map((args) => args.find((arg) => arg.startsWith("presence="))),
    operators.map(
      (arg) => (arg == null ? void 0 : arg.split("presence=")[1].split(",").map((r) => r.trim())) || []
    )
  ), useMock$ = debugPresenceParam$.pipe(
    operators.filter((args) => args.includes("fake_others")),
    operators.tap(() => {
      console.log(
        'Faking other users present in the studio. They will hang out in the document with _type: "presence" and _id: "presence-debug"'
      );
    }),
    operators.switchMapTo(mock$)
  ), debugIntrospect$ = debugPresenceParam$.pipe(operators.map((args) => args.includes("show_own"))), syncEvent$ = rxjs.merge(myRollCall$, presenceEvents$).pipe(
    operators.filter(
      (event) => event.type === "state" || event.type === "disconnect"
    )
  ), stateEventToSession = (stateEvent) => ({
    lastActiveAt: stateEvent.timestamp,
    locations: stateEvent.locations,
    sessionId: stateEvent.sessionId,
    userId: stateEvent.userId
  }), states$ = rxjs.merge(syncEvent$, useMock$).pipe(
    operators.scan(
      (keyed, event) => event.type === "disconnect" ? omit__default.default(keyed, event.sessionId) : { ...keyed, [event.sessionId]: stateEventToSession(event) },
      {}
    )
  ), allSessions$ = connectionChange$.pipe(
    operators.switchMap((status) => status === "connected" ? rxjs.merge(states$, reportLocation$) : rxjs.NEVER),
    operators.map((keyedSessions) => Object.values(keyedSessions)),
    operators.switchMap((sessions) => {
      const userIds = uniq__default.default(sessions.map((sess) => sess.userId));
      return rxjs.from(userStore.getUsers(userIds)).pipe(
        operators.map(
          (users) => sessions.map((session) => ({
            // eslint-disable-next-line max-nested-callbacks
            user: users.find((res) => res.id === session.userId),
            session
          })).filter(userSessionPairHasUser)
        )
      );
    }),
    operators.takeUntil(
      rxjs.fromEvent(window, "beforeunload").pipe(operators.switchMap(() => sendMessage({ type: "disconnect" })))
    ),
    operators.shareReplay({ refCount: !0, bufferSize: 1 })
  );
  function userSessionPairHasUser(pair) {
    return !!(pair.user && pair.session);
  }
  const globalPresence$ = allSessions$.pipe(
    operators.map((sessions) => {
      const grouped = groupBy__default.default(
        sessions.map((s) => s.session),
        (e) => e.userId
      );
      return Object.keys(grouped).map((userId) => {
        var _a2;
        return {
          user: (_a2 = sessions.find((s) => s.user.id === userId)) == null ? void 0 : _a2.user,
          sessions: grouped[userId]
        };
      });
    }),
    operators.withLatestFrom(debugIntrospect$),
    operators.map(
      ([userAndSessions, debugIntrospect]) => userAndSessions.filter((userAndSession) => debugIntrospect ? !0 : !userAndSession.sessions.some((sess) => sess.sessionId === SESSION_ID))
    ),
    operators.map(
      (userAndSessions) => userAndSessions.map((userAndSession) => {
        var _a2;
        return {
          user: userAndSession.user,
          status: "online",
          lastActiveAt: (_a2 = userAndSession.sessions.sort()[0]) == null ? void 0 : _a2.lastActiveAt,
          locations: flatten__default.default(
            (userAndSession.sessions || []).map((session) => session.locations || [])
          ).map((location) => ({
            type: location.type,
            documentId: location.documentId,
            path: location.path,
            lastActiveAt: location.lastActiveAt
          })).reduce((prev, curr) => prev.concat(curr), [])
        };
      })
    )
  );
  return { setLocation, reportLocations, debugPresenceParam$, globalPresence$, documentPresence: (documentId) => allSessions$.pipe(
    operators.withLatestFrom(debugIntrospect$),
    operators.switchMap(
      ([userAndSessions, debugIntrospect]) => rxjs.from(userAndSessions).pipe(
        operators.filter(
          (userAndSession) => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID
        ),
        operators.flatMap(
          (userAndSession) => (userAndSession.session.locations || []).filter((item) => item.documentId === documentId).map((location) => ({
            user: userAndSession.user,
            lastActiveAt: userAndSession.session.lastActiveAt,
            path: location.path || [],
            sessionId: userAndSession.session.sessionId
          }))
        ),
        operators.toArray()
      )
    )
  ) };
}
function createProjectStore(context) {
  const { client: client2 } = context, projectId = client2.config().projectId, versionedClient = client2.withConfig({ apiVersion: "2021-12-15" });
  function get2() {
    return versionedClient.observable.request({
      url: `/projects/${projectId}`
    });
  }
  function getDatasets() {
    return versionedClient.observable.request({
      url: `/projects/${projectId}/datasets`
    });
  }
  return { get: get2, getDatasets };
}
function createMultiKeyWeakMap() {
  const rootMap = /* @__PURE__ */ new WeakMap(), idCache = /* @__PURE__ */ new WeakMap();
  function randomId() {
    return Array.from({ length: 10 }).map(
      () => Math.floor(Math.random() * 255).toString(16).padStart(2, "0")
    ).join("");
  }
  function assignId(key) {
    const cachedId = idCache.get(key);
    if (cachedId)
      return cachedId;
    const id2 = randomId();
    return idCache.set(key, id2), id2;
  }
  function arrangeKeys(keys) {
    return Array.from(new Set(keys)).map((key) => [assignId(key), key]).sort(([a], [b]) => a.localeCompare(b, "en")).map(([, key]) => key);
  }
  function getDeep(keys, map) {
    if (!keys.length)
      return;
    const [firstKey, ...restOfKeys] = keys, node = map.get(firstKey);
    if (node)
      return restOfKeys.length ? getDeep(restOfKeys, node.next) : node.value;
  }
  function setDeep(keys, map, value) {
    if (!keys.length)
      return;
    const [firstKey, ...restOfKeys] = keys, node = map.get(firstKey) || {
      type: "multi-key-weak-map-node",
      value: void 0,
      next: /* @__PURE__ */ new WeakMap()
    };
    if (map.set(firstKey, node), !restOfKeys.length) {
      node.value = value;
      return;
    }
    setDeep(restOfKeys, node.next, value);
  }
  function get2(keys) {
    return getDeep(arrangeKeys(keys), rootMap);
  }
  function set2(keys, value) {
    setDeep(arrangeKeys(keys), rootMap, value);
  }
  return { get: get2, set: set2 };
}
const ResourceCacheContext = React.createContext(null);
function ResourceCacheProvider({ children }) {
  const resourceCache = React.useMemo(() => {
    const namespaces = /* @__PURE__ */ new Map(), nullReplacer = {};
    return {
      get: ({ namespace, dependencies }) => {
        const dependenciesWithoutNull = dependencies.map(
          (dep) => dep === null ? nullReplacer : dep
        ), namespaceMap = namespaces.get(namespace);
        return namespaceMap == null ? void 0 : namespaceMap.get(dependenciesWithoutNull);
      },
      set: ({ namespace, dependencies, value }) => {
        const namespaceMap = namespaces.get(namespace) || createMultiKeyWeakMap(), dependenciesWithoutNull = dependencies.map(
          (dep) => dep === null ? nullReplacer : dep
        );
        namespaces.set(namespace, namespaceMap), namespaceMap.set(dependenciesWithoutNull, value);
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsx(ResourceCacheContext.Provider, { value: resourceCache, children });
}
function useResourceCache() {
  const cache = React.useContext(ResourceCacheContext);
  if (!cache)
    throw new Error("Could not find `cache` context");
  return cache;
}
const INTERNAL_USER_IDS = [
  {
    id: "<system>",
    displayName: "Sanity",
    imageUrl: "https://public.sanity.io/logos/favicon-192.png"
  }
];
function createUserStore({ client: _client, currentUser }) {
  const client2 = _client.withConfig({ apiVersion: "2021-06-07" }), userLoader = new DataLoader__default.default(
    async (userIds) => {
      const value = await client2.request({
        uri: `/users/${userIds.join(",")}`,
        withCredentials: !0,
        tag: "users.get"
      }), users = (Array.isArray(value) ? value : [value]).reduce(
        (acc, next) => (next != null && next.id && (acc[next.id] = next), acc),
        {}
      );
      return userIds.map((id2) => users[id2] || null);
    },
    { batchScheduleFn: (cb) => raf__default.default(cb) }
  ), userFromCurrentUser = currentUser && {
    id: currentUser.id,
    displayName: currentUser.name,
    imageUrl: currentUser.profileImage
  };
  return userLoader.prime("me", userFromCurrentUser), userFromCurrentUser != null && userFromCurrentUser.id && userLoader.prime(userFromCurrentUser.id, userFromCurrentUser), INTERNAL_USER_IDS.forEach((user) => userLoader.prime(user.id, user)), {
    getUser: async (userId) => {
      if (!userId)
        return Promise.resolve(null);
      try {
        return await userLoader.load(userId);
      } catch (err) {
        if (err.statusCode === 403)
          return Promise.resolve(null);
        throw err;
      }
    },
    getUsers: async (userIds) => (await userLoader.loadMany(userIds)).filter(
      (result) => isRecord$4(result) && typeof result.id == "string"
    )
  };
}
function useUserStore() {
  const { getClient, currentUser } = useSource(), resourceCache = useResourceCache(), client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useMemo(() => {
    const userStore = resourceCache.get({
      namespace: "userStore",
      dependencies: [client2, currentUser]
    }) || createUserStore({ client: client2, currentUser });
    return resourceCache.set({
      namespace: "userStore",
      dependencies: [client2, currentUser],
      value: userStore
    }), userStore;
  }, [client2, currentUser, resourceCache]);
}
function useGrantsStore() {
  const { getClient } = useSource(), client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), currentUser = useCurrentUser(), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const grantsStore = resourceCache.get({
      namespace: "grantsStore",
      dependencies: [client2, currentUser]
    }) || createGrantsStore({ client: client2, userId: (currentUser == null ? void 0 : currentUser.id) || null });
    return resourceCache.set({
      namespace: "grantsStore",
      dependencies: [client2, currentUser],
      value: grantsStore
    }), grantsStore;
  }, [client2, currentUser, resourceCache]);
}
function useHistoryStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const historyStore = resourceCache.get({
      namespace: "historyStore",
      dependencies: [client2]
    }) || createHistoryStore({ client: client2 });
    return resourceCache.set({
      namespace: "historyStore",
      dependencies: [client2],
      value: historyStore
    }), historyStore;
  }, [client2, resourceCache]);
}
function useDocumentPreviewStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const documentPreviewStore = resourceCache.get({
      namespace: "documentPreviewStore",
      dependencies: [client2]
    }) || createDocumentPreviewStore({ client: client2 });
    return resourceCache.set({
      namespace: "documentPreviewStore",
      dependencies: [client2],
      value: documentPreviewStore
    }), documentPreviewStore;
  }, [client2, resourceCache]);
}
function useDocumentStore() {
  const { getClient, i18n } = useSource(), schema2 = useSchema(), templates = useTemplates(), resourceCache = useResourceCache(), historyStore = useHistoryStore(), documentPreviewStore = useDocumentPreviewStore();
  return React.useMemo(() => {
    const documentStore = resourceCache.get({
      namespace: "documentStore",
      dependencies: [getClient, documentPreviewStore, historyStore, schema2, i18n]
    }) || createDocumentStore({
      getClient,
      documentPreviewStore,
      historyStore,
      initialValueTemplates: templates,
      schema: schema2,
      i18n
    });
    return resourceCache.set({
      namespace: "documentStore",
      dependencies: [getClient, documentPreviewStore, historyStore, schema2, i18n],
      value: documentStore
    }), documentStore;
  }, [getClient, documentPreviewStore, historyStore, resourceCache, schema2, templates, i18n]);
}
function useConnectionStatusStore() {
  const { bifur } = useSource().__internal, resourceCache = useResourceCache();
  return React.useMemo(() => {
    const connectionStatusStore = resourceCache.get({
      namespace: "connectionStatusStore",
      dependencies: [bifur]
    }) || createConnectionStatusStore({ bifur });
    return resourceCache.set({
      namespace: "connectionStatusStore",
      dependencies: [bifur],
      value: connectionStatusStore
    }), connectionStatusStore;
  }, [bifur, resourceCache]);
}
function usePresenceStore() {
  const {
    __internal: { bifur }
  } = useSource(), resourceCache = useResourceCache(), userStore = useUserStore(), connectionStatusStore = useConnectionStatusStore();
  return React.useMemo(() => {
    const presenceStore = resourceCache.get({
      namespace: "presenceStore",
      dependencies: [bifur, connectionStatusStore, userStore]
    }) || __tmp_wrap_presenceStore({ bifur, connectionStatusStore, userStore });
    return resourceCache.set({
      namespace: "presenceStore",
      dependencies: [bifur, connectionStatusStore, userStore],
      value: presenceStore
    }), presenceStore;
  }, [bifur, connectionStatusStore, resourceCache, userStore]);
}
function useProjectStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const projectStore = resourceCache.get({
      namespace: "projectStore",
      dependencies: [client2]
    }) || createProjectStore({ client: client2 });
    return resourceCache.set({
      namespace: "projectStore",
      dependencies: [client2],
      value: projectStore
    }), projectStore;
  }, [client2, resourceCache]);
}
function useKeyValueStore() {
  const resourceCache = useResourceCache(), workspace = useWorkspace(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useMemo(() => {
    const keyValueStore = resourceCache.get({
      dependencies: [workspace],
      namespace: "KeyValueStore"
    }) || createKeyValueStore({ client: client2 });
    return resourceCache.set({
      dependencies: [workspace],
      namespace: "KeyValueStore",
      value: keyValueStore
    }), keyValueStore;
  }, [client2, resourceCache, workspace]);
}
function useDocumentPresence(documentId) {
  const presenceStore = usePresenceStore(), [presence, setPresence] = React.useState([]);
  return React.useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]), presence;
}
function useGlobalPresence() {
  const [presence, setPresence] = React.useState([]), presenceStore = usePresenceStore();
  return React.useEffect(() => {
    const subscription = presenceStore.globalPresence$.subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [presenceStore]), presence;
}
const INITIAL_STATE = { referringDocuments: [], isLoading: !0 };
function useReferringDocuments(id2) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.listenQuery(
      "*[references($docId)] [0...101]",
      { docId: id2 },
      { tag: "use-referring-documents" }
    ).pipe(
      operators.map(
        (docs) => ({
          referringDocuments: docs,
          isLoading: !1
        })
      ),
      operators.startWith(INITIAL_STATE)
    ),
    [documentStore, id2],
    INITIAL_STATE
  );
}
const AssetUsageList = ({
  asset,
  assetType,
  referringDocuments
}) => {
  const { t: t2 } = useTranslation(), count = referringDocuments.length;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: count > 0, marginTop: 2, paddingBottom: 2, marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: "h2", weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        t: t2,
        i18nKey: `asset-source.usage-list.documents-using-${assetType}`,
        context: asset.originalFilename ? "named" : "unnamed",
        values: { filename: asset.originalFilename, count }
      }
    ) }) }),
    referringDocuments.map((document2) => /* @__PURE__ */ jsxRuntime.jsx(DocumentLink, { document: document2 }, document2._id))
  ] });
}, DocumentLink = ({ document: document2 }) => {
  const schema2 = useSchema(), LinkComponent = React.useCallback(
    (linkProps) => /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { ...linkProps, params: { id: document2._id, type: document2._type }, intent: "edit" }),
    [document2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: LinkComponent, radius: 2, "data-as": "a", tabIndex: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    Preview,
    {
      layout: "default",
      value: { _type: "reference", _ref: document2._id },
      schemaType: schema2.get(document2._type)
    }
  ) }) }, document2._id);
}, STYLE_ASSET_IMAGE = {
  maxWidth: "100%",
  height: "120px",
  objectFit: "contain",
  objectPosition: "center"
}, STYLE_CONFIRM_CARD = {
  gridColumn: "span 1",
  overflow: "hidden",
  display: "flex",
  alignSelf: "center",
  justifyContent: "center"
}, STYLE_IMAGE_WRAPPER = { height: "100%" }, ConfirmMessage = ({ asset, assetType, hasResults = !1 }) => {
  const isImage = assetType === "image", { t: t2 } = useTranslation();
  return hasResults ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "caution", padding: [3, 3, 4], border: !0, radius: 2, marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 3, gap: [2, 3, 4], children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: [3, 4], align: "center", style: { gridColumn: isImage ? "span 2" : "span 3" }, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2(`asset-source.delete-dialog.usage-list.warning-${assetType}-is-in-use`, {
        context: asset.originalFilename ? "named" : "unnamed",
        filename: asset.originalFilename
      }) })
    ] }),
    isImage && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, border: !0, radius: 1, style: STYLE_CONFIRM_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        src: `${asset.url}?w=200`,
        style: STYLE_ASSET_IMAGE,
        alt: t2("asset-source.usage-list.image-alt"),
        referrerPolicy: "strict-origin-when-cross-origin"
      }
    ) }) })
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingX: [2, 3, 4], paddingY: [3, 3, 3, 4], children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 3, gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { gridColumn: isImage ? "span 2" : "span 3" }, align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        t: t2,
        i18nKey: `asset-source.delete-dialog.usage-list.confirm-delete-${assetType}`,
        context: asset.originalFilename ? "named" : "unnamed",
        values: { filename: asset.originalFilename }
      }
    ) }) }),
    isImage && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, border: !0, radius: 1, style: STYLE_CONFIRM_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        src: `${asset.url}?w=200`,
        style: STYLE_ASSET_IMAGE,
        alt: t2("asset-source.asset-list.table.preview-alt"),
        referrerPolicy: "strict-origin-when-cross-origin"
      }
    ) }) })
  ] }) });
};
function AssetDeleteDialog({
  asset,
  assetType,
  isDeleting = !1,
  onClose,
  onDelete
}) {
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id), publishedDocuments = React.useMemo(() => {
    const drafts = referringDocuments.reduce(
      (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
      []
    );
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]), hasResults = publishedDocuments.length > 0, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      __unstable_autoFocus: isLoading,
      footer: {
        cancelButton: {
          onClick: onClose,
          text: t2("asset-source.delete-dialog.action.cancel")
        },
        confirmButton: {
          disabled: hasResults,
          icon: icons.TrashIcon,
          loading: isDeleting,
          onClick: onDelete,
          text: t2("asset-source.delete-dialog.action.delete")
        }
      },
      header: t2("asset-source.delete-dialog.header", { context: assetType }),
      id: "asset-dialog",
      onClickOutside: onClose,
      onClose,
      width: 1,
      children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Stack,
        {
          paddingX: hasResults ? [2, 3, 4] : 0,
          paddingY: hasResults ? [3, 3, 3, 4] : 0,
          space: 1,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(ConfirmMessage, { asset, assetType, hasResults }),
            hasResults && /* @__PURE__ */ jsxRuntime.jsx(
              AssetUsageList,
              {
                asset,
                referringDocuments: publishedDocuments,
                assetType
              }
            )
          ]
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS = { portal: !0, placement: "right" };
function AssetMenu({
  isSelected,
  border = !0,
  onAction
}) {
  const triggerButtonMode = isSelected ? "default" : "bleed", triggerButtonTone = isSelected ? "primary" : "default", { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          mode: border ? "ghost" : triggerButtonMode,
          tone: border ? "default" : triggerButtonTone
        }
      ),
      id: "asset-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: t2("asset-source.asset-list.menu.show-usage"),
            icon: icons.LinkIcon,
            onClick: () => {
              onAction({ type: "showUsage" });
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            text: t2("asset-source.asset-list.menu.delete"),
            icon: icons.TrashIcon,
            tone: "critical",
            onClick: () => {
              onAction({ type: "delete" });
            }
          }
        )
      ] }),
      popover: MENU_POPOVER_PROPS
    }
  );
}
function AssetUsageDialog({ asset, assetType, onClose }) {
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id), publishedDocuments = React.useMemo(() => {
    const drafts = referringDocuments.reduce(
      (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
      []
    );
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      __unstable_autoFocus: !0,
      header: t2("asset-source.asset-usage-dialog.header", { context: assetType }),
      id: "asset-dialog",
      onClickOutside: onClose,
      onClose,
      width: 1,
      children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(
        AssetUsageList,
        {
          asset,
          referringDocuments: publishedDocuments,
          assetType
        }
      )
    }
  );
}
const MIME_TYPES = {
  // Images
  "image/bmp": {
    title: "Bitmap Image"
  },
  "image/jpeg": {
    title: "JPEG Image"
  },
  "image/gif": {
    title: "GIF Image"
  },
  "image/vnd.microsoft.icon": {
    title: "Icon"
  },
  "image/png": {
    title: "PNG Image"
  },
  "image/svg+xml": {
    title: "SVG Image"
  },
  "image/webp": {
    title: "WebP Image"
  },
  "image/tiff": {
    title: "TIFF Image"
  },
  "image/heic": {
    title: "HEIC Image"
  },
  // Audio
  "audio/midi": {
    title: "MIDI Audio"
  },
  "audio/midi-x": {
    title: "MIDI Audio"
  },
  "audio/mpeg": {
    title: "MP3 Audio"
  },
  "audio/ogg": {
    title: "OGG Audio"
  },
  "audio/wav": {
    title: "WAV Audio"
  },
  "audio/webm": {
    title: "WebM Audio"
  },
  "audio/aac": {
    title: "AAC Audio"
  },
  // Video
  "video/x-msvideo": {
    title: "AVI Video"
  },
  "video/mp4": {
    title: "MP4 Video"
  },
  "video/mpeg": {
    title: "MPEG Video"
  },
  "video/ogg": {
    title: "OGG Video"
  },
  "video/webm": {
    title: "WebM Video"
  },
  "video/quicktime": {
    title: "QuickTime Video"
  },
  // Documents
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    title: "Excel Spreadsheet"
  },
  "application/vnd.ms-excel": {
    title: "Excel Spreadsheet"
  },
  "text/plain": {
    title: "Text"
  },
  "text/javascript": {
    title: "JavaScript"
  },
  "text/markdown": {
    title: "Markdown"
  },
  "text/csv": {
    title: "CSV"
  },
  "text/css": {
    title: "CSS"
  },
  "application/pdf": {
    title: "PDF Document"
  },
  "application/xml": {
    title: "XML Document"
  },
  "text/xml": {
    title: "XML Document"
  },
  "application/zip": {
    title: "ZIP Archive"
  },
  "application/vnd.rar": {
    title: "RAR Archive"
  },
  "application/x-7z-compressed": {
    title: "7-zip Archive"
  },
  "application/octet-stream": {
    title: "Binary"
  }
};
function convertMimeTypeToSomethingNice(mimeType) {
  const part = mimeType.replace("x-", "").split("/")[1];
  return part.charAt(0).toUpperCase() + part.slice(1);
}
function formatMimeType(mimeType) {
  return MIME_TYPES != null && MIME_TYPES[mimeType] ? MIME_TYPES[mimeType].title : convertMimeTypeToSomethingNice(mimeType);
}
const CardIconWrapper = styled__default.default.span`
  background-color: transparent;
  flex-shrink: 0;
`, CustomFlex = styled__default.default(ui.Flex)``, CustomCard$1 = styled__default.default(ui.Card)`
  ${(props2) => props2.isSelected && styled.css`
      --card-muted-fg-color: var(--card-bg-color);
      --card-fg-color: var(--card-bg-color);
    `}
`, RowButton = styled__default.default(ui.Button)`
  box-shadow: none;
  min-width: 0;
  cursor: pointer;
  position: initial;

  &:before,
  &:after {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
  }

  &:before {
    z-index: 0;
    pointer-events: none;
    border-radius: inherit;
  }

  ${(props2) => props2.isSelected && styled.css`
      --card-muted-fg-color: var(--card-bg-color);
      --card-fg-color: var(--card-bg-color);

      &:before {
        background-color: var(--card-focus-ring-color);
      }

      ${CardIconWrapper} {
        --card-muted-fg-color: var(--card-bg-color);
      }

      ${CustomFlex} {
        --card-muted-fg-color: var(--card-bg-color);
        --card-fg-color: var(--card-bg-color);
      }
    `}

  ${(props2) => !props2.isSelected && styled.css`
      &:hover:before {
        background-color: var(--card-bg-color);
      }

      &:focus:before {
        background-color: var(--card-code-bg-color);
      }

      &:focus-within:before {
        background-color: var(--card-bg-color);
      }
    `}
`, TypeText = styled__default.default(ui.Text)`
  overflow-wrap: anywhere;
`, STYLES_ROW_CARD = {
  position: "relative"
}, STYLES_ICON_CARD = { flexShrink: 0 }, STYLES_BUTTON_TEXT = { minWidth: 0 }, STYLES_ASSETMENU_WRAPPER = {
  zIndex: 3,
  marginTop: "-0.5rem",
  marginBottom: "-0.5rem"
}, AssetRow = (props2) => {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), toast = ui.useToast(), deleteRef$ = React.useRef(), [showUsageDialog, setShowUsageDialog] = React.useState(!1), [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [isDeleting, setIsDeleting] = React.useState(!1), [isOpen, setIsOpen] = React.useState(!1), { asset, onClick, onKeyPress, onDeleteFinished, isSelected, isMobile } = props2, { originalFilename, _id, mimeType, size, _createdAt } = asset, formattedTime = useRelativeTime(_createdAt, { useTemporalPhrase: !0 }), formattedMimeType = formatMimeType(mimeType), formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 }), formattedSize = getHumanFriendlyBytes(size, formatUnit), showTooltip = (originalFilename || "").length > 37, { t: t2 } = useTranslation(), handleConfirmDelete = React.useCallback(() => {
    setShowDeleteDialog(!0);
  }, []), handleDeleteError = React.useCallback(
    (error) => {
      toast.push({
        closable: !0,
        status: "error",
        title: t2("asset-source.file.asset-list.delete-failed"),
        description: error.message
      });
    },
    [t2, toast]
  ), handleDeleteSuccess = React.useCallback(() => {
    toast.push({
      status: "success",
      title: t2("asset-source.file.asset-list.delete-successful")
    });
  }, [t2, toast]), handleDeleteAsset = React.useCallback(() => {
    setIsDeleting(!0), deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({
      next: () => {
        setIsDeleting(!1), onDeleteFinished == null || onDeleteFinished(asset._id), setShowDeleteDialog(!1), handleDeleteSuccess();
      },
      error: (err) => {
        setIsDeleting(!1), handleDeleteError(err), console.error("Could not delete asset", err);
      }
    });
  }, [
    asset._id,
    handleDeleteError,
    handleDeleteSuccess,
    onDeleteFinished,
    versionedClient.observable
  ]), handleDialogClose = () => {
    setShowUsageDialog(!1), setShowDeleteDialog(!1);
  }, handleToggleUsageDialog = () => {
    setShowUsageDialog(!0);
  }, handleToggleOpen = () => {
    setIsOpen(!isOpen);
  }, handleMenuAction = (action) => {
    action.type === "delete" && handleConfirmDelete(), action.type === "showUsage" && handleToggleUsageDialog();
  }, usageDialog = React.useMemo(() => showUsageDialog && /* @__PURE__ */ jsxRuntime.jsx(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose }), [asset, showUsageDialog]), deleteDialog = React.useMemo(() => showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
    AssetDeleteDialog,
    {
      assetType: "file",
      asset,
      onClose: handleDialogClose,
      onDelete: handleDeleteAsset,
      isDeleting
    }
  ), [asset, handleDeleteAsset, isDeleting, showDeleteDialog]);
  return isMobile ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { paddingBottom: 2, style: STYLES_ROW_CARD, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Grid,
      {
        columns: 4,
        gap: 1,
        style: {
          position: "relative",
          gridTemplateColumns: "1fr 30px",
          opacity: isDeleting ? 0.5 : 1
        },
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            RowButton,
            {
              asset,
              mode: "bleed",
              padding: 0,
              "data-id": _id,
              onClick,
              paddingY: 1,
              radius: 2,
              children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, flex: 2, align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: CardIconWrapper, padding: 2, tone: "transparent", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 2, style: STYLES_ICON_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }) }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-end", align: "center", paddingRight: 1, style: STYLES_ASSETMENU_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              mode: "bleed",
              fontSize: 1,
              padding: 2,
              onClick: handleToggleOpen,
              icon: isOpen ? icons.ChevronUpIcon : icons.ChevronDownIcon
            }
          ) })
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { marginTop: 3, columns: 3, gap: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.size") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedSize })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.type") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedMimeType })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.date-added") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedTime })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, marginTop: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            fontSize: 1,
            tone: "default",
            mode: "ghost",
            text: t2("asset-source.file.asset-list.action.show-usage.title"),
            onClick: handleToggleUsageDialog,
            icon: icons.LinkIcon
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            fontSize: 1,
            tone: "critical",
            mode: "ghost",
            text: t2("asset-source.file.asset-list.action.delete.title"),
            icon: icons.TrashIcon,
            disabled: isSelected,
            title: t2(
              isSelected ? "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file" : "asset-source.file.asset-list.action.delete.title"
            ),
            onClick: handleConfirmDelete
          }
        )
      ] })
    ] }),
    usageDialog || deleteDialog
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(
    CustomCard$1,
    {
      asset,
      paddingBottom: 1,
      style: STYLES_ROW_CARD,
      radius: 0,
      overflow: "hidden",
      isSelected,
      "aria-selected": "true",
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Grid,
          {
            columns: 4,
            gap: 1,
            "data-id": _id,
            paddingY: 1,
            style: {
              position: "relative",
              gridTemplateColumns: "3fr 1fr 1fr 2fr 30px",
              opacity: isDeleting ? 0.5 : 1
            },
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                RowButton,
                {
                  asset,
                  mode: "bleed",
                  "data-id": _id,
                  onClick,
                  padding: 0,
                  onKeyPress,
                  title: t2("asset-source.file.asset-list.item.select-file-tooltip", {
                    filename: originalFilename
                  }),
                  isSelected,
                  radius: 2,
                  children: /* @__PURE__ */ jsxRuntime.jsxs(
                    CustomFlex,
                    {
                      gap: 2,
                      flex: 2,
                      paddingRight: 1,
                      align: "center",
                      onClick,
                      onKeyPress,
                      "data-id": _id,
                      children: [
                        /* @__PURE__ */ jsxRuntime.jsx(
                          ui.Card,
                          {
                            as: CardIconWrapper,
                            padding: 2,
                            tone: "transparent",
                            radius: 2,
                            style: STYLES_ICON_CARD,
                            children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 2, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) })
                          }
                        ),
                        showTooltip && /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: originalFilename, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename }) }),
                        !showTooltip && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedSize }) }),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(TypeText, { size: 1, muted: !0, textOverflow: "ellipsis", children: formattedMimeType }) }) }),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "time", size: 1, muted: !0, dateTime: _createdAt, children: formattedTime }) }),
              /* @__PURE__ */ jsxRuntime.jsx(
                CustomFlex,
                {
                  justify: "flex-end",
                  align: "center",
                  paddingX: 1,
                  paddingY: 1,
                  style: STYLES_ASSETMENU_WRAPPER,
                  children: /* @__PURE__ */ jsxRuntime.jsx(AssetMenu, { border: !1, isSelected: !1, onAction: handleMenuAction })
                }
              )
            ]
          }
        ),
        usageDialog || deleteDialog
      ]
    }
  );
}, STYLES_FILENAME = { paddingLeft: "2.2rem" }, STYLES_GRID = { gridTemplateColumns: "3fr 1fr 1fr 2fr 30px" };
function FileListView(props2) {
  const isMobile = ui.useMediaIndex() < 2, { assets, onClick, onKeyPress, onDeleteFinished, selectedAssets, isLoading } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, paddingBottom: 2, marginBottom: 1, children: isMobile ? /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { style: STYLES_GRID, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 2, paddingLeft: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.filename") }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: STYLES_GRID, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 2, style: STYLES_FILENAME, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.filename") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.size") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.type") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.date-added") }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 4, paddingBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }) }) }),
      assets.map((asset) => /* @__PURE__ */ jsxRuntime.jsx(
        AssetRow,
        {
          asset,
          isMobile,
          isSelected: selectedAssets.some((selected) => selected._id === asset._id),
          onClick,
          onKeyPress,
          onDeleteFinished
        },
        asset._id
      ))
    ] })
  ] });
}
const DPI = typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(window.devicePixelRatio), Image$4 = styled__default.default.img`
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
`, Container$1 = styled__default.default(ui.Card)`
  position: relative;
  z-index: 1;
  padding-bottom: 100%;
`, Root$7 = styled__default.default.div`
  position: relative;
  display: inherit;
`, MenuContainer = styled__default.default.div`
  box-sizing: border-box;
  position: absolute;
  z-index: 2;
  top: 3px;
  right: 3px;

  & button[data-selected] {
    display: block;
  }

  @media (hover: hover) {
    // If hover is supported, hide the buttons until the user hovers or focuses the asset
    // Use opacity to enable the buttons to still be focusable
    & button {
      opacity: 0;
    }

    ${Root$7}:hover & {
      button {
        opacity: 1;
      }
    }

    ${Root$7}:focus-within & {
      button {
        opacity: 1;
      }
    }
  }
`, AssetThumb = React.memo(function(props2) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), toast = ui.useToast(), deleteRef$ = React.useRef(), { asset, onClick, onKeyPress, onDeleteFinished, isSelected } = props2, [showUsageDialog, setShowUsageDialog] = React.useState(!1), [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [isDeleting, setIsDeleting] = React.useState(!1), { t: t2 } = useTranslation();
  React.useEffect(() => () => {
    deleteRef$.current && deleteRef$.current.unsubscribe();
  }, []);
  const handleConfirmDelete = React.useCallback(() => {
    setShowDeleteDialog(!0);
  }, [setShowDeleteDialog]), handleDialogClose = React.useCallback(() => {
    setShowUsageDialog(!1), setShowDeleteDialog(!1);
  }, [setShowUsageDialog, setShowDeleteDialog]), handleToggleUsageDialog = React.useCallback(() => {
    setShowUsageDialog(!0);
  }, [setShowUsageDialog]), handleDeleteError = React.useCallback(
    (error) => {
      toast.push({
        closable: !0,
        status: "error",
        title: t2("asset-source.image.asset-list.delete-failed"),
        description: error.message
      });
    },
    [t2, toast]
  ), handleDeleteSuccess = React.useCallback(() => {
    toast.push({
      status: "success",
      title: t2("asset-source.image.asset-list.delete-successful")
    });
  }, [t2, toast]), handleDeleteAsset = React.useCallback(() => {
    setIsDeleting(!0), deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({
      next: () => {
        setIsDeleting(!1), onDeleteFinished(asset._id), setShowDeleteDialog(!1), handleDeleteSuccess();
      },
      error: (err) => {
        setIsDeleting(!1), handleDeleteError(err), console.error("Could not delete asset", err);
      }
    });
  }, [
    asset._id,
    handleDeleteError,
    handleDeleteSuccess,
    onDeleteFinished,
    versionedClient.observable
  ]), handleMenuAction = React.useCallback(
    (action) => {
      action.type === "delete" && handleConfirmDelete(), action.type === "showUsage" && handleToggleUsageDialog();
    },
    [handleConfirmDelete, handleToggleUsageDialog]
  ), usageDialog = React.useMemo(() => showUsageDialog && /* @__PURE__ */ jsxRuntime.jsx(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose }), [asset, handleDialogClose, showUsageDialog]), deleteDialog = React.useMemo(() => showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
    AssetDeleteDialog,
    {
      assetType: "file",
      asset,
      onClose: handleDialogClose,
      onDelete: handleDeleteAsset,
      isDeleting
    }
  ), [asset, handleDeleteAsset, handleDialogClose, isDeleting, showDeleteDialog]), { originalFilename, _id, url } = asset, imgH = 200 * Math.max(1, DPI), imageUrl = url.includes(".gif") ? `${url}?h=${imgH}&fit=max&fm=jpg` : `${url}?h=${imgH}&fit=max`;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$7, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        selected: isSelected,
        tabIndex: 0,
        "data-id": _id,
        mode: "ghost",
        onKeyPress,
        padding: 0,
        style: { padding: 2 },
        children: /* @__PURE__ */ jsxRuntime.jsxs(Container$1, { __unstable_checkered: !0, children: [
          /* @__PURE__ */ jsxRuntime.jsx(Image$4, { alt: originalFilename, src: imageUrl, onClick, "data-id": _id }),
          isDeleting && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(MenuContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(AssetMenu, { isSelected, onAction: handleMenuAction }) }),
    usageDialog || deleteDialog
  ] });
}), ThumbGrid = styled__default.default(ui.Grid)`
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
`;
function ImageListView(props2) {
  const { isLoading, assets, selectedAssets, onItemClick, onItemKeyPress, onDeleteFinished } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ThumbGrid, { gap: 2, children: assets.map((asset) => /* @__PURE__ */ jsxRuntime.jsx(
      AssetThumb,
      {
        asset,
        isSelected: selectedAssets.some((selected) => selected._id === asset._id),
        onClick: onItemClick,
        onKeyPress: onItemKeyPress,
        onDeleteFinished
      },
      asset._id
    )) }),
    isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }) }),
    !isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0 })
  ] });
}
const PER_PAGE = 200, ASSET_TYPE_IMAGE = "sanity.imageAsset", ASSET_TYPE_FILE = "sanity.fileAsset", buildFilterQuery = (acceptParam) => {
  const WILDCARD_ACCEPT = ["image/*", "audio/*", "video/*"], typesForFilter = acceptParam.split(",").map((accept) => accept.trim()).reduce(
    (acceptTypes, acceptValue) => WILDCARD_ACCEPT.includes(acceptValue) ? {
      ...acceptTypes,
      wildcards: `mimeType match '${acceptValue}' || ${acceptTypes.wildcards}`
    } : acceptValue.indexOf(".") === 0 ? {
      ...acceptTypes,
      extensions: `'${acceptValue.replace(".", "")}', ${acceptTypes.extensions}`
    } : { ...acceptTypes, mimes: `'${acceptValue}', ${acceptTypes.mimes}` },
    { mimes: "", extensions: "", wildcards: "" }
  );
  return `&&
  (
    ${typesForFilter.wildcards}
    extension in [${typesForFilter.extensions}] ||
    mimeType in [${typesForFilter.mimes}]
  )`;
}, buildQuery = (start = 0, end = PER_PAGE, assetType = ASSET_TYPE_IMAGE, acceptParam) => {
  const filterCondition = acceptParam.length > 0 ? buildFilterQuery(acceptParam) : "";
  return `
  *[_type == "${assetType}" ${filterCondition}] | order(_updatedAt desc) [${start}...${end}] {
    _id,
    _updatedAt,
    _createdAt,
    url,
    originalFilename,
    mimeType,
    extension,
    size,
    metadata {dimensions}
  }
`;
}, CardLoadMore = styled__default.default(ui.Card)`
  border-top: 1px solid var(--card-border-color);
  position: sticky;
  bottom: 0;
  z-index: 200;
`, DefaultAssetSource = function(props2, ref) {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), versionedClient = React.useMemo(() => client2.withConfig({ apiVersion: "2023-02-14" }), [client2]), _elementId = React.useRef(`default-asset-source-${uniqueId__default.default()}`), currentPageNumber = React.useRef(0), { t: t2 } = useTranslation(), fetch$ = React.useRef(), [assets, setAssets] = React.useState([]), [isLastPage, setIsLastPage] = React.useState(!1), [hasResetAutoFocus, setHasResetFocus] = React.useState(!1), [isLoading, setIsLoading] = React.useState(!0), { selectedAssets, assetType = "image", dialogHeaderTitle, onClose, onSelect, accept } = props2, isImageOnlyWildCard = accept && accept === "image/*" && assetType === "image", fetchPage = React.useCallback(
    (pageNumber) => {
      const start = pageNumber * PER_PAGE, end = start + PER_PAGE, isImageAssetType = assetType === "image", tag = isImageAssetType ? "asset.image-list" : "asset.file-list", assetTypeParam = isImageAssetType ? ASSET_TYPE_IMAGE : ASSET_TYPE_FILE;
      setIsLoading(!0), typeof accept < "u" && (fetch$.current = versionedClient.observable.fetch(buildQuery(start, end, assetTypeParam, accept), {}, { tag }).subscribe((result) => {
        setIsLastPage(result.length < PER_PAGE), setAssets((prevState) => prevState.concat(result)), setIsLoading(!1);
      }));
    },
    [assetType, accept, versionedClient]
  ), handleDeleteFinished = React.useCallback(
    (id2) => {
      setAssets((prevState) => prevState.filter((asset) => asset._id !== id2));
    },
    [setAssets]
  ), select2 = React.useCallback(
    (id2) => {
      assets.find((doc) => doc._id === id2) && onSelect([{ kind: "assetDocumentId", value: id2 }]);
    },
    [assets, onSelect]
  ), handleItemClick = React.useCallback(
    (event) => {
      event.preventDefault();
      const id2 = event.currentTarget.getAttribute("data-id");
      if (!id2)
        throw new Error("Missing data-id attribute on item");
      select2(id2);
    },
    [select2]
  ), handleItemKeyPress = React.useCallback(
    (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        const id2 = event.currentTarget.getAttribute("data-id");
        if (!id2)
          throw new Error("Missing data-id attribute on item");
        select2(id2);
      }
    },
    [select2]
  ), handleClose = React.useCallback(() => {
    onClose && onClose();
  }, [onClose]), handleFetchNextPage = React.useCallback(
    (event) => {
      event.preventDefault(), fetchPage(++currentPageNumber.current);
    },
    [fetchPage]
  );
  React.useEffect(() => (fetchPage(currentPageNumber.current), () => {
    fetch$.current && fetch$.current.unsubscribe();
  }), [fetchPage]), React.useEffect(() => {
    !isLoading && (!currentPageNumber.current || currentPageNumber.current === 0) && setHasResetFocus(!0);
  }, [isLoading]);
  const listFormat = useListFormat({ style: "narrow" });
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      __unstable_autoFocus: hasResetAutoFocus,
      header: dialogHeaderTitle || t2("asset-source.dialog.default-title", {
        context: assetType
      }),
      id: _elementId.current,
      onClickOutside: handleClose,
      onClose: handleClose,
      ref,
      width: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
        !isImageOnlyWildCard && !isLoading && (accept == null ? void 0 : accept.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "primary", padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "asset-source.dialog.accept-message",
              values: {
                acceptTypes: listFormat.format(accept.split(",").map((type) => type.trim()))
              }
            }
          ) })
        ] }) }),
        assetType === "file" && /* @__PURE__ */ jsxRuntime.jsx(
          FileListView,
          {
            assets,
            onDeleteFinished: handleDeleteFinished,
            onClick: handleItemClick,
            onKeyPress: handleItemKeyPress,
            isLoading,
            selectedAssets
          }
        ),
        assetType === "image" && /* @__PURE__ */ jsxRuntime.jsx(
          ImageListView,
          {
            assets,
            onDeleteFinished: handleDeleteFinished,
            onItemClick: handleItemClick,
            onItemKeyPress: handleItemKeyPress,
            isLoading,
            selectedAssets
          }
        ),
        assets.length > 0 && !isLastPage && /* @__PURE__ */ jsxRuntime.jsx(CardLoadMore, { tone: "default", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            type: "button",
            icon: icons.DownloadIcon,
            loading: isLoading,
            onClick: handleFetchNextPage,
            size: "large",
            text: t2("asset-source.dialog.load-more"),
            tone: "primary"
          }
        ) }) })
      ] })
    }
  );
}, DefaultSource = React.memo(React.forwardRef(DefaultAssetSource)), FileSource = {
  name: "sanity-default",
  title: "Uploaded files",
  i18nKey: "asset-source.file.title",
  component: DefaultSource,
  icon: icons.DocumentsIcon
}, ImageSource = {
  name: "sanity-default",
  title: "Uploaded images",
  i18nKey: "asset-source.image.title",
  component: DefaultSource,
  icon: icons.ImageIcon
}, initialDocumentBadges = [], initialDocumentActions = [], initialLanguageFilter = [], schemaTypesReducer = (prev, { schema: schema2 }, context) => {
  const schemaTypes = schema2 == null ? void 0 : schema2.types;
  if (!schemaTypes)
    return prev;
  if (typeof schemaTypes == "function")
    return schemaTypes(prev, context);
  if (Array.isArray(schemaTypes))
    return [...prev, ...schemaTypes];
  throw new Error(
    `Expected \`schema.types\` to be an array or a function, but received ${getPrintableType(
      schemaTypes
    )}`
  );
}, resolveProductionUrlReducer = async (prev, { document: document2 }, context) => {
  const resolveProductionUrl = document2 == null ? void 0 : document2.productionUrl;
  return resolveProductionUrl ? await resolveProductionUrl(prev, context) : prev;
}, toolsReducer = (prev, { tools }, context) => {
  if (!tools)
    return prev;
  if (typeof tools == "function")
    return tools(prev, context);
  if (Array.isArray(tools))
    return [...prev, ...tools];
  throw new Error(
    `Expected \`tools\` to be an array or a function, but received ${getPrintableType(tools)}`
  );
}, schemaTemplatesReducer = (prev, { schema: schema2 }, context) => {
  const schemaTemplates = schema2 == null ? void 0 : schema2.templates;
  if (!schemaTemplates)
    return prev;
  if (typeof schemaTemplates == "function")
    return schemaTemplates(prev, context);
  if (Array.isArray(schemaTemplates))
    return [...prev, ...schemaTemplates];
  throw new Error(
    `Expected \`schema.templates\` to be an array or a function, but received ${getPrintableType(
      schemaTemplates
    )}`
  );
}, localeDefReducer = (prev, { i18n }, context) => {
  const locales = i18n == null ? void 0 : i18n.locales;
  if (!locales)
    return prev;
  if (typeof locales == "function")
    return locales(prev, context);
  if (Array.isArray(locales))
    return [...prev, ...locales];
  throw new Error(
    `Expected \`i18n.locales\` to be an array or a function, but received ${getPrintableType(
      locales
    )}`
  );
}, localeBundlesReducer = (prev, { i18n }, context) => {
  const bundles = i18n == null ? void 0 : i18n.bundles;
  if (!bundles)
    return prev;
  if (Array.isArray(bundles))
    return [...prev, ...bundles];
  if (typeof bundles == "function")
    return bundles(prev, context);
  throw new Error(
    `Expected \`i18n.bundles\` to be an array or a function, but received ${typeof bundles}`
  );
}, documentBadgesReducer = (prev, { document: document2 }, context) => {
  const documentBadges = document2 == null ? void 0 : document2.badges;
  if (!documentBadges)
    return prev;
  if (typeof documentBadges == "function")
    return documentBadges(prev, context);
  if (Array.isArray(documentBadges))
    return [...prev, ...documentBadges];
  throw new Error(
    `Expected \`document.badges\` to be an array or a function, but received ${getPrintableType(
      documentBadges
    )}`
  );
}, documentActionsReducer = (prev, { document: document2 }, context) => {
  const documentActions = document2 == null ? void 0 : document2.actions;
  if (!documentActions)
    return prev;
  if (typeof documentActions == "function")
    return documentActions(prev, context);
  if (Array.isArray(documentActions))
    return [...prev, ...documentActions];
  throw new Error(
    `Expected \`document.actions\` to be an array or a function, but received ${getPrintableType(
      documentActions
    )}`
  );
}, newDocumentOptionsResolver = (prev, { document: document2 }, context) => {
  const resolveNewDocumentOptions = document2 == null ? void 0 : document2.newDocumentOptions;
  if (!resolveNewDocumentOptions)
    return prev;
  if (typeof resolveNewDocumentOptions != "function")
    throw new Error(
      `Expected \`document.resolveNewDocumentOptions\` to be a function, but received ${getPrintableType(
        resolveNewDocumentOptions
      )}`
    );
  return resolveNewDocumentOptions(prev, context);
}, fileAssetSourceResolver = (prev, { form }, context) => {
  var _a2;
  const assetSources = (_a2 = form == null ? void 0 : form.file) == null ? void 0 : _a2.assetSources;
  if (!assetSources)
    return prev;
  if (typeof assetSources == "function")
    return assetSources(prev, context);
  if (Array.isArray(assetSources))
    return [...prev, ...assetSources];
  throw new Error(
    `Expected \`form.file.assetSources\` to be an array or a function, but received ${getPrintableType(
      assetSources
    )}`
  );
}, imageAssetSourceResolver = (prev, { form }, context) => {
  var _a2;
  const assetSources = (_a2 = form == null ? void 0 : form.image) == null ? void 0 : _a2.assetSources;
  if (!assetSources)
    return prev;
  if (typeof assetSources == "function")
    return assetSources(prev, context);
  if (Array.isArray(assetSources))
    return [...prev, ...assetSources];
  throw new Error(
    `Expected \`form.image.assetSources\` to be an array or a function, but received ${getPrintableType(
      assetSources
    )}`
  );
}, documentLanguageFilterReducer = (prev, { document: document2 }, context) => {
  const resolveDocumentLanguageFilter = document2 == null ? void 0 : document2.unstable_languageFilter;
  if (!resolveDocumentLanguageFilter)
    return prev;
  if (typeof resolveDocumentLanguageFilter == "function")
    return resolveDocumentLanguageFilter(prev, context);
  if (Array.isArray(resolveDocumentLanguageFilter))
    return [...prev, ...resolveDocumentLanguageFilter];
  throw new Error(
    `Expected \`document.unstable_languageFilter\` to be an array or a function, but received ${getPrintableType(
      resolveDocumentLanguageFilter
    )}`
  );
}, documentInspectorsReducer = (prev, { document: document2 }, context) => {
  const resolveInspectorsFilter = document2 == null ? void 0 : document2.inspectors;
  if (!resolveInspectorsFilter)
    return prev;
  if (typeof resolveInspectorsFilter == "function")
    return resolveInspectorsFilter(prev, context);
  if (Array.isArray(resolveInspectorsFilter))
    return [...prev, ...resolveInspectorsFilter];
  throw new Error(
    `Expected \`document.inspectors\` to be an array or a function, but received ${getPrintableType(
      resolveInspectorsFilter
    )}`
  );
}, documentCommentsEnabledReducer = (opts) => {
  const { config, context, initialValue } = opts;
  return flattenConfig(config, []).reduce((acc, { config: innerConfig }) => {
    var _a2, _b;
    const resolver = (_b = (_a2 = innerConfig.document) == null ? void 0 : _a2.unstable_comments) == null ? void 0 : _b.enabled;
    if (!resolver && typeof resolver != "boolean")
      return acc;
    if (typeof resolver == "function")
      return resolver(context);
    if (typeof resolver == "boolean")
      return resolver;
    throw new Error(
      `Expected \`document.unstable_comments.enabled\` to be a boolean or a function, but received ${getPrintableType(
        resolver
      )}`
    );
  }, initialValue);
}, internalTasksReducer = (opts) => {
  const { config } = opts;
  return flattenConfig(config, []).reduce(
    (acc, { config: innerConfig }) => {
      const resolver = innerConfig.__internal_tasks;
      if (!resolver)
        return acc;
      if (typeof resolver == "object" && resolver.footerAction)
        return resolver;
      throw new Error(
        `Expected \`__internal__tasks\` to be an object with footerAction, but received ${getPrintableType(
          resolver
        )}`
      );
    },
    void 0
  );
}, partialIndexingEnabledReducer = (opts) => {
  const { config, initialValue } = opts;
  return flattenConfig(config, []).reduce((acc, { config: innerConfig }) => {
    var _a2, _b;
    const resolver = (_b = (_a2 = innerConfig.search) == null ? void 0 : _a2.unstable_partialIndexing) == null ? void 0 : _b.enabled;
    if (!resolver && typeof resolver != "boolean")
      return acc;
    if (typeof resolver == "boolean")
      return resolver;
    throw new Error(
      `Expected \`search.unstable_partialIndexing.enabled\` to be a boolean, but received ${getPrintableType(
        resolver
      )}`
    );
  }, initialValue);
}, newSearchEnabledReducer = (prev, { search: search2 }) => prev || (search2 == null ? void 0 : search2.unstable_enableNewSearch) || !1;
function resolveConfigProperty({
  config: inputConfig,
  context,
  initialValue,
  propertyName,
  ...reducers
}) {
  const configs = flattenConfig(inputConfig, []);
  if ("reducer" in reducers)
    return configs.reduce((acc, { config, path }) => {
      try {
        return reducers.reducer(acc, config, context);
      } catch (e) {
        throw new ConfigPropertyError({
          propertyName,
          path,
          cause: e
        });
      }
    }, initialValue);
  const reducer = reducers.asyncReducer;
  return (async () => {
    let current = initialValue;
    for (const { config, path } of configs)
      try {
        current = await reducer(current, config, context);
      } catch (e) {
        throw new ConfigPropertyError({
          propertyName,
          path,
          cause: e
        });
      }
    return current;
  })();
}
function createSanityI18nBackend(options) {
  const { bundles } = options;
  function init() {
  }
  function read2(locale, namespace, callback) {
    const loadable = bundles.filter(
      (bundle) => bundle.locale === locale && bundle.namespace === namespace
    );
    if (loadable.length === 0) {
      callback(
        `No translations found for namespace "${namespace}", language "${locale}"`,
        void 0
        // Returning undefined here will i18next _not_ retry
      );
      return;
    }
    loadBundles(loadable).then((resources) => callback(null, resources)).catch((err) => callback(err, !0));
  }
  return {
    type: "backend",
    init,
    read: read2
  };
}
async function loadBundles(bundles) {
  var _a2, _b;
  const resolved = await Promise.all(
    bundles.map(async (bundle) => ({
      ...bundle,
      resources: await loadBundleResources(bundle)
    }))
  ), base = {};
  for (const item of resolved) {
    const deep = (_a2 = item.deep) != null ? _a2 : !0, overwrite = (_b = item.overwrite) != null ? _b : !0;
    deep ? deepExtend(base, item.resources, overwrite) : overwrite ? Object.assign(base, item.resources) : Object.assign({}, item.resources, base);
  }
  return base;
}
async function loadBundleResources(bundle) {
  if (typeof bundle.resources != "function")
    return bundle.resources;
  const resources = await bundle.resources();
  return maybeUnwrapModule(resources);
}
function deepExtend(target, source, overwrite = !1) {
  for (const prop in source) {
    if (prop === "__proto__" || prop === "constructor")
      continue;
    if (!(prop in target)) {
      target[prop] = source[prop];
      continue;
    }
    const targetLeaf = target[prop], sourceLeaf = source[prop], targetIsString = isStringLeaf(targetLeaf), sourceIsString = isStringLeaf(sourceLeaf);
    if ((targetIsString || sourceIsString) && overwrite) {
      target[prop] = source[prop];
      continue;
    }
    if (targetIsString || sourceIsString)
      continue;
    const sourceIsArray = Array.isArray(sourceLeaf), targetIsArray = Array.isArray(targetLeaf);
    if (sourceIsArray || targetIsArray) {
      overwrite && (target[prop] = sourceLeaf);
      continue;
    }
    deepExtend(targetLeaf, sourceLeaf, overwrite);
  }
  return target;
}
function isStringLeaf(target) {
  return typeof target == "string" || target instanceof String;
}
function maybeUnwrapModule(maybeModule) {
  return isWrappedModule(maybeModule) ? maybeModule.default : maybeModule;
}
function isWrappedModule(mod) {
  return "default" in mod && typeof mod.default == "object" && isPlainObject__default.default(mod.default);
}
function prepareI18n(source) {
  const { projectId, dataset, name: sourceName } = source, context = { projectId, dataset }, locales = resolveConfigProperty({
    config: source,
    context,
    propertyName: "i18n.locales",
    reducer: localeDefReducer,
    initialValue: [defaultLocale]
  }), bundles = resolveConfigProperty({
    config: source,
    context,
    propertyName: "i18n.bundles",
    reducer: localeBundlesReducer,
    initialValue: normalizeResourceBundles(locales)
  });
  return createI18nApi({
    locales,
    bundles,
    projectId,
    sourceName
  });
}
function createI18nApi({
  locales,
  bundles,
  projectId,
  sourceName
}) {
  const namespaceNames = new Set(bundles.map((bundle) => bundle.namespace)), options = getI18NextOptions(projectId, sourceName, locales, namespaceNames), i18nInstance = i18next.createInstance().use(createSanityI18nBackend({ bundles })).use(reactI18next.initReactI18next);
  i18nInstance.init(options).catch((err) => {
    console.error("Failed to initialize i18n backend: %s", err);
  });
  const reducedLocales = locales.map(reduceLocaleDefinition);
  return {
    /** @public */
    source: {
      get currentLocale() {
        var _a2;
        return (_a2 = reducedLocales.find((locale) => locale.id === i18nInstance.language)) != null ? _a2 : defaultLocale;
      },
      loadNamespaces(namespaces) {
        const missing = namespaces.filter((ns) => !i18nInstance.hasLoadedNamespace(ns));
        return missing.length === 0 ? Promise.resolve() : i18nInstance.loadNamespaces(missing);
      },
      locales: reducedLocales,
      t: maybeWrapT(i18nInstance.t)
    },
    /** @internal */
    i18next: i18nInstance
  };
}
function normalizeResourceBundles(locales) {
  const normalized = [];
  for (const lang of locales) {
    if (lang.bundles && !Array.isArray(lang.bundles))
      throw new Error(`Resource bundle for locale ${lang.id} is not an array`);
    if (lang.bundles)
      for (const bundle of lang.bundles) {
        if ("locale" in bundle && bundle.locale !== lang.id)
          throw new Error(`Resource bundle inside locale ${lang.id} has mismatching locale id`);
        if (!bundle.namespace)
          throw new Error(`Resource bundle for locale ${lang.id} is missing namespace`);
        normalized.push("locale" in bundle ? bundle : { ...bundle, locale: lang.id });
      }
  }
  return normalized;
}
const defaultOptions = {
  /**
   * Even though we're only defining the studio namespace, i18next will still load requested
   * namespaces through the backend. The reason why we're defining the namespace at all is to
   * prevent i18next from (trying) to load the i18next default `translation` namespace.
   */
  ns: [studioLocaleNamespace],
  defaultNS: studioLocaleNamespace,
  partialBundledLanguages: !0,
  // Fall back to English (US) locale
  fallbackLng: defaultLocale.id,
  // This will be overriden with the users detected/preferred locale before initing,
  // but to satisfy the init options and prevent mistakes, we include a default here.
  lng: defaultLocale.id,
  // In rare cases we'll want to be able to debug i18next - there is a `debug` option
  // in the studio i18n configuration for that, which will override this value.
  debug: DEBUG_I18N,
  // When specifying language 'en-US', do not load 'en-US', 'en', 'dev' - only `en-US`.
  load: "currentOnly",
  // We always use our "backend" for loading translations, allowing us to handle i18n resources
  // in a single place with a single approach. This means we shouldn't need to wait for the init,
  // as any missing translations will be loaded async (through react suspense).
  initImmediate: !0,
  // Because we use i18next-react, we do not need to escale values
  interpolation: {
    escapeValue: !1
  },
  // Theoretically, if the framework somehow gets new translations added, re-render.
  // Note that this shouldn't actually happen, as we only use the Sanity backend
  react: {
    bindI18nStore: "added"
  }
};
function getI18NextOptions(projectId, sourceName, locales, namespaces) {
  var _a2, _b;
  const preferredLocaleId = getPreferredLocale(projectId, sourceName), preferredLocale = locales.find((l) => l.id === preferredLocaleId), lastLocale = locales[locales.length - 1], locale = (_b = (_a2 = preferredLocale == null ? void 0 : preferredLocale.id) != null ? _a2 : lastLocale.id) != null ? _b : defaultOptions.lng;
  return {
    ...defaultOptions,
    ns: Array.from(namespaces),
    // For now, let us load all namespaces. We can optimize later.
    lng: locale,
    supportedLngs: locales.map((def) => def.id)
  };
}
function reduceLocaleDefinition(definition) {
  const { bundles, ...locale } = definition;
  return locale;
}
function createFilterDefinitionDictionary(filterDefinitions2) {
  return filterDefinitions2.reduce((acc, val) => (acc[val.name] = val, acc), {});
}
function defineSearchFilter(filterDef) {
  return filterDef;
}
function defineSearchFilterOperators(operators2) {
  return operators2;
}
function getFilterDefinition(definitions, filterName) {
  return definitions[filterName];
}
function getSupportedFieldTypes(filterDefs) {
  return filterDefs.reduce((acc, val) => (val.type === "field" && acc.push(val.fieldType), acc), []);
}
const filterDefinitions = [
  // 'Pinned' filters
  {
    fieldPath: "_updatedAt",
    icon: icons.CalendarIcon,
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" }
    ],
    title: "Edited at",
    name: "updatedAt",
    type: "pinned"
  },
  {
    fieldPath: "_createdAt",
    icon: icons.CalendarIcon,
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" }
    ],
    title: "Created at",
    name: "createdAt",
    type: "pinned"
  },
  {
    icon: icons.LinkIcon,
    operators: [
      { name: "referencesDocument", type: "item" },
      { name: "referencesAssetImage", type: "item" },
      { name: "referencesAssetFile", type: "item" }
    ],
    title: "Contains document, image or file",
    name: "references",
    type: "pinned"
  },
  // 'Field' filters
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "array",
    operators: [
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "arrayList",
    operators: [
      { name: "arrayListIncludes", type: "item" },
      { name: "arrayListNotIncludes", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "arrayReferences",
    operators: [
      { name: "arrayReferenceIncludes", type: "item" },
      { name: "arrayReferenceNotIncludes", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "boolean",
    icon: icons.CheckmarkCircleIcon,
    name: "boolean",
    operators: [
      { name: "booleanEqual", type: "item" },
      { type: "divider" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "date",
    icon: icons.CalendarIcon,
    name: "date",
    operators: [
      { name: "dateLast", type: "item" },
      { type: "divider" },
      { name: "dateRange", type: "item" },
      { name: "dateAfter", type: "item" },
      { name: "dateBefore", type: "item" },
      { type: "divider" },
      { name: "dateEqual", type: "item" },
      { name: "dateNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "datetime",
    icon: icons.CalendarIcon,
    name: "datetime",
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "email",
    icon: icons.StringIcon,
    name: "email",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "file",
    icon: icons.DocumentIcon,
    name: "file",
    operators: [
      { name: "assetFileEqual", type: "item" },
      { name: "assetFileNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "image",
    icon: icons.ImageIcon,
    name: "image",
    operators: [
      { name: "assetImageEqual", type: "item" },
      { name: "assetImageNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "number",
    icon: icons.NumberIcon,
    name: "number",
    operators: [
      { name: "numberEqual", type: "item" },
      { name: "numberNotEqual", type: "item" },
      { type: "divider" },
      { name: "numberGt", type: "item" },
      { name: "numberGte", type: "item" },
      { name: "numberLt", type: "item" },
      { name: "numberLte", type: "item" },
      { type: "divider" },
      { name: "numberRange", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.BlockContentIcon,
    name: "portableText",
    operators: [
      { name: "portableTextMatches", type: "item" },
      { name: "portableTextNotMatches", type: "item" },
      { type: "divider" },
      { name: "portableTextEqual", type: "item" },
      { name: "portableTextNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "reference",
    icon: icons.LinkIcon,
    name: "reference",
    operators: [
      { name: "referenceEqual", type: "item" },
      { name: "referenceNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "slug",
    icon: icons.StringIcon,
    name: "slug",
    operators: [
      { name: "slugMatches", type: "item" },
      { name: "slugNotMatches", type: "item" },
      { type: "divider" },
      { name: "slugEqual", type: "item" },
      { name: "slugNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "string",
    icon: icons.StringIcon,
    name: "string",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "string",
    icon: icons.ChevronDownIcon,
    name: "stringList",
    operators: [
      { name: "stringListEqual", type: "item" },
      { name: "stringListNotEqual", type: "item" },
      { type: "divider" },
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "text",
    icon: icons.StringIcon,
    name: "text",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "url",
    icon: icons.StringIcon,
    name: "url",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  }
];
function useDateTimeFormat(options = {}) {
  const currentLocale = getJsonStream.useCurrentLocale().id;
  return intlCache.dateTimeFormat(currentLocale, options);
}
function useUnitFormatter(options = {}) {
  const currentLocale = getJsonStream.useCurrentLocale().id, defaultOptions2 = {
    unitDisplay: "long",
    ...options,
    style: "unit"
  };
  return function(value, unit) {
    return intlCache.numberFormat(currentLocale, { ...defaultOptions2, unit }).format(value);
  };
}
function ReferencePreviewTitle({
  documentId,
  schemaType
}) {
  const documentPreviewStore = useDocumentPreviewStore(), { draft, published, isLoading } = reactRx.useMemoObservable(
    () => getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""),
    [documentId, documentPreviewStore, schemaType]
  ), sanityDocument = React.useMemo(() => ({
    _id: documentId,
    _type: schemaType.name
  }), [documentId, schemaType.name]), previewValue = getPreviewValueWithFallback({
    draft,
    published,
    value: sanityDocument
  });
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, marginLeft: 1, radius: 2, style: { width: "10ch", height: "1em" } }) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: previewValue.title || documentId.slice(0, 8) });
}
function SearchButtonValueDate({
  value
}) {
  const dateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: value.includeTime ? "short" : void 0
  }), date = value != null && value.date ? new Date(value.date) : null;
  return !date || !dateFns.isValid(date) ? null : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: dateFormat.format(date) });
}
function SearchButtonValueDateLast({
  value
}) {
  var _a2;
  const formatUnit = useUnitFormatter();
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: formatUnit(Math.floor((_a2 = value == null ? void 0 : value.unitValue) != null ? _a2 : 0), value.unit) });
}
function SearchButtonValueDateRange({
  value
}) {
  const dateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: value.includeTime ? "short" : void 0
  }), startDate = value != null && value.from ? new Date(value.from) : null, endDate = value != null && value.to ? new Date(value.to) : null;
  if (!endDate || !startDate || !dateFns.isValid(endDate) || !dateFns.isValid(startDate))
    return null;
  const from = dateFormat.format(startDate), to = dateFormat.format(endDate);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: `${from} \u2192 ${to}` });
}
function SearchButtonValueReference({ value }) {
  const schema2 = useSchema(), documentId = value._ref, schemaType = schema2.get(value._type);
  return schemaType ? /* @__PURE__ */ jsxRuntime.jsx(ReferencePreviewTitle, { documentId, schemaType }) : null;
}
const SearchContext = React.createContext(void 0);
function useSearchState() {
  const context = React.useContext(SearchContext);
  if (context === void 0)
    throw new Error("useSearchState must be used within an SearchProvider");
  return context;
}
function SearchFilterNumberInput({ value, onChange }) {
  const [uncontrolledValue, setUncontrolledValue] = React.useState(value != null ? value : ""), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => {
      setUncontrolledValue(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange(Number.isFinite(numValue) ? numValue : null);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      placeholder: t2("search.filter-number-value-placeholder"),
      radius: 2,
      step: "any",
      type: "number",
      value: uncontrolledValue
    }
  );
}
function SearchFilterNumberRangeInput({
  onChange,
  value
}) {
  var _a2, _b;
  const [to, setTo] = React.useState((_a2 = value == null ? void 0 : value.to) != null ? _a2 : ""), [from, setFrom] = React.useState((_b = value == null ? void 0 : value.from) != null ? _b : ""), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleToChange = React.useCallback(
    (event) => {
      var _a22;
      setTo(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange({
        to: Number.isFinite(numValue) ? numValue : null,
        from: (_a22 = value == null ? void 0 : value.from) != null ? _a22 : null
      });
    },
    [value == null ? void 0 : value.from, onChange]
  ), handleFromChange = React.useCallback(
    (event) => {
      var _a22;
      setFrom(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange({
        to: (_a22 = value == null ? void 0 : value.to) != null ? _a22 : null,
        from: Number.isFinite(numValue) ? numValue : null
      });
    },
    [value == null ? void 0 : value.to, onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        fontSize: fullscreen ? 2 : 1,
        onChange: handleFromChange,
        placeholder: t2("search.filter-number-min-value-placeholder"),
        radius: 2,
        step: "any",
        type: "number",
        value: from
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        fontSize: fullscreen ? 2 : 1,
        onChange: handleToChange,
        placeholder: t2("search.filter-number-max-value-placeholder"),
        radius: 2,
        step: "any",
        type: "number",
        value: to
      }
    ) })
  ] });
}
function getSchemaField(schemaType, fieldPath) {
  const paths = fieldPath.split("."), firstPath = paths[0];
  if (firstPath && types.isObjectSchemaType(schemaType)) {
    const field = schemaType.fields.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = paths.slice(1).join(".");
      return nextPath ? getSchemaField(field.type, nextPath) : field;
    }
  }
}
const SearchResultItemPreviewBox = styled__default.default(ui.Box)`
  @supports (-webkit-overflow-scrolling: touch) {
    * [data-ui='Box'] {
      background-attachment: scroll;
    }
  }
`;
function SearchResultItemPreview({
  documentId,
  layout,
  presence,
  schemaType,
  showBadge = !0
}) {
  const documentPreviewStore = useDocumentPreviewStore(), { draft, published, isLoading } = reactRx.useMemoObservable(
    () => getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""),
    [documentId, documentPreviewStore, schemaType]
  ), sanityDocument = React.useMemo(() => ({
    _id: documentId,
    _type: schemaType.name
  }), [documentId, schemaType.name]), status = React.useMemo(() => isLoading ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(DocumentPreviewPresence, { presence }),
    showBadge && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { children: schemaType.title }),
    /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusIndicator, { draft, published })
  ] }), [draft, isLoading, presence, published, schemaType.title, showBadge]), tooltip = /* @__PURE__ */ jsxRuntime.jsx(DocumentStatus, { draft, published });
  return /* @__PURE__ */ jsxRuntime.jsx(SearchResultItemPreviewBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({
        draft,
        published,
        value: sanityDocument
      }),
      isPlaceholder: isLoading != null ? isLoading : !0,
      layout: layout || "default",
      icon: schemaType.icon,
      status,
      tooltip
    }
  ) });
}
function SearchResultItem({
  disableIntentLink,
  documentId,
  documentType,
  layout,
  onClick,
  onItemSelect,
  ...rest
}) {
  const type = useSchema().get(documentType), documentPresence = useDocumentPresence(documentId), params = React.useMemo(() => ({ id: documentId, type: type == null ? void 0 : type.name }), [documentId, type == null ? void 0 : type.name]), { onClick: onIntentClick, href } = router.useIntentLink({
    intent: "edit",
    params
  }), handleClick = React.useCallback(
    (e) => {
      onItemSelect == null || onItemSelect({ _id: documentId, _type: documentType }), disableIntentLink || onIntentClick(e), onClick == null || onClick();
    },
    [onItemSelect, documentId, documentType, disableIntentLink, onClick, onIntentClick]
  );
  return type ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    PreviewCard,
    {
      as: "a",
      "data-as": "a",
      flex: 1,
      href: disableIntentLink ? void 0 : href,
      onClick: handleClick,
      radius: 2,
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        SearchResultItemPreview,
        {
          documentId,
          layout,
          presence: documentPresence,
          schemaType: type
        }
      )
    }
  ) }) : null;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), DEBUG_FRAGMENT = "_debug_search_score", DEBUG_MODE = !1, SEARCH_LIMIT = 1e3, GLOBAL_SEARCH_KEY = "k", GLOBAL_SEARCH_KEY_MODIFIER = IS_MAC ? "Cmd" : "Ctrl", POPOVER_INPUT_PADDING = ui.studioTheme.space[4], POPOVER_MAX_HEIGHT = 735, POPOVER_MAX_WIDTH = 800, POPOVER_VERTICAL_MARGIN = 5, POPOVER_RADIUS = 3;
function hasSearchableTerms({
  allowEmptyQueries,
  terms
}) {
  const hasQuery = allowEmptyQueries ? !0 : terms.query.length > 0, hasFilter = !!terms.filter, hasSelectedTypes = terms.types.length > 0;
  return hasQuery || hasFilter || hasSelectedTypes;
}
function getSelectableOmnisearchTypes(schema2, typeFilter) {
  return getSearchableOmnisearchTypes(schema2).filter((type) => inTypeFilter(type, typeFilter)).sort(sortTypes);
}
function getSearchableOmnisearchTypes(schema2) {
  return getSearchableTypes(schema2).filter(
    (type) => type.__experimental_omnisearch_visibility !== !1
  );
}
function sortTypes(a, b) {
  var _a2, _b;
  return ((_a2 = a.title) != null ? _a2 : a.name).localeCompare((_b = b.title) != null ? _b : b.name);
}
function inTypeFilter(type, typeFilter) {
  var _a2;
  return !typeFilter || ((_a2 = type.title) != null ? _a2 : type.name).toLowerCase().includes(typeFilter == null ? void 0 : typeFilter.toLowerCase());
}
const DEFAULT_DEBOUNCE_TIME = 300, INITIAL_SEARCH_STATE = {
  error: null,
  hits: [],
  loading: !1,
  terms: {
    query: "",
    types: []
  }
};
function nonNullable(v) {
  return v !== null;
}
function sanitizeRequest(request) {
  var _a2;
  return {
    ...request,
    terms: {
      ...request.terms,
      filter: (_a2 = request.terms.filter) == null ? void 0 : _a2.trim(),
      query: request.terms.query.trim()
    }
  };
}
function useSearch({
  allowEmptyQueries,
  initialState,
  onComplete,
  onError,
  onStart,
  schema: schema2
}) {
  const [searchState, setSearchState] = React.useState(initialState), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), maxFieldDepth = useSearchMaxFieldDepth(), { unstable_enableNewSearch = !1 } = useWorkspace().search, search2 = React.useMemo(
    () => createSearch(getSearchableOmnisearchTypes(schema2), client2, {
      tag: "search.global",
      unique: !0,
      unstable_enableNewSearch,
      maxDepth: maxFieldDepth
    }),
    [client2, maxFieldDepth, schema2, unstable_enableNewSearch]
  ), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      // Ignore null values
      operators.filter(nonNullable),
      // Sanitize request (trim query and filter)
      operators.map(sanitizeRequest),
      // Only emit when values have changed
      operators.distinctUntilChanged(isEqual__default$1.default),
      // Debounce requests
      operators.debounce((request) => rxjs.timer((request == null ? void 0 : request.debounceTime) || DEFAULT_DEBOUNCE_TIME)),
      // Trigger `onStart` callback
      operators.tap(onStart),
      operators.switchMap((request) => rxjs.concat(
        // Emit loading start
        rxjs.of({
          ...INITIAL_SEARCH_STATE,
          loading: !0,
          options: request.options,
          terms: request.terms
        }),
        // Conditionally trigger search ONLY if we have valid searchable terms.
        // Typically, search terms are valid if either query, filter or selected types is non-empty.
        // There are exceptions (e.g. searching within <AutoComplete> components) where empty queries are permitted,
        // which is what `allowEmptyQueries` is used for.
        rxjs.iif(
          () => hasSearchableTerms({ allowEmptyQueries, terms: request.terms }),
          // If we have a valid search, run async fetch, map results and trigger `onComplete` / `onError` callbacks
          search2(request.terms, request.options).pipe(
            operators.tap(({ hits, nextCursor }) => onComplete == null ? void 0 : onComplete({ hits, nextCursor })),
            operators.catchError((error) => (onError == null || onError(error), rxjs.of({
              ...INITIAL_SEARCH_STATE,
              error,
              loading: !1,
              options: request.options,
              terms: request.terms
            })))
          ),
          // If there is no valid search, emit an empty observable and trigger `onComplete` event
          rxjs.of(rxjs.EMPTY).pipe(operators.tap(() => onComplete == null ? void 0 : onComplete({ hits: [], nextCursor: void 0 })))
        ),
        // Emit loading completed
        rxjs.of({ loading: !1 })
      )),
      operators.scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE),
      // Update local search state
      operators.tap(setSearchState)
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- @todo: add onComplete, onError and onStart to the deps list when it's verified that it's safe to do so
    [allowEmptyQueries, search2]
  );
  return { handleSearch: React.useCallback(
    (searchRequest) => handleQueryChange(searchRequest),
    [handleQueryChange]
  ), searchState };
}
const DEFAULT_AVAILABLE_CHARS = 40;
function getDocumentTypesTruncated({
  availableCharacters = DEFAULT_AVAILABLE_CHARS,
  types: types2
}) {
  if (types2.length === 0)
    return { remainingCount: 0, types: [] };
  const visibleTypes = types2.reduce(
    /* @__PURE__ */ function() {
      let remaining = availableCharacters;
      return function(acc, val, index) {
        const title = typeTitle(val);
        return remaining -= title.length, (index === 0 || availableCharacters > title.length && remaining > title.length) && acc.push(val), acc;
      };
    }(),
    []
  );
  return {
    remainingCount: types2.length - visibleTypes.length,
    types: visibleTypes.map(typeTitle)
  };
}
function documentTypesTruncated({
  t: t2,
  availableCharacters,
  types: types2
}) {
  if (types2.length === 0)
    return t2("search.document-type-list-all-types");
  const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({
    availableCharacters,
    types: types2
  }), key = remainingCount > 0 ? "search.document-type-list-truncated" : "search.document-type-list";
  return t2(key, {
    count: remainingCount,
    types: visibleTypes,
    formatParams: { types: { style: "short", type: "unit" } }
  });
}
function typeTitle(schemaType) {
  var _a2;
  return (_a2 = schemaType.title) != null ? _a2 : schemaType.name;
}
const NO_FILTER = () => !0, StyledText$2 = styled__default.default(ui.Text)`
  word-break: break-word;
`, ReferenceAutocomplete = React.forwardRef(function({ onSelect, types: types2 = [], value }, ref) {
  const autocompletePopoverReferenceElementRef = React.useRef(null), schema2 = useSchema(), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), autocompleteId = React.useId(), [hits, setHits] = React.useState([]), { handleSearch, searchState } = useSearch({
    allowEmptyQueries: !0,
    initialState: {
      hits: [],
      loading: !1,
      error: null,
      terms: { query: "", types: types2 }
    },
    onComplete: (result) => {
      setHits(result.hits.map(({ hit }) => ({ value: hit._id, hit })));
    },
    schema: schema2
  }), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleSearch({
      debounceTime: 0,
      options: { limit: 100 },
      terms: { query: "", types: types2 }
    });
  }, [handleSearch, types2]), handleQueryChange = React.useCallback(
    (query) => {
      handleSearch(query ? {
        options: { limit: 100 },
        terms: { query: query || "", types: types2 }
      } : {
        debounceTime: 0,
        options: { limit: 0 },
        terms: { query: "", types: types2 }
      });
    },
    [handleSearch, types2]
  ), handleSelect = React.useCallback(
    (val) => {
      var _a2;
      const hit = (_a2 = hits.find((h) => h.value === val)) == null ? void 0 : _a2.hit;
      hit && (onSelect == null || onSelect({
        _ref: getPublishedId(hit._id),
        _type: hit._type
      }));
    },
    [hits, onSelect]
  ), placeholderText = React.useMemo(() => {
    if (types2.length === 0)
      return t2("search.action.search-all-types");
    const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({ types: types2 }), key = remainingCount > 0 ? "search.action.search-specific-types-truncated" : "search.action.search-specific-types";
    return t2(key, {
      count: remainingCount,
      types: visibleTypes,
      formatParams: { types: { style: "short", type: "unit" } }
    });
  }, [types2, t2]), renderOption = React.useCallback((option) => /* @__PURE__ */ jsxRuntime.jsx(
    SearchResultItem,
    {
      disableIntentLink: !0,
      documentId: option.value,
      documentType: option.hit._type,
      layout: "compact"
    }
  ), []), renderPopover = React.useCallback(
    (props2, contentRef) => {
      const { content: content2, hidden, onMouseEnter, onMouseLeave } = props2, hasResults = hits && hits.length > 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Popover,
        {
          constrainSize: !0,
          content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : searchState.terms.query && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$2, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "new-document.no-results",
              values: { searchQuery: searchState.terms.query }
            }
          ) }) }) }) }),
          fallbackPlacements: ["bottom", "bottom-end"],
          matchReferenceWidth: !0,
          onMouseEnter,
          onMouseLeave,
          open: !searchState.loading && !hidden,
          overflow: "auto",
          placement: "bottom-start",
          radius: POPOVER_RADIUS,
          referenceElement: autocompletePopoverReferenceElementRef.current
        }
      );
    },
    [hits, searchState.loading, searchState.terms.query, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref: autocompletePopoverReferenceElementRef, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Autocomplete,
    {
      "aria-label": placeholderText,
      filterOption: NO_FILTER,
      fontSize: fullscreen ? 2 : 1,
      id: autocompleteId,
      loading: searchState.loading,
      openButton: { onClick: handleAutocompleteOpenButtonClick },
      options: hits,
      onQueryChange: handleQueryChange,
      onSelect: handleSelect,
      placeholder: placeholderText,
      radius: 2,
      ref,
      renderOption,
      renderPopover,
      value: value == null ? void 0 : value._ref
    }
  ) });
});
function SearchFilterReferenceInput({
  fieldDefinition,
  onChange,
  value
}) {
  const {
    onClose,
    state: { documentTypesNarrowed }
  } = useSearchState(), schema2 = useSchema(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (referenceValue) => onChange(referenceValue),
    [onChange]
  ), searchableTypes = React.useMemo(() => fieldDefinition ? fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).flatMap((type) => {
    const schemaType = schema2.get(type);
    if (schemaType) {
      const field = getSchemaField(schemaType, fieldDefinition.fieldPath);
      if (types.isArraySchemaType(field == null ? void 0 : field.type))
        return field == null ? void 0 : field.type.of.filter(types.isReferenceSchemaType).flatMap((i) => i.to);
      if (types.isReferenceSchemaType(field == null ? void 0 : field.type))
        return field == null ? void 0 : field.type.to;
    }
    return [];
  }).reduce((acc, val) => (acc.findIndex((v) => v.name === (val == null ? void 0 : val.name)) < 0 && acc.push(val), acc), []) : [], [documentTypesNarrowed, fieldDefinition, schema2]), handleClear = React.useCallback(() => handleChange(null), [handleChange]), handleClick = React.useCallback(() => {
    onClose == null || onClose();
  }, [onClose]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { width: "min(calc(100vw - 40px), 420px)" }, children: value != null && value._ref && value != null && value._type ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 1, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      SearchResultItem,
      {
        documentId: value._ref,
        documentType: value._type,
        layout: "compact",
        onClick: handleClick
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        mode: "ghost",
        onClick: handleClear,
        text: t2("search.filter-reference-clear"),
        tone: "critical"
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(ReferenceAutocomplete, { onSelect: handleChange, types: searchableTypes, value }) });
}
function CustomMenuItem$2({
  onClick,
  selected,
  title,
  value
}) {
  const handleClick = React.useCallback(() => onClick(value), [onClick, value]);
  let menuItemText = `${title}`;
  return typeof value < "u" && title !== value && (menuItemText += ` (${value})`), /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuItem, { onClick: handleClick, pressed: selected, tone: "default", text: menuItemText });
}
function SearchFilterStringListInput({
  fieldDefinition,
  onChange,
  value
}) {
  const menuButtonId = React.useId(), {
    state: { documentTypesNarrowed }
  } = useSearchState(), { t: t2 } = useTranslation(), schema2 = useSchema(), items = React.useMemo(() => fieldDefinition ? fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).map((type) => {
    const schemaType = schema2.get(type);
    if (schemaType) {
      const field = getSchemaField(schemaType, fieldDefinition.fieldPath);
      return field == null ? void 0 : field.type.options;
    }
    return null;
  }).filter(isNonNullable$2).map((o) => o.list).flatMap((list) => list == null ? void 0 : list.map((l) => toSelectItem(l))).filter(isNonNullable$2).reduce((acc, val) => {
    const prevIndex = acc.findIndex((v) => v.value === (val == null ? void 0 : val.value));
    if (prevIndex > -1) {
      const prevValue = acc[prevIndex];
      acc[prevIndex] = {
        ...acc[prevIndex],
        title: uniq__default.default([...prevValue.title, val.title]).sort()
      };
    } else
      acc.push({
        ...val,
        title: [val.title]
      });
    return acc;
  }, []) : [], [documentTypesNarrowed, fieldDefinition, schema2]), handleClick = React.useCallback(
    (v) => {
      onChange(v);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          mode: "ghost",
          iconRight: icons.ChevronDownIcon,
          text: value ? String(value) : t2("search.filter-string-value-select-predefined-value")
        }
      ),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: items.map((item, index) => /* @__PURE__ */ jsxRuntime.jsx(
        CustomMenuItem$2,
        {
          onClick: handleClick,
          selected: item.value === value,
          title: item.title.join(", "),
          value: item.value || ""
        },
        index
      )) }),
      popover: {
        constrainSize: !0,
        placement: "bottom-start",
        portal: !1,
        radius: 2
      }
    }
  );
}
function toSelectItem(option) {
  return types.isTitledListValue(option) ? option : { title: capitalize__default.default(`${option}`), value: option };
}
const GteIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.04 19V17.512H17.36V19H7.04ZM7.04 15.328V13.624L12.08 11.872L15.32 10.816V10.72L12.08 9.664L7.04 7.912V6.208L17.36 9.88V11.656L7.04 15.328Z",
    fill: "currentColor"
  }
) }), GtIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.568 18.848V16.952L14.792 12.08V11.984L7.568 7.112V5.216L16.52 11.288V12.776L7.568 18.848Z",
    fill: "currentColor"
  }
) }), LteIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.04 19V17.512H17.36V19H7.04ZM17.36 15.328L7.04 11.656V9.88L17.36 6.208V7.912L12.32 9.664L9.08 10.72V10.816L12.32 11.872L17.36 13.624V15.328Z",
    fill: "currentColor"
  }
) }), LtIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M16.952 19.632L8 13.56V12.072L16.952 6V7.896L9.728 12.768V12.864L16.952 17.736V19.632Z",
    fill: "currentColor"
  }
) });
function defineSearchOperator(definition) {
  return definition;
}
function toJSON(val) {
  return JSON.stringify(val);
}
const arrayOperators = {
  arrayCountEqual: {
    nameKey: "search.operator.array-count-equal.name",
    descriptionKey: "search.operator.array-count-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountEqual"
  },
  arrayCountGt: {
    nameKey: "search.operator.array-count-gt.name",
    descriptionKey: "search.operator.array-count-gt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) > ${toJSON(value)}` : null,
    icon: GtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountGt"
  },
  arrayCountGte: {
    nameKey: "search.operator.array-count-gte.name",
    descriptionKey: "search.operator.array-count-gte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) >= ${toJSON(value)}` : null,
    icon: GteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountGte"
  },
  arrayCountLt: {
    nameKey: "search.operator.array-count-lt.name",
    descriptionKey: "search.operator.array-count-lt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) < ${toJSON(value)}` : null,
    icon: LtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountLt"
  },
  arrayCountLte: {
    nameKey: "search.operator.array-count-lte.name",
    descriptionKey: "search.operator.array-count-lte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) <= ${toJSON(value)}` : null,
    icon: LteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountLte"
  },
  arrayCountNotEqual: {
    nameKey: "search.operator.array-count-not-equal.name",
    descriptionKey: "search.operator.array-count-not-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountNotEqual"
  },
  arrayCountRange: {
    nameKey: "search.operator.array-count-range.name",
    descriptionKey: "search.operator.array-count-range.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? `count(${fieldPath}) > ${toJSON(value == null ? void 0 : value.from)} && count(${fieldPath}) < ${toJSON(
      value == null ? void 0 : value.to
    )}` : "",
    initialValue: null,
    inputComponent: SearchFilterNumberRangeInput,
    type: "arrayCountRange"
  },
  arrayListIncludes: {
    nameKey: "search.operator.array-list-includes.name",
    descriptionKey: "search.operator.array-list-includes.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${toJSON(value)} in ${fieldPath}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "arrayListIncludes"
  },
  arrayListNotIncludes: {
    nameKey: "search.operator.array-list-not-includes.name",
    descriptionKey: "search.operator.array-list-not-includes.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${toJSON(value)} in ${fieldPath})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "arrayListNotIncludes"
  },
  arrayReferenceIncludes: {
    nameKey: "search.operator.array-reference-includes.name",
    descriptionKey: "search.operator.array-reference-includes.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${toJSON(value._ref)} in ${fieldPath}[]._ref` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "arrayReferenceIncludes"
  },
  arrayReferenceNotIncludes: {
    nameKey: "search.operator.array-reference-not-includes.name",
    descriptionKey: "search.operator.array-reference-not-includes.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `!(${toJSON(value._ref)} in ${fieldPath}[]._ref)` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "arrayReferenceNotIncludes"
  }
}, SourceContext = React.createContext(null);
function SourceProvider({ children, ...props2 }) {
  const parentSource = React.useContext(SourceContext), { unstable_sources: sources } = useWorkspace();
  if ("source" in props2) {
    const { source } = props2;
    return /* @__PURE__ */ jsxRuntime.jsx(SourceContext.Provider, { value: source, children });
  }
  if ("name" in props2) {
    const { name } = props2, source = sources.find((s) => s.name === name);
    if (!source)
      throw new Error(`Could not find source with name \`${name}\` in current workspace`);
    return parentSource === source ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }) : /* @__PURE__ */ jsxRuntime.jsx(SourceContext.Provider, { value: source, children });
  }
  throw new Error(
    "Invalid props passed into SourceProvider. A `name` or a `source` object is required."
  );
}
function useSource() {
  const source = React.useContext(SourceContext);
  if (!source)
    throw new Error("Could not find `source` context");
  return source;
}
function AssetSourceError(props2) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...props2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", weight: "medium", children: t2("search.error.no-valid-asset-source-title") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", children: t2("search.error.no-valid-asset-source-only-default-description") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", children: t2("search.error.no-valid-asset-source-check-config-description") })
    ] })
  ] }) });
}
function FileReferencePreview({ reference }) {
  const documentPreviewStore = useDocumentPreviewStore(), observeAsset = React.useCallback(
    (id2) => observeFileAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    WithReferencedAsset,
    {
      observeAsset,
      reference,
      waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton, {}),
      children: (asset) => /* @__PURE__ */ jsxRuntime.jsx(FilePreview, { asset })
    }
  );
}
function FilePreview({ asset }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "space-between", wrap: "nowrap", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: (asset == null ? void 0 : asset.originalFilename) || asset._id }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formatBytes(asset.size) })
    ] })
  ] }) });
}
function FileSkeleton() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "100%" }, radius: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "100%" }, radius: 1 })
    ] })
  ] }) });
}
const Container = styled__default.default(ui.Card)`
  position: relative;
  padding-bottom: 100%;
`, Image$3 = styled__default.default.img`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
`;
function ImageReferencePreview({ reference }) {
  const documentPreviewStore = useDocumentPreviewStore(), observeAsset = React.useCallback(
    (id2) => observeImageAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference, children: (asset) => /* @__PURE__ */ jsxRuntime.jsx(ImagePreview, { asset }) });
}
function ImagePreview({ asset }) {
  const [loaded, setLoaded] = React.useState(!1), imageUrl = `${asset.url}?h=800&fit=max`, handleLoad = React.useCallback(() => setLoaded(!0), []);
  return /* @__PURE__ */ jsxRuntime.jsxs(Container, { __unstable_checkered: !0, border: !0, children: [
    !loaded && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0, showText: !0 }),
    /* @__PURE__ */ jsxRuntime.jsx(Image$3, { onLoad: handleLoad, src: imageUrl })
  ] });
}
function AssetPreview({ reference }) {
  return reference ? reference._type.startsWith("sanity.fileAsset") ? /* @__PURE__ */ jsxRuntime.jsx(FileReferencePreview, { reference }) : reference._type.startsWith("sanity.imageAsset") ? /* @__PURE__ */ jsxRuntime.jsx(ImageReferencePreview, { reference }) : null : null;
}
const ASSET_TYPE = {
  file: "sanity.fileAsset",
  image: "sanity.imageAsset"
}, ContainerBox = styled__default.default(ui.Box)`
  width: min(calc(100vw - 40px), 320px);
`;
function SearchFilterAssetInput(type) {
  return function({
    onChange,
    value
  }) {
    const [selectedAssetSource, setSelectedAssetSource] = React.useState(null), [selectedAssetFromSource, setSelectedAssetFromSource] = React.useState(
      null
    );
    useSearchState();
    const { file, image } = useSource().form, { t: t2 } = useTranslation(), assetSources = React.useMemo(() => {
      switch (type) {
        case "file":
          return file.assetSources.filter((a) => a.name === FileSource.name);
        case "image":
          return image.assetSources.filter((a) => a.name === ImageSource.name);
        default:
          throw Error("Unknown asset source found");
      }
    }, [file.assetSources, image.assetSources]), menuButtonId = React.useId(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), handleClear = React.useCallback(() => {
      setSelectedAssetFromSource(null), onChange(null);
    }, [onChange]), handleCloseAssetSource = React.useCallback(() => {
      setSelectedAssetSource(null);
    }, []), handleSelectAssetFromSource2 = React.useCallback(
      (assetFromSource) => {
        const firstAsset = assetFromSource[0];
        setSelectedAssetFromSource(firstAsset), handleCloseAssetSource();
      },
      [handleCloseAssetSource]
    ), handleSelectAssetSource = React.useCallback(
      (source) => setSelectedAssetSource(source),
      []
    );
    React.useEffect(() => {
      (selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.kind) === "assetDocumentId" && typeof (selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.value) == "string" && type && onChange({
        _ref: selectedAssetFromSource.value,
        _type: ASSET_TYPE[type]
      });
    }, [client2, onChange, selectedAssetFromSource]);
    const AssetSourceComponent = selectedAssetSource == null ? void 0 : selectedAssetSource.component, buttonText = t2(value ? "search.filter-asset-change" : "search.filter-asset-select", {
      context: type
    }), accept = get__default.default(type, "options.accept", type === "image" ? "image/*" : "");
    return /* @__PURE__ */ jsxRuntime.jsx(ContainerBox, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      selectedAssetSource && AssetSourceComponent && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsx(
        AssetSourceComponent,
        {
          assetType: type,
          dialogHeaderTitle: t2("search.action.select-asset", { context: type }),
          onClose: handleCloseAssetSource,
          onSelect: handleSelectAssetFromSource2,
          selectedAssets: [],
          selectionType: "single",
          accept
        }
      ) }),
      value && /* @__PURE__ */ jsxRuntime.jsx(AssetPreview, { reference: value }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
        assetSources.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(AssetSourceError, { padding: 2 }),
        assetSources.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: assetSources.length > 1 ? /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuButton,
          {
            button: /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.Button,
              {
                icon: value ? icons.UndoIcon : icons.SearchIcon,
                iconRight: icons.ChevronDownIcon,
                mode: "ghost",
                width: value ? "fill" : void 0,
                text: buttonText
              }
            ),
            id: menuButtonId,
            menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((source) => /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                icon: source.icon || icons.ImageIcon,
                onClick: () => handleSelectAssetSource(source),
                text: (source.i18nKey ? t2(source.i18nKey) : source.title) || startCase__default.default(source.name)
              },
              source.name
            )) }),
            popover: {
              constrainSize: !0,
              portal: !1,
              radius: 2
            }
          }
        ) : /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            icon: value ? icons.UndoIcon : icons.SearchIcon,
            mode: "ghost",
            onClick: () => handleSelectAssetSource(assetSources[0]),
            width: value ? "fill" : void 0,
            text: buttonText
          }
        ) }),
        value && /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "ghost",
            onClick: handleClear,
            width: "fill",
            text: t2("search.filter-asset-clear"),
            tone: "critical"
          }
        )
      ] })
    ] }) });
  };
}
const assetOperators = {
  assetFileEqual: {
    nameKey: "search.operator.asset-file-equal.name",
    descriptionKey: "search.operator.asset-file-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    label: "is",
    type: "assetFileEqual"
  },
  assetFileNotEqual: {
    nameKey: "search.operator.asset-file-not-equal.name",
    descriptionKey: "search.operator.asset-file-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    label: "is not",
    type: "assetFileNotEqual"
  },
  assetImageEqual: {
    nameKey: "search.operator.asset-image-equal.name",
    descriptionKey: "search.operator.asset-image-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    label: "is",
    type: "assetImageEqual"
  },
  assetImageNotEqual: {
    nameKey: "search.operator.asset-image-not-equal.name",
    descriptionKey: "search.operator.asset-image-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    label: "is not",
    type: "assetImageNotEqual"
  }
};
function SearchFilterBooleanInput({ onChange, value }) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => {
      onChange(event.currentTarget.value === "true");
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Select,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      radius: 2,
      value: String(value != null ? value : !0),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("option", { value: "true", children: t2("search.filter-boolean-true") }),
        /* @__PURE__ */ jsxRuntime.jsx("option", { value: "false", children: t2("search.filter-boolean-false") })
      ]
    }
  );
}
const booleanOperators = {
  booleanEqual: {
    nameKey: "search.operator.boolean-equal.name",
    descriptionKey: "search.operator.boolean-equal.description",
    groqFilter: ({ fieldPath, value }) => typeof value < "u" && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: !0,
    inputComponent: SearchFilterBooleanInput,
    type: "booleanEqual"
  }
}, TimeLabelText = styled__default.default(ui.Text)`
  cursor: default;
`;
function DateIncludeTimeFooter({ onChange, value }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "flex-end", marginTop: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(TimeLabelText, { muted: !0, onClick: onChange, size: 1, weight: "medium", children: t2("calendar.action.include-time-label") }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { checked: value, label: t2("calendar.action.include-time-label"), onChange })
  ] });
}
const CalendarContext = React.createContext(void 0);
function useCalendar() {
  const context = React.useContext(CalendarContext);
  if (context === void 0)
    throw new Error("useCalendar must be used within an CalendarContext.Provider");
  return context;
}
function CalendarHeader(props2) {
  const { t: t2 } = useTranslation(), monthFormatter = useDateTimeFormat({ month: "long", year: "numeric" }), { focusedDate } = useCalendar(), { moveFocusedDate, onNowClick } = props2, handlePrevMonthClick = React.useCallback(() => moveFocusedDate(-1), [moveFocusedDate]), handleNextMonthClick = React.useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, justify: "space-between", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingLeft: 2, space: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: upperFirst__default.default(monthFormatter.format(focusedDate)) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t2("calendar.action.go-to-today-aria-label"),
          mode: "bleed",
          onClick: onNowClick,
          text: t2("calendar.action.go-to-today")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.ChevronLeftIcon,
          mode: "bleed",
          onClick: handlePrevMonthClick,
          tooltipProps: { content: t2("calendar.action.go-to-previous-month") }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.ChevronRightIcon,
          mode: "bleed",
          onClick: handleNextMonthClick,
          tooltipProps: { content: t2("calendar.action.go-to-next-month") }
        }
      )
    ] })
  ] });
}
const CircleSvg = styled__default.default.svg(({ theme: theme2 }) => styled.css`
    bottom: 0;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;

    circle {
      stroke: ${theme2.sanity.color.card.enabled.border};
      stroke-width: 3;
      fill: none;
    }
  `), CustomCard = styled__default.default(ui.Card)`
  position: relative;

  &[data-focused='true'] {
    z-index: 1;
  }

  &[data-start-date='true'] {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }

  &[data-end-date='true'] {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  &[data-within-range='true'] {
    border-radius: 0;
  }
`;
function CalendarDay({ date, onSelect }) {
  const handleClick = React.useCallback(() => {
    onSelect(date);
  }, [date, onSelect]), { date: selectedDate, endDate: selectedEndDate, focusedDate, selectRange } = useCalendar(), isSelected = selectedDate && dateFns.isSameDay(date, selectedDate), isStartDate = selectRange && selectedDate && dateFns.isSameDay(date, selectedDate), isEndDate = selectRange && selectedEndDate && dateFns.isSameDay(date, selectedEndDate), isCurrentMonth = dateFns.isSameMonth(date, focusedDate), isFocused = focusedDate && dateFns.isSameDay(date, focusedDate), isToday = dateFns.isSameDay(date, /* @__PURE__ */ new Date()), isWithinRange = selectedDate && selectedEndDate && !isStartDate && !isEndDate && dateFns.isAfter(date, selectedDate) && dateFns.isBefore(date, selectedEndDate);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    CustomCard,
    {
      __unstable_focusRing: !0,
      "aria-label": date.toDateString(),
      "aria-pressed": isSelected,
      "data-end-date": isEndDate ? !0 : void 0,
      "data-focused": isFocused ? "true" : "",
      "data-ui": "CalendarDay",
      "aria-selected": isSelected,
      "data-start-date": isStartDate ? !0 : void 0,
      "data-within-range": isWithinRange ? !0 : void 0,
      forwardedAs: "button",
      onClick: handleClick,
      paddingX: 3,
      paddingY: 2,
      radius: 2,
      role: "button",
      selected: isSelected || isStartDate || isEndDate,
      tabIndex: -1,
      tone: isWithinRange ? "primary" : "default",
      children: [
        isToday && /* @__PURE__ */ jsxRuntime.jsx(
          CircleSvg,
          {
            height: "100%",
            preserveAspectRatio: "xMidYMid meet",
            vectorEffect: "non-scaling-stroke",
            viewBox: "0 0 100 100",
            width: "100%",
            children: /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "50", cy: "50", r: "40%" })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Text,
          {
            align: "center",
            muted: !isSelected && !isCurrentMonth,
            size: 1,
            weight: isCurrentMonth ? "medium" : "regular",
            children: date.getDate()
          }
        )
      ]
    }
  );
}
const SHORT_WEEK_DAY_KEYS = [
  "calendar.weekday-names.short.monday",
  "calendar.weekday-names.short.tuesday",
  "calendar.weekday-names.short.wednesday",
  "calendar.weekday-names.short.thursday",
  "calendar.weekday-names.short.friday",
  "calendar.weekday-names.short.saturday",
  "calendar.weekday-names.short.sunday"
];
range__default.default(0, 24);
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], TAIL_WEEKDAYS = [1, 2, 3, 4, 5, 6], getWeekStartsOfMonth = (date, weekStartsOn) => {
  const firstDay = dateFns.startOfMonth(date);
  return dateFns.eachWeekOfInterval(
    {
      start: firstDay,
      end: dateFns.lastDayOfMonth(firstDay)
    },
    {
      weekStartsOn: weekStartsOn === 7 ? 0 : weekStartsOn
    }
  );
}, getWeekDaysFromWeekStarts = (weekStarts) => weekStarts.map((weekStart) => [
  weekStart,
  ...TAIL_WEEKDAYS.map((d) => dateFns.addDays(weekStart, d))
]), useWeeksOfMonth = (date) => {
  const { weekInfo } = getJsonStream.useCurrentLocale();
  return getWeekDaysFromWeekStarts(getWeekStartsOfMonth(date, weekInfo.firstDay)).map(
    (days) => ({
      number: dateFns.getWeek(days[0]),
      days
    })
  );
}, WEEK_DAY_NAME_KEYS = {
  // Monday is start of the week
  1: SHORT_WEEK_DAY_KEYS,
  // Sunday is start of the week
  7: [SHORT_WEEK_DAY_KEYS[6], ...SHORT_WEEK_DAY_KEYS.slice(0, 6)]
}, CustomGrid = styled__default.default(ui.Grid)`
  grid-template-columns: repeat(7, minmax(44px, auto));
`;
function CalendarMonth({ hidden, onSelect }) {
  const { focusedDate, firstWeekDay } = useCalendar(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "aria-hidden": hidden || !1, "data-ui": "CalendarMonth", children: /* @__PURE__ */ jsxRuntime.jsxs(CustomGrid, { gapY: 1, children: [
    WEEK_DAY_NAME_KEYS[firstWeekDay].map((weekdayDay) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 3, paddingTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, weight: "medium", children: t2(weekdayDay) }) }, weekdayDay)),
    useWeeksOfMonth(focusedDate).map(
      (week, weekIdx) => week.days.map((weekDayDate, dayIdx) => /* @__PURE__ */ jsxRuntime.jsx(
        CalendarDay,
        {
          date: weekDayDate,
          onSelect
        },
        `${weekIdx}-${dayIdx}`
      ))
    )
  ] }) });
}
const PRESERVE_FOCUS_ELEMENT = /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    "data-preserve-focus": !0,
    style: { overflow: "hidden", position: "absolute", outline: "none" },
    tabIndex: -1
  }
);
function Calendar(props2) {
  const { date, endDate, onSelect, selectRange, selectTime } = props2, [calendarElement, setCalendarElement] = React.useState(null), [selectEndValue, setSelectEndValue] = React.useState(!1), [focusedDate, setFocusedDate] = React.useState(date || /* @__PURE__ */ new Date()), previousDate = React.useRef(date || null), previousEndDate = React.useRef(endDate || null), {
    weekInfo: { firstDay: firstWeekDay }
  } = getJsonStream.useCurrentLocale(), focusCurrentWeekDay = React.useCallback(() => {
    var _a2;
    (_a2 = calendarElement == null ? void 0 : calendarElement.querySelector('[data-focused="true"]')) == null || _a2.focus();
  }, [calendarElement]), handleDateChange = React.useCallback(
    (d) => {
      const selectedDate = dateFns.set(d, {
        hours: d.getHours(),
        minutes: d.getMinutes(),
        seconds: 0,
        milliseconds: 0
      }), dateIsBeforeStartDate = date && dateFns.isBefore(selectedDate, date), dateIsAfterEndDate = endDate && dateFns.isAfter(selectedDate, endDate);
      if (selectRange) {
        if (dateIsBeforeStartDate || dateIsAfterEndDate) {
          onSelect({ date: selectedDate, endDate: null });
          return;
        }
        onSelect(selectEndValue ? { date: date || null, endDate: selectedDate } : { date: selectedDate, endDate: date ? null : endDate || null });
      } else
        onSelect({ date: selectedDate });
    },
    [date, endDate, onSelect, selectEndValue, selectRange]
  ), handleNowClick = React.useCallback(() => {
    const now = /* @__PURE__ */ new Date();
    selectRange ? setFocusedDate(now) : onSelect({ date: now });
  }, [onSelect, selectRange, setFocusedDate]), handleKeyDown = React.useCallback(
    (event) => {
      var _a2;
      if (ARROW_KEYS.includes(event.key)) {
        if (event.preventDefault(), event.target.hasAttribute("data-calendar-grid")) {
          focusCurrentWeekDay();
          return;
        }
        event.key === "ArrowUp" && setFocusedDate(dateFns.addDays(focusedDate, -7)), event.key === "ArrowDown" && setFocusedDate(dateFns.addDays(focusedDate, 7)), event.key === "ArrowLeft" && setFocusedDate(dateFns.addDays(focusedDate, -1)), event.key === "ArrowRight" && setFocusedDate(dateFns.addDays(focusedDate, 1)), (_a2 = calendarElement == null ? void 0 : calendarElement.querySelector("[data-preserve-focus]")) == null || _a2.focus();
      }
    },
    [calendarElement, focusCurrentWeekDay, focusedDate, setFocusedDate]
  ), moveFocusedDate = React.useCallback(
    (by) => setFocusedDate(dateFns.addMonths(focusedDate, by)),
    [focusedDate, setFocusedDate]
  );
  return React.useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]), React.useEffect(() => {
    var _a2;
    (_a2 = document.activeElement) != null && _a2.matches(
      "[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]"
    ) && focusCurrentWeekDay();
  }, [focusCurrentWeekDay, focusedDate]), React.useEffect(() => {
    var _a2, _b;
    const dateChanged = (date == null ? void 0 : date.getTime()) !== ((_a2 = previousDate.current) == null ? void 0 : _a2.getTime()), endDateChanged = (endDate == null ? void 0 : endDate.getTime()) !== ((_b = previousEndDate.current) == null ? void 0 : _b.getTime()), onlyDateChanged = dateChanged && !endDateChanged, onlyEndDateChanged = !dateChanged && endDateChanged, dateIsAfterEndDate = date && endDate && dateFns.isAfter(date, endDate);
    onlyDateChanged && (dateIsAfterEndDate && (setSelectEndValue(!0), onSelect({ date, endDate: null })), setSelectEndValue(!!date), date && setFocusedDate(date)), onlyEndDateChanged && (dateIsAfterEndDate && (setSelectEndValue(!0), onSelect({ date: endDate, endDate: null })), setSelectEndValue(!!date && !endDate), endDate && setFocusedDate(endDate)), dateChanged && endDateChanged && (setSelectEndValue(!0), date && setFocusedDate(date)), previousDate.current = date || null, previousEndDate.current = endDate || null;
  }, [date, endDate, onSelect]), /* @__PURE__ */ jsxRuntime.jsx(
    CalendarContext.Provider,
    {
      value: {
        date,
        endDate,
        focusedDate,
        selectRange,
        selectTime,
        firstWeekDay
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { "data-ui": "Calendar", ref: setCalendarElement, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(CalendarHeader, { moveFocusedDate, onNowClick: handleNowClick }) }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Box,
          {
            "data-calendar-grid": !0,
            onKeyDown: handleKeyDown,
            marginTop: 2,
            overflow: "hidden",
            tabIndex: 0,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(CalendarMonth, { onSelect: handleDateChange }),
              PRESERVE_FOCUS_ELEMENT
            ]
          }
        )
      ] })
    }
  );
}
function DatePicker({ date, endDate, onChange, selectRange, selectTime }) {
  const handleSelect = React.useCallback(
    (dates) => {
      onChange(dates);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Calendar,
    {
      date,
      endDate,
      onSelect: handleSelect,
      selectRange,
      selectTime
    }
  );
}
const CustomTextInputBox = styled__default.default(ui.Box)(({ $background, $smallClearButton }) => styled.css`
    width: 100%;

    input + span {
      background: ${({ theme: theme2 }) => $background ? theme2.sanity.color.card.disabled.bg2 : "transparent"};
    }

    [data-qa='clear-button'] {
      background: none;
      box-shadow: none;
      display: flex; /* TODO: hack, currently used to vertically center <TextInput>'s clearButton */
      transform: ${$smallClearButton ? "scale(0.8)" : "scale(1)"};
      &:hover {
        opacity: 0.5;
      }
    }
  `), CustomTextInput = React.forwardRef(
  function(props2, ref) {
    const { $background, $smallClearButton, ...rest } = props2;
    return /* @__PURE__ */ jsxRuntime.jsx(CustomTextInputBox, { $background, $smallClearButton, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...rest, ref }) });
  }
);
function getDateISOString({
  date,
  dateOnly,
  roundDay
}) {
  let adjustedDate;
  switch (roundDay) {
    case "end":
      adjustedDate = dateFns.endOfDay(date);
      break;
    case "start":
      adjustedDate = dateFns.startOfDay(date);
      break;
    default:
      adjustedDate = date;
      break;
  }
  return dateOnly ? adjustedDate.toISOString().split("T")[0] : adjustedDate.toISOString();
}
const FORMAT = {
  date: {
    exampleDate: "Jan 1, 2000",
    pattern: "MMM d, yyyy"
  },
  datetime: {
    exampleDate: "Jan 1, 2000 12:00 AM",
    pattern: "MMM d, yyyy p"
  }
};
function ParsedDateTextInput({
  isDateTime,
  onChange,
  placeholderDate,
  isDateTimeFormat,
  value,
  ...rest
}) {
  const { t: t2 } = useTranslation(), dateFormat = isDateTimeFormat ? FORMAT.datetime.pattern : FORMAT.date.pattern, [customValidity, setCustomValidity] = React.useState(void 0), [inputValue, setInputValue] = React.useState(() => {
    if (!value)
      return "";
    const inputValueDate = new Date(value);
    return dateFns.format(inputValueDate, dateFormat);
  }), formattedPlaceholder = React.useMemo(() => dateFns.format(placeholderDate || /* @__PURE__ */ new Date(), dateFormat), [dateFormat, placeholderDate]), processInputString = React.useCallback(
    ({ dateString, triggerOnChange }) => {
      if (!dateString)
        return;
      const dateParsed = dateFns.parse(dateString, dateFormat, /* @__PURE__ */ new Date()), validDate = dateFns.isValid(dateParsed);
      validDate && (triggerOnChange && onChange(getDateISOString({ date: dateParsed, dateOnly: !isDateTime })), setInputValue(dateFns.format(dateParsed, dateFormat))), setCustomValidity(validDate ? void 0 : `Invalid ${isDateTime ? "datetime" : "date"}`);
    },
    [dateFormat, isDateTime, onChange]
  ), handleTextInputBlur = React.useCallback(() => {
    processInputString({ dateString: inputValue, triggerOnChange: !0 });
  }, [inputValue, processInputString]), handleTextInputChange = React.useCallback((event) => {
    setInputValue(event.currentTarget.value);
  }, []), handleTextInputClear = React.useCallback(() => {
    onChange(null), setCustomValidity(void 0), setInputValue("");
  }, [onChange]), handleTextInputKeyDown = React.useCallback(
    (event) => {
      event.key === "Enter" && processInputString({ dateString: inputValue, triggerOnChange: !0 });
    },
    [inputValue, processInputString]
  );
  return React.useEffect(() => {
    const updatedDate = value && new Date(value);
    updatedDate && processInputString({
      dateString: dateFns.format(updatedDate, dateFormat),
      triggerOnChange: !1
    });
  }, [dateFormat, processInputString, isDateTimeFormat, value]), /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: t2("calendar.error.must-be-in-format", {
        exampleDate: isDateTimeFormat ? FORMAT.datetime.exampleDate : FORMAT.date.exampleDate
      }),
      disabled: !customValidity,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        CustomTextInput,
        {
          ...rest,
          clearButton: !!inputValue,
          customValidity,
          onBlur: handleTextInputBlur,
          onChange: handleTextInputChange,
          onClear: handleTextInputClear,
          onKeyDown: handleTextInputKeyDown,
          placeholder: formattedPlaceholder,
          value: inputValue
        }
      )
    }
  );
}
function CommonDateDirectionInput({
  direction,
  isDateTime,
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), roundDay = React.useMemo(() => {
    switch (direction) {
      case "after":
        return "end";
      case "before":
        return "start";
      default:
        return;
    }
  }, [direction]), handleDatePickerChange = React.useCallback(
    ({ date }) => {
      let dateISOString = null;
      date && (dateISOString = getDateISOString({
        date,
        dateOnly: !isDateTime,
        roundDay: value != null && value.includeTime ? void 0 : roundDay
      })), onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: dateISOString
      });
    },
    [isDateTime, onChange, roundDay, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime), date = value != null && value.date ? new Date(value.date) : null;
    let dateISOString = null;
    date && (dateISOString = getDateISOString({
      date,
      dateOnly: !isDateTime,
      roundDay: includeTime ? "start" : roundDay
    })), onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, roundDay, value]), handleTextDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: date || null
      });
    },
    [onChange, value == null ? void 0 : value.includeTime]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ParsedDateTextInput,
      {
        "aria-label": t2("search.filter-date-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        isDateTime,
        isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
        onChange: handleTextDateChange,
        radius: 2,
        value: value == null ? void 0 : value.date
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker,
      {
        date: value != null && value.date ? new Date(value.date) : void 0,
        onChange: handleDatePickerChange,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] });
}
function SearchFilterDateAfterInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: !1 });
}
function SearchFilterDateBeforeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: !1 });
}
function CommonDateEqualInput({
  isDateTime,
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleDatePickerChange = React.useCallback(
    ({ date }) => {
      if (date) {
        const dateISOString = getDateISOString({ date, dateOnly: !isDateTime });
        onChange({
          includeTime: value == null ? void 0 : value.includeTime,
          date: dateISOString
        });
      } else
        onChange(null);
    },
    [isDateTime, onChange, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime), date = value != null && value.date ? new Date(value.date) : null;
    let dateISOString = null;
    date && (dateISOString = getDateISOString({
      date,
      dateOnly: !isDateTime
    })), onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, value]), handleTextDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: date || null
      });
    },
    [onChange, value == null ? void 0 : value.includeTime]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ParsedDateTextInput,
      {
        "aria-label": t2("search.filter-date-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        isDateTime,
        isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
        onChange: handleTextDateChange,
        radius: 2,
        value: value == null ? void 0 : value.date
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker,
      {
        date: value != null && value.date ? new Date(value.date) : void 0,
        onChange: handleDatePickerChange,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] });
}
function SearchFilterDateEqualInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateEqualInput, { ...props2, isDateTime: !1 });
}
const UNIT_CHOICES = [
  { unit: "day", key: "search.filter-date-unit_days" },
  { unit: "month", key: "search.filter-date-unit_months" },
  { unit: "year", key: "search.filter-date-unit_years" }
];
function SearchFilterDateLastInput({
  onChange,
  value
}) {
  const [uncontrolledValue, setUncontrolledValue] = React.useState((value == null ? void 0 : value.unitValue) || ""), dateUnit = React.useRef("day"), dateValue = React.useRef((value == null ? void 0 : value.unitValue) || null), { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), handleChange = React.useCallback(() => {
    onChange({
      unit: dateUnit == null ? void 0 : dateUnit.current,
      unitValue: dateValue == null ? void 0 : dateValue.current
    });
  }, [onChange]), handleUnitChange = React.useCallback(
    (event) => {
      dateUnit.current = event.currentTarget.value, handleChange();
    },
    [handleChange]
  ), handleValueChange = React.useCallback(
    (event) => {
      setUncontrolledValue(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      dateValue.current = Number.isFinite(numValue) ? numValue : null, handleChange();
    },
    [handleChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        "aria-label": t2("search.filter-date-value-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        onChange: handleValueChange,
        pattern: "\\d*",
        radius: 2,
        step: "1",
        type: "number",
        value: uncontrolledValue
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Select,
      {
        "aria-label": t2("search.filter-date-unit-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        onChange: handleUnitChange,
        radius: 2,
        value: value == null ? void 0 : value.unit,
        children: UNIT_CHOICES.map((choice) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: choice.unit, children: t2(choice.key) }, choice.key))
      }
    ) })
  ] });
}
const PLACEHOLDER_START_DATE_OFFSET = -7;
function CommonDateRangeInput({
  isDateTime,
  onChange,
  value
}) {
  const { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), placeholderStartDate = React.useMemo(() => dateFns.addDays(/* @__PURE__ */ new Date(), PLACEHOLDER_START_DATE_OFFSET), []), placeholderEndDate = React.useMemo(() => /* @__PURE__ */ new Date(), []), handleDatePickerChange = React.useCallback(
    ({ date, endDate }) => {
      onChange(
        getStartAndEndDate({
          date,
          endDate,
          includeTime: value == null ? void 0 : value.includeTime,
          isDateTime
        })
      );
    },
    [isDateTime, onChange, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime);
    onChange(
      getStartAndEndDate({
        date: value != null && value.from ? new Date(value.from) : null,
        endDate: value != null && value.to ? new Date(value.to) : null,
        includeTime,
        isDateTime
      })
    );
  }, [isDateTime, onChange, value]), handleTextEndDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        to: date || null,
        from: (value == null ? void 0 : value.from) || null
      });
    },
    [onChange, value]
  ), handleTextStartDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        to: (value == null ? void 0 : value.to) || null,
        from: date || null
      });
    },
    [onChange, value]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ParsedDateTextInput,
        {
          "aria-label": t2("search.filter-date-range-start-date-aria-label"),
          fontSize: fullscreen ? 2 : 1,
          isDateTime,
          isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
          onChange: handleTextStartDateChange,
          placeholderDate: placeholderStartDate,
          radius: 2,
          value: value == null ? void 0 : value.from
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ParsedDateTextInput,
        {
          "aria-label": t2("search.filter-date-range-end-date-aria-label"),
          fontSize: fullscreen ? 2 : 1,
          isDateTime,
          isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
          onChange: handleTextEndDateChange,
          placeholderDate: placeholderEndDate,
          radius: 2,
          value: value == null ? void 0 : value.to
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker,
      {
        date: value != null && value.from ? new Date(value.from) : void 0,
        endDate: value != null && value.to ? new Date(value.to) : void 0,
        onChange: handleDatePickerChange,
        selectRange: !0,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] }) });
}
function getStartAndEndDate({
  date,
  endDate,
  includeTime,
  isDateTime
}) {
  return includeTime ? {
    includeTime,
    to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "start" }) : null,
    from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null
  } : {
    includeTime,
    to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "end" }) : null,
    from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null
  };
}
function SearchFilterDateRangeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateRangeInput, { ...props2, isDateTime: !1 });
}
function SearchFilterDateTimeAfterInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: !0 });
}
function SearchFilterDateTimeBeforeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: !0 });
}
function SearchFilterDateTimeEqualInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateEqualInput, { ...props2, isDateTime: !0 });
}
function SearchFilterDateTimeRangeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateRangeInput, { ...props2, isDateTime: !0 });
}
const COMMON = {
  dateAfter: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: null
  },
  dateBefore: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: null
  },
  dateEqual: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: {
      date: null,
      includeTime: !1
    }
  },
  dateLast: {
    buttonValueComponent: SearchButtonValueDateLast
  },
  dateNotEqual: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: {
      date: null,
      includeTime: !1
    }
  },
  dateRange: {
    initialValue: null
  }
}, dateOperators = {
  dateAfter: {
    ...COMMON.dateAfter,
    nameKey: "search.operator.date-after.name",
    descriptionKey: "search.operator.date-after.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} > ${toJSON(value == null ? void 0 : value.date)}` : null,
    inputComponent: SearchFilterDateAfterInput,
    type: "dateAfter"
  },
  dateBefore: {
    ...COMMON.dateBefore,
    nameKey: "search.operator.date-before.name",
    descriptionKey: "search.operator.date-before.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} < ${toJSON(value == null ? void 0 : value.date)}` : null,
    inputComponent: SearchFilterDateBeforeInput,
    type: "dateBefore"
  },
  dateEqual: {
    ...COMMON.dateEqual,
    nameKey: "search.operator.date-equal.name",
    descriptionKey: "search.operator.date-equal.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} == ${toJSON(value.date)}` : null,
    inputComponent: SearchFilterDateEqualInput,
    type: "dateEqual"
  },
  dateLast: {
    ...COMMON.dateLast,
    nameKey: "search.operator.date-last.name",
    descriptionKey: "search.operator.date-last.description",
    groqFilter: ({ fieldPath, value }) => {
      const flooredValue = typeof (value == null ? void 0 : value.unitValue) == "number" ? Math.floor(value.unitValue) : void 0, timestampAgo = Number.isFinite(flooredValue) ? dateFns.sub(/* @__PURE__ */ new Date(), {
        days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0,
        months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0,
        years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0
      }).toISOString().split("T")[0] : null;
      return timestampAgo && fieldPath ? `${fieldPath} > ${toJSON(timestampAgo)}` : null;
    },
    inputComponent: SearchFilterDateLastInput,
    initialValue: {
      unit: "day",
      unitValue: 7
    },
    type: "dateLast"
  },
  dateNotEqual: {
    ...COMMON.dateNotEqual,
    nameKey: "search.operator.date-not-equal.name",
    descriptionKey: "search.operator.date-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} != ${toJSON(value.date)}` : null,
    inputComponent: SearchFilterDateEqualInput,
    type: "dateNotEqual"
  },
  dateRange: {
    ...COMMON.dateRange,
    nameKey: "search.operator.date-range.name",
    descriptionKey: "search.operator.date-range.description",
    buttonValueComponent: SearchButtonValueDateRange,
    groqFilter: ({ fieldPath, value }) => value != null && value.to && value != null && value.from && fieldPath ? `${fieldPath} >= ${toJSON(value.from)} && ${fieldPath} <= ${toJSON(value.to)}` : null,
    initialValue: {
      includeTime: !1,
      to: dateFns.startOfToday().toISOString(),
      from: null
    },
    inputComponent: SearchFilterDateRangeInput,
    type: "dateRange"
  },
  dateTimeAfter: {
    ...COMMON.dateAfter,
    nameKey: "search.operator.date-time-after.name",
    descriptionKey: "search.operator.date-time-after.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `dateTime(${fieldPath}) > dateTime(${toJSON(value.date)})` : null,
    inputComponent: SearchFilterDateTimeAfterInput,
    type: "dateTimeAfter"
  },
  dateTimeBefore: {
    ...COMMON.dateBefore,
    nameKey: "search.operator.date-time-before.name",
    descriptionKey: "search.operator.date-time-before.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `dateTime(${fieldPath}) < dateTime(${toJSON(value.date)})` : null,
    inputComponent: SearchFilterDateTimeBeforeInput,
    type: "dateTimeBefore"
  },
  dateTimeEqual: {
    ...COMMON.dateEqual,
    nameKey: "search.operator.date-time-equal.name",
    descriptionKey: "search.operator.date-time-equal.description",
    groqFilter: ({ fieldPath, value }) => {
      const date = (value == null ? void 0 : value.date) && new Date(value.date);
      if (!date || !dateFns.isValid(date) || !fieldPath)
        return null;
      const dateStart = (value != null && value.includeTime ? dateFns.startOfMinute(date) : dateFns.startOfDay(date)).toISOString(), dateEnd = (value != null && value.includeTime ? dateFns.endOfMinute(date) : dateFns.endOfDay(date)).toISOString();
      return `dateTime(${fieldPath}) > dateTime(${toJSON(
        dateStart
      )}) && dateTime(${fieldPath}) < dateTime(${toJSON(dateEnd)})`;
    },
    inputComponent: SearchFilterDateTimeEqualInput,
    type: "dateTimeEqual"
  },
  dateTimeLast: {
    ...COMMON.dateLast,
    nameKey: "search.operator.date-time-last.name",
    descriptionKey: "search.operator.date-time-last.description",
    groqFilter: ({ fieldPath, value }) => {
      const flooredValue = typeof (value == null ? void 0 : value.unitValue) == "number" ? Math.floor(value.unitValue) : void 0, timestampAgo = Number.isFinite(flooredValue) ? dateFns.sub(/* @__PURE__ */ new Date(), {
        days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0,
        months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0,
        years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0
      }).toISOString() : null;
      return timestampAgo && fieldPath ? `dateTime(${fieldPath}) > dateTime(${toJSON(timestampAgo)})` : null;
    },
    initialValue: {
      unit: "day",
      unitValue: 7
    },
    inputComponent: SearchFilterDateLastInput,
    type: "dateTimeLast"
  },
  dateTimeNotEqual: {
    ...COMMON.dateNotEqual,
    nameKey: "search.operator.date-time-not-equal.name",
    descriptionKey: "search.operator.date-time-not-equal.description",
    groqFilter: ({ fieldPath, value }) => {
      const date = (value == null ? void 0 : value.date) && new Date(value.date);
      if (!date || !dateFns.isValid(date) || !fieldPath)
        return null;
      const dateStart = (value != null && value.includeTime ? dateFns.startOfMinute(date) : dateFns.startOfDay(date)).toISOString(), dateEnd = (value != null && value.includeTime ? dateFns.endOfMinute(date) : dateFns.endOfDay(date)).toISOString();
      return `dateTime(${fieldPath}) < dateTime(${toJSON(
        dateStart
      )}) || dateTime(${fieldPath}) > dateTime(${toJSON(dateEnd)})`;
    },
    inputComponent: SearchFilterDateTimeEqualInput,
    type: "dateTimeNotEqual"
  },
  dateTimeRange: {
    ...COMMON.dateRange,
    nameKey: "search.operator.date-time-range.name",
    descriptionKey: "search.operator.date-time-range.description",
    buttonValueComponent: SearchButtonValueDateRange,
    groqFilter: ({ fieldPath, value }) => value != null && value.to && value != null && value.from && fieldPath ? `dateTime(${fieldPath}) >= dateTime(${toJSON(
      value.from
    )}) && dateTime(${fieldPath}) <= dateTime(${toJSON(value.to)})` : null,
    initialValue: {
      includeTime: !1,
      to: dateFns.startOfToday().toISOString(),
      from: null
    },
    inputComponent: SearchFilterDateTimeRangeInput,
    type: "dateTimeRange"
  }
}, definedOperators = {
  defined: {
    nameKey: "search.operator.defined.name",
    descriptionKey: "search.operator.defined.description",
    groqFilter: ({ fieldPath }) => fieldPath ? `defined(${fieldPath})` : null,
    type: "defined"
  },
  notDefined: {
    nameKey: "search.operator.not-defined.name",
    descriptionKey: "search.operator.not-defined.description",
    i18nKey: "search.operator.not-defined",
    groqFilter: ({ fieldPath }) => fieldPath ? `!defined(${fieldPath})` : null,
    type: "notDefined"
  }
}, numberOperators = {
  numberEqual: {
    nameKey: "search.operator.number-equal.name",
    descriptionKey: "search.operator.number-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberEqual"
  },
  numberGt: {
    nameKey: "search.operator.number-gt.name",
    descriptionKey: "search.operator.number-gt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} > ${toJSON(value)}` : null,
    icon: GtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberGt"
  },
  numberGte: {
    nameKey: "search.operator.number-gte.name",
    descriptionKey: "search.operator.number-gte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} >= ${toJSON(value)}` : null,
    icon: GteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberGte"
  },
  numberLt: {
    nameKey: "search.operator.number-lt.name",
    descriptionKey: "search.operator.number-lt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} < ${toJSON(value)}` : null,
    icon: LtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberLt"
  },
  numberLte: {
    nameKey: "search.operator.number-lte.name",
    descriptionKey: "search.operator.number-lte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} <= ${toJSON(value)}` : null,
    icon: LteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberLte"
  },
  numberNotEqual: {
    nameKey: "search.operator.number-not-equal.name",
    descriptionKey: "search.operator.number-not-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberNotEqual"
  },
  numberRange: {
    nameKey: "search.operator.number-range.name",
    descriptionKey: "search.operator.number-range.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? `${fieldPath} > ${toJSON(value == null ? void 0 : value.from)} && ${fieldPath} < ${toJSON(value == null ? void 0 : value.to)}` : "",
    initialValue: null,
    inputComponent: SearchFilterNumberRangeInput,
    type: "numberRange"
  }
};
function SearchFilterStringInput({
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => onChange(event.currentTarget.value || null),
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      placeholder: t2("search.filter-string-value-placeholder"),
      radius: 2,
      value: value || ""
    }
  );
}
const portableTextOperators = {
  portableTextEqual: {
    nameKey: "search.operator.portable-text-equal.name",
    descriptionKey: "search.operator.portable-text-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextEqual"
  },
  portableTextMatches: {
    nameKey: "search.operator.portable-text-contains.name",
    descriptionKey: "search.operator.portable-text-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextMatches"
  },
  portableTextNotEqual: {
    nameKey: "search.operator.portable-text-not-equal.name",
    descriptionKey: "search.operator.portable-text-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextNotEqual"
  },
  portableTextNotMatches: {
    nameKey: "search.operator.portable-text-not-contains.name",
    descriptionKey: "search.operator.portable-text-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(pt::text(${fieldPath}) match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextNotMatches"
  }
}, referenceOperators = {
  referenceEqual: {
    nameKey: "search.operator.reference-equal.name",
    descriptionKey: "search.operator.reference-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referenceEqual"
  },
  referenceNotEqual: {
    nameKey: "search.operator.reference-not-equal.name",
    descriptionKey: "search.operator.reference-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referenceNotEqual"
  },
  referencesAssetFile: {
    nameKey: "search.operator.reference-asset-file.name",
    descriptionKey: "search.operator.reference-asset-file.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    type: "referencesAssetFile"
  },
  referencesAssetImage: {
    nameKey: "search.operator.reference-asset-image.name",
    descriptionKey: "search.operator.reference-asset-image.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    type: "referencesAssetImage"
  },
  referencesDocument: {
    nameKey: "search.operator.reference-document.name",
    descriptionKey: "search.operator.reference-document.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referencesDocument"
  }
}, slugOperators = {
  slugEqual: {
    nameKey: "search.operator.slug-equal.name",
    descriptionKey: "search.operator.slug-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugEqual"
  },
  slugMatches: {
    nameKey: "search.operator.slug-contains.name",
    descriptionKey: "search.operator.slug-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    label: "contains",
    type: "slugMatches"
  },
  slugNotEqual: {
    nameKey: "search.operator.slug-not-equal.name",
    descriptionKey: "search.operator.slug-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugNotEqual"
  },
  slugNotMatches: {
    nameKey: "search.operator.slug-not-contains.name",
    descriptionKey: "search.operator.slug-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${fieldPath}.current match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugNotMatches"
  }
}, stringOperators = {
  stringEqual: {
    nameKey: "search.operator.string-equal.name",
    descriptionKey: "search.operator.string-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringEqual"
  },
  stringListEqual: {
    nameKey: "search.operator.string-list-equal.name",
    descriptionKey: "search.operator.string-list-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "stringListEqual"
  },
  stringListNotEqual: {
    nameKey: "search.operator.string-list-not-equal.name",
    descriptionKey: "search.operator.string-list-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "stringListNotEqual"
  },
  stringMatches: {
    nameKey: "search.operator.string-contains.name",
    descriptionKey: "search.operator.string-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringMatches"
  },
  stringNotEqual: {
    nameKey: "search.operator.string-not-equal.name",
    descriptionKey: "search.operator.string-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringNotEqual"
  },
  stringNotMatches: {
    nameKey: "search.operator.string-not-contains.name",
    descriptionKey: "search.operator.string-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${fieldPath} match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringNotMatches"
  }
}, searchOperators = {
  ...arrayOperators,
  ...assetOperators,
  ...booleanOperators,
  ...dateOperators,
  ...definedOperators,
  ...numberOperators,
  ...portableTextOperators,
  ...referenceOperators,
  ...slugOperators,
  ...stringOperators
}, operatorDefinitions = Object.values(searchOperators);
function pseudoRandomNumber(seed) {
  const hashCode = seed.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0);
  return Math.abs(hashCode * 16807 % 2147483647) / 2147483647;
}
const SvgText = styled__default.default.text`
  font-family: ${({ theme: theme2 }) => theme2.sanity.fonts.text.family};
  font-weight: ${({ theme: theme2 }) => theme2.sanity.fonts.text.weights.medium};
  font-size: ${({ theme: theme2 }) => theme2.sanity.fonts.text.sizes[1].fontSize}px;
  transform: translateY(1px);
`;
function createDefaultIcon(title, subtitle) {
  const rng1 = pseudoRandomNumber(`${title} ${subtitle}`), huesWithoutGray = color.COLOR_HUES.filter((hue) => hue !== "gray"), colorHue = huesWithoutGray[Math.floor(rng1 * huesWithoutGray.length)], possibleTints = ["300", "400", "500", "600", "700"], rng2 = pseudoRandomNumber(rng1.toString()), tint = possibleTints[Math.floor(rng2 * possibleTints.length)], color$1 = color.hues[colorHue][tint].hex, letters = title.split(/\s/g).map((word) => word.replace(/\\W/g, "")).filter(Boolean).slice(0, 2).map((i) => i.charAt(0).toUpperCase()), darkened = color2k.darken(color$1, 0.4), lightened = color2k.lighten(color$1, 0.4), textColor = color2k.hasBadContrast(color$1, "readable", darkened) ? color2k.hasBadContrast(color$1, "readable", lightened) ? color2k.readableColor(color$1) : lightened : darkened;
  return /* @__PURE__ */ jsxRuntime.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: [
    /* @__PURE__ */ jsxRuntime.jsx("rect", { width: 32, height: 32, rx: 2, fill: color$1 }),
    /* @__PURE__ */ jsxRuntime.jsx(
      SvgText,
      {
        x: "50%",
        y: "50%",
        textAnchor: "middle",
        alignmentBaseline: "middle",
        dominantBaseline: "middle",
        fill: textColor,
        children: letters
      }
    )
  ] });
}
function resolveSchemaTypes({
  config,
  context
}) {
  return resolveConfigProperty({
    propertyName: "schema.types",
    config,
    context,
    initialValue: [],
    reducer: schemaTypesReducer
  });
}
class SchemaError extends Error {
  constructor(schema2) {
    super("SchemaError"), this.schema = schema2;
  }
}
const isError = (p) => p.severity === "error";
function normalizeIcon(icon, title, subtitle = "") {
  return reactIs.isValidElementType(icon) ? React.createElement(icon) : React.isValidElement(icon) ? icon : createDefaultIcon(title, subtitle);
}
const preparedWorkspaces = /* @__PURE__ */ new WeakMap();
function prepareConfig(config, options) {
  if (!Array.isArray(config) && "missingConfigFile" in config)
    throw new ConfigResolutionError({
      name: "",
      type: "configuration file",
      causes: ["No `sanity.config.ts` file found", "No `sanity.config.js` file found"]
    });
  const rootPath = getRootPath(options == null ? void 0 : options.basePath), workspaceOptions = Array.isArray(config) ? config : [config];
  try {
    validateWorkspaces({ workspaces: workspaceOptions });
  } catch (e) {
    throw new ConfigResolutionError({
      name: "",
      type: "workspace",
      causes: [e.message]
    });
  }
  return { type: "prepared-config", workspaces: workspaceOptions.map((rawWorkspace) => {
    var _a2;
    if (preparedWorkspaces.has(rawWorkspace))
      return preparedWorkspaces.get(rawWorkspace);
    const { unstable_sources: nestedSources = [], ...rootSource } = rawWorkspace, resolvedSources = [rootSource, ...nestedSources].map((source) => {
      const { projectId, dataset } = source;
      let schemaTypes;
      try {
        schemaTypes = resolveSchemaTypes({
          config: source,
          context: { projectId, dataset }
        });
      } catch (e) {
        throw new ConfigResolutionError({
          name: source.name,
          type: "source",
          causes: [e]
        });
      }
      const schema2 = createSchema({
        name: source.name,
        types: schemaTypes
      }), schemaValidationProblemGroups = schema2._validation, schemaErrors = schemaValidationProblemGroups == null ? void 0 : schemaValidationProblemGroups.filter(
        (msg) => msg.problems.some(isError)
      );
      if (schemaValidationProblemGroups && schemaErrors != null && schemaErrors.length)
        throw new SchemaError(schema2);
      const auth = getAuthStore(source), i18n = prepareI18n(source), source$ = auth.state.pipe(
        operators.map(({ client: client2, authenticated, currentUser }) => resolveSource({
          config: source,
          client: client2,
          currentUser,
          schema: schema2,
          authenticated,
          auth,
          i18n
        })),
        operators.shareReplay(1)
      );
      return {
        name: source.name,
        projectId: source.projectId,
        dataset: source.dataset,
        title: source.title || startCase__default.default(source.name),
        auth,
        schema: schema2,
        i18n: i18n.source,
        source: source$
      };
    }), title = rootSource.title || startCase__default.default(rootSource.name), workspaceSummary = {
      type: "workspace-summary",
      auth: resolvedSources[0].auth,
      basePath: joinBasePath(rootPath, rootSource.basePath),
      dataset: rootSource.dataset,
      schema: resolvedSources[0].schema,
      i18n: resolvedSources[0].i18n,
      customIcon: !!rootSource.icon,
      icon: normalizeIcon(rootSource.icon, title, `${rootSource.projectId} ${rootSource.dataset}`),
      name: rootSource.name || "default",
      projectId: rootSource.projectId,
      theme: rootSource.theme || ui.studioTheme,
      title,
      subtitle: rootSource.subtitle,
      __internal: {
        sources: resolvedSources
      },
      tasks: (_a2 = rawWorkspace.unstable_tasks) != null ? _a2 : { enabled: !0 }
    };
    return preparedWorkspaces.set(rawWorkspace, workspaceSummary), workspaceSummary;
  }) };
}
function getAuthStore(source) {
  if (isAuthStore(source.auth))
    return source.auth;
  const clientFactory = source.unstable_clientFactory || client.createClient, { projectId, dataset, apiHost } = source;
  return createAuthStore({ apiHost, ...source.auth, clientFactory, dataset, projectId });
}
function getBifurClient(client2, auth) {
  const bifurVersionedClient = client2.withConfig({ apiVersion: "2022-06-30" }), { dataset, url: baseUrl, requestTagPrefix = "sanity.studio" } = bifurVersionedClient.config(), urlWithTag = `${`${baseUrl.replace(/\/+$/, "")}/socket/${dataset}`.replace(/^http/, "ws")}?tag=${requestTagPrefix}`, options = auth.token ? { token$: auth.token } : {};
  return bifurClient.fromUrl(urlWithTag, options);
}
function resolveSource({
  config,
  client: client2,
  currentUser,
  schema: schema2,
  authenticated,
  auth,
  i18n
}) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const { dataset, projectId } = config, bifur = getBifurClient(client2, auth), errors = [], clients = {}, getClient = (options) => {
    if (!options || !options.apiVersion)
      throw new Error("Missing required `apiVersion` option");
    return clients[options.apiVersion] || (clients[options.apiVersion] = client2.withConfig(options)), clients[options.apiVersion];
  }, context = {
    client: client2,
    getClient,
    currentUser,
    dataset,
    projectId,
    schema: schema2,
    i18n: i18n.source
  }, wrappedClient = client2;
  context.client = [...Object.keys(client2), ...Object.keys(wrappedClient.__proto__)].reduce(
    (acc, key) => {
      const original = Object.hasOwnProperty.call(client2, key) ? wrappedClient[key] : wrappedClient.__proto__[key];
      return Object.defineProperty(acc, key, {
        get() {
          return console.warn(
            '`configContext.client` is deprecated and will be removed in the next release! Use `context.getClient({apiVersion: "2021-06-07"})` instead'
          ), original;
        }
      });
    },
    {}
  );
  let templates;
  try {
    templates = resolveConfigProperty({
      config,
      context,
      propertyName: "schema.templates",
      reducer: schemaTemplatesReducer,
      initialValue: schema2.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema2.get(typeName)).filter(isNonNullable$2).filter((schemaType) => {
        var _a22;
        return ((_a22 = schemaType.type) == null ? void 0 : _a22.name) === "document";
      }).map((schemaType) => ({
        id: schemaType.name,
        schemaType: schemaType.name,
        title: schemaType.title || schemaType.name,
        icon: schemaType.icon,
        value: schemaType.initialValue || { _type: schemaType.name }
      }))
    });
  } catch (e) {
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: [e]
    });
  }
  let tools;
  try {
    tools = resolveConfigProperty({
      config,
      context,
      initialValue: [],
      propertyName: "tools",
      reducer: toolsReducer
    });
  } catch (e) {
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: [e]
    });
  }
  if (tools.some(({ name }) => name === "tool"))
    throw new Error('A tool cannot have the name "tool". Please enter a different name.');
  const initialTemplatesResponses = templates.filter((template) => {
    var _a22;
    return !((_a22 = template.parameters) != null && _a22.length);
  }).map(
    (template) => ({
      templateId: template.id,
      description: template.description,
      icon: template.icon,
      title: template.title
    })
  ), templateMap = templates.reduce((acc, template) => (acc.set(template.id, template), acc), /* @__PURE__ */ new Map()), resolveNewDocumentOptions = (creationContext) => {
    const { schemaType: schemaTypeName } = creationContext, templateResponses = resolveConfigProperty({
      config,
      context: { ...context, creationContext },
      initialValue: initialTemplatesResponses,
      propertyName: "document.resolveNewDocumentOptions",
      reducer: newDocumentOptionsResolver
    }), templateErrors = [];
    if (templateErrors.length)
      throw new ConfigResolutionError({
        name: config.name,
        type: "source",
        causes: templateErrors
      });
    return templateResponses.map((response, index) => {
      const template = templateMap.get(response.templateId);
      if (!template)
        throw new Error(`Could not find template with ID \`${response.templateId}\``);
      const schemaType = schema2.get(template.schemaType);
      if (!schemaType)
        throw new Error(
          `Could not find matching schema type \`${template.schemaType}\` for template \`${template.id}\``
        );
      const title = response.title || template.title, defaultSubtitle = (schemaType == null ? void 0 : schemaType.title) === title || schemaType == null ? void 0 : schemaType.title;
      return {
        id: `${response.templateId}-${index}`,
        templateId: response.templateId,
        type: "initialValueTemplateItem",
        title,
        i18n: response.i18n || template.i18n,
        subtitle: response.subtitle || defaultSubtitle,
        description: response.description || template.description,
        icon: response.icon || template.icon || (schemaType == null ? void 0 : schemaType.icon),
        initialDocumentId: response.initialDocumentId,
        parameters: response.parameters,
        schemaType: template.schemaType
      };
    }).filter((item) => {
      var _a22;
      return !schemaTypeName || creationContext.type === "document" ? !0 : schemaTypeName === ((_a22 = templateMap.get(item.templateId)) == null ? void 0 : _a22.schemaType);
    });
  };
  let staticInitialValueTemplateItems;
  try {
    staticInitialValueTemplateItems = resolveNewDocumentOptions({ type: "global" });
  } catch (e) {
    errors.push(e);
  }
  if (errors.length)
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: errors
    });
  return {
    type: "source",
    name: config.name,
    title: config.title || startCase__default.default(config.name),
    schema: schema2,
    getClient,
    dataset,
    projectId,
    tools,
    currentUser,
    authenticated,
    templates,
    auth,
    i18n: i18n.source,
    // eslint-disable-next-line camelcase
    __internal_tasks: internalTasksReducer({
      config
    }),
    document: {
      actions: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentActions,
        propertyName: "document.actions",
        reducer: documentActionsReducer
      }),
      badges: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentBadges,
        propertyName: "document.badges",
        reducer: documentBadgesReducer
      }),
      unstable_fieldActions: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentFieldActions,
        propertyName: "document.unstable_fieldActions",
        reducer: documentFieldActionsReducer
      }),
      inspectors: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: EMPTY_ARRAY$b,
        propertyName: "document.inspectors",
        reducer: documentInspectorsReducer
      }),
      resolveProductionUrl: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: void 0,
        propertyName: "resolveProductionUrl",
        asyncReducer: resolveProductionUrlReducer
      }),
      resolveNewDocumentOptions,
      unstable_languageFilter: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialLanguageFilter,
        propertyName: "document.unstable_languageFilter",
        reducer: documentLanguageFilterReducer
      }),
      unstable_comments: {
        enabled: (partialContext) => documentCommentsEnabledReducer({
          context: partialContext,
          config,
          initialValue: !0
        })
      }
    },
    form: {
      file: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: [FileSource],
          propertyName: "formBuilder.file.assetSources",
          reducer: fileAssetSourceResolver
        }),
        directUploads: (
          // TODO: consider refactoring this to `noDirectUploads` or similar
          // default value for this is `true`
          ((_b = (_a2 = config.form) == null ? void 0 : _a2.file) == null ? void 0 : _b.directUploads) === void 0 ? !0 : config.form.file.directUploads
        )
      },
      image: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: [ImageSource],
          propertyName: "formBuilder.image.assetSources",
          reducer: imageAssetSourceResolver
        }),
        directUploads: (
          // TODO: consider refactoring this to `noDirectUploads` or similar
          // default value for this is `true`
          ((_d = (_c = config.form) == null ? void 0 : _c.image) == null ? void 0 : _d.directUploads) === void 0 ? !0 : config.form.image.directUploads
        )
      }
    },
    search: {
      filters: filterDefinitions,
      operators: operatorDefinitions,
      unstable_partialIndexing: {
        enabled: partialIndexingEnabledReducer({
          config,
          initialValue: (_g = (_f = (_e = config.search) == null ? void 0 : _e.unstable_partialIndexing) == null ? void 0 : _f.enabled) != null ? _g : !1
        })
      },
      unstable_enableNewSearch: resolveConfigProperty({
        config,
        context,
        reducer: newSearchEnabledReducer,
        propertyName: "search.unstable_enableNewSearch",
        initialValue: !1
      })
      // we will use this when we add search config to PluginOptions
      /*filters: resolveConfigProperty({
        config,
        context: context,
        initialValue: filterDefinitions,
        propertyName: 'search.filters',
        reducer: searchFilterReducer,
      }),
      operators: resolveConfigProperty({
        config,
        context: context,
        initialValue: operatorDefinitions as SearchOperatorDefinition[],
        propertyName: 'search.operators',
        reducer: searchOperatorsReducer,
      }),*/
    },
    __internal: {
      bifur,
      i18next: i18n.i18next,
      staticInitialValueTemplateItems,
      options: config
    }
  };
}
function getRootPath(basePath) {
  const rootPath = basePath || "";
  if (typeof rootPath != "string" || rootPath.length > 0 && !rootPath.startsWith("/"))
    throw new ConfigResolutionError({
      name: "",
      type: "options",
      causes: ["basePath must be a string, and must start with a slash"]
    });
  return rootPath === "/" ? "" : rootPath;
}
function joinBasePath(rootPath, basePath) {
  return `/${[rootPath, basePath || ""].map((path) => path.replace(/^\/+/g, "").replace(/\/+$/g, "")).filter(Boolean).join("/")}`;
}
function WorkspacesProvider({ config, children, basePath }) {
  const { workspaces } = React.useMemo(() => prepareConfig(config, { basePath }), [config, basePath]);
  return /* @__PURE__ */ jsxRuntime.jsx(WorkspacesContext.Provider, { value: workspaces, children });
}
const RouterHistoryContext = React.createContext(null);
function RouterHistoryProvider({
  children,
  history: history2
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(RouterHistoryContext.Provider, { value: history2, children });
}
function useRouterHistory() {
  const value = React.useContext(RouterHistoryContext);
  if (!value)
    throw new Error("Could not find `RouterHistoryProvider` context");
  return value;
}
const ActiveWorkspaceMatcherContext = React.createContext(null), ActiveWorkspaceMatcherProvider = React.memo(function({
  children,
  history: history2,
  activeWorkspace,
  setActiveWorkspace
}) {
  const value = React.useMemo(
    () => ({
      activeWorkspace,
      setActiveWorkspace
    }),
    [activeWorkspace, setActiveWorkspace]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ActiveWorkspaceMatcherContext.Provider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(RouterHistoryProvider, { history: history2, children }) });
});
function createCommonBasePathRegex(workspaces) {
  const commonBasePath = workspaces.map(
    (workspace) => (
      // gets the segments from the basePath
      workspace.basePath.substring(1).split("/")
    )
  ).reduce((commonSegments, segments) => {
    for (let i = 0; i < commonSegments.length; i++) {
      const commonSegment = commonSegments[i], segment = segments[i].toLowerCase();
      if (commonSegment !== segment)
        return commonSegments.slice(0, i);
    }
    return commonSegments;
  });
  function createCommonBasePathRegexRecursively([first, ...rest]) {
    return first ? `(\\/${escapeRegExp__default.default(first)}${createCommonBasePathRegexRecursively(rest)}(\\/|$))?` : "";
  }
  return new RegExp(`^${createCommonBasePathRegexRecursively(commonBasePath)}$`, "i");
}
function matchWorkspace({
  pathname,
  workspaces,
  basePathRegex
}) {
  const [firstWorkspace] = workspaces;
  for (const { workspace, basePath, basePathRegex: basePathRegex2 } of workspaces)
    if (basePathRegex2.test(pathname) || basePath === "/")
      return { type: "match", workspace };
  return pathname === "/" ? { type: "redirect", pathname: firstWorkspace.basePath } : basePathRegex.test(pathname) ? { type: "redirect", pathname: firstWorkspace.basePath } : { type: "not-found" };
}
function useNormalizedWorkspaces(workspaces) {
  return React.useMemo(
    () => normalizedWorkspaces(workspaces),
    [workspaces]
  );
}
function normalizedWorkspaces(workspaces) {
  return workspaces.map((workspace) => {
    const basePath = workspace.basePath || "/";
    return {
      workspace,
      name: workspace.name,
      basePath,
      // this regex ends with a `(\\/|$)` (forward slash or end) to prevent false
      // matches where the pathname is a false subset of the current pathname.
      // e.g. if the `workspace.basePath` is `/base/foobar` and the current
      // pathname is `/base/foo`, then that should not be a match
      basePathRegex: new RegExp(`^${escapeRegExp__default.default(basePath)}(\\/|$)`, "i")
    };
  });
}
function useSyncPathnameWithWorkspace(history2, _workspaces) {
  const workspaces = useNormalizedWorkspaces(_workspaces), basePathRegex = React.useMemo(() => createCommonBasePathRegex(workspaces), [workspaces]), [serverSnapshot] = React.useState(() => history2.location.pathname), store = React.useMemo(() => ({
    subscribe: (onStoreChange) => history2.listen(onStoreChange),
    getSnapshot: () => history2.location.pathname,
    getServerSnapshot: () => serverSnapshot,
    selector: (pathname) => matchWorkspace({ basePathRegex, pathname, workspaces }),
    isEqual: (a, b) => {
      if (a.type !== b.type)
        return !1;
      switch (a.type) {
        case "match":
          return a.workspace === b.workspace;
        case "redirect":
          return a.pathname === b.pathname;
        case "not-found":
          return !0;
        default:
          throw new Error(`Unknown type: ${a.type}`);
      }
    }
  }), [basePathRegex, history2, serverSnapshot, workspaces]);
  return withSelector.useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getSnapshot,
    store.getServerSnapshot,
    store.selector,
    store.isEqual
  );
}
const createHistory = () => typeof document > "u" ? history$1.createMemoryHistory() : history$1.createBrowserHistory();
function ActiveWorkspaceMatcher({
  children,
  LoadingComponent,
  NotFoundComponent,
  unstable_history: historyProp
}) {
  const workspaces = useWorkspaces(), history2 = React.useMemo(() => historyProp || createHistory(), [historyProp]), setActiveWorkspaceName = React.useCallback(
    (workspaceName) => {
      const foundWorkspace = workspaces.find((workspace) => workspace.name === workspaceName);
      foundWorkspace && history2.push(foundWorkspace.basePath);
    },
    [history2, workspaces]
  ), handleNavigateToDefaultWorkspace = React.useCallback(() => {
    setActiveWorkspaceName(workspaces[0].name);
  }, [setActiveWorkspaceName, workspaces]), result = useSyncPathnameWithWorkspace(history2, workspaces);
  switch (React.useEffect(() => {
    result.type === "redirect" && history2.replace(result.pathname);
  }, [history2, result]), result.type) {
    case "match":
      return /* @__PURE__ */ jsxRuntime.jsx(
        ActiveWorkspaceMatcherProvider,
        {
          activeWorkspace: result.workspace,
          history: history2,
          setActiveWorkspace: setActiveWorkspaceName,
          children
        }
      );
    case "redirect":
      return /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
    case "not-found":
      return /* @__PURE__ */ jsxRuntime.jsx(NotFoundComponent, { onNavigateToDefaultWorkspace: handleNavigateToDefaultWorkspace });
    default:
      throw new Error(`Unknown type: ${result.type}`);
  }
}
function useActiveWorkspace() {
  const value = React.useContext(ActiveWorkspaceMatcherContext);
  if (!value)
    throw new Error("Could not find `ActiveWorkspaceMatcher` context");
  return value;
}
const AddonDatasetContext = React.createContext(null), ColorSchemeValueContext = React.createContext(null), ColorSchemeSetValueContext = React.createContext(null);
function useSystemScheme() {
  return ui.usePrefersDark() ? "dark" : "light";
}
function ColorThemeProvider({
  children,
  scheme: _scheme
}) {
  const systemScheme = useSystemScheme();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { scheme: _scheme === "system" ? systemScheme : _scheme, theme: ui.studioTheme, children });
}
const LOCAL_STORAGE_KEY = "sanityStudio:ui:colorScheme";
function ColorSchemeProvider({
  children,
  onSchemeChange,
  scheme: schemeProp
}) {
  return schemeProp ? /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeCustomProvider, { scheme: schemeProp, onSchemeChange, children }) : /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeLocalStorageProvider, { onSchemeChange, children });
}
function ColorSchemeLocalStorageProvider({
  children,
  onSchemeChange
}) {
  const store = React.useMemo(() => {
    let snapshot;
    const subscribers = /* @__PURE__ */ new Set();
    return {
      subscribe: (onStoreChange) => (snapshot || (snapshot = getScheme(localStorage.getItem(LOCAL_STORAGE_KEY)) || "system"), subscribers.add(onStoreChange), () => {
        subscribers.delete(onStoreChange);
      }),
      getSnapshot: () => snapshot,
      setSnapshot: (nextScheme) => {
        snapshot = getScheme(nextScheme);
        for (const subscription of subscribers)
          subscription();
      },
      // Only called during server-side rendering, and hydration if using hydrateRoot
      // https://beta.reactjs.org/apis/react/useSyncExternalStore#adding-support-for-server-rendering
      getServerSnapshot: () => "system"
    };
  }, []), scheme = React.useSyncExternalStore(store.subscribe, store.getSnapshot, store.getServerSnapshot);
  return React.useEffect(() => {
    typeof onSchemeChange == "function" && onSchemeChange(scheme), localStorage.setItem(LOCAL_STORAGE_KEY, scheme);
  }, [onSchemeChange, scheme]), /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeSetValueContext.Provider, { value: store.setSnapshot, children: /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ColorThemeProvider, { scheme, children }) }) });
}
function getScheme(scheme) {
  switch (scheme) {
    case "dark":
    case "light":
      return scheme;
    default:
      return "system";
  }
}
function ColorSchemeCustomProvider({
  children,
  onSchemeChange,
  scheme
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ColorSchemeSetValueContext.Provider,
    {
      value: typeof onSchemeChange == "function" ? onSchemeChange : !1,
      children: /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ColorThemeProvider, { scheme, children }) })
    }
  );
}
function useColorSchemeSetValue() {
  const setValue = React.useContext(ColorSchemeSetValueContext);
  if (setValue === null)
    throw new Error("Could not find `ColorSchemeSetValueContext` context");
  return setValue;
}
function _useColorSchemeInternalValue() {
  const value = React.useContext(ColorSchemeValueContext);
  if (value === null)
    throw new Error("Could not find `ColorSchemeValueContext` context");
  return value;
}
function useColorSchemeValue() {
  const scheme = _useColorSchemeInternalValue(), systemScheme = useSystemScheme();
  return scheme === "system" ? systemScheme : scheme;
}
function useColorScheme() {
  const scheme = useColorSchemeValue(), setScheme = useColorSchemeSetValue();
  return React.useMemo(() => ({ scheme, setScheme }), [scheme, setScheme]);
}
function useColorSchemeOptions(setScheme, t2) {
  const scheme = _useColorSchemeInternalValue();
  return React.useMemo(() => [
    {
      title: t2("user-menu.color-scheme.system-title"),
      name: "system",
      label: t2("user-menu.color-scheme.system-description"),
      selected: scheme === "system",
      onSelect: () => setScheme("system"),
      icon: icons.DesktopIcon
    },
    {
      title: t2("user-menu.color-scheme.dark-title"),
      name: "dark",
      label: t2("user-menu.color-scheme.dark-description"),
      selected: scheme === "dark",
      onSelect: () => setScheme("dark"),
      icon: icons.MoonIcon
    },
    {
      title: t2("user-menu.color-scheme.light-title"),
      name: "light",
      label: t2("user-menu.color-scheme.light-description"),
      selected: scheme === "light",
      onSelect: () => setScheme("light"),
      icon: icons.SunIcon
    }
  ], [scheme, setScheme, t2]);
}
const isSearchHotKey = isHotkey__default.default(`mod+${GLOBAL_SEARCH_KEY}`), isEscape$1 = isHotkey__default.default("escape");
function useSearchHotkeys({
  open,
  onClose,
  onOpen
}) {
  const { isTopLayer } = ui.useLayer(), handleClose = React.useCallback(() => {
    onClose == null || onClose();
  }, [onClose]), handleGlobalKeyDown = React.useCallback(
    (event) => {
      isSearchHotKey(event) && (event.preventDefault(), open ? handleClose() : onOpen == null || onOpen()), isEscape$1(event) && open && isTopLayer && handleClose();
    },
    [handleClose, isTopLayer, open, onOpen]
  );
  ui.useGlobalKeyDown(handleGlobalKeyDown);
}
function SearchWrapper({
  children,
  hasValidTerms,
  onClose,
  onOpen,
  open
}) {
  const isMountedRef = React.useRef(!1), {
    dispatch,
    searchCommandList,
    setOnClose,
    state: { result }
  } = useSearchState(), handleClose = React.useCallback(() => {
    var _a2;
    dispatch({ index: (_a2 = searchCommandList == null ? void 0 : searchCommandList.getTopIndex()) != null ? _a2 : -1, type: "LAST_ACTIVE_INDEX_SET" }), onClose();
  }, [dispatch, onClose, searchCommandList]);
  return useSearchHotkeys({ onClose: handleClose, onOpen, open }), React.useEffect(() => {
    setOnClose(handleClose);
  }, [handleClose, setOnClose]), React.useEffect(() => {
    (!hasValidTerms || result.loaded) && isMountedRef.current && dispatch({ index: 0, type: "LAST_ACTIVE_INDEX_SET" });
  }, [dispatch, hasValidTerms, result.loaded]), React.useEffect(() => {
    !hasValidTerms && isMountedRef.current && !open && dispatch({ type: "ORDERING_RESET" });
  }, [dispatch, hasValidTerms, open]), React.useEffect(() => {
    isMountedRef != null && isMountedRef.current || (isMountedRef.current = !0);
  }, []), children;
}
function createOperatorDefinitionDictionary(operatorDefinitions2) {
  return operatorDefinitions2.reduce((acc, val) => (acc[val.type] = val, acc), {});
}
function getOperatorDefinition(operators2, operatorType) {
  return operatorType ? operators2[operatorType] : void 0;
}
function getOperatorInitialValue(operators2, operatorType) {
  var _a2;
  return (_a2 = getOperatorDefinition(operators2, operatorType)) == null ? void 0 : _a2.initialValue;
}
function buildSearchFilter(filterDefinition, fieldId) {
  var _a2;
  return {
    fieldId,
    filterName: filterDefinition.name,
    operatorType: ((_a2 = filterDefinition == null ? void 0 : filterDefinition.operators.find((operator) => operator.type === "item")) == null ? void 0 : _a2.name) || ""
  };
}
function generateFilterQuery({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  operatorDefinitions: operatorDefinitions2
}) {
  return filters.filter(
    (filter) => validateFilter({
      filter,
      filterDefinitions: filterDefinitions2,
      fieldDefinitions,
      operatorDefinitions: operatorDefinitions2
    })
  ).map((filter) => {
    var _a2;
    return (_a2 = getOperatorDefinition(operatorDefinitions2, filter.operatorType)) == null ? void 0 : _a2.groqFilter({
      fieldPath: resolveFieldPath({ filter, fieldDefinitions, filterDefinitions: filterDefinitions2 }),
      value: filter == null ? void 0 : filter.value
    });
  }).filter((filter) => !isEmpty__default.default(filter)).filter(isNonNullable$2).join(" && ");
}
function getFieldFromFilter(fields, filter) {
  return filter != null && filter.fieldId ? fields[filter.fieldId] : void 0;
}
function getFilterKey(filter) {
  return [filter.filterName, ...filter.fieldId ? [filter.fieldId] : []].join("-");
}
function narrowDocumentTypes({
  fieldDefinitions,
  filters,
  types: types2
}) {
  const selectedDocumentTypes = types2.map((type) => type.name), filteredDocumentTypes = Object.values(fieldDefinitions).filter((field) => filters.map((filter) => filter == null ? void 0 : filter.fieldId).includes(field.id)).filter((field) => field.documentTypes.length > 0).map((field) => field.documentTypes), intersectingDocumentTypes = intersection__default$1.default(...filteredDocumentTypes), documentTypes = [];
  return selectedDocumentTypes.length > 0 && documentTypes.push(selectedDocumentTypes), intersectingDocumentTypes.length > 0 && documentTypes.push(intersectingDocumentTypes), intersection__default$1.default(...documentTypes).sort();
}
function resolveFieldPath({
  filter,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2
}) {
  const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter), filterDefinition = getFilterDefinition(filterDefinitions2, filter.filterName);
  if (filterDefinition)
    switch (filterDefinition.type) {
      case "field":
        return fieldDefinition == null ? void 0 : fieldDefinition.fieldPath;
      case "pinned":
        return filterDefinition == null ? void 0 : filterDefinition.fieldPath;
      default:
        return;
    }
}
function validateFilter({
  filter,
  filterDefinitions: filterDefinitions2,
  fieldDefinitions,
  operatorDefinitions: operatorDefinitions2
}) {
  const filterDef = getFilterDefinition(filterDefinitions2, filter.filterName), operatorDef = getOperatorDefinition(operatorDefinitions2, filter.operatorType), fieldDef = getFieldFromFilter(fieldDefinitions, filter);
  return !(!filterDef || !operatorDef || filter.fieldId && !fieldDef || filterDef.type === "field" && (!(fieldDef != null && fieldDef.fieldPath) || !filter.fieldId || !operatorDef.groqFilter({
    fieldPath: fieldDef.fieldPath,
    value: filter.value
  })) || filterDef.type === "pinned" && !operatorDef.groqFilter({
    fieldPath: filterDef.fieldPath,
    value: filter.value
  }));
}
const isEscape = isHotkey__default.default("escape"), MAX_HEIGHT = 500, HiddenOverlay = styled__default.default.div`
  background: transparent;
  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: -1;
`;
function FilterPopoverWrapper({
  anchorElement,
  children,
  onClose
}) {
  const { isTopLayer } = ui.useLayer(), handleGlobalKeyDown = React.useCallback(
    (event) => {
      isEscape(event) && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  ui.useGlobalKeyDown(handleGlobalKeyDown);
  const popoverOffset = usePopoverOffset(anchorElement || null);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(HiddenOverlay, { onClick: onClose }),
    /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !1, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        display: "flex",
        overflow: "hidden",
        radius: POPOVER_RADIUS,
        style: {
          maxHeight: `min(calc(100vh - ${popoverOffset}px - ${POPOVER_VERTICAL_MARGIN}px - ${POPOVER_INPUT_PADDING}px), ${MAX_HEIGHT}px`,
          zIndex: 1
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children })
      }
    ) })
  ] });
}
function calcPopoverOffset(element) {
  const rect = element.getBoundingClientRect();
  return rect.y + rect.height + POPOVER_VERTICAL_MARGIN;
}
function usePopoverOffset(element) {
  const [offset, setOffset] = React.useState(element && calcPopoverOffset(element)), handleWindowResize = React.useCallback(() => {
    element && setOffset(calcPopoverOffset(element));
  }, [element]);
  return React.useEffect(() => {
    element && setOffset(calcPopoverOffset(element));
  }, [element]), React.useEffect(() => (window.addEventListener("resize", handleWindowResize), () => window.removeEventListener("resize", handleWindowResize)), [handleWindowResize]), offset;
}
const SearchHeaderBox = styled__default.default(ui.Box)`
  border-bottom: 1px solid ${({ theme: theme2 }) => theme2.sanity.color.base.border};
  flex-shrink: 0;
`, SearchHeaderContentFlex = styled__default.default(ui.Flex)`
  box-sizing: border-box;
`, FilterPopoverContentHeader = React.forwardRef(function({ ariaInputLabel, onChange, onClear, typeFilter }, ref) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(SearchHeaderBox, { children: /* @__PURE__ */ jsxRuntime.jsx(SearchHeaderContentFlex, { align: "center", flex: 1, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    CustomTextInput,
    {
      __unstable_disableFocusRing: !0,
      $smallClearButton: !0,
      "aria-label": ariaInputLabel,
      autoComplete: "off",
      border: !1,
      clearButton: !!typeFilter,
      fontSize: fullscreen ? 2 : 1,
      icon: icons.SearchIcon,
      muted: !0,
      onChange,
      onClear,
      placeholder: t2("search.filter-placeholder"),
      ref,
      spellCheck: !1,
      radius: 2,
      value: typeFilter
    }
  ) }) });
});
function createFilterMenuItems({
  documentTypesNarrowed,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  schema: schema2,
  titleFilter,
  types: types2,
  t: t2
}) {
  const fieldFilters = Object.values(fieldDefinitions).filter((fieldDef) => includesTitleInFieldDefinition(fieldDef, titleFilter)).map((fieldDef) => {
    const filterDef = getFilterDefinition(filterDefinitions2, fieldDef.filterName);
    return filterDef ? buildSearchFilter(filterDef, fieldDef.id) : null;
  }).filter(isNonNullable$2), pinnedItems = buildPinnedMenuItems({
    fieldDefinitions,
    filterDefinitions: filterDefinitions2,
    titleFilter
  });
  return documentTypesNarrowed.length === 0 ? [
    ...pinnedItems,
    // All fields
    ...filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: fieldFilters,
      headerTitle: t2("search.filter-all-fields-header"),
      id: "field"
    })
  ] : [
    ...pinnedItems,
    // All shared / narrowed items
    ...buildFieldMenuItemsNarrowed({
      documentTypesNarrowed,
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: fieldFilters,
      schema: schema2,
      types: types2,
      t: t2
    })
  ];
}
function filterGroup({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  id: id2,
  headerTitle,
  tone
}) {
  const header = {
    title: headerTitle || "",
    tone: tone || "default",
    type: "header"
  }, filterItems = filters.map(
    (filter) => ({
      fieldDefinition: getFieldFromFilter(fieldDefinitions, filter),
      filterDefinition: getFilterDefinition(filterDefinitions2, filter.filterName),
      filter,
      group: id2,
      tone: tone || "default",
      type: "filter"
    })
  );
  return filterItems.length > 0 ? [
    ...headerTitle ? [header] : [],
    //
    ...filterItems
  ] : [];
}
function buildFieldMenuItemsNarrowed({
  documentTypesNarrowed,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  schema: schema2,
  types: types2,
  t: t2
}) {
  const sharedFilters = filters.filter((filter) => {
    const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter);
    return sharesDocumentTypes(documentTypesNarrowed, fieldDefinition);
  }), sharedItems = documentTypesNarrowed.length > 1 && types2.length > 1 ? filterGroup({
    fieldDefinitions,
    filterDefinitions: filterDefinitions2,
    filters: sharedFilters,
    headerTitle: t2("search.filter-shared-fields-header"),
    id: "shared",
    tone: "primary"
  }) : [], groupedItems = documentTypesNarrowed.map((documentType) => {
    const docType = schema2.get(documentType);
    return {
      // Note: it shouldn't be possible to select document types that do not exist in schema,
      // and there is no way to inject it into state (eg not persisted in URL), thus we leave
      // this fallback (`Unknown type`) only as a edge-case safety net and will not translate it.
      title: (docType == null ? void 0 : docType.title) || startCase__default.default(docType == null ? void 0 : docType.name) || "(Unknown type)",
      documentType
    };
  }).sort((a, b) => a.title.localeCompare(b.title)).map(({ documentType, title }) => {
    const groupFilters = filters.filter((filter) => {
      const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter);
      return includesDocumentTypes([documentType], fieldDefinition);
    });
    return filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: groupFilters,
      id: title,
      headerTitle: title
    });
  }).flat();
  return [...sharedItems, ...groupedItems];
}
function buildPinnedMenuItems({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  titleFilter
}) {
  const ungroupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithoutGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).map((filterDef) => buildSearchFilter(filterDef)), groupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).reduce((acc, val) => (acc[val.group] = acc[val.group] || [], acc[val.group].push(buildSearchFilter(val)), acc), {});
  return [
    // Ungrouped
    ...filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: ungroupedPinnedFilters,
      id: "pinned-ungrouped",
      tone: "primary"
    }),
    // Grouped
    ...Object.entries(groupedPinnedFilters).flatMap(
      ([groupTitle, filters]) => filterGroup({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        filters,
        headerTitle: groupTitle,
        id: groupTitle,
        tone: "primary"
      })
    )
  ];
}
function includesDocumentTypes(documentTypes, fieldDefinition) {
  return fieldDefinition == null ? void 0 : fieldDefinition.documentTypes.some((type) => documentTypes.includes(type));
}
function includesTitleInFieldDefinition(field, currentTitle) {
  return field.titlePath.join("/").toLowerCase().includes(currentTitle.toLowerCase());
}
function includesTitleInPinnedFilterDefinition(filter, currentTitle) {
  return filter.title.toLowerCase().includes(currentTitle.toLowerCase());
}
function isPinnedFilterDefWithGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) < "u";
}
function isPinnedFilterDefWithoutGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) > "u";
}
function sharesDocumentTypes(documentTypes, fieldDefinition) {
  return difference__default.default(documentTypes, (fieldDefinition == null ? void 0 : fieldDefinition.documentTypes) || []).length === 0;
}
function FilterTitle({ filter, maxLength }) {
  const {
    state: { definitions }
  } = useSearchState(), title = React.useMemo(() => {
    const filterDef = getFilterDefinition(definitions.filters, filter.filterName);
    switch (filterDef == null ? void 0 : filterDef.type) {
      case "field": {
        const fieldDefinition = getFieldFromFilter(definitions.fields, filter);
        return fieldDefinition != null && fieldDefinition.titlePath ? fieldDefinition.titlePath[fieldDefinition.titlePath.length - 1] : null;
      }
      case "pinned":
        return filterDef.title;
      default:
        return null;
    }
  }, [definitions, filter]);
  return title ? maxLength && title.length > maxLength ? /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
    title.slice(0, maxLength),
    "\u2026"
  ] }) : /* @__PURE__ */ jsxRuntime.jsx("span", { children: title }) : null;
}
function FilterIcon({ filter }) {
  var _a2;
  const {
    state: { definitions }
  } = useSearchState(), icon = (_a2 = getFilterDefinition(definitions.filters, filter.filterName)) == null ? void 0 : _a2.icon;
  return icon ? React.createElement(icon) : /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {});
}
function FilterDetails({ filter }) {
  var _a2;
  const {
    state: { definitions }
  } = useSearchState(), fieldDefinition = getFieldFromFilter(definitions.fields, filter);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    (fieldDefinition == null ? void 0 : fieldDefinition.titlePath) && ((_a2 = fieldDefinition.titlePath) == null ? void 0 : _a2.length) > 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 0, children: fieldDefinition.titlePath.slice(0, -1).map((pathTitle, index) => /* @__PURE__ */ jsxRuntime.jsxs(
      React.Fragment,
      {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx("span", { children: pathTitle }),
          index !== fieldDefinition.titlePath.length - 2 && /* @__PURE__ */ jsxRuntime.jsx(
            "span",
            {
              style: {
                opacity: 0.75,
                paddingLeft: "0.25em",
                paddingRight: "0.25em"
              },
              children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {})
            }
          )
        ]
      },
      index
    )) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FilterIcon, { filter }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(FilterTitle, { filter }) })
    ] })
  ] });
}
function sanitizeFieldValue(name) {
  return React.isValidElement(name) ? stripHtmlTags(server.renderToString(name)) : typeof name == "string" ? name : "";
}
function stripHtmlTags(str) {
  var _a2;
  return ((_a2 = new DOMParser().parseFromString(str, "text/html")) == null ? void 0 : _a2.body.textContent) || "";
}
const MAX_VISIBLE_TYPES = 10;
function FilterTooltip({
  children,
  fieldDefinition,
  filterDefinition,
  visible
}) {
  const {
    state: { documentTypesNarrowed }
  } = useSearchState(), { t: t2 } = useTranslation(), schema2 = useSchema(), fieldDefinitionDocumentTypeTitles = React.useMemo(() => fieldDefinition != null && fieldDefinition.documentTypes ? fieldDefinition.documentTypes.map((d) => {
    const defType = schema2.get(d);
    return (defType == null ? void 0 : defType.title) || startCase__default.default(defType == null ? void 0 : defType.name);
  }).filter(isNonNullable$2).sort() : [], [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, schema2]), fieldDefinitionDescription = React.useMemo(() => {
    if (fieldDefinition != null && fieldDefinition.documentTypes) {
      const descriptions = fieldDefinition.documentTypes.map((d) => {
        const defType = schema2.get(d);
        if (defType) {
          const field = getSchemaField(defType, fieldDefinition.fieldPath);
          return (field == null ? void 0 : field.type.description) && sanitizeFieldValue(field == null ? void 0 : field.type.description);
        }
        return null;
      }).filter(isNonNullable$2).sort(), uniqueDescriptions = uniq__default.default(descriptions);
      if (uniqueDescriptions.length === 1)
        return uniqueDescriptions[0];
    }
  }, [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, fieldDefinition == null ? void 0 : fieldDefinition.fieldPath, schema2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "default", radius: 2, style: { maxWidth: "250px" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        fieldDefinition && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-name") }),
          /* @__PURE__ */ jsxRuntime.jsx(
            TextWithTone,
            {
              size: 1,
              style: { fontFamily: "monospace" },
              tone: "primary",
              textOverflow: "ellipsis",
              children: fieldDefinition == null ? void 0 : fieldDefinition.name
            }
          )
        ] }),
        fieldDefinitionDescription && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: truncateString(fieldDefinitionDescription, 256) })
        ] }),
        (filterDefinition == null ? void 0 : filterDefinition.description) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: truncateString(filterDefinition.description, 256) }),
        !documentTypesNarrowed.length && fieldDefinitionDocumentTypeTitles.length > 0 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-used-in-document-types") }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: fieldDefinitionDocumentTypeTitles.length }) })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "regular", muted: !0, children: [
            fieldDefinitionDocumentTypeTitles.slice(0, MAX_VISIBLE_TYPES).join(", "),
            (fieldDefinitionDocumentTypeTitles == null ? void 0 : fieldDefinitionDocumentTypeTitles.length) > MAX_VISIBLE_TYPES ? ` +${fieldDefinitionDocumentTypeTitles.length - MAX_VISIBLE_TYPES} more` : ""
          ] })
        ] })
      ] }) }),
      disabled: !visible,
      fallbackPlacements: ["left"],
      placement: "right",
      portal: !0,
      children
    }
  );
}
const MenuItemFilter = React.memo(function({
  item,
  onClose,
  ...rest
}) {
  const {
    dispatch,
    state: { filters }
  } = useSearchState(), handleClick = React.useCallback(() => {
    dispatch({ filter: item.filter, type: "TERMS_FILTERS_ADD" }), onClose == null || onClose();
  }, [dispatch, item.filter, onClose]), isAlreadyActive = !!filters.find((f) => getFilterKey(f) === getFilterKey(item.filter)), tooltipEnabled = !!(item.fieldDefinition || item.filterDefinition.description);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      disabled: isAlreadyActive,
      fontSize: 1,
      justify: "flex-start",
      mode: "bleed",
      onClick: isAlreadyActive ? void 0 : handleClick,
      padding: 0,
      style: { position: "relative", whiteSpace: "normal", width: "100%" },
      tabIndex: -1,
      tone: item == null ? void 0 : item.tone,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        FilterTooltip,
        {
          fieldDefinition: item.fieldDefinition,
          filterDefinition: item.filterDefinition,
          visible: tooltipEnabled,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FilterDetails, { filter: item.filter }) })
        }
      )
    }
  ) });
}), MenuItemHeader = React.memo(function({ item }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, paddingX: 2, paddingY: 3, tone: item == null ? void 0 : item.tone, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: item.title }) }) });
}), POPOVER_STYLES$1 = { width: "300px" };
function AddFilterPopoverContent({ onClose }) {
  const [inputElement, setInputElement] = React.useState(null), [titleFilter, setTitleFilter] = React.useState(""), { t: t2 } = useTranslation(), handleFilterChange = React.useCallback(
    (e) => setTitleFilter(e.currentTarget.value),
    [setTitleFilter]
  ), handleFilterClear = React.useCallback(() => setTitleFilter(""), []), schema2 = useSchema(), {
    state: {
      documentTypesNarrowed,
      definitions,
      filters,
      terms: { types: types2 }
    }
  } = useSearchState(), filteredMenuItems = React.useMemo(
    () => createFilterMenuItems({
      documentTypesNarrowed,
      fieldDefinitions: definitions.fields,
      filterDefinitions: definitions.filters,
      schema: schema2,
      titleFilter,
      types: types2,
      t: t2
    }),
    [documentTypesNarrowed, definitions.fields, definitions.filters, schema2, titleFilter, types2, t2]
  ), renderItem = React.useCallback(
    (item) => item.type === "filter" ? /* @__PURE__ */ jsxRuntime.jsx(MenuItemFilter, { item, onClose, paddingBottom: 1 }) : item.type === "header" ? /* @__PURE__ */ jsxRuntime.jsx(MenuItemHeader, { item }) : null,
    [onClose]
  ), getItemDisabled = React.useCallback(
    (index) => {
      const filterItem = filteredMenuItems[index];
      return filterItem.type !== "filter" || !!filters.find((f) => getFilterKey(f) === getFilterKey(filterItem.filter));
    },
    [filteredMenuItems, filters]
  ), getItemKey2 = React.useCallback(
    (index) => {
      const menuItem = filteredMenuItems[index];
      switch (menuItem.type) {
        case "filter":
          return [
            ...menuItem.group ? [menuItem.group] : [],
            //
            getFilterKey(menuItem.filter)
          ].join("-");
        case "header":
          return `${menuItem.type}-${menuItem.title}`;
        default:
          return index;
      }
    },
    [filteredMenuItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", style: POPOVER_STYLES$1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FilterPopoverContentHeader,
      {
        ariaInputLabel: t2("search.filter-by-title-aria-label"),
        onChange: handleFilterChange,
        onClear: handleFilterClear,
        ref: setInputElement,
        typeFilter: titleFilter
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      filteredMenuItems.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CommandList,
        {
          activeItemDataAttr: "data-hovered",
          ariaLabel: t2("search.filters-aria-label", { count: filteredMenuItems.length }),
          autoFocus: "input",
          getItemDisabled,
          getItemKey: getItemKey2,
          inputElement,
          itemHeight: 45,
          items: filteredMenuItems,
          overscan: 20,
          padding: 1,
          paddingBottom: 0,
          renderItem
        }
      ),
      filteredMenuItems.length == 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: t2("search.filter-no-matches-found", { filter: titleFilter }) }) })
    ] })
  ] });
}
function AddFilterButton() {
  const [open, setOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []);
  return ui.useClickOutside(handleClose, [buttonElement, popoverElement]), /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(AddFilterPopoverContent, { onClose: handleClose }) }),
      open,
      placement: "bottom-start",
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.AddIcon,
          mode: "bleed",
          onClick: handleOpen,
          size: fullscreen ? "large" : "default",
          ref: setButtonElement,
          selected: open,
          text: t2("search.action.add-filter")
        }
      )
    }
  );
}
const DocumentTypeFilterItem = React.memo(function({
  selected,
  type,
  ...rest
}) {
  var _a2, _b;
  const { dispatch } = useSearchState(), handleTypeAdd = React.useCallback(() => {
    dispatch({ type: "TERMS_TYPE_ADD", schemaType: type });
  }, [dispatch, type]), handleTypeRemove = React.useCallback(() => {
    dispatch({ type: "TERMS_TYPE_REMOVE", schemaType: type });
  }, [dispatch, type]), handleClick = React.useCallback(() => {
    selected ? handleTypeRemove() : handleTypeAdd();
  }, [handleTypeAdd, handleTypeRemove, selected]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      iconRight: selected && icons.CheckmarkIcon,
      justify: "flex-start",
      mode: "bleed",
      onClick: handleClick,
      width: "fill",
      size: "large",
      tabIndex: -1,
      text: (_b = type.title) != null ? _b : type.name,
      tone: selected ? "primary" : "default"
    },
    (_a2 = type.title) != null ? _a2 : type.name
  ) });
}), ClearButtonBox = styled__default.default(ui.Box)`
  border-top: 1px solid ${({ theme: theme2 }) => theme2.sanity.color.base.border};
  flex-shrink: 0;
`, POPOVER_STYLES = { width: "250px" };
function DocumentTypesPopoverContent() {
  const [inputElement, setInputElement] = React.useState(null), [typeFilter, setTypeFilter] = React.useState(""), commandListRef = React.useRef(null), { t: t2 } = useTranslation(), schema2 = useSchema(), {
    dispatch,
    state: {
      terms: { types: selectedTypes }
    }
  } = useSearchState(), [selectedTypesSnapshot, setSelectedTypesSnapshot] = React.useState(selectedTypes), documentTypeItems = useGetDocumentTypeItems(
    schema2,
    selectedTypes,
    selectedTypesSnapshot,
    typeFilter
  ), handleFilterChange = React.useCallback(
    (e) => setTypeFilter(e.currentTarget.value),
    [setTypeFilter]
  ), handleFilterClear = React.useCallback(() => setTypeFilter(""), []), handleTypesClear = React.useCallback(() => {
    var _a2, _b;
    setSelectedTypesSnapshot([]), dispatch({ type: "TERMS_TYPES_CLEAR" }), (_a2 = commandListRef == null ? void 0 : commandListRef.current) == null || _a2.focusInputElement(), (_b = commandListRef == null ? void 0 : commandListRef.current) == null || _b.scrollToIndex(0);
  }, [dispatch]), getItemKey2 = React.useCallback(
    (index) => {
      const virtualItem = documentTypeItems[index];
      switch (virtualItem.type) {
        case "divider":
          return `${virtualItem.type}-${index}`;
        case "header":
          return `${virtualItem.type}-${virtualItem.title}`;
        case "item":
          return `${virtualItem.type}-${virtualItem.item.name}`;
        default:
          return index;
      }
    },
    [documentTypeItems]
  ), renderItem = React.useCallback((item) => item.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}) }) : item.type === "header" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: item.title }) }) : item.type === "item" ? /* @__PURE__ */ jsxRuntime.jsx(DocumentTypeFilterItem, { paddingBottom: 1, selected: item.selected, type: item.item }) : null, []), getItemDisabled = React.useCallback(
    (index) => documentTypeItems[index].type !== "item",
    [documentTypeItems]
  ), getItemSelected = React.useCallback(
    (index) => {
      const item = documentTypeItems[index];
      return item.type === "item" && item.selected;
    },
    [documentTypeItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", style: POPOVER_STYLES, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FilterPopoverContentHeader,
      {
        ariaInputLabel: t2("search.action.filter-by-document-type-aria-label"),
        onChange: handleFilterChange,
        onClear: handleFilterClear,
        ref: setInputElement,
        typeFilter
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      documentTypeItems.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CommandList,
        {
          activeItemDataAttr: "data-hovered",
          ariaLabel: t2("search.document-types-aria-label"),
          ariaMultiselectable: !0,
          autoFocus: "input",
          getItemDisabled,
          getItemSelected,
          getItemKey: getItemKey2,
          inputElement,
          itemHeight: 37,
          items: documentTypeItems,
          overscan: 20,
          padding: 1,
          paddingBottom: 0,
          ref: commandListRef,
          renderItem
        }
      ),
      !documentTypeItems.length && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: t2("search.document-types-no-matches-found", { filter: typeFilter }) }) })
    ] }),
    !typeFilter && selectedTypes.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ClearButton, { onClick: handleTypesClear, selectedTypes })
  ] });
}
function ClearButton({ onClick, selectedTypes }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ClearButtonBox, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      "aria-label": t2("search.action.clear-type-filters-aria-label"),
      "data-name": "type-filter-button",
      disabled: selectedTypes.length === 0,
      mode: "bleed",
      onClick,
      text: t2("search.action.clear-type-filters-label"),
      tone: "primary"
    }
  ) }) });
}
function useGetDocumentTypeItems(schema2, selectedTypes, selectedTypesSnapshot, typeFilter) {
  return React.useMemo(() => {
    const [itemsSelected, itemsUnselected] = partition__default.default(
      getSelectableOmnisearchTypes(schema2, typeFilter),
      (type) => selectedTypesSnapshot.includes(type)
    ), hasSelectedItems = itemsSelected.length > 0, hasUnselectedItems = itemsSelected.length > 0, items = [];
    return hasSelectedItems && items.push({ title: "Selected", type: "header" }), itemsSelected.forEach(
      (item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" })
    ), hasSelectedItems && hasUnselectedItems && items.push({ type: "divider" }), itemsUnselected.forEach(
      (item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" })
    ), items;
  }, [schema2, selectedTypes, selectedTypesSnapshot, typeFilter]);
}
const FALLBACK_PLACEMENTS = ["top-start", "bottom-start"];
function DocumentTypesButton() {
  const [open, setOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), {
    state: {
      fullscreen,
      terms: { types: types2 }
    }
  } = useSearchState(), { t: t2 } = useTranslation(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []);
  ui.useClickOutside(handleClose, [buttonElement, popoverElement]);
  const title = React.useMemo(() => documentTypesTruncated({ types: types2, t: t2 }), [types2, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesPopoverContent, {}) }),
      open,
      placement: "bottom-start",
      fallbackPlacements: FALLBACK_PLACEMENTS,
      portal: !0,
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          iconRight: icons.ChevronDownIcon,
          mode: "ghost",
          onClick: handleOpen,
          size: fullscreen ? "large" : "default",
          ref: setButtonElement,
          selected: open,
          text: title,
          tone: "default"
        }
      )
    }
  );
}
const CustomBox = styled__default.default(ui.Box)`
  flex-shrink: ${({ $flexShrink = 0 }) => $flexShrink};
`;
function FilterLabel({ filter, fontSize = 1, showContent = !0 }) {
  const { t: t2 } = useTranslation(), {
    state: { definitions, fullscreen }
  } = useSearchState(), operator = getOperatorDefinition(definitions.operators, filter.operatorType), ButtonValue = operator == null ? void 0 : operator.buttonValueComponent, filterValue = filter.value, components2 = React.useMemo(
    () => ({
      Field: () => /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: fullscreen ? 1 : 0, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(FilterTitle, { filter, maxLength: fullscreen ? 25 : 40 }) }) }),
      Operator: ({ children }) => showContent ? /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: 0, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "regular", children }) }) : null,
      Value: ({ children }) => showContent ? /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "medium", children: ButtonValue ? /* @__PURE__ */ jsxRuntime.jsx(ButtonValue, { value: filterValue }) : children }) }) : null
    }),
    [filter, fontSize, fullscreen, showContent, ButtonValue, filterValue]
  );
  if (operator != null && operator.descriptionKey || console.warn("Missing `descriptionKey` for operator `%s`", filter.operatorType), !showContent || !(operator != null && operator.descriptionKey)) {
    const Field = components2.Field;
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Field, {}) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: operator == null ? void 0 : operator.descriptionKey,
      components: components2,
      values: getFilterValues(filter)
    }
  ) });
}
function getFilterValues(filter) {
  const values2 = {};
  return typeof filter.value == "number" && (values2.count = filter.value), isStringOrNumber(filter.value) && (values2.value = filter.value), isRecord$4(filter.value) && "from" in filter.value && isStringOrNumber(filter.value.from) && (values2.from = filter.value.from), isRecord$4(filter.value) && "to" in filter.value && isStringOrNumber(filter.value.to) && (values2.to = filter.value.to), values2;
}
function isStringOrNumber(value) {
  return typeof value == "string" || typeof value == "number";
}
function FilterError(props2) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...props2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t2("search.error.display-filter-title") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", children: t2("search.error.display-filter-description") })
    ] })
  ] }) });
}
function CustomMenuItem$1({
  onClick,
  operator,
  selected
}) {
  const handleClick = React.useCallback(() => onClick(operator.type), [onClick, operator.type]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      onClick: handleClick,
      pressed: selected,
      tone: "default",
      text: t2(operator.nameKey),
      iconRight: operator == null ? void 0 : operator.icon
    }
  );
}
function OperatorsMenuButton({ filter, operator }) {
  var _a2;
  const menuButtonId = React.useId(), { t: t2 } = useTranslation(), { dispatch, state } = useSearchState(), operatorItems = (_a2 = getFilterDefinition(state.definitions.filters, filter.filterName)) == null ? void 0 : _a2.operators, handleClick = React.useCallback(
    (operatorType) => {
      dispatch({
        filterKey: getFilterKey(filter),
        operatorType,
        type: "TERMS_FILTERS_SET_OPERATOR"
      });
    },
    [dispatch, filter]
  );
  return !operator || !operatorItems || operatorItems.length <= 1 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { mode: "ghost", iconRight: icons.ChevronDownIcon, text: t2(operator.nameKey) }),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: operatorItems.map((item, index) => {
        if (item.type === "item") {
          const menuOperator = getOperatorDefinition(state.definitions.operators, item.name);
          return menuOperator ? /* @__PURE__ */ jsxRuntime.jsx(
            CustomMenuItem$1,
            {
              onClick: handleClick,
              operator: menuOperator,
              selected: operator.type === item.name
            },
            index
          ) : null;
        }
        return item.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}, index) : null;
      }) }),
      placement: "bottom-start",
      popover: {
        constrainSize: !0,
        portal: !1,
        radius: 2
      }
    }
  ) });
}
function FilterForm({ filter }) {
  const [errorParams, setErrorParams] = React.useState(null), {
    dispatch,
    state: { definitions, fullscreen }
  } = useSearchState(), filterDefinition = getFilterDefinition(definitions.filters, filter.filterName), operator = getOperatorDefinition(definitions.operators, filter.operatorType), fieldDefinition = getFieldFromFilter(definitions.fields, filter), filterKey = getFilterKey(filter), handleClose = React.useCallback(() => {
    dispatch({
      filterKey: getFilterKey(filter),
      type: "TERMS_FILTERS_REMOVE"
    });
  }, [dispatch, filter]), handleValueChange = React.useCallback(
    (value) => {
      dispatch({
        filterKey,
        type: "TERMS_FILTERS_SET_VALUE",
        value
      });
    },
    [dispatch, filterKey]
  ), handleCatchError = React.useCallback((params) => {
    setErrorParams(params);
  }, []), Component = operator == null ? void 0 : operator.inputComponent;
  return errorParams ? /* @__PURE__ */ jsxRuntime.jsx(FilterError, { padding: 4 }) : /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: handleCatchError, children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !supportsTouch, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column-reverse", children: [
    Component && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        fieldDefinition,
        onChange: handleValueChange,
        value: filter.value
      },
      filter.operatorType
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, justify: "space-between", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 1, paddingRight: 2, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FilterDetails, { filter }) }),
        fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            icon: icons.TrashIcon,
            mode: "bleed",
            onClick: handleClose,
            tone: "critical",
            tooltipProps: { content: "Remove filter" }
          }
        )
      ] }),
      (filterDefinition == null ? void 0 : filterDefinition.description) && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 3, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: filterDefinition.description }) }),
      /* @__PURE__ */ jsxRuntime.jsx(OperatorsMenuButton, { filter, operator })
    ] }) })
  ] }) }) });
}
const ContainerFlex = styled__default.default(ui.Flex)`
  max-width: 480px;
  min-width: 150px;
  overflow: hidden;
  overflow: clip;
  width: 100%;
`;
function FilterPopoverContent({ filter }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ContainerFlex, { direction: "column", children: [
    /* @__PURE__ */ jsxRuntime.jsx(FilterForm, { filter }),
    DEBUG_MODE
  ] });
}
const CloseButton = styled__default.default(ui.Button)`
  border-radius: ${({ theme: theme2 }) => `0 ${ui.rem(theme2.sanity.radius[2])} ${ui.rem(theme2.sanity.radius[2])} 0`};
`, CloseCard = styled__default.default(ui.Card)`
  position: absolute;
  right: 0;
`, ContainerDiv = styled__default.default.div`
  align-items: center;
  display: inline-flex;
  max-width: 100%;
  position: relative;
`, LabelButton = styled__default.default(ui.Button)`
  border: none;
  width: 100%;
`;
function FilterButton({ filter, initialOpen }) {
  const [open, setOpen] = React.useState(initialOpen), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), {
    dispatch,
    state: { definitions, fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []), handleRemove = React.useCallback(
    () => dispatch({
      filterKey: getFilterKey(filter),
      type: "TERMS_FILTERS_REMOVE"
    }),
    [dispatch, filter]
  ), handleKeyDown = React.useCallback(
    (event) => {
      ["Backspace", "Delete"].includes(event.key) && handleRemove();
    },
    [handleRemove]
  );
  ui.useClickOutside(handleClose, [buttonElement, popoverElement]);
  const isValid = validateFilter({
    fieldDefinitions: definitions.fields,
    filter,
    filterDefinitions: definitions.filters,
    operatorDefinitions: definitions.operators
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverContent, { filter }) }),
      constrainSize: !0,
      open,
      overflow: "auto",
      placement: "bottom-start",
      portal: !0,
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ContainerDiv, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            __unstable_focusRing: !0,
            display: "flex",
            radius: 2,
            tone: isValid ? "primary" : "transparent",
            children: /* @__PURE__ */ jsxRuntime.jsx(
              LabelButton,
              {
                mode: "bleed",
                onClick: handleOpen,
                onKeyDown: handleKeyDown,
                paddingLeft: fullscreen ? 3 : 2,
                paddingRight: fullscreen ? 3 : 5,
                paddingY: fullscreen ? 3 : 2,
                ref: setButtonElement,
                children: /* @__PURE__ */ jsxRuntime.jsx(FilterLabel, { filter, showContent: isValid })
              }
            )
          }
        ),
        !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
          CloseCard,
          {
            __unstable_focusRing: !0,
            display: "flex",
            radius: 2,
            tone: isValid ? "primary" : "transparent",
            children: /* @__PURE__ */ jsxRuntime.jsx(
              CloseButton,
              {
                "aria-label": t2("search.action.remove-filter-aria-label"),
                fontSize: 1,
                icon: icons.CloseIcon,
                mode: "bleed",
                onClick: handleRemove,
                onKeyDown: handleKeyDown,
                padding: 2,
                radius: 2
              }
            )
          }
        )
      ] })
    }
  );
}
function Filters() {
  const {
    dispatch,
    state: {
      filters,
      fullscreen,
      lastAddedFilter,
      terms: { types: types2 }
    }
  } = useSearchState(), { t: t2 } = useTranslation(), isMounted = React.useRef(!1), handleClear = React.useCallback(() => {
    dispatch({ type: "TERMS_FILTERS_CLEAR" }), dispatch({ type: "TERMS_TYPES_CLEAR" });
  }, [dispatch]), clearFiltersButtonVisible = filters.length > 0 || types2.length > 0;
  React.useEffect(() => {
    isMounted.current = !0;
  }, []);
  const lastAddedFilterKey = lastAddedFilter && getFilterKey(lastAddedFilter), ClearFiltersButton = () => /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      mode: "bleed",
      onClick: handleClear,
      size: fullscreen ? "large" : "default",
      text: t2("search.action.clear-filters"),
      tone: "critical"
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, justify: "space-between", padding: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, gap: 2, wrap: "wrap", children: [
        /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesButton, {}),
        filters == null ? void 0 : filters.map((filter) => {
          const key = getFilterKey(filter);
          return /* @__PURE__ */ jsxRuntime.jsx(
            FilterButton,
            {
              filter,
              initialOpen: isMounted.current && lastAddedFilterKey === key
            },
            key
          );
        }),
        !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(AddFilterButton, {})
      ] }),
      clearFiltersButtonVisible && !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(ClearFiltersButton, {})
    ] }),
    fullscreen && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-between", paddingBottom: 2, paddingX: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(AddFilterButton, {}),
      clearFiltersButtonVisible && /* @__PURE__ */ jsxRuntime.jsx(ClearFiltersButton, {})
    ] }),
    DEBUG_MODE
  ] });
}
const MAX_OBJECT_TRAVERSAL_DEPTH = 3;
function createFieldDefinitions(schema2, filterDefinitions2) {
  var _a2;
  const searchableDocumentTypeNames = getSearchableOmnisearchTypes(schema2).map((s) => s.name), { documentTypes, objectTypes } = (((_a2 = schema2._original) == null ? void 0 : _a2.types) || []).filter(
    (t2) => isDocumentObjectDefinition(t2) ? searchableDocumentTypeNames.includes(t2.name) : !0
  ).filter((schemaType) => schemaType.name !== "slug").filter((schemaType) => !schemaType.name.startsWith("sanity.")).reduce(
    (acc, schemaType) => (isDocumentObjectDefinition(schemaType) && (acc.documentTypes[schemaType.name] = schemaType), isObjectDefinition(schemaType) && (acc.objectTypes[schemaType.name] = schemaType), acc),
    { documentTypes: {}, objectTypes: {} }
  ) || { documentTypes: {}, objectTypes: {} }, supportedFieldTypes = getSupportedFieldTypes(filterDefinitions2);
  return getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes);
}
function createFieldDefinitionDictionary(fieldDefinitions) {
  return fieldDefinitions.reduce((acc, val) => (acc[val.id] = val, acc), {});
}
function generateFieldId(field) {
  return [field.type, field.fieldPath, field.filterName, field.documentTypes.join(",")].join("-");
}
function getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes) {
  function addFieldDefinitionRecursive({
    acc,
    defType,
    depth = 0,
    documentType,
    prevFieldPath,
    prevTitlePath
  }) {
    var _a2;
    const continueRecursion = depth <= MAX_OBJECT_TRAVERSAL_DEPTH, isInternalField = defType.name.startsWith("_"), title = defType != null && defType.title ? sanitizeFieldValue(defType.title) : startCase__default$1.default(defType.name), fieldPath = prevFieldPath ? `${prevFieldPath}.${defType.name}` : defType.name, titlePath = prevTitlePath ? [...prevTitlePath, title] : [title];
    if (!continueRecursion)
      return;
    const existingObject = objectTypes[defType.type], existingDocument = documentTypes[defType.type], inlineObject = isObjectDefinition(defType) ? defType : null, targetObject = existingDocument || existingObject || inlineObject;
    if (targetObject) {
      (_a2 = targetObject == null ? void 0 : targetObject.fields) == null || _a2.forEach(
        (field) => addFieldDefinitionRecursive({
          acc,
          defType: field,
          depth: depth + 1,
          documentType,
          prevFieldPath: fieldPath,
          prevTitlePath: titlePath
        })
      );
      return;
    }
    supportedFieldTypes.includes(defType.type) && acc.push({
      documentTypes: documentType && !isInternalField ? [documentType] : [],
      fieldPath,
      filterName: resolveFilterName(defType),
      id: "",
      name: defType.name,
      titlePath,
      title,
      type: defType.type
    });
  }
  return Object.values(documentTypes).reduce((acc, documentType) => {
    const documentFields = documentType.fields.reduce((a, field) => (addFieldDefinitionRecursive({ acc: a, defType: field, documentType: documentType.name }), a), []);
    return acc.push(...documentFields), acc;
  }, []).reduce((acc, val) => {
    const prevIndex = acc.findIndex(
      (v) => v.fieldPath === val.fieldPath && v.title === val.title && v.type === val.type
    );
    return prevIndex > -1 ? acc[prevIndex] = {
      ...acc[prevIndex],
      documentTypes: [...acc[prevIndex].documentTypes, ...val.documentTypes]
    } : acc.push(val), acc;
  }, []).map(addFieldDefinitionId).sort(sortFieldDefinitions);
}
function addFieldDefinitionId(field) {
  return {
    ...field,
    id: generateFieldId(field)
  };
}
function isArrayOfPrimitives(schemaType) {
  var _a2;
  return isArrayDefinition(schemaType) ? schemaType.of.every((item) => ["boolean", "number", "string"].includes(item.type)) && ((_a2 = schemaType.options) != null && _a2.list ? schemaType.options.list.length > 0 : !1) : !1;
}
function isArrayDefinition(schemaType) {
  return schemaType.type === "array";
}
function isDocumentObjectDefinition(schemaType) {
  return schemaType.type === "document";
}
function isObjectDefinition(schemaType) {
  return schemaType.type === "object";
}
function isStringDefinition(schemaType) {
  return schemaType.type === "string";
}
function isStringListDefinition(schemaType) {
  var _a2;
  return isStringDefinition(schemaType) && (_a2 = schemaType.options) != null && _a2.list ? schemaType.options.list.length > 0 : !1;
}
function resolveFilterName(schemaType) {
  if (isStringListDefinition(schemaType))
    return "stringList";
  if (isArrayDefinition(schemaType)) {
    if (schemaType.of.some((item) => item.type === "reference"))
      return "arrayReferences";
    if (schemaType.of.find((item) => item.type === "block"))
      return "portableText";
    if (isArrayOfPrimitives(schemaType))
      return "arrayList";
  }
  return schemaType.type;
}
function sortFieldDefinitions(a, b) {
  const aTitlePath = a.titlePath.slice(0, -1).join("/"), bTitlePath = b.titlePath.slice(0, -1).join("/");
  return a.title.localeCompare(b.title) || aTitlePath.localeCompare(bTitlePath) || a.fieldPath.localeCompare(b.fieldPath);
}
const RECENT_SEARCH_VERSION$1 = 2, STORED_SEARCHES_NAMESPACE = "studio.search.recent", defaultValue = {
  version: RECENT_SEARCH_VERSION$1,
  recentSearches: []
};
function useStoredSearch() {
  const keyValueStore = useKeyValueStore(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { dataset } = client2.config(), keyValueStoreKey = React.useMemo(() => `${STORED_SEARCHES_NAMESPACE}.${dataset}`, [dataset]), [value, setValue] = React.useState(defaultValue), settings = React.useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  React.useEffect(() => {
    const sub = settings.pipe(
      operators.startWith(defaultValue),
      operators.map((data) => (data == null ? void 0 : data.version) !== RECENT_SEARCH_VERSION$1 ? (keyValueStore.setKey(keyValueStoreKey, defaultValue), defaultValue) : data)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [settings, keyValueStore, keyValueStoreKey]);
  const set2 = React.useCallback(
    (newValue) => {
      setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue);
    },
    [keyValueStore, keyValueStoreKey]
  );
  return React.useMemo(() => [value, set2], [set2, value]);
}
const MAX_RECENT_SEARCHES = 5, RECENT_SEARCH_VERSION = 2;
function useRecentSearchesStore() {
  const [storedSearch, setStoredSearch] = useStoredSearch(), schema2 = useSchema(), {
    search: { operators: operators2, filters }
  } = useSource(), { fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 } = React.useMemo(() => ({
    fieldDefinitions: createFieldDefinitionDictionary(createFieldDefinitions(schema2, filters)),
    filterDefinitions: createFilterDefinitionDictionary(filters),
    operatorDefinitions: createOperatorDefinitionDictionary(operators2)
  }), [filters, operators2, schema2]);
  return {
    /**
     * Write a search term to Local Storage and return updated recent searches.
     */
    addSearch: (searchTerm, searchFilters) => {
      const validStoredFilters = (searchFilters || []).map(
        (filter) => ({
          fieldId: filter.fieldId,
          filterName: filter.filterName,
          operatorType: filter.operatorType,
          value: filter.value
        })
      ).filter(
        (filter) => validateFilter({
          fieldDefinitions,
          filter,
          filterDefinitions: filterDefinitions2,
          operatorDefinitions: operatorDefinitions2
        })
      ), newSearchItem = {
        created: (/* @__PURE__ */ new Date()).toISOString(),
        filters: validStoredFilters,
        terms: {
          query: searchTerm.query.trim(),
          typeNames: searchTerm.types.map((s) => s.name)
        }
      }, newRecent = {
        version: RECENT_SEARCH_VERSION,
        recentSearches: [
          newSearchItem,
          ...storedSearch.recentSearches.filter((r) => !isEqual__default.default(omit__default.default(r, "created"), omit__default.default(newSearchItem, "created")))
        ].slice(0, MAX_RECENT_SEARCHES)
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    },
    /**
     * Fetch all recent searches from Local Storage.
     * Invalid search terms will be filtered out and terms will be re-written to Local Storage.
     */
    getRecentSearches: () => getRecentSearchTerms({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      operatorDefinitions: operatorDefinitions2,
      schema: schema2,
      storedSearch,
      setStoredSearch
    }),
    /**
     * Remove all search terms from Local Storage and return updated recent searches.
     */
    removeSearch: () => {
      const newRecent = {
        ...storedSearch,
        recentSearches: []
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    },
    /**
     * Remove a search term from Local Storage and return updated recent searches.
     */
    removeSearchAtIndex: (index) => {
      if (index < 0 || index > storedSearch.recentSearches.length)
        return getRecentSearchTerms({
          fieldDefinitions,
          filterDefinitions: filterDefinitions2,
          operatorDefinitions: operatorDefinitions2,
          schema: schema2,
          storedSearch,
          setStoredSearch
        });
      const newRecent = {
        ...storedSearch,
        recentSearches: [
          ...storedSearch.recentSearches.slice(0, index),
          ...storedSearch.recentSearches.slice(index + 1)
        ]
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    }
  };
}
function getRecentSearchTerms({
  schema: schema2,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  operatorDefinitions: operatorDefinitions2,
  storedSearch,
  setStoredSearch
}) {
  return sanitizeStoredSearch({
    studioSchema: schema2,
    filterDefinitions: filterDefinitions2,
    fieldDefinitions,
    operatorDefinitions: operatorDefinitions2,
    storedSearch,
    setStoredSearch
  }).recentSearches.filter((r) => !!r.terms).map((r, index) => ({
    __recent: {
      index,
      timestamp: new Date(r.created).getTime()
    },
    filters: r.filters,
    query: r.terms.query,
    types: r.terms.typeNames.map((typeName) => schema2.get(typeName)).filter((s) => !!(s && s.jsonType === "object"))
  }));
}
function sanitizeStoredSearch({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  operatorDefinitions: operatorDefinitions2,
  studioSchema,
  storedSearch,
  setStoredSearch
}) {
  const searchableTypeNames = getSearchableOmnisearchTypes(studioSchema).map(
    (schema2) => schema2.name
  ), filteredSearch = storedSearch.recentSearches.filter((recentSearch) => (
    // Has valid searchable types (not hidden by omnisearch)
    recentSearch.terms.typeNames.every((typeName) => searchableTypeNames.includes(typeName)) && recentSearch.filters.every(
      (filter) => validateFilter({ fieldDefinitions, filter, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 })
    )
  )), newStoredSearch = {
    version: RECENT_SEARCH_VERSION,
    recentSearches: filteredSearch
  };
  return newStoredSearch.recentSearches.length < storedSearch.recentSearches.length && setStoredSearch(newStoredSearch), newStoredSearch;
}
function Instructions() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", gap: 4, paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "search.instructions",
      components: {
        ControlsIcon: () => /* @__PURE__ */ jsxRuntime.jsx(icons.ControlsIcon, { style: { padding: "0 0.25rem" } }, 0)
      }
    }
  ) }) }) });
}
function DocumentTypesPill({ availableCharacters, types: types2 }) {
  const { t: t2 } = useTranslation(), title = React.useMemo(
    () => documentTypesTruncated({ availableCharacters, types: types2, t: t2 }),
    [availableCharacters, types2, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 2, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: title }) });
}
const FilterPillCard = styled__default.default(ui.Card)`
  cursor: default;
`;
function FilterPill({ filter }) {
  return /* @__PURE__ */ jsxRuntime.jsx(FilterPillCard, { border: !0, padding: 2, radius: 2, tone: "primary", children: /* @__PURE__ */ jsxRuntime.jsx(FilterLabel, { filter }) });
}
const DEFAULT_COMBINED_TYPE_COUNT = 40, RecentSearchItemButton = styled__default.default(ui.Button)`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  cursor: default;
  width: 100%;
`, SearchItemPillsBox = styled__default.default(ui.Box)`
  flex-shrink: 3;
`, SearchItemQueryFlex = styled__default.default(ui.Flex)`
  flex-shrink: 2;
`, CloseButtonDiv = styled__default.default.div`
  opacity: 0.8;
  visibility: hidden;

  @media (hover: hover) {
    ${RecentSearchItemButton}:hover & {
      visibility: visible;
    }
    &:hover {
      opacity: 0.4;
    }
  }
`;
function RecentSearchItem({
  index,
  maxVisibleTypePillChars = DEFAULT_COMBINED_TYPE_COUNT,
  value,
  ...rest
}) {
  var _a2;
  const { dispatch } = useSearchState(), recentSearchesStore = useRecentSearchesStore(), availableCharacters = maxVisibleTypePillChars - value.query.length, handleClick = React.useCallback(() => {
    dispatch({ type: "TERMS_SET", filters: value == null ? void 0 : value.filters, terms: value }), recentSearchesStore && (recentSearchesStore == null || recentSearchesStore.addSearch(value, value == null ? void 0 : value.filters));
  }, [dispatch, recentSearchesStore, value]), handleDelete = React.useCallback(
    (event) => {
      event.stopPropagation(), recentSearchesStore && (recentSearchesStore == null || recentSearchesStore.removeSearchAtIndex(index));
    },
    [index, recentSearchesStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    RecentSearchItemButton,
    {
      mode: "bleed",
      onClick: handleClick,
      paddingLeft: 3,
      paddingRight: 1,
      paddingY: 1,
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "stretch", children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { paddingY: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ClockIcon, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "\u200B" })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "stretch", flex: 1, gap: 2, justify: "flex-start", marginLeft: 3, wrap: "wrap", children: [
          value.query && /* @__PURE__ */ jsxRuntime.jsx(SearchItemQueryFlex, { align: "center", paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: value.query }) }),
          value.types.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(SearchItemPillsBox, { children: /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesPill, { availableCharacters, types: value.types }) }),
          (_a2 = value == null ? void 0 : value.filters) == null ? void 0 : _a2.map((filter, i) => /* @__PURE__ */ jsxRuntime.jsx(FilterPill, { filter }, i))
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(CloseButtonDiv, { onClick: handleDelete, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.CloseIcon, {}) }) }) }) })
      ] })
    }
  ) });
}
const VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT = 36, MAX_COMBINED_TYPE_COUNT_SMALL = 20, MAX_COMBINED_TYPE_COUNT_LARGE = 40, RecentSearchesBox = styled__default.default(ui.Card)`
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
`;
function RecentSearches({ inputElement }) {
  const {
    dispatch,
    state: { filtersVisible, fullscreen }
  } = useSearchState(), recentSearchesStore = useRecentSearchesStore(), recentSearches = React.useMemo(
    () => recentSearchesStore == null ? void 0 : recentSearchesStore.getRecentSearches(),
    [recentSearchesStore]
  ), commandListRef = React.useRef(null), { t: t2 } = useTranslation(), handleClearRecentSearchesClick = React.useCallback(() => {
    var _a2;
    recentSearchesStore && recentSearchesStore.removeSearch(), (_a2 = commandListRef == null ? void 0 : commandListRef.current) == null || _a2.focusInputElement();
  }, [recentSearchesStore]), mediaIndex = ui.useMediaIndex(), maxVisibleTypePillChars = React.useMemo(() => mediaIndex < 2 ? MAX_COMBINED_TYPE_COUNT_SMALL : MAX_COMBINED_TYPE_COUNT_LARGE, [mediaIndex]), renderItem = React.useCallback(
    (item, { virtualIndex }) => /* @__PURE__ */ jsxRuntime.jsx(
      RecentSearchItem,
      {
        index: virtualIndex,
        maxVisibleTypePillChars,
        paddingBottom: 1,
        value: item
      }
    ),
    [maxVisibleTypePillChars]
  ), hasRecentSearches = !!recentSearches.length;
  return /* @__PURE__ */ jsxRuntime.jsx(
    RecentSearchesBox,
    {
      borderTop: hasRecentSearches || !hasRecentSearches && !filtersVisible && fullscreen,
      flex: 1,
      children: recentSearches.length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 2, paddingTop: 4, paddingX: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.recent-searches-label") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
          CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t2("search.recent-searches-aria-label"),
            inputElement,
            initialIndex: 0,
            itemHeight: VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT,
            items: recentSearches,
            paddingX: 2,
            paddingY: 1,
            renderItem
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 2, paddingTop: 1, paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "bleed",
            onClick: handleClearRecentSearchesClick,
            tone: "default",
            text: t2("search.action.clear-recent-searches"),
            muted: !0
          }
        ) })
      ] }) : !filtersVisible && fullscreen && /* @__PURE__ */ jsxRuntime.jsx(Instructions, {})
    }
  );
}
const rotate = styled.keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled__default.default(icons.SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`, FilterDiv = styled__default.default.div`
  line-height: 0;
  position: relative;
`, SearchHeader = React.forwardRef(function({ ariaInputLabel, onClose }, ref) {
  const isMountedRef = React.useRef(!1), {
    dispatch,
    state: {
      filters,
      filtersVisible,
      fullscreen,
      result: { loading },
      terms: { types: types2, query }
    }
  } = useSearchState(), { t: t2 } = useTranslation(), handleFiltersToggle = React.useCallback(
    () => dispatch({ type: "FILTERS_VISIBLE_SET", visible: !filtersVisible }),
    [dispatch, filtersVisible]
  ), handleQueryChange = React.useCallback(
    (e) => dispatch({ type: "TERMS_QUERY_SET", query: e.currentTarget.value }),
    [dispatch]
  ), handleQueryClear = React.useCallback(() => {
    dispatch({ type: "TERMS_QUERY_SET", query: "" });
  }, [dispatch]);
  React.useEffect(() => {
    fullscreen || dispatch({ type: "FILTERS_VISIBLE_SET", visible: !0 });
  }, [dispatch, fullscreen]), React.useEffect(() => {
    isMountedRef.current = !0;
  }, []);
  const notificationBadgeVisible = filters.length > 0 || types2.length > 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: fullscreen ? 2 : 1, padding: fullscreen ? 2 : 1, children: [
    fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t2("search.action.close-search-aria-label"),
        icon: icons.ArrowLeftIcon,
        mode: "bleed",
        onClick: onClose,
        size: "large",
        tooltipProps: { content: t2("search.action.close-search-aria-label") }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      CustomTextInput,
      {
        __unstable_disableFocusRing: !0,
        $background: fullscreen,
        $smallClearButton: fullscreen,
        "aria-label": ariaInputLabel,
        autoComplete: "off",
        border: !1,
        clearButton: !!query,
        fontSize: [2, 2, 1],
        icon: loading ? AnimatedSpinnerIcon : icons.SearchIcon,
        onChange: handleQueryChange,
        onClear: handleQueryClear,
        placeholder: t2("search.placeholder"),
        radius: 2,
        ref,
        spellCheck: !1,
        value: query
      }
    ) }),
    fullscreen && /* @__PURE__ */ jsxRuntime.jsx(FilterDiv, { children: /* @__PURE__ */ jsxRuntime.jsx(
      StatusButton,
      {
        "aria-expanded": filtersVisible,
        "aria-label": t2("search.action.toggle-filters-aria-label", {
          context: filtersVisible ? "hide" : "show"
        }),
        icon: icons.ControlsIcon,
        mode: "bleed",
        onClick: handleFiltersToggle,
        selected: filtersVisible,
        size: "large",
        tone: notificationBadgeVisible ? "primary" : void 0,
        tooltipProps: {
          content: t2("search.action.toggle-filters-label", {
            context: filtersVisible ? "hide" : "show"
          })
        }
      }
    ) })
  ] }) });
});
function NoResults() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "aria-live": "assertive", space: 4, paddingX: 4, paddingY: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, weight: "medium", children: t2("search.no-results-title") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t2("search.no-results-help-description") })
  ] }) });
}
const TextWithToneStyle = styled__default.default(ui.Text)`
  &:not([data-muted]) {
    &[data-tone='default'] {
      --card-fg-color: var(--card-badge-default-fg-color);
    }
    &[data-tone='primary'] {
      --card-fg-color: var(--card-badge-primary-fg-color);
    }
    &[data-tone='positive'] {
      --card-fg-color: var(--card-badge-positive-fg-color);
    }
    &[data-tone='caution'] {
      --card-fg-color: var(--card-badge-caution-fg-color);
    }
    &[data-tone='critical'] {
      --card-fg-color: var(--card-badge-critical-fg-color);
    }
  }

  &[data-dimmed] {
    opacity: 0.3;
  }
`, TextWithTone = React.forwardRef(function(props2, ref) {
  const { tone, dimmed, muted, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TextWithToneStyle,
    {
      "data-ui": "TextWithTone",
      "data-dimmed": dimmed ? "" : void 0,
      "data-muted": muted ? "" : void 0,
      "data-tone": tone,
      muted,
      ref,
      ...rest
    }
  );
});
function SearchError() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: "center",
      "aria-live": "assertive",
      direction: "column",
      flex: 1,
      gap: 3,
      marginY: 2,
      padding: 4,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
        /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 2, tone: "critical", weight: "medium", children: t2("search.error.unspecified-error-title") }),
        /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", children: t2("search.error.unspecified-error-help-description") })
      ]
    }
  );
}
const ORDERINGS = {
  createdAsc: {
    ignoreScore: !0,
    sort: { direction: "asc", field: "_createdAt" },
    titleKey: "search.ordering.created-ascending-label"
  },
  createdDesc: {
    ignoreScore: !0,
    sort: { direction: "desc", field: "_createdAt" },
    titleKey: "search.ordering.created-descending-label"
  },
  relevance: {
    customMeasurementLabel: "relevance",
    sort: { direction: "desc", field: "_updatedAt" },
    titleKey: "search.ordering.best-match-label"
  },
  updatedAsc: {
    ignoreScore: !0,
    sort: { direction: "asc", field: "_updatedAt" },
    titleKey: "search.ordering.updated-ascending-label"
  },
  updatedDesc: {
    ignoreScore: !0,
    sort: { direction: "desc", field: "_updatedAt" },
    titleKey: "search.ordering.updated-descending-label"
  }
}, MENU_ORDERINGS = [
  ORDERINGS.relevance,
  { type: "divider" },
  ORDERINGS.createdAsc,
  ORDERINGS.createdDesc,
  { type: "divider" },
  ORDERINGS.updatedAsc,
  ORDERINGS.updatedDesc
], SortMenuContentFlex = styled__default.default(ui.Flex)`
  box-sizing: border-box;
`;
function isSearchDivider(item) {
  return item.type === "divider";
}
function CustomMenuItem({ ordering }) {
  const { t: t2 } = useTranslation(), {
    dispatch,
    state: { ordering: currentOrdering }
  } = useSearchState(), handleClick = React.useCallback(() => {
    dispatch({ ordering, type: "ORDERING_SET" });
  }, [dispatch, ordering]), isSelected = React.useMemo(() => isEqual__default$1.default(currentOrdering, ordering), [currentOrdering, ordering]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      onClick: handleClick,
      pressed: isSelected,
      tone: "default",
      text: t2(ordering.titleKey)
    }
  );
}
function SortMenu() {
  const { t: t2 } = useTranslation(), {
    state: { ordering }
  } = useSearchState(), menuButtonId = React.useId(), currentMenuItem = MENU_ORDERINGS.find(
    (item) => isEqual__default$1.default(ordering, item) && !isSearchDivider(item)
  );
  return currentMenuItem ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsx(SortMenuContentFlex, { align: "center", flex: 1, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { mode: "bleed", icon: icons.SortIcon, text: t2(currentMenuItem.titleKey) }),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: MENU_ORDERINGS.map((item, index) => isSearchDivider(item) ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}, index) : /* @__PURE__ */ jsxRuntime.jsx(
        CustomMenuItem,
        {
          ordering: item
        },
        index
      )) }),
      placement: "bottom-start",
      popover: { portal: !0, radius: 2 }
    }
  ) }) }) : null;
}
const DebugScoreCard = styled__default.default(ui.Card)`
  cursor: help;
  left: 0;
  position: absolute;
  top: 0;
`;
function DebugOverlay({ data }) {
  const { score } = data;
  let tone = "default";
  score <= 0.1 ? tone = "critical" : score >= 0.5 && (tone = "primary");
  const matchingStories = data.stories.filter((story) => story.score > 0);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: matchingStories.length ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: matchingStories.map((story) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, weight: "medium", children: story.path }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, children: story.why })
      ] }, story.path)) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, children: "No matches" }) }),
      placement: "bottom-start",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(DebugScoreCard, { padding: 1, shadow: 1, tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Code, { size: 0, children: [
        "score: ",
        score
      ] }) })
    }
  ) });
}
const VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT = 57, VIRTUAL_LIST_OVERSCAN = 4, SearchResultsInnerFlex = styled__default.default(ui.Flex)`
  opacity: ${({ $loading }) => $loading ? 0.5 : 1};
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
  transition: 300ms opacity;
  width: 100%;
`;
function SearchResults({ disableIntentLink, inputElement, onItemSelect }) {
  const {
    dispatch,
    onClose,
    setSearchCommandList,
    state: { debug: debug2, filters, fullscreen, lastActiveIndex, result, terms }
  } = useSearchState(), { t: t2 } = useTranslation(), recentSearchesStore = useRecentSearchesStore(), hasSearchResults = !!result.hits.length, hasNoSearchResults = !result.hits.length && result.loaded, hasError = result.error, handleSearchResultClick = React.useCallback(() => {
    recentSearchesStore && recentSearchesStore.addSearch(terms, filters), onClose == null || onClose();
  }, [filters, onClose, recentSearchesStore, terms]), handleEndReached = React.useCallback(() => {
    dispatch({ type: "PAGE_INCREMENT" });
  }, [dispatch]), renderItem = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        SearchResultItem,
        {
          disableIntentLink,
          documentId: getPublishedId(item.hit._id) || "",
          documentType: item.hit._type,
          onClick: handleSearchResultClick,
          onItemSelect,
          paddingY: 1
        }
      ),
      debug2 && /* @__PURE__ */ jsxRuntime.jsx(DebugOverlay, { data: item })
    ] }),
    [debug2, disableIntentLink, handleSearchResultClick, onItemSelect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      borderTop: fullscreen || !!(hasError || hasSearchResults || hasNoSearchResults),
      flex: 1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
        hasSearchResults && /* @__PURE__ */ jsxRuntime.jsx(SortMenu, {}),
        /* @__PURE__ */ jsxRuntime.jsx(SearchResultsInnerFlex, { $loading: result.loading, "aria-busy": result.loading, flex: 1, children: hasError ? /* @__PURE__ */ jsxRuntime.jsx(SearchError, {}) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          hasSearchResults && /* @__PURE__ */ jsxRuntime.jsx(
            CommandList,
            {
              activeItemDataAttr: "data-hovered",
              ariaLabel: t2("search.search-results-label"),
              "data-testid": "search-results",
              fixedHeight: !0,
              initialIndex: lastActiveIndex,
              inputElement,
              itemHeight: VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT,
              items: result.hits,
              overscan: VIRTUAL_LIST_OVERSCAN,
              onEndReached: handleEndReached,
              paddingX: 2,
              paddingY: 1,
              ref: setSearchCommandList,
              renderItem
            }
          ),
          hasNoSearchResults && /* @__PURE__ */ jsxRuntime.jsx(NoResults, {})
        ] }) })
      ] })
    }
  ) });
}
const ANIMATION_TRANSITION$1 = {
  duration: 0.4,
  type: "spring"
}, CARD_VARIANTS = {
  open: { opacity: 1, scale: 1, x: "-50%" },
  closed: { opacity: 0, scale: 0.99, x: "-50%" }
}, OVERLAY_VARIANTS = {
  open: { opacity: 1 },
  closed: { opacity: 0 }
}, Y_POSITION = 12, MotionOverlay = styled__default.default(framerMotion.motion(ui.Card))`
  background-color: var(--card-backdrop-color);
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
`, SearchMotionCard = styled__default.default(framerMotion.motion(ui.Card))`
  display: flex !important;
  flex-direction: column;
  left: 50%;
  max-height: min(
    calc(100vh - ${Y_POSITION}vh - ${POPOVER_INPUT_PADDING}px),
    ${POPOVER_MAX_HEIGHT}px
  );
  position: absolute;
  top: ${Y_POSITION}vh;
  width: min(calc(100vw - ${POPOVER_INPUT_PADDING * 2}px), ${POPOVER_MAX_WIDTH}px);
`;
function SearchPopover({
  disableFocusLock,
  disableIntentLink,
  onClose,
  onItemSelect,
  onOpen,
  open
}) {
  const [inputElement, setInputElement] = React.useState(null), popoverElement = React.useRef(null), { isTopLayer, zIndex } = ui.useLayer(), { t: t2 } = useTranslation(), {
    onClose: onSearchClose,
    state: { filtersVisible, terms }
  } = useSearchState(), hasValidTerms = hasSearchableTerms({ terms }), handleClickOutside = React.useCallback(() => {
    isTopLayer && onSearchClose && open && onSearchClose();
  }, [isTopLayer, onSearchClose, open]);
  return ui.useClickOutside(handleClickOutside, [popoverElement.current]), /* @__PURE__ */ jsxRuntime.jsx(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: open && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsxs(FocusLock__default.default, { autoFocus: !supportsTouch, disabled: disableFocusLock, returnFocus: !0, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      MotionOverlay,
      {
        animate: "open",
        exit: "closed",
        initial: "closed",
        style: { zIndex },
        transition: ANIMATION_TRANSITION$1,
        variants: OVERLAY_VARIANTS
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      SearchMotionCard,
      {
        animate: "open",
        exit: "closed",
        initial: "closed",
        overflow: "hidden",
        radius: POPOVER_RADIUS,
        ref: popoverElement,
        shadow: 2,
        style: { zIndex },
        transition: ANIMATION_TRANSITION$1,
        variants: CARD_VARIANTS,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            SearchHeader,
            {
              ariaInputLabel: t2(hasValidTerms ? "search.search-results-aria-label" : "search.recent-searches-aria-label"),
              onClose,
              ref: setInputElement
            }
          ),
          filtersVisible && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(Filters, {}) }),
          hasValidTerms ? /* @__PURE__ */ jsxRuntime.jsx(
            SearchResults,
            {
              inputElement,
              onItemSelect,
              disableIntentLink
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(RecentSearches, { inputElement })
        ]
      }
    )
  ] }) }) }) });
}
function isRecentSearchTerms(terms) {
  return typeof terms.__recent < "u";
}
const rootName = "core:studio:navbar:search:";
debug__default.default(rootName);
function debugWithName(name) {
  const namespace = `${rootName}${name}`;
  return debug__default.default && debug__default.default.enabled(namespace) ? debug__default.default(namespace) : debug__default.default(rootName);
}
function isDebugMode() {
  return typeof window > "u" ? !1 : window.location.hash.slice(1).split(";").includes(DEBUG_FRAGMENT);
}
function initialSearchState({
  currentUser,
  fullscreen,
  definitions,
  pagination
}) {
  return {
    currentUser,
    debug: isDebugMode(),
    documentTypesNarrowed: [],
    filters: [],
    filtersVisible: !0,
    fullscreen,
    lastActiveIndex: -1,
    ordering: ORDERINGS.relevance,
    ...pagination,
    result: {
      error: null,
      hasLocal: !1,
      hits: [],
      loaded: !1,
      loading: !1
    },
    terms: {
      query: "",
      types: []
    },
    definitions
  };
}
const debug = debugWithName("reducer");
function searchReducer(state, action) {
  var _a2, _b;
  let prefix = "\u{1F50D}";
  switch (action.type.startsWith("SEARCH_REQUEST") && (prefix = "\u{1F6A8}"), action.type.startsWith("RECENT_SEARCHES") && (prefix = "\u{1F4BE}"), debug(prefix, action), action.type) {
    case "FILTERS_VISIBLE_SET":
      return {
        ...state,
        filtersVisible: action.visible
      };
    case "LAST_ACTIVE_INDEX_SET":
      return {
        ...state,
        lastActiveIndex: action.index
      };
    case "ORDERING_RESET":
      return {
        ...state,
        ordering: ORDERINGS.relevance,
        terms: stripRecent(state.terms)
      };
    case "ORDERING_SET":
      return {
        ...state,
        ordering: action.ordering,
        terms: stripRecent(state.terms),
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    case "PAGE_INCREMENT":
      return {
        ...state,
        cursor: (_a2 = state.nextCursor) != null ? _a2 : state.cursor,
        nextCursor: null,
        terms: stripRecent(state.terms)
      };
    case "SEARCH_CLEAR":
      return {
        ...state,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          hasLocal: !1,
          hits: []
        }
      };
    case "SEARCH_REQUEST_COMPLETE":
      return {
        ...state,
        nextCursor: (_b = action.nextCursor) != null ? _b : null,
        result: {
          ...state.result,
          error: null,
          hasLocal: !0,
          hits: state.result.hasLocal ? deduplicate([...state.result.hits, ...action.hits]) : action.hits,
          loaded: !0,
          loading: !1
        }
      };
    case "SEARCH_REQUEST_ERROR":
      return {
        ...state,
        result: {
          ...state.result,
          error: action.error,
          loaded: !1,
          loading: !1
        }
      };
    case "SEARCH_REQUEST_START":
      return {
        ...state,
        result: {
          ...state.result,
          loaded: !1,
          loading: !0
        }
      };
    case "TERMS_FILTERS_ADD": {
      const newFilter = {
        ...action.filter,
        value: getOperatorInitialValue(state.definitions.operators, action.filter.operatorType)
      }, filters = [...state.filters, newFilter];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        lastAddedFilter: newFilter,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_FILTERS_CLEAR": {
      const filters = [];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_FILTERS_REMOVE": {
      const index = state.filters.findIndex((filter) => getFilterKey(filter) === action.filterKey), filters = [
        ...state.filters.slice(0, index),
        //
        ...state.filters.slice(index + 1)
      ];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_FILTERS_SET_OPERATOR": {
      const matchedFilter = state.filters.find(
        (filter) => getFilterKey(filter) === action.filterKey
      ), currentOperator = getOperatorDefinition(
        state.definitions.operators,
        matchedFilter == null ? void 0 : matchedFilter.operatorType
      ), nextOperator = getOperatorDefinition(state.definitions.operators, action.operatorType), nextInitialValue = nextOperator == null ? void 0 : nextOperator.initialValue, inputComponentChanged = (currentOperator == null ? void 0 : currentOperator.inputComponent) != (nextOperator == null ? void 0 : nextOperator.inputComponent), filters = state.filters.map((filter) => getFilterKey(filter) === action.filterKey ? {
        ...filter,
        operatorType: action.operatorType,
        ...inputComponentChanged ? { value: nextInitialValue } : {}
      } : filter);
      return {
        ...state,
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_FILTERS_SET_VALUE": {
      const filters = state.filters.map((filter) => getFilterKey(filter) === action.filterKey ? {
        ...filter,
        value: action.value
      } : filter);
      return {
        ...state,
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_QUERY_SET":
      return {
        ...state,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          query: action.query
        })
      };
    case "TERMS_SET": {
      const filters = action.filters || [], types2 = [
        ...state.terms.types || [],
        //
        ...action.terms.types
      ].sort(sortTypes);
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: types2
        }),
        filters,
        lastAddedFilter: null,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: {
          ...action.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_TYPE_ADD": {
      const types2 = [
        ...state.terms.types || [],
        //
        action.schemaType
      ].sort(sortTypes), documentTypesNarrowed = narrowDocumentTypes({
        fieldDefinitions: state.definitions.fields,
        filters: [],
        types: types2
      }), filters = state.filters.filter((f) => {
        const fieldDefinition = getFieldFromFilter(state.definitions.fields, f);
        return fieldDefinition ? fieldDefinition.documentTypes.length === 0 ? !0 : documentTypesNarrowed.every(
          (type) => fieldDefinition.documentTypes.findIndex((t2) => t2 === type) > -1
        ) : !0;
      });
      return {
        ...state,
        documentTypesNarrowed,
        filters,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            operatorDefinitions: state.definitions.operators,
            filters
          }),
          types: types2
        })
      };
    }
    case "TERMS_TYPE_REMOVE": {
      const types2 = (state.terms.types || []).filter((s) => s !== action.schemaType);
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters: state.filters,
          types: types2
        }),
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          types: types2
        })
      };
    }
    case "TERMS_TYPES_CLEAR": {
      const types2 = [];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters: state.filters,
          types: types2
        }),
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          types: []
        })
      };
    }
    default:
      return state;
  }
}
function stripRecent(terms) {
  if (isRecentSearchTerms(terms)) {
    const { __recent, ...rest } = terms;
    return rest;
  }
  return terms;
}
function deduplicate(hits) {
  const hitsById = hits.reduce((map, hit) => {
    const id2 = getPublishedId(hit.hit._id);
    return {
      ...map,
      [id2]: hit
    };
  }, {});
  return Object.values(hitsById);
}
function SearchProvider({ children, fullscreen }) {
  const onCloseRef = React.useRef(null), [searchCommandList, setSearchCommandList] = React.useState(null), schema2 = useSchema(), currentUser = useCurrentUser(), {
    search: { operators: operators2, filters }
  } = useSource(), { fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 } = React.useMemo(() => ({
    fieldDefinitions: createFieldDefinitionDictionary(createFieldDefinitions(schema2, filters)),
    filterDefinitions: createFilterDefinitionDictionary(filters),
    operatorDefinitions: createOperatorDefinitionDictionary(operators2)
  }), [filters, operators2, schema2]), initialState = React.useMemo(
    () => initialSearchState({
      currentUser,
      fullscreen,
      definitions: {
        fields: fieldDefinitions,
        operators: operatorDefinitions2,
        filters: filterDefinitions2
      },
      pagination: {
        cursor: null,
        nextCursor: null
      }
    }),
    [currentUser, fieldDefinitions, filterDefinitions2, fullscreen, operatorDefinitions2]
  ), [state, dispatch] = React.useReducer(searchReducer, initialState), { documentTypesNarrowed, filters: currentFilters, ordering, cursor, result, terms } = state, isMountedRef = React.useRef(!1), previousOrderingRef = React.useRef(initialState.ordering), previousCursorRef = React.useRef(initialState.cursor), previousTermsRef = React.useRef(initialState.terms), { handleSearch, searchState } = useSearch({
    initialState: { ...result, terms },
    onComplete: (searchResult) => dispatch({ ...searchResult, type: "SEARCH_REQUEST_COMPLETE" }),
    onError: (error) => dispatch({ error, type: "SEARCH_REQUEST_ERROR" }),
    onStart: () => dispatch({ type: "SEARCH_REQUEST_START" }),
    schema: schema2
  }), hasValidTerms = hasSearchableTerms({ terms }), documentTypes = documentTypesNarrowed.map((documentType) => schema2.get(documentType)), completeFilters = currentFilters.filter(
    (filter) => validateFilter({
      fieldDefinitions,
      filter,
      filterDefinitions: filterDefinitions2,
      operatorDefinitions: operatorDefinitions2
    })
  ), handleSetOnClose = React.useCallback((onClose) => {
    onCloseRef.current = onClose;
  }, []);
  return React.useEffect(() => {
    const orderingChanged = !isEqual__default$1.default(ordering, previousOrderingRef.current), cursorChanged = cursor !== previousCursorRef.current, termsChanged = !isEqual__default$1.default(terms, previousTermsRef.current);
    if (orderingChanged || cursorChanged || termsChanged) {
      const sortLabel = (ordering == null ? void 0 : ordering.customMeasurementLabel) || `${ordering.sort.field} ${ordering.sort.direction}`;
      handleSearch({
        options: {
          // Comments prepended to each query for future measurement
          comments: [
            ...isRecentSearchTerms(terms) ? [`findability-recent-search:${terms.__recent.index}`] : [],
            `findability-selected-types:${terms.types.length}`,
            `findability-sort:${sortLabel}`,
            "findability-source: global",
            `findability-filter-count:${completeFilters.length}`
          ],
          limit: SEARCH_LIMIT,
          skipSortByScore: ordering.ignoreScore,
          sort: [ordering.sort],
          cursor: cursor || void 0
        },
        terms: {
          ...terms,
          // Narrow document type search
          ...documentTypes ? { types: documentTypes } : {}
        }
      }), previousCursorRef.current = cursor;
    }
    previousOrderingRef.current = ordering, previousTermsRef.current = terms;
  }, [
    completeFilters.length,
    currentFilters,
    documentTypes,
    handleSearch,
    hasValidTerms,
    ordering,
    searchState.terms,
    terms,
    cursor
  ]), React.useEffect(() => {
    !hasValidTerms && isMountedRef != null && isMountedRef.current && result.hits.length > 0 && dispatch({ type: "SEARCH_CLEAR" }), isMountedRef.current = !0;
  }, [dispatch, hasValidTerms, result.hits, terms.query, terms.types]), /* @__PURE__ */ jsxRuntime.jsx(
    SearchContext.Provider,
    {
      value: {
        dispatch,
        onClose: onCloseRef == null ? void 0 : onCloseRef.current,
        searchCommandList,
        setSearchCommandList,
        setOnClose: handleSetOnClose,
        state: {
          ...state,
          fullscreen
        }
      },
      children
    }
  );
}
const SearchButton = React.forwardRef(function({ onClick }, ref) {
  const { t: t2 } = reactI18next.useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      "aria-label": t2("search.action-open-aria-label"),
      "data-testid": "studio-search",
      icon: icons.SearchIcon,
      tooltipProps: {
        content: t2("search.button.tooltip"),
        hotkeys: [GLOBAL_SEARCH_KEY_MODIFIER, GLOBAL_SEARCH_KEY.toUpperCase()],
        portal: !0
      },
      onClick,
      mode: "bleed",
      ref
    }
  );
}), InnerCard = styled__default.default(ui.Card)`
  flex-direction: column;
  overflow: hidden;
  overflow: clip;
  pointer-events: all;
  position: relative;
`, SearchDialogBox = styled__default.default(ui.Box)`
  height: 100%;
  left: 0;
  overflow: hidden;
  overflow: clip;
  pointer-events: none;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1;
`;
function SearchDialog({ onClose, onOpen, open }) {
  const [inputElement, setInputElement] = React.useState(null), { scheme } = useColorScheme(), { t: t2 } = useTranslation(), {
    state: { filtersVisible, terms }
  } = useSearchState(), hasValidTerms = hasSearchableTerms({ terms });
  return /* @__PURE__ */ jsxRuntime.jsx(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: open && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !supportsTouch, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsx(SearchDialogBox, { children: /* @__PURE__ */ jsxRuntime.jsxs(InnerCard, { display: "flex", height: "fill", scheme, tone: "default", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      SearchHeader,
      {
        ariaInputLabel: t2(hasValidTerms ? "search.search-results-aria-label" : "search.recent-searches-aria-label"),
        onClose,
        ref: setInputElement
      }
    ),
    filtersVisible && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(Filters, {}) }),
    hasValidTerms ? /* @__PURE__ */ jsxRuntime.jsx(SearchResults, { inputElement }) : /* @__PURE__ */ jsxRuntime.jsx(RecentSearches, { inputElement })
  ] }) }) }) }) });
}
function StudioActiveToolLayout(props2) {
  const { activeTool } = props2;
  return React.createElement(activeTool.component, { tool: activeTool });
}
function NoToolsScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "medium", children: "No configured tools" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: "Please configure a tool in your Studio configuration." }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        "a",
        {
          href: "https://www.sanity.io/docs/studio-tools",
          rel: "noreferrer",
          target: "_blank",
          children: "Learn how to add a tool \u2192"
        }
      ) })
    ] })
  ] }) }) }) }) });
}
function RedirectingScreen(props2) {
  const { reason = "Redirecting\u2026" } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "primary", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DoubleChevronRightIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "bold", children: reason }) })
  ] }) }) }) }) });
}
function ToolNotFoundScreen(props2) {
  const { toolName } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "h1", size: 1, weight: "medium", children: [
      "Tool not found: ",
      /* @__PURE__ */ jsxRuntime.jsx("code", { children: toolName })
    ] }) })
  ] }) }) }) }) });
}
const WORKSPACES_DOCS_URL = "https://www.sanity.io/docs/workspaces", useWorkspaceAuthStates = createHookFromObservableFactory(
  (workspaces) => rxjs.combineLatest(
    workspaces.map(
      (workspace) => (
        // eslint-disable-next-line max-nested-callbacks
        workspace.auth.state.pipe(operators.map((state) => [workspace.name, state]))
      )
    )
  ).pipe(operators.map((entries) => Object.fromEntries(entries)))
), STATE_TITLES = {
  "logged-in": "",
  "logged-out": "Signed out",
  "no-access": ""
}, Media$1 = styled__default.default.div`
  width: ${(props2) => props2.$size === "small" ? "25px" : "41px"};
  height: ${(props2) => props2.$size === "small" ? "25px" : "41px"};

  svg {
    width: 100%;
    height: 100%;
  }
`, WorkspacePreviewIcon = ({
  icon,
  size = "small"
}) => {
  const iconComponent = React.useMemo(() => createIcon(icon), [icon]);
  return /* @__PURE__ */ jsxRuntime.jsx(Media$1, { $size: size, children: iconComponent });
}, createIcon = (icon) => {
  if (reactIs.isValidElementType(icon))
    return React.createElement(icon);
  if (React.isValidElement(icon))
    return icon;
};
function WorkspacePreview(props2) {
  const { state, subtitle, selected, title, icon, iconRight } = props2, iconRightComponent = React.useMemo(() => createIcon(iconRight), [iconRight]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: "none", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon, size: "small" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title }),
      subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: subtitle })
    ] }),
    state && STATE_TITLES[state] && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: STATE_TITLES[state] }) }),
    (selected || iconRightComponent) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 4, paddingLeft: 3, paddingRight: 2, children: [
      selected && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}) }),
      iconRightComponent && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: iconRightComponent })
    ] })
  ] });
}
const LINKS = [
  {
    url: "https://slack.sanity.io/",
    i18nKey: "workspaces.community-title",
    title: "Community"
  },
  {
    url: "https://www.sanity.io/docs",
    i18nKey: "workspaces.docs-title",
    title: "Docs"
  },
  {
    url: "https://www.sanity.io/legal/privacy",
    i18nKey: "workspaces.privacy-title",
    title: "Privacy"
  },
  {
    url: "https://www.sanity.io",
    i18nKey: "workspaces.sanity-io-title",
    title: "sanity.io"
  }
], StyledText$1 = styled__default.default(ui.Text)`
  a {
    color: inherit;
  }
`;
function Layout(props2) {
  const { children, footer, header } = props2;
  return useTranslation(), /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 6, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 3, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      typeof header == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: header }),
      typeof header == "string" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { align: "center", size: 1, children: header }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !!header, borderBottom: !!footer, children }) }),
      footer && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: footer })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 4, justify: "center", align: "center", paddingBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 3, children: /* @__PURE__ */ jsxRuntime.jsx(logos.SanityLogo, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: LINKS.map((link, index) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(StyledText$1, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("a", { href: link.url, target: "_blank", rel: "noopener noreferrer", children: link.title }) }),
        index < LINKS.length - 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: "\u2022" })
      ] }, link.title)) })
    ] })
  ] });
}
function WorkspaceAuth() {
  var _a2;
  const workspaces = useWorkspaces(), { activeWorkspace, setActiveWorkspace } = useActiveWorkspace(), [authStates] = useWorkspaceAuthStates(workspaces), [selectedWorkspaceName, setSelectedWorkspaceName] = React.useState(
    (activeWorkspace == null ? void 0 : activeWorkspace.name) || null
  ), selectedWorkspace = workspaces.length === 1 ? workspaces[0] : workspaces.find((workspace) => workspace.name === selectedWorkspaceName), LoginComponent = (_a2 = selectedWorkspace == null ? void 0 : selectedWorkspace.auth) == null ? void 0 : _a2.LoginComponent, handleBack = React.useCallback(() => setSelectedWorkspaceName(null), []), { t: t2 } = useTranslation();
  return authStates ? LoginComponent && selectedWorkspace ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    workspaces.length > 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.ArrowLeftIcon,
        mode: "bleed",
        onClick: handleBack,
        text: t2("workspaces.action.choose-another-workspace")
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      Layout,
      {
        header: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
          WorkspacePreview,
          {
            icon: selectedWorkspace.icon,
            title: selectedWorkspace.title,
            subtitle: selectedWorkspace == null ? void 0 : selectedWorkspace.subtitle
          }
        ) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, paddingBottom: 3, paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
          LoginComponent,
          {
            projectId: selectedWorkspace.projectId,
            redirectPath: window.location.pathname.startsWith(selectedWorkspace.basePath) ? (
              // NOTE: the fragment cannot be preserved because it's used
              // to transfer an sid to a token
              `${window.location.pathname}${window.location.search}`
            ) : selectedWorkspace.basePath
          },
          selectedWorkspaceName
        ) })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    Layout,
    {
      header: t2("workspaces.choose-your-workspace-label"),
      footer: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          as: "a",
          href: WORKSPACES_DOCS_URL,
          icon: icons.AddIcon,
          mode: "bleed",
          rel: "noopener noreferrer",
          size: "large",
          target: "__blank",
          text: t2("workspaces.action.add-workspace")
        }
      ) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, paddingX: 1, paddingY: 2, children: workspaces.map((workspace) => {
        const state = authStates[workspace.name].authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access";
        return /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            as: "button",
            radius: 2,
            padding: 2,
            onClick: () => {
              state === "logged-in" && workspace.name !== activeWorkspace.name && setActiveWorkspace(workspace.name), state === "logged-out" && setSelectedWorkspaceName(workspace.name);
            },
            children: /* @__PURE__ */ jsxRuntime.jsx(
              WorkspacePreview,
              {
                icon: workspace == null ? void 0 : workspace.icon,
                iconRight: icons.ChevronRightIcon,
                state,
                subtitle: workspace == null ? void 0 : workspace.subtitle,
                title: (workspace == null ? void 0 : workspace.title) || workspace.name
              }
            )
          },
          workspace.name
        );
      }) })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 });
}
const StyledMenu$3 = styled__default.default(ui.Menu)`
  max-width: 350px;
  min-width: 250px;
`, POPOVER_PROPS = {
  constrainSize: !0,
  fallbackPlacements: ["bottom-end", "bottom"],
  placement: "bottom-end"
};
function WorkspaceMenuButton() {
  const workspaces = useWorkspaces(), { activeWorkspace, setActiveWorkspace } = useActiveWorkspace(), [authStates] = useWorkspaceAuthStates(workspaces), { navigateUrl } = router.useRouter(), { t: t2 } = useTranslation();
  if (!(workspaces.length > 1))
    return null;
  const disabled = !authStates;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: t2("workspaces.select-workspace-tooltip"), disabled, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { disabled, mode: "bleed", padding: 2, width: "fill", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: activeWorkspace.title }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) })
      ] }) }) }) }),
      id: "workspace-menu",
      menu: !disabled && authStates ? /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$3, { children: workspaces.map((workspace) => {
        const state = authStates[workspace.name].authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access", handleSelectWorkspace = () => {
          state === "logged-in" && workspace.name !== activeWorkspace.name && setActiveWorkspace(workspace.name), state === "logged-out" && navigateUrl({ path: workspace.basePath });
        }, isSelected = workspace.name === activeWorkspace.name;
        return /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            badgeText: STATE_TITLES[state],
            iconRight: isSelected ? icons.CheckmarkIcon : void 0,
            onClick: handleSelectWorkspace,
            pressed: isSelected,
            preview: /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon: workspace.icon, size: "small" }),
            selected: isSelected,
            __unstable_subtitle: workspace.subtitle,
            __unstable_space: 1,
            text: (workspace == null ? void 0 : workspace.title) || workspace.name
          },
          workspace.name
        );
      }) }) : void 0,
      popover: POPOVER_PROPS
    }
  );
}
function AuthenticateScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", overflow: "auto", paddingX: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { height: "fill", direction: "column", align: "center", justify: "center", paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceAuth, {}) }) }) });
}
function ConfigErrorsScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "TODO: implement config errors screen" });
}
const ScreenReaderLabel = styled__default.default.label`
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  overflow: clip;
  position: absolute;
  white-space: nowrap;
  width: 1px;
`;
function CorsOriginErrorScreen(props2) {
  const { projectId } = props2, origin = window.location.origin, corsUrl = React.useMemo(() => {
    const url = new URL(`https://sanity.io/manage/project/${projectId}/api`);
    return url.searchParams.set("cors", "add"), url.searchParams.set("origin", origin), url.searchParams.set("credentials", ""), url.toString();
  }, [origin, projectId]);
  return React.useEffect(() => {
    const handleFocus = () => {
      window.location.reload();
    };
    return window.addEventListener("focus", handleFocus), () => {
      window.removeEventListener("focus", handleFocus);
    };
  }, []), /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      id: "cors-error-dialog",
      header: "Before you continue...",
      width: 1,
      footer: {
        confirmButton: {
          text: "Continue",
          iconRight: icons.LaunchIcon,
          as: "a",
          href: corsUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          tone: "primary"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
          "To access your content, you need to ",
          /* @__PURE__ */ jsxRuntime.jsx("b", { children: "add the following URL as a CORS origin" }),
          " to your Sanity project."
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ScreenReaderLabel, { "aria-hidden": "true", children: "CORS URL to be added" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: origin, readOnly: !0 })
      ] })
    }
  ) });
}
function NotAuthenticatedScreen() {
  const [currentUser, setCurrentUser] = React.useState(null), [error, handleError] = React.useState(null);
  if (error)
    throw error;
  const { activeWorkspace } = useActiveWorkspace(), handleLogout = React.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = activeWorkspace.auth).logout) == null || _b.call(_a2);
  }, [activeWorkspace]);
  React.useEffect(() => {
    const subscription = activeWorkspace.auth.state.subscribe({
      next: ({ currentUser: user }) => {
        setCurrentUser(user);
      },
      error: handleError
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]);
  const providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider), providerHelp = providerTitle ? ` through ${providerTitle}` : "";
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      id: "not-authorized-dialog",
      header: "Not authorized",
      width: 1,
      footer: {
        confirmButton: {
          text: "Sign out",
          onClick: handleLogout,
          tone: "default"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "You are not authorized to access this studio. Maybe you could ask someone to invite you to collaborate on this project?" }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
          "If you think this is an error, verify that you are signed in with the correct account. You are currently signed in as",
          " ",
          /* @__PURE__ */ jsxRuntime.jsxs("strong", { children: [
            currentUser == null ? void 0 : currentUser.name,
            " (",
            currentUser == null ? void 0 : currentUser.email,
            ")"
          ] }),
          providerHelp,
          "."
        ] })
      ] })
    }
  ) });
}
function NotFoundScreen(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", sizing: "border", tone: "caution", display: "flex", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "row", justify: "center", flex: 1, align: "center", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", children: "Workspace not found" }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        text: "Go to default workspace",
        onClick: props2.onNavigateToDefaultWorkspace,
        mode: "ghost"
      }
    ) })
  ] }) }) });
}
function renderPath(path) {
  return path.map((segment) => segment.kind === "type" ? `${segment.name || "<unnamed>"}(${segment.type})` : segment.kind === "property" ? segment.name : null).filter(Boolean).join(" > ");
}
function reportWarnings(schema2) {
  const problemGroups = schema2._validation, groupsWithWarnings = problemGroups == null ? void 0 : problemGroups.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "warning")
  );
  (groupsWithWarnings == null ? void 0 : groupsWithWarnings.length) !== 0 && (console.groupCollapsed(`\u26A0\uFE0F Schema has ${groupsWithWarnings == null ? void 0 : groupsWithWarnings.length} warnings`), groupsWithWarnings == null || groupsWithWarnings.forEach((group2) => {
    const path = renderPath(group2.path);
    console.group(`%cAt ${path}`, "color: #FF7636"), group2.problems.forEach((problem) => {
      console.log(problem.message);
    }), console.groupEnd();
  }), console.groupEnd());
}
const TONES = {
  error: "critical",
  warning: "caution"
}, SegmentSpan = styled__default.default.code`
  && {
    background: none;
    color: inherit;
  }
`, ErrorMessageText = styled__default.default(ui.Text)`
  white-space: pre-line;
`;
function SchemaProblemGroups(props2) {
  const { problemGroups } = props2;
  useTranslation();
  const items = React.useMemo(() => {
    const ret = [];
    for (const problemGroup of problemGroups)
      for (const problem of problemGroup.problems)
        ret.push({ group: problemGroup, problem });
    return ret;
  }, [problemGroups]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 4, children: items.map(({ group: group2, problem }, i) => {
    const isError2 = problem.severity === "error", isWarning = problem.severity === "warning", schemaType = getTypeInfo(group2);
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { border: !0, padding: 4, radius: 2, tone: TONES[problem.severity], children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
          isError2 && /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}),
          isWarning && /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: schemaType ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          capitalize__default.default(schemaType.type),
          ' type "',
          schemaType.name,
          '"'
        ] }) : null }) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Breadcrumbs,
        {
          separator: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "\u2192" }),
          children: group2.path.map((segment, j) => {
            if (segment.kind === "type") {
              const text = `${_renderSegmentName(
                segment.name || `<anonymous ${segment.type}>`
              )}:${segment.type}`;
              return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: text, size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(SegmentSpan, { children: text }) }, j);
            }
            return segment.kind === "property" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: segment.name, size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(SegmentSpan, { children: segment.name }) }, j) : null;
          })
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "ul", marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ErrorMessageText, { muted: !0, size: 1, children: problem.message }),
        problem.helpId && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          "a",
          {
            href: generateHelpUrl.generateHelpUrl(problem.helpId),
            target: "_blank",
            rel: "noopener noreferrer",
            children: "View documentation \u2192"
          }
        ) })
      ] }) }) })
    ] }, i);
  }) });
}
function getTypeInfo(problem) {
  const first = problem.path[0];
  return first.kind === "type" ? { name: first.name || `<anonymous ${first.type}>`, type: first.type } : null;
}
function _renderSegmentName(str) {
  return str != null && str.startsWith("<unnamed_type_@_index") ? `[${str.slice(1, -1).split("_")[4]}]` : str;
}
function SchemaErrorsScreen({ schema: schema2 }) {
  var _a2;
  const groupsWithErrors = ((_a2 = schema2._validation) == null ? void 0 : _a2.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "error")
  )) || [];
  return React.useEffect(() => reportWarnings(schema2), [schema2]), /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", children: "Schema errors" }),
    /* @__PURE__ */ jsxRuntime.jsx(SchemaProblemGroups, { problemGroups: groupsWithErrors })
  ] }) }) });
}
function StudioErrorBoundary({
  children,
  heading = "An error occured"
}) {
  const [{ error }, setError] = React.useState({ error: null }), message = isRecord$4(error) && typeof error.message == "string" && error.message, stack = isRecord$4(error) && typeof error.stack == "string" && error.stack, handleResetError = React.useCallback(() => setError({ error: null }), [setError]);
  return useHotModuleReload.useHotModuleReload(handleResetError), error instanceof CorsOriginError ? /* @__PURE__ */ jsxRuntime.jsx(CorsOriginErrorScreen, { projectId: error == null ? void 0 : error.projectId }) : error instanceof SchemaError ? /* @__PURE__ */ jsxRuntime.jsx(SchemaErrorsScreen, { schema: error.schema }) : error ? /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      height: "fill",
      overflow: "auto",
      paddingY: [4, 5, 6, 7],
      paddingX: 4,
      sizing: "border",
      tone: "critical",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { children: heading }),
        /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { onClick: handleResetError, text: "Retry", tone: "default" }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 2, overflow: "auto", padding: 4, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
          message && /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsxs("strong", { children: [
            "Error: ",
            message
          ] }) }),
          stack && /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: stack })
        ] }) })
      ] }) })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setError, children });
}
const SearchFullscreenPortalCard = styled__default.default(ui.Card)`
  height: 100%;
  left: 0;
  overflow: hidden;
  overflow: clip;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 200;
`, NavbarContext = React.createContext({
  onSearchFullscreenOpenChange: () => "",
  onSearchOpenChange: () => "",
  searchFullscreenOpen: !1,
  searchFullscreenPortalEl: null,
  searchOpen: !1
});
function StudioLayout() {
  const Layout2 = useLayoutComponent();
  return /* @__PURE__ */ jsxRuntime.jsx(Layout2, {});
}
function StudioLayoutComponent() {
  var _a2;
  const { name, title, tools } = useWorkspace(), router$1 = router.useRouter(), activeToolName = router.useRouterState(
    React.useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), activeTool = React.useMemo(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), [searchFullscreenOpen, setSearchFullscreenOpen] = React.useState(!1), [searchFullscreenPortalEl, setSearchFullscreenPortalEl] = React.useState(
    null
  ), [searchOpen, setSearchOpen] = React.useState(!1), documentTitle = React.useMemo(() => {
    const mainTitle = title || startCase__default.default(name);
    return activeToolName ? `${startCase__default.default(activeToolName)} | ${mainTitle}` : mainTitle;
  }, [activeToolName, name, title]), toolControlsDocumentTitle = !!(activeTool != null && activeTool.controlsDocumentTitle);
  React.useEffect(() => {
    toolControlsDocumentTitle || (document.title = documentTitle);
  }, [documentTitle, toolControlsDocumentTitle]);
  const handleSearchFullscreenOpenChange = React.useCallback((open) => {
    setSearchFullscreenOpen(open);
  }, []), handleSearchOpenChange = React.useCallback((open) => {
    setSearchOpen(open);
  }, []), navbarContextValue = React.useMemo(
    () => ({
      searchFullscreenOpen,
      searchFullscreenPortalEl,
      searchOpen,
      onSearchFullscreenOpenChange: handleSearchFullscreenOpenChange,
      onSearchOpenChange: handleSearchOpenChange
    }),
    [
      searchFullscreenOpen,
      searchFullscreenPortalEl,
      searchOpen,
      handleSearchFullscreenOpenChange,
      handleSearchOpenChange
    ]
  ), Navbar = useNavbarComponent(), ActiveToolLayout = useActiveToolLayoutComponent(), isLegacyDeskRedirect = !activeTool && (activeToolName === "desk" || !activeToolName) && typeof window < "u" && /\/desk(\/|$)/.test(window.location.pathname) && tools.some((tool) => tool.name === "structure");
  return React.useEffect(() => {
    isLegacyDeskRedirect && router$1.navigateUrl({
      path: window.location.pathname.replace(/\/desk/, "/structure"),
      replace: !0
    });
  }, [isLegacyDeskRedirect, router$1]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { "data-ui": "ToolScreen", direction: "column", height: "fill", "data-testid": "studio-layout", children: [
    /* @__PURE__ */ jsxRuntime.jsx(NavbarContext.Provider, { value: navbarContextValue, children: /* @__PURE__ */ jsxRuntime.jsx(Navbar, {}) }),
    isLegacyDeskRedirect && /* @__PURE__ */ jsxRuntime.jsx(RedirectingScreen, {}),
    tools.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(NoToolsScreen, {}),
    tools.length > 0 && !activeTool && activeToolName && !isLegacyDeskRedirect && /* @__PURE__ */ jsxRuntime.jsx(ToolNotFoundScreen, { toolName: activeToolName }),
    searchFullscreenOpen && /* @__PURE__ */ jsxRuntime.jsx(SearchFullscreenPortalCard, { ref: setSearchFullscreenPortalEl, overflow: "auto" }),
    /* @__PURE__ */ jsxRuntime.jsx(StudioErrorBoundary, { heading: `The ${activeTool == null ? void 0 : activeTool.name} tool crashed`, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, hidden: searchFullscreenOpen, children: activeTool && activeToolName && /* @__PURE__ */ jsxRuntime.jsx(
      router.RouteScope,
      {
        scope: activeToolName,
        __unsafe_disableScopedSearchParams: (_a2 = activeTool.router) == null ? void 0 : _a2.__unsafe_disableScopedSearchParams,
        children: /* @__PURE__ */ jsxRuntime.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }), children: /* @__PURE__ */ jsxRuntime.jsx(ActiveToolLayout, { activeTool }) })
      }
    ) }) }, activeTool == null ? void 0 : activeTool.name)
  ] });
}
function pickToolMenuComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.toolMenu;
}
function pickNavbarComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.navbar;
}
function pickLayoutComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.layout;
}
function pickActiveToolLayoutComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.activeToolLayout;
}
function useToolMenuComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioToolMenu,
    pick: pickToolMenuComponent
  });
}
function useNavbarComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioNavbar,
    pick: pickNavbarComponent
  });
}
function useLayoutComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioLayoutComponent,
    pick: pickLayoutComponent
  });
}
function useActiveToolLayoutComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioActiveToolLayout,
    pick: pickActiveToolLayoutComponent
  });
}
function ConfigIssuesButton() {
  var _a2;
  const groupsWithWarnings = ((_a2 = useSchema()._validation) == null ? void 0 : _a2.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "warning")
  )) || [], { scheme } = useColorScheme(), { t: t2 } = useTranslation(), dialogId = React.useId(), [isDialogOpen, setDialogOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), handleOpen = React.useCallback(() => setDialogOpen(!0), []), handleClose = React.useCallback(() => {
    setDialogOpen(!1), buttonElement && buttonElement.focus();
  }, [buttonElement]);
  return groupsWithWarnings.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      StatusButton,
      {
        icon: icons.WarningOutlineIcon,
        mode: "bleed",
        onClick: handleOpen,
        ref: setButtonElement,
        selected: isDialogOpen,
        tone: "caution",
        tooltipProps: { scheme, content: t2("configuration-issues.button.tooltip") }
      }
    ),
    isDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Dialog,
      {
        header: "Configuration issues",
        width: 2,
        onClickOutside: handleClose,
        onClose: handleClose,
        scheme,
        id: dialogId,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "h2", size: 1, weight: "medium", children: [
              "Found ",
              groupsWithWarnings.length,
              " schema warnings"
            ] }),
            " ",
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "Configuration checks are only performed during development and will not be visible in production builds" })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(SchemaProblemGroups, { problemGroups: groupsWithWarnings })
        ] })
      }
    )
  ] });
}
const TrialDialogViewed = telemetry.defineEvent({
  name: "Trial Dialog Viewed",
  version: 1,
  description: "User viewed a dialog or popover related to free trial"
}), TrialDialogDismissed = telemetry.defineEvent({
  name: "Trial Dialog Dismissed",
  version: 1,
  description: "User dismissed a dialog or popover related to free trial"
}), TrialDialogCTAClicked = telemetry.defineEvent({
  name: "Trial Dialog CTA Clicked",
  version: 1,
  description: "User clicked a CTA in a dialog or popover related to free trial"
});
function getTrialStage({
  showOnLoad,
  dialogId
}) {
  return showOnLoad && dialogId.toLowerCase() === "free-upgrade-popover" ? "trialStarted" : showOnLoad && dialogId.toLowerCase() === "trial-ending-popover" ? "trialEndingSoon" : showOnLoad && dialogId.toLowerCase() === "project-downgraded-to-free" ? "trialEnded" : !showOnLoad && dialogId.toLowerCase() === "after-trial-upgrade" ? "postTrial" : "trialActive";
}
const UpsellDialogViewed = telemetry.defineEvent({
  name: "Upsell Dialog Viewed",
  version: 1,
  description: "User viewed the upsell dialog"
}), UpsellDialogDismissed = telemetry.defineEvent({
  name: "Upsell Dialog Dismissed",
  version: 1,
  description: "User dismissed the upsell dialog"
}), UpsellDialogUpgradeCtaClicked = telemetry.defineEvent({
  name: "Upsell Dialog Upgrade CTA Clicked",
  version: 1,
  description: 'User clicked the "Upgrade" CTA in the upsell dialog'
}), UpsellDialogLearnMoreCtaClicked = telemetry.defineEvent({
  name: "Upsell Dialog Learn More CTA Clicked",
  version: 1,
  description: 'User clicked the "Learn More" CTA in the upsell dialog'
}), TRANSFORMATIONS = {
  inlineIcon: (child, idx, block) => {
    var _a2, _b, _c, _d;
    if (!types.isPortableTextTextBlock(block))
      return block;
    const hasTextLeft = !!(((_a2 = block.children[idx - 1]) == null ? void 0 : _a2._type) === "span" && (_b = block.children[idx - 1]) != null && _b.text), hasTextRight = !!(((_c = block.children[idx + 1]) == null ? void 0 : _c._type) === "span" && (_d = block.children[idx + 1]) != null && _d.text);
    return {
      ...child,
      hasTextRight,
      hasTextLeft
    };
  }
}, transformBlocks = (blocks) => blocks.map((block) => {
  if (types.isPortableTextTextBlock(block) && block._type === "block") {
    const children = block.children.map((child, idx) => TRANSFORMATIONS[child._type] ? TRANSFORMATIONS[child._type](child, idx, block) : child);
    return {
      ...block,
      children
    };
  }
  return block;
}), Divider = styled__default.default(ui.Box)`
  height: 1px;
  background: var(--card-border-color);
  width: 100%;
`, SerializerContainer = styled__default.default.div`
  // Remove margin top of first element
  > div:first-child {
    margin-top: 0;
  }
  // Remove margin bottom to last box.
  > [data-ui='Box']:last-child {
    margin-bottom: 0;
  }
`, IconTextContainer = styled__default.default(ui.Text)((props2) => props2.accent ? `
    --card-icon-color: var(--card-accent-fg-color);
    ` : ""), AccentSpan = styled__default.default.span`
  color: var(--card-accent-fg-color);
  --card-icon-color: var(--card-accent-fg-color);
`, SemiboldSpan = styled__default.default.span(({ theme: theme2 }) => {
  const { weights } = theme2.sanity.fonts.text;
  return styled.css`
    font-weight: ${weights.semibold};
  `;
}), InlineIcon = styled__default.default(icons.Icon)`
  &[data-sanity-icon] {
    /* Forces the icon to leave the necessary space to the right or left it has surrounding text */
    margin-left: ${(props2) => props2.$hasTextLeft ? "0" : ""};
    margin-right: ${(props2) => props2.$hasTextRight ? "0" : ""};
  }
`, Link = styled__default.default.a`
  font-weight: 600;
  color: ${(props2) => props2.useTextColor ? "var(--card-muted-fg-color) !important" : ""};
`, DynamicIconContainer = styled__default.default.span`
  > svg {
    display: inline;
    font-size: calc(21 / 16 * 1rem) !important;
    margin: -0.375rem 0 !important;
    *[stroke] {
      stroke: currentColor;
    }
  }
`, accentSpanWrapper = (children) => /* @__PURE__ */ jsxRuntime.jsx(AccentSpan, { children }), DynamicIcon = (props2) => {
  const [ref, setRef] = React.useState(null);
  return React.useEffect(() => {
    if (!ref)
      return;
    const controller = new AbortController(), signal = controller.signal;
    return fetch(props2.icon.url, { signal }).then((response) => {
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      return response.text();
    }).then((data) => {
      ref && (ref.innerHTML = data);
    }).catch((error) => {
      error.name !== "AbortError" && console.error(error);
    }), () => {
      controller.abort();
    };
  }, [ref, props2.icon.url]), /* @__PURE__ */ jsxRuntime.jsx(DynamicIconContainer, { ref: setRef });
};
function NormalBlock(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginBottom: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children }) });
}
function HeadingBlock(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginY: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 2, as: "h2", children }) });
}
const components = {
  block: {
    normal: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h2: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(HeadingBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  listItem: {
    bullet: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children })
  },
  marks: {
    strong: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx("strong", { children }),
    semibold: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(SemiboldSpan, { children }),
    link: (props2) => /* @__PURE__ */ jsxRuntime.jsxs(
      Link,
      {
        href: props2.value.href,
        rel: "noopener noreferrer",
        target: "_blank",
        useTextColor: props2.value.useTextColor,
        children: [
          props2.children,
          props2.value.showIcon && /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, { style: { marginLeft: "2px" } })
        ]
      }
    ),
    accent: (props2) => /* @__PURE__ */ jsxRuntime.jsx(AccentSpan, { children: props2.children })
  },
  types: {
    inlineIcon: (props2) => /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.ConditionalWrapper, { condition: props2.value.accent, wrapper: accentSpanWrapper, children: props2.value.sanityIcon ? /* @__PURE__ */ jsxRuntime.jsx(
      InlineIcon,
      {
        symbol: props2.value.sanityIcon,
        $hasTextLeft: props2.value.hasTextLeft,
        $hasTextRight: props2.value.hasTextRight
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(DynamicIcon, { icon: props2.value.icon }) }),
    divider: () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(Divider, {}) }) }),
    iconAndText: (props2) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", paddingX: 2, paddingTop: 1, paddingBottom: 2, marginTop: 2, gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, style: { flexShrink: 0 }, children: [
        /* @__PURE__ */ jsxRuntime.jsx(IconTextContainer, { size: 1, accent: props2.value.accent, children: props2.value.sanityIcon ? /* @__PURE__ */ jsxRuntime.jsx(icons.Icon, { symbol: props2.value.sanityIcon }) : /* @__PURE__ */ jsxRuntime.jsx(DynamicIcon, { icon: props2.value.icon }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", accent: props2.value.accent, children: props2.value.title })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, accent: props2.value.accent, children: props2.value.text })
    ] })
  }
};
function UpsellDescriptionSerializer(props2) {
  const value = React.useMemo(() => transformBlocks(props2.blocks), [props2.blocks]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(SerializerContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(
    react$1.PortableText,
    {
      value,
      components,
      onMissingComponent: !1
    }
  ) }) });
}
const StyledButton$1 = styled__default.default(getJsonStream.Button)`
  position: absolute;
  top: 12px;
  right: 12px;
  z-index: 20;
  background: transparent;
  border-radius: 9999px;
  box-shadow: none;
  color: white;
  --card-fg-color: white;
  :hover {
    --card-fg-color: white;
  }
`, Image$2 = styled__default.default.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 196px;
`, StyledDialog$1 = styled__default.default(getJsonStream.Dialog)`
  > [data-ui='DialogCard'] {
    max-width: 22.5rem;
  }
`;
function DialogContent({
  onClose,
  onOpenNext,
  onOpenUrlCallback,
  content: content2,
  open
}) {
  var _a2, _b, _c, _d, _e;
  function handleClose() {
    onClose("xClick");
  }
  function handleClickOutside() {
    onClose("outsideClick");
  }
  function handleCTAClose() {
    onClose("ctaClicked");
  }
  const schemeValue = useColorSchemeValue();
  return open ? /* @__PURE__ */ jsxRuntime.jsxs(
    StyledDialog$1,
    {
      id: "free-trial-modal",
      onClose,
      onClickOutside: handleClickOutside,
      padding: !1,
      __unstable_hideCloseButton: !0,
      scheme: schemeValue,
      footer: {
        cancelButton: (_a2 = content2.secondaryButton) != null && _a2.text ? {
          text: content2.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          onClick: handleClose
        } : void 0,
        confirmButton: {
          text: (_b = content2.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...((_c = content2.ctaButton) == null ? void 0 : _c.action) === "openUrl" ? {
            href: content2.ctaButton.url,
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            onClick: onOpenUrlCallback
          } : {
            onClick: ((_d = content2.ctaButton) == null ? void 0 : _d.action) === "openNext" ? onOpenNext : handleCTAClose
          }
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          StyledButton$1,
          {
            icon: icons.CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: handleClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        content2.image && /* @__PURE__ */ jsxRuntime.jsx(Image$2, { src: content2.image.asset.url, alt: (_e = content2.image.asset.altText) != null ? _e : "" }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 3, direction: "column", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 2, children: content2.headingText }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(UpsellDescriptionSerializer, { blocks: content2.descriptionText }) })
        ] })
      ]
    }
  ) : null;
}
const CenteredStroke = styled__default.default.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
`, SvgFilledOutline = ({ daysLeft, totalDays }) => {
  const progress = totalDays - daysLeft, percentage = Math.round(progress / totalDays * 100), radius = 10, strokeDasharray = 2 * Math.PI * radius, strokeDashOffset = strokeDasharray * ((100 - percentage) / 100), strokeWidth = 1.2, size = radius * 2 + strokeWidth;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(CenteredStroke, { children: /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: size,
      height: size,
      viewBox: `0 0 ${size} ${size}`,
      style: { transform: "rotate(-90deg)" },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "circle",
          {
            r: radius,
            cx: size / 2,
            cy: size / 2,
            fill: "transparent",
            strokeWidth,
            stroke: percentage > 75 ? color.yellow[600].hex : color.purple[400].hex
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "circle",
          {
            r: radius,
            cx: size / 2,
            cy: size / 2,
            fill: "transparent",
            strokeWidth,
            stroke: "var(--card-border-color)",
            strokeDasharray,
            strokeDashoffset: strokeDashOffset
          }
        )
      ]
    }
  ) }) });
}, FreeTrialButtonTopbar = React.forwardRef(function({ toggleShowContent, daysLeft, totalDays }, ref) {
  const { t: t2 } = reactI18next.useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    getJsonStream.Button,
    {
      mode: "bleed",
      onClick: toggleShowContent,
      ref,
      tooltipProps: {
        content: daysLeft ? t2("free-trial.tooltip.days-count", { count: daysLeft }) : t2("free-trial.tooltip.trial-finished")
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.BoltIcon, {}) }),
        daysLeft > 0 && /* @__PURE__ */ jsxRuntime.jsx(SvgFilledOutline, { daysLeft, totalDays })
      ]
    }
  );
}), FreeTrialButtonSidebar = React.forwardRef(function({ toggleShowContent, daysLeft }, ref) {
  const { t: t2 } = reactI18next.useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ref,
      icon: icons.BoltIcon,
      justify: "flex-start",
      mode: "bleed",
      size: "large",
      onClick: toggleShowContent,
      text: daysLeft ? t2("user-menu.action.free-trial", { count: daysLeft }) : t2("user-menu.action.free-trial-finished")
    }
  );
}), FreeTrialContext = React.createContext(void 0), useFreeTrialContext = () => {
  const context = React.useContext(FreeTrialContext);
  if (!context)
    throw new Error("useFreeTrial must be used within a FreeTrialProvider");
  return context;
}, Image$1 = styled__default.default.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
`;
function PopoverContent({ content: content2, handleClose, handleOpenNext }) {
  var _a2, _b, _c, _d, _e;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 3, overflow: "hidden", width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Container, { width: 0, children: [
    content2.image && /* @__PURE__ */ jsxRuntime.jsx(Image$1, { src: content2.image.asset.url, alt: (_a2 = content2.image.asset.altText) != null ? _a2 : "" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 3, direction: "column", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 1, children: content2.headingText }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(UpsellDescriptionSerializer, { blocks: content2.descriptionText }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { width: "full", gap: 3, justify: "flex-end", padding: 3, children: [
      ((_b = content2.secondaryButton) == null ? void 0 : _b.text) && /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          mode: "bleed",
          text: content2.secondaryButton.text,
          tone: "default",
          onClick: () => handleClose("xClick")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          mode: "default",
          tooltipProps: null,
          text: (_c = content2.ctaButton) == null ? void 0 : _c.text,
          autoFocus: !0,
          tone: "primary",
          ...((_d = content2.ctaButton) == null ? void 0 : _d.action) === "openUrl" ? {
            href: content2.ctaButton.url,
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a"
          } : {
            onClick: ((_e = content2.ctaButton) == null ? void 0 : _e.action) === "openNext" ? handleOpenNext : () => handleClose("ctaClicked")
          }
        }
      )
    ] })
  ] }) });
}
function FreeTrial({ type }) {
  const { data, showDialog, showOnLoad, toggleShowContent } = useFreeTrialContext(), scheme = useColorSchemeValue(), telemetry2 = react.useTelemetry(), [ref, setRef] = React.useState(null), [showPopover, setShowPopover] = React.useState(!1);
  React.useEffect(() => {
    ref && setShowPopover(!0);
  }, [ref]);
  const closeAndReOpen = React.useCallback(() => toggleShowContent(!0), [toggleShowContent]), toggleDialog = React.useCallback(() => {
    ref == null || ref.focus(), toggleShowContent(!1);
  }, [toggleShowContent, ref]), handleClose = React.useCallback(
    (dialogType) => (action) => {
      const dialog = (data == null ? void 0 : data.showOnLoad) || (data == null ? void 0 : data.showOnClick);
      dialog && telemetry2.log(TrialDialogDismissed, {
        dialogId: dialog.id,
        dialogRevision: dialog._rev,
        dialogType,
        source: "studio",
        trialDaysLeft: data.daysLeft,
        dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
        dialogDismissAction: action
      }), toggleDialog();
    },
    [data, toggleDialog, showOnLoad, telemetry2]
  ), handleDialogCTAClick = React.useCallback(
    (action) => () => {
      const dialog = (data == null ? void 0 : data.showOnLoad) || (data == null ? void 0 : data.showOnClick);
      dialog && telemetry2.log(TrialDialogCTAClicked, {
        dialogId: dialog.id,
        dialogRevision: dialog._rev,
        dialogType: "modal",
        source: "studio",
        trialDaysLeft: data.daysLeft,
        dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
        dialogCtaType: action === "openURL" ? "upgrade" : "learnMore"
      }), closeAndReOpen();
    },
    [data, closeAndReOpen, telemetry2, showOnLoad]
  ), handlePopoverCTAClick = React.useCallback(() => {
    data != null && data.showOnLoad && telemetry2.log(TrialDialogCTAClicked, {
      dialogId: data.showOnLoad.id,
      dialogRevision: data.showOnLoad._rev,
      dialogType: "popover",
      source: "studio",
      trialDaysLeft: data.daysLeft,
      dialogTrialStage: getTrialStage({ showOnLoad: !0, dialogId: data.showOnLoad.id }),
      dialogCtaType: "learnMore"
    }), closeAndReOpen();
  }, [data == null ? void 0 : data.showOnLoad, data == null ? void 0 : data.daysLeft, closeAndReOpen, telemetry2]), handleOnTrialButtonClick = React.useCallback(() => {
    data != null && data.showOnClick && telemetry2.log(TrialDialogViewed, {
      dialogId: data.showOnClick.id,
      dialogRevision: data.showOnClick._rev,
      dialogTrigger: "fromClick",
      dialogType: "modal",
      source: "studio",
      trialDaysLeft: data.daysLeft,
      dialogTrialStage: getTrialStage({ showOnLoad: !0, dialogId: data.showOnClick.id })
    }), closeAndReOpen();
  }, [data == null ? void 0 : data.showOnClick, data == null ? void 0 : data.daysLeft, telemetry2, closeAndReOpen]);
  if (!(data != null && data.id))
    return null;
  const dialogToRender = showOnLoad ? data.showOnLoad : data.showOnClick;
  if (!dialogToRender)
    return null;
  const button = type === "sidebar" ? /* @__PURE__ */ jsxRuntime.jsx(
    FreeTrialButtonSidebar,
    {
      toggleShowContent: handleOnTrialButtonClick,
      daysLeft: data.daysLeft,
      ref: setRef
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    FreeTrialButtonTopbar,
    {
      toggleShowContent: handleOnTrialButtonClick,
      daysLeft: data.daysLeft,
      totalDays: data.totalDays,
      ref: setRef
    }
  );
  return (dialogToRender == null ? void 0 : dialogToRender.dialogType) === "popover" ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      open: showDialog && showPopover,
      size: 0,
      scheme,
      radius: 3,
      portal: !0,
      placement: type === "sidebar" ? "top" : "bottom-end",
      content: /* @__PURE__ */ jsxRuntime.jsx(
        PopoverContent,
        {
          content: dialogToRender,
          handleClose: handleClose("popover"),
          handleOpenNext: handlePopoverCTAClick
        }
      ),
      children: button
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    button,
    /* @__PURE__ */ jsxRuntime.jsx(
      DialogContent,
      {
        content: dialogToRender,
        onClose: handleClose("modal"),
        onOpenNext: handleDialogCTAClick("openNext"),
        onOpenUrlCallback: handleDialogCTAClick("openURL"),
        open: showDialog
      }
    )
  ] });
}
const SANITY_VERSION = "3.36.2", FreeTrialProvider = ({ children }) => {
  var _a2;
  const router$1 = router.useRouter(), [data, setData] = React.useState(null), [showDialog, setShowDialog] = React.useState(!1), [showOnLoad, setShowOnLoad] = React.useState(!1), client2 = useClient({ apiVersion: "2023-12-11" }), telemetry2 = react.useTelemetry();
  React.useEffect(() => {
    const dialog = data == null ? void 0 : data.showOnLoad;
    showDialog && showOnLoad && dialog && telemetry2.log(TrialDialogViewed, {
      dialogId: dialog.id,
      dialogRevision: dialog._rev,
      dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
      dialogTrigger: showOnLoad ? "auto" : "fromClick",
      dialogType: dialog.dialogType,
      source: "studio",
      trialDaysLeft: data.daysLeft
    });
  }, [showDialog, data, showOnLoad, telemetry2]);
  const searchParamsAsString = new URLSearchParams(router$1.state._searchParams).toString();
  React.useEffect(() => {
    const searchParams = new URLSearchParams(searchParamsAsString), queryParams = new URLSearchParams();
    queryParams.append("studioVersion", SANITY_VERSION);
    const trialState = searchParams.get("trialState");
    trialState && queryParams.append("trialState", trialState);
    const seenBefore = searchParams.get("seenBefore");
    seenBefore && queryParams.append("seenBefore", seenBefore);
    const queryURL = queryParams.get("trialState") ? "/journey/trial/override" : "/journey/trial", request = client2.observable.request({
      url: `${queryURL}?${queryParams.toString()}`
    }).subscribe(
      (response) => {
        setData(response), response != null && response.showOnLoad && (setShowOnLoad(!0), setShowDialog(!0));
      },
      () => {
      }
    );
    return () => {
      request.unsubscribe();
    };
  }, [client2, searchParamsAsString]);
  const toggleShowContent = React.useCallback(
    (closeAndReOpen = !1) => {
      var _a22;
      showOnLoad ? (setShowOnLoad(!1), setShowDialog(closeAndReOpen), (_a22 = data == null ? void 0 : data.showOnLoad) != null && _a22.id && client2.request({ url: `/journey/trial/${data == null ? void 0 : data.showOnLoad.id}`, method: "POST" })) : setShowDialog((p) => !p);
    },
    [client2, showOnLoad, (_a2 = data == null ? void 0 : data.showOnLoad) == null ? void 0 : _a2.id]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FreeTrialContext.Provider, { value: { data, showDialog, toggleShowContent, showOnLoad }, children });
};
function SanityLogo() {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      width: "100%",
      height: "100%",
      viewBox: "0 0 33 33",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "100%", height: "100%", fill: "#EC5446" }),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M10.1637 8.5498C10.1637 11.3854 11.9461 13.0725 15.5143 13.9622L19.2955 14.8235C22.6725 15.5855 24.729 17.4783 24.729 20.5619C24.7553 21.9053 24.3107 23.2168 23.4698 24.2765C23.4698 21.1999 21.8499 19.5376 17.9425 18.538L14.2299 17.7086C11.257 17.0423 8.9623 15.4863 8.9623 12.1368C8.94666 10.8433 9.36932 9.58143 10.1637 8.5498Z",
            fill: "white"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M21.1463 19.8069C22.7591 20.8206 23.4662 22.2384 23.4662 24.2729C22.1313 25.953 19.7861 26.8958 17.0297 26.8958C12.3899 26.8958 9.1427 24.6521 8.42111 20.7533H12.8769C13.4506 22.5432 14.9695 23.3726 16.9972 23.3726C19.4722 23.3726 21.1175 22.0753 21.1499 19.7998",
            fill: "#F8B1AA"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M12.4801 12.7536C11.7436 12.3236 11.1394 11.7057 10.7316 10.9656C10.3238 10.2255 10.1276 9.3907 10.1638 8.54984C11.4518 6.88396 13.6923 5.8667 16.4235 5.8667C21.1499 5.8667 23.8848 8.31945 24.5595 11.7717H20.2732C19.8006 10.4107 18.6172 9.35089 16.4596 9.35089C14.1541 9.35089 12.5811 10.6694 12.4909 12.7536",
            fill: "#F8B1AA"
          }
        )
      ]
    }
  );
}
const LOGO_MARK_SIZE = 25, RADIUS = 2, LogoMarkContainer = styled__default.default(ui.Card).attrs({
  overflow: "hidden",
  radius: RADIUS
})`
  height: ${LOGO_MARK_SIZE}px;
  width: ${LOGO_MARK_SIZE}px;
`, StyledCard$1 = styled__default.default(ui.Card)`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[RADIUS])};
  display: flex;
  outline: none;
  text-decoration: none;
  &:focus-visible {
    box-shadow: ${({ theme: theme2 }) => focusRingStyle$1({
  base: theme2.sanity.color.base,
  focusRing: { ...theme2.sanity.focusRing, offset: 1 }
})};
  }
`;
function HomeButton() {
  const workspaces = useWorkspaces(), { activeWorkspace } = useActiveWorkspace(), { href: rootHref, onClick: handleRootClick } = router.useStateLink({ state: {} }), multipleWorkspaces = workspaces.length > 1;
  return /* @__PURE__ */ jsxRuntime.jsx(StyledCard$1, { as: "a", href: rootHref, onClick: handleRootClick, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(LogoMarkContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: multipleWorkspaces || activeWorkspace.customIcon ? /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon: activeWorkspace.icon, size: "small" }) : /* @__PURE__ */ jsxRuntime.jsx(SanityLogo, {}) }) }),
    !multipleWorkspaces && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: activeWorkspace.title }) })
  ] }) });
}
function AppearanceMenu$1({
  setScheme
}) {
  const { t: t2 } = useTranslation(), options = useColorSchemeOptions(setScheme, t2);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", padding: 2, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 1, children: options.map(({ icon, label, name, onSelect, selected, title }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      "aria-label": label,
      icon,
      iconRight: selected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}),
      justify: "flex-start",
      mode: "bleed",
      onClick: onSelect,
      selected,
      size: "large",
      text: title
    }
  ) }, name)) }) });
}
function LocaleMenu$1() {
  return getJsonStream.useLocale(), null;
}
function ManageMenu$1() {
  const { currentUser, projectId } = useWorkspace(), isAdmin = !!(currentUser && userHasRole(currentUser, "administrator")), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { as: "ul", space: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(FreeTrial, { type: "sidebar" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t2("user-menu.action.manage-project-aria-label"),
        as: "a",
        href: `https://sanity.io/manage/project/${projectId}`,
        icon: icons.CogIcon,
        justify: "flex-start",
        mode: "bleed",
        size: "large",
        target: "_blank",
        text: t2("user-menu.action.manage-project")
      }
    ) }),
    isAdmin && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t2("user-menu.action.invite-members-aria-label"),
        as: "a",
        href: `https://sanity.io/manage/project/${projectId}/members`,
        icon: icons.UsersIcon,
        justify: "flex-start",
        mode: "bleed",
        size: "large",
        target: "_blank",
        text: t2("user-menu.action.invite-members")
      }
    ) })
  ] }) });
}
const ANIMATION_TRANSITION = {
  bounce: 0,
  damping: 20,
  mass: 0.5,
  stiffness: 200,
  type: "spring"
}, BACKDROP_VARIANTS = {
  open: {
    opacity: 1
  },
  closed: {
    opacity: 0
  }
}, INNER_CARD_VARIANTS = {
  open: {
    x: "0%"
  },
  closed: {
    x: "-100%"
  }
}, Root$6 = styled__default.default(ui.Layer)`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
`, BackdropMotion = styled__default.default(framerMotion.motion(ui.Card))`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--card-shadow-penumbra-color);
`, InnerCardMotion = styled__default.default(framerMotion.motion(ui.Card))`
  position: relative;
  pointer-events: all;
  flex-direction: column;
  height: 100%;
  min-width: 200px;
  max-width: 280px;
  overflow: auto;
`, NavDrawer = React.memo(function(props2) {
  const { __internal_actions: actions, activeToolName, isOpen, onClose, tools } = props2, setScheme = useColorSchemeSetValue(), { auth, currentUser } = useWorkspace(), workspaces = useWorkspaces(), ToolMenu = useToolMenuComponent(), { t: t2 } = useTranslation(), handleKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && onClose();
    },
    [onClose]
  ), handleActionClick = React.useCallback(
    (action) => {
      action == null || action(), onClose();
    },
    [onClose]
  ), actionNodes = React.useMemo(() => {
    var _a2;
    return (_a2 = actions == null ? void 0 : actions.filter((v) => v.location === "sidebar")) == null ? void 0 : _a2.map((action) => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: action == null ? void 0 : action.icon,
        justify: "flex-start",
        mode: "bleed",
        onClick: () => handleActionClick(action.onAction),
        selected: action.selected,
        size: "large",
        text: action.title,
        width: "fill"
      },
      action.name
    ));
  }, [actions, handleActionClick]);
  return /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(Root$6, { onKeyDown: handleKeyDown, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      BackdropMotion,
      {
        animate: "open",
        "data-open": isOpen,
        exit: "closed",
        initial: "closed",
        onClick: onClose,
        transition: ANIMATION_TRANSITION,
        variants: BACKDROP_VARIANTS
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      InnerCardMotion,
      {
        animate: "open",
        "data-open": isOpen,
        display: "flex",
        exit: "closed",
        height: "fill",
        initial: "closed",
        shadow: 1,
        transition: ANIMATION_TRANSITION,
        variants: INNER_CARD_VARIANTS,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, padding: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, align: "center", paddingRight: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: "me" }),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ui.Box,
                  {
                    flex: 1,
                    marginLeft: 3,
                    title: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email),
                    children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email) })
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntime.jsx(
                getJsonStream.Button,
                {
                  icon: icons.CloseIcon,
                  mode: "bleed",
                  onClick: onClose,
                  tooltipProps: { content: t2("user-menu.close-menu") }
                }
              )
            ] }),
            workspaces.length > 1 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, gap: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(HomeButton, {}),
              /* @__PURE__ */ jsxRuntime.jsx(WorkspaceMenuButton, {})
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", flex: 1, justify: "space-between", overflow: "auto", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
              ToolMenu,
              {
                activeToolName,
                closeSidebar: onClose,
                context: "sidebar",
                isSidebarOpen: isOpen,
                tools
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", children: [
              actionNodes && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: actionNodes }) }),
              setScheme && /* @__PURE__ */ jsxRuntime.jsx(AppearanceMenu$1, { setScheme }),
              /* @__PURE__ */ jsxRuntime.jsx(LocaleMenu$1, {}),
              /* @__PURE__ */ jsxRuntime.jsx(ManageMenu$1, {})
            ] })
          ] }),
          auth.logout && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, borderTop: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              iconRight: icons.LeaveIcon,
              justify: "flex-start",
              mode: "bleed",
              onClick: auth.logout,
              size: "large",
              text: t2("user-menu.action.sign-out")
            }
          ) }) })
        ]
      }
    )
  ] }) }) });
});
function isQueryMatch(query, option) {
  const lowercaseTitle = option.title.toLowerCase();
  return query.trim().toLowerCase().split(/[\s\-_]+/).every((word) => lowercaseTitle.includes(word));
}
function sortResultRelevance(query, a, b) {
  const titleA = a.title.toLowerCase(), titleB = b.title.toLowerCase(), lowercaseQuery = query.trim().toLowerCase();
  return titleA.startsWith(lowercaseQuery) && !titleB.startsWith(lowercaseQuery) ? -1 : titleB.startsWith(lowercaseQuery) && !titleA.startsWith(lowercaseQuery) ? 1 : titleA.includes(lowercaseQuery) && !titleB.includes(lowercaseQuery) ? -1 : titleB.includes(lowercaseQuery) && !titleA.includes(lowercaseQuery) ? 1 : 0;
}
function filterOptions(options, query, getI18nText) {
  return options.map((option) => ({
    ...option,
    title: getI18nText({ ...option, title: (option == null ? void 0 : option.title) || option.id }).title
  })).sort((a, b) => a.title.localeCompare(b.title)).filter((option) => isQueryMatch(query, option)).sort((a, b) => sortResultRelevance(query, a, b));
}
const StyledPopover$1 = styled__default.default(getJsonStream.Popover)(() => styled.css`
    [data-ui='Popover__wrapper'] {
      width: 320px;
      display: flex;
      flex-direction: column;
      border-radius: ${({ theme: theme2 }) => theme2.sanity.radius[3]}px;
      position: relative;
      overflow: hidden;
      overflow: clip;
    }
  `), StyledDialog = styled__default.default(getJsonStream.Dialog)(() => styled.css`
    [data-ui='DialogCard'] {
      justify-content: flex-start;
    }
  `), RootFlex$1 = styled__default.default(ui.Flex)``, PopoverHeaderCard = styled__default.default(ui.Card)`
  min-height: max-content;
`, DialogHeaderCard = styled__default.default(ui.Card)`
  min-height: max-content;
`, PopoverListFlex = styled__default.default(ui.Flex)((props2) => {
  const { $maxDisplayedItems, $itemHeight } = props2;
  return styled.css`
    --item-height: ${$itemHeight}px;
    --max-items: ${$maxDisplayedItems};
    --list-padding: 0.5rem;

    position: relative;
    max-height: calc(var(--item-height) * var(--max-items) + var(--list-padding));
    min-height: calc((var(--item-height) * 1));
  `;
}), INLINE_PREVIEW_HEIGHT = 33;
function NewDocumentListOption(props2) {
  const { option, currentUser, onClick, preview } = props2, params = React.useMemo(
    () => ({ template: option.templateId, type: option.schemaType }),
    [option.schemaType, option.templateId]
  ), { onClick: onIntentClick, href } = router.useIntentLink({
    intent: "create",
    params
  }), handleDocumentClick = React.useCallback(
    (event) => {
      onIntentClick(event), onClick(option);
    },
    [onIntentClick, onClick, option]
  ), { title } = useI18nText(option);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      disabled: option.hasPermission,
      portal: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(InsufficientPermissionsMessage, { currentUser, context: "create-document" }),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: option.hasPermission ? "a" : "button",
          "data-testid": `create-new-${option.templateId}`,
          disabled: !option.hasPermission,
          href,
          marginBottom: 1,
          onClick: handleDocumentClick,
          padding: preview === "inline" ? 3 : 4,
          radius: 2,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: preview === "inline" ? 1 : void 0, children: title })
        }
      ) })
    },
    option.id
  );
}
const ContentFlex = styled__default.default(ui.Flex)`
  min-height: 100px;
`;
function NewDocumentList(props2) {
  const { currentUser, loading, onDocumentClick, options, preview, searchQuery, textInputElement } = props2, { t: t2 } = useTranslation(), hasOptions = options.length > 0 && !loading, handleDocumentClick = React.useCallback(() => {
    onDocumentClick();
  }, [onDocumentClick]), getItemDisabled = React.useCallback(
    (index) => {
      var _a2;
      return ((_a2 = options[index]) == null ? void 0 : _a2.hasPermission) === !1;
    },
    [options]
  ), renderItem = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsx(
      NewDocumentListOption,
      {
        currentUser,
        onClick: handleDocumentClick,
        option: item,
        preview
      },
      item.id
    ),
    [currentUser, handleDocumentClick, preview]
  );
  return loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : !hasOptions && searchQuery ? /* @__PURE__ */ jsxRuntime.jsx(
    ContentFlex,
    {
      align: "center",
      flex: 1,
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "new-document.no-results", values: { searchQuery } }) })
    }
  ) : hasOptions ? /* @__PURE__ */ jsxRuntime.jsx(
    CommandList,
    {
      activeItemDataAttr: "data-hovered",
      ariaLabel: t2("new-document.new-document"),
      autoFocus: supportsTouch ? void 0 : "input",
      getItemDisabled,
      inputElement: textInputElement,
      itemHeight: INLINE_PREVIEW_HEIGHT,
      items: options,
      overscan: 5,
      padding: preview === "inline" ? 1 : 2,
      paddingBottom: 0,
      renderItem
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ContentFlex,
    {
      align: "center",
      flex: 1,
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t2("new-document.no-document-types-found") })
    }
  );
}
const MAX_DISPLAYED_ITEMS = 10;
function NewDocumentButton(props2) {
  const { canCreateDocument, modal = "popover", loading, options } = props2, [open, setOpen] = React.useState(!1), [searchQuery, setSearchQuery] = React.useState(""), [popoverElement, setPopoverElement] = React.useState(null), [dialogElement, setDialogElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), [searchInputElement, setSearchInputElement] = React.useState(null), { t: t2 } = useTranslation(), getI18nText = useGetI18nText(options), { scheme } = useColorScheme(), currentUser = useCurrentUser(), schema2 = useSchema(), hasNewDocumentOptions = options.length > 0, disabled = !canCreateDocument || !hasNewDocumentOptions, placeholder = t2("new-document.filter-placeholder"), title = t2("new-document.title"), openDialogAriaLabel = t2("new-document.open-dialog-aria-label"), validOptions = React.useMemo(
    () => options.filter((option) => {
      const optionSchema = schema2.get(option.schemaType);
      return optionSchema && !types.isDeprecatedSchemaType(optionSchema);
    }),
    [options, schema2]
  ), filteredOptions = React.useMemo(
    () => filterOptions(validOptions, searchQuery, getI18nText),
    [validOptions, searchQuery, getI18nText]
  ), handleSearchChange = React.useCallback((event) => {
    setSearchQuery(event.currentTarget.value);
  }, []), handleToggleOpen = React.useCallback(() => setOpen((v) => !v), []), handleClose = React.useCallback(() => {
    setOpen(!1), setSearchQuery(""), buttonElement == null || buttonElement.focus();
  }, [buttonElement]), handleOpenButtonKeyDown = React.useCallback(
    (e) => {
      e.key === "ArrowDown" && !open && setOpen(!0);
    },
    [open]
  ), handlePopoverKeyDown = React.useCallback(
    (e) => {
      (e.key === "Escape" || e.key === "Tab") && open && handleClose();
    },
    [handleClose, open]
  );
  ui.useClickOutside(() => {
    open && handleClose();
  }, [buttonElement, dialogElement, popoverElement]);
  const sharedListProps = React.useMemo(
    () => ({
      currentUser,
      loading,
      onDocumentClick: handleToggleOpen,
      options: filteredOptions,
      searchQuery,
      preview: modal === "popover" ? "inline" : "default",
      textInputElement: searchInputElement
    }),
    [
      currentUser,
      filteredOptions,
      handleToggleOpen,
      loading,
      modal,
      searchInputElement,
      searchQuery
    ]
  ), sharedTextInputProps = React.useMemo(
    () => ({
      __unstable_disableFocusRing: !0,
      border: !1,
      "data-testid": "new-document-button-search-input",
      defaultValue: searchQuery,
      disabled: loading,
      icon: icons.SearchIcon,
      onChange: handleSearchChange,
      placeholder,
      ref: setSearchInputElement
    }),
    [handleSearchChange, loading, placeholder, searchQuery]
  ), sharedOpenButtonProps = React.useMemo(
    () => ({
      "aria-label": openDialogAriaLabel,
      "data-testid": "new-document-button",
      disabled: disabled || loading,
      icon: icons.AddIcon,
      text: t2("new-document.button"),
      mode: "ghost",
      onClick: handleToggleOpen,
      ref: setButtonElement,
      selected: open
    }),
    [disabled, handleToggleOpen, loading, open, openDialogAriaLabel, t2]
  ), tooltipContent = React.useMemo(() => hasNewDocumentOptions ? canCreateDocument ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("new-document.create-new-document-label") }) : /* @__PURE__ */ jsxRuntime.jsx(InsufficientPermissionsMessage, { currentUser, context: "create-any-document" }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("new-document.no-document-types-label") }), [canCreateDocument, currentUser, hasNewDocumentOptions, t2]), sharedTooltipProps = React.useMemo(
    () => ({
      content: tooltipContent,
      disabled: loading || open,
      scheme
    }),
    [loading, open, scheme, tooltipContent]
  );
  return modal === "dialog" ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { ...sharedTooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { ...sharedOpenButtonProps }) }) }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      StyledDialog,
      {
        header: title,
        id: "create-new-document-dialog",
        onClickOutside: handleClose,
        onClose: handleClose,
        ref: setDialogElement,
        scheme,
        width: 1,
        children: /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$1, { direction: "column", flex: 1, height: "fill", children: [
          /* @__PURE__ */ jsxRuntime.jsx(DialogHeaderCard, { padding: 2, borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.TextInput,
            {
              "data-testid": "new-document-button-search-input",
              ...sharedTextInputProps
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsx(NewDocumentList, { ...sharedListProps }) })
        ] })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover$1,
    {
      constrainSize: !0,
      onKeyDown: handlePopoverKeyDown,
      open,
      portal: !0,
      radius: 3,
      ref: setPopoverElement,
      scheme,
      content: /* @__PURE__ */ jsxRuntime.jsxs(
        RootFlex$1,
        {
          direction: "column",
          flex: 1,
          forwardedAs: FocusLock__default.default,
          height: "fill",
          returnFocus: !0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(PopoverHeaderCard, { sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...sharedTextInputProps, fontSize: 1, radius: 1 }) }) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(
              PopoverListFlex,
              {
                $itemHeight: INLINE_PREVIEW_HEIGHT,
                $maxDisplayedItems: MAX_DISPLAYED_ITEMS,
                direction: "column",
                overflow: "hidden",
                children: /* @__PURE__ */ jsxRuntime.jsx(NewDocumentList, { ...sharedListProps })
              }
            )
          ]
        }
      ),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { ...sharedTooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          ...sharedOpenButtonProps,
          "aria-expanded": open,
          "aria-haspopup": "true",
          onKeyDown: handleOpenButtonKeyDown
        }
      ) }) }) })
    }
  );
}
function useNewDocumentOptions() {
  const {
    __internal: { staticInitialValueTemplateItems }
  } = useSource(), [permissions, loading] = useTemplatePermissions({
    templateItems: staticInitialValueTemplateItems
  }), canCreateDocument = (permissions == null ? void 0 : permissions.some((p) => staticInitialValueTemplateItems.some((t2) => t2.id === p.id))) || !1, optionsWithPermissions = React.useMemo(() => staticInitialValueTemplateItems.map((item) => {
    var _a2;
    return {
      ...item,
      title: (item == null ? void 0 : item.title) || item.id,
      hasPermission: ((_a2 = permissions == null ? void 0 : permissions.find((p) => p.id === item.id)) == null ? void 0 : _a2.granted) || !1
    };
  }), [permissions, staticInitialValueTemplateItems]);
  return {
    canCreateDocument,
    loading,
    options: optionsWithPermissions
  };
}
const PresenceMenuItem = React.memo(function(props2) {
  const { presence, focused, onFocus } = props2, [menuItemElement, setMenuItemElement] = React.useState(null), { t: t2 } = useTranslation(), lastActiveLocation = orderBy__default.default(presence.locations || [], ["lastActiveAt"], ["desc"]).find(
    (location) => location.documentId
  ), hasLink = !!(lastActiveLocation != null && lastActiveLocation.documentId);
  React.useEffect(() => {
    focused && menuItemElement && (menuItemElement.focus(), menuItemElement.setAttribute("data-selected", "")), focused || menuItemElement == null || menuItemElement.removeAttribute("data-selected");
  }, [menuItemElement, focused]);
  const handleFocus = React.useCallback(() => {
    onFocus(presence.user.id);
  }, [onFocus, presence.user.id]), LinkComponent = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(linkProps, ref) {
        return lastActiveLocation != null && lastActiveLocation.path ? /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...linkProps,
            intent: "edit",
            params: {
              id: lastActiveLocation == null ? void 0 : lastActiveLocation.documentId,
              path: PathUtils__namespace.toString(lastActiveLocation == null ? void 0 : lastActiveLocation.path)
            },
            ref
          }
        ) : null;
      })
    ),
    [lastActiveLocation]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      as: lastActiveLocation ? LinkComponent : "div",
      "data-as": "a",
      disabled: !hasLink,
      onFocus: handleFocus,
      preview: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: presence.user }, presence.user.id),
      ref: setMenuItemElement,
      text: presence.user.displayName,
      tooltipProps: hasLink ? void 0 : { content: t2("presence.not-in-a-document"), placement: "left" }
    }
  );
}), StyledMenu$2 = styled__default.default(ui.Menu)`
  max-width: 260px;
`, FooterStack = styled__default.default(ui.Stack)`
  position: sticky;
  bottom: 0;
  background-color: var(--card-bg-color);
`;
function PresenceMenu() {
  const presence = useGlobalPresence(), { projectId } = useWorkspace(), { scheme } = useColorScheme(), { t: t2 } = useTranslation(), hasPresence = presence.length > 0, [focusedId, setFocusedId] = React.useState(), handleItemFocus = React.useCallback((id2) => {
    setFocusedId(id2);
  }, []), handleClearFocusedItem = React.useCallback(() => {
    setFocusedId("");
  }, []), handleClose = React.useCallback(() => {
    setFocusedId("");
  }, []), button = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsx(
    StatusButton,
    {
      icon: icons.UsersIcon,
      mode: "bleed",
      tone: hasPresence ? "positive" : void 0,
      tooltipProps: {
        content: t2("presence.tooltip-content")
      }
    }
  ), [hasPresence, t2]), popoverProps = React.useMemo(
    () => ({
      constrainSize: !0,
      fallbackPlacements: ["bottom"],
      placement: "bottom",
      portal: !0,
      scheme
    }),
    [scheme]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button,
      "aria-label": t2("presence.aria-label"),
      id: "global-presence-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu$2, { children: [
        hasPresence && presence.map((item) => /* @__PURE__ */ jsxRuntime.jsx(
          PresenceMenuItem,
          {
            focused: focusedId === item.user.id,
            onFocus: handleItemFocus,
            presence: item
          },
          item.user.id
        )),
        !hasPresence && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: t2("presence.no-one-else-title") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("presence.no-one-else-description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(FooterStack, { space: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              as: "a",
              href: `https://sanity.io/manage/project/${projectId}`,
              iconRight: icons.CogIcon,
              onFocus: handleClearFocusedItem,
              rel: "noopener noreferrer",
              target: "_blank",
              text: t2("presence.action.manage-members")
            }
          )
        ] })
      ] }),
      onClose: handleClose,
      popover: popoverProps
    }
  );
}
function getHelpResources(client2, locale) {
  return client2.withConfig({ apiVersion: "1" }).observable.request({
    url: "/help",
    /*
      query and tag is used by analytics for tracking.
      Builds to: `{m: ['sanity@3.0.2']}' and serializes to: `?m=sanity@3.0.2`.
      Final format will be e.g. https://api.sanity.io/v1/help?tag=sanity.studio.module.version-check&m=sanity%403.0.2
      */
    query: { m: [`sanity@${SANITY_VERSION}`], locale },
    tag: "module.version-check",
    json: !0
  });
}
function useGetHelpResources() {
  const client2 = useClient({ apiVersion: "1" }), locale = getJsonStream.useCurrentLocale().id, moduleStatus$ = React.useMemo(() => getHelpResources(client2, locale), [client2, locale]);
  return useLoadable(moduleStatus$);
}
function ResourcesMenuItems({ error, isLoading, value }) {
  var _a2;
  const sections = (_a2 = value == null ? void 0 : value.resources) == null ? void 0 : _a2.sectionArray, latestStudioVersion = value == null ? void 0 : value.latestVersion, { t: t2 } = useTranslation();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 });
  const fallbackLinks = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.join-our-community"),
        href: "https://www.sanity.io/exchange/community",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.help-and-support"),
        href: "https://www.sanity.io/contact/support",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.contact-sales"),
        href: "https://www.sanity.io/contact/sales?ref=studio",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
  ] });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    (value === void 0 || error) && /* @__PURE__ */ jsxRuntime.jsx("div", { children: fallbackLinks }),
    !error && (sections == null ? void 0 : sections.map((subSection) => subSection ? /* @__PURE__ */ jsxRuntime.jsx(SubSection, { subSection }, subSection._key) : null)),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", textOverflow: "ellipsis", children: t2("help-resources.studio-version", { studioVersion: SANITY_VERSION }) }),
      !error && latestStudioVersion && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: t2("help-resources.latest-sanity-version", {
        latestVersion: latestStudioVersion
      }) }) })
    ] })
  ] });
}
function SubSection({ subSection }) {
  var _a2;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    (_a2 = subSection == null ? void 0 : subSection.items) == null ? void 0 : _a2.map((item) => {
      if (!item || !item.title)
        return null;
      switch (item._type) {
        case "externalLink":
          return item.url ? /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              as: "a",
              tone: "default",
              text: item.title,
              href: item.url,
              target: "_blank"
            },
            item._key
          ) : null;
        case "internalAction":
          return item.type ? item.type === "show-welcome-modal" && /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.MenuItem, { text: item.title }, item._key) : null;
        default:
          return null;
      }
    }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
  ] });
}
const StyledMenu$1 = styled__default.default(ui.Menu)`
  max-width: 300px;
  min-width: 200px;
`;
function ResourcesButton() {
  const { t: t2 } = useTranslation(), { value, error, isLoading } = useGetHelpResources();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t2("help-resources.title"),
          icon: icons.HelpCircleIcon,
          mode: "bleed",
          tooltipProps: { content: t2("help-resources.title") }
        }
      ),
      id: "menu-button-resources",
      menu: /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$1, { children: /* @__PURE__ */ jsxRuntime.jsx(ResourcesMenuItems, { error, isLoading, value }) }),
      popover: { constrainSize: !0 }
    }
  );
}
function LocaleMenu() {
  return getJsonStream.useLocale(), null;
}
function AppearanceMenu({
  setScheme
}) {
  const { t: t2 } = useTranslation(), options = useColorSchemeOptions(setScheme, t2);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    options.map(({ icon, label, name, onSelect, selected, title }) => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        "aria-label": label,
        icon,
        onClick: onSelect,
        pressed: selected,
        text: title,
        iconRight: selected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {})
      },
      name
    ))
  ] });
}
const Root$5 = styled__default.default.div`
  position: absolute;
  width: 18px;
  height: 18px;
  background: var(--card-bg-color);
  bottom: -4px;
  right: -4px;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px solid var(--card-bg-color);
  box-sizing: content-box;

  svg {
    box-sizing: content-box;
    border: 1px solid var(--card-hairline-soft-color);
    border-radius: 50%;
    padding: 2px;
    width: 12px;
    height: 12px;
  }

  &[data-logo='github'] {
    svg {
      path {
        fill: var(--card-fg-color);
      }
    }
  }

  &[data-logo='saml'] {
    svg {
      path {
        fill: var(--card-fg-color);
      }
    }
  }
`, Google = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsxs("g", { clipPath: "url(#clip0)", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M12 6.13764C12 5.72977 11.9663 5.31971 11.8943 4.91846H6.12036V7.22895H9.42684C9.28963 7.97412 8.84876 8.63332 8.20322 9.05221V10.5514H10.1759C11.3342 9.50637 12 7.9631 12 6.13764Z",
        fill: "#4285F4"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M6.12019 12.0002C7.77118 12.0002 9.16349 11.4688 10.1779 10.5517L8.20529 9.05253C7.65646 9.41851 6.94793 9.62574 6.12244 9.62574C4.52544 9.62574 3.17136 8.56971 2.68552 7.1499H0.649902V8.69537C1.68908 10.7215 3.80567 12.0002 6.12019 12.0002V12.0002Z",
        fill: "#34A853"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M2.68332 7.14986C2.4269 6.40469 2.4269 5.59778 2.68332 4.8526V3.30713H0.649951C-0.218278 5.00252 -0.218278 6.99995 0.649951 8.69533L2.68332 7.14986V7.14986Z",
        fill: "#FBBC04"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M6.12019 2.37483C6.99291 2.3616 7.8364 2.68348 8.46845 3.27433L10.2161 1.56131C9.1095 0.542752 7.64071 -0.017233 6.12019 0.000404333C3.80566 0.000404333 1.68908 1.27911 0.649902 3.3074L2.68326 4.85288C3.16686 3.43087 4.52319 2.37483 6.12019 2.37483V2.37483Z",
        fill: "#EA4335"
      }
    )
  ] }),
  /* @__PURE__ */ jsxRuntime.jsx("defs", { children: /* @__PURE__ */ jsxRuntime.jsx("clipPath", { id: "clip0", children: /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "12", height: "12", fill: "white" }) }) })
] }), GitHub = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsx("g", { clipPath: "url(#clip0)", children: /* @__PURE__ */ jsxRuntime.jsx(
    "path",
    {
      d: "M11.195 3.13503C10.6711 2.22838 9.91808 1.47537 9.01144 0.951471C8.09222 0.414976 7.08837 0.146729 5.99987 0.146729C4.91137 0.146729 3.90752 0.414976 2.98831 0.951471C2.08163 1.47534 1.32862 2.22836 0.804744 3.13503C0.268248 4.05497 0 5.05883 0 6.14659C0 7.45399 0.381531 8.62978 1.14459 9.67394C1.90765 10.7181 2.89327 11.4408 4.10143 11.8419C4.24208 11.868 4.34624 11.8497 4.41392 11.7872C4.44666 11.7577 4.47263 11.7215 4.49006 11.681C4.50749 11.6405 4.51595 11.5967 4.51488 11.5527C4.51488 11.537 4.51361 11.3963 4.51105 11.1307C4.5085 10.8651 4.50722 10.6334 4.50722 10.4355L4.32745 10.4666C4.18407 10.4895 4.03885 10.4986 3.89375 10.494C3.71159 10.4908 3.53001 10.4725 3.35087 10.4393C3.16049 10.4045 2.98119 10.3246 2.82796 10.2064C2.66705 10.0846 2.54715 9.91661 2.48428 9.72484L2.40602 9.54506C2.34022 9.40286 2.25754 9.2691 2.15976 9.14666C2.04775 9.00072 1.93447 8.90176 1.81991 8.84977L1.76518 8.81064C1.72769 8.78356 1.6936 8.75205 1.66367 8.71679C1.63479 8.6841 1.61108 8.64719 1.59334 8.60734C1.57766 8.57085 1.5907 8.54085 1.63247 8.51731C1.67461 8.49405 1.75123 8.48256 1.86068 8.48256L2.01692 8.50582C2.12108 8.52662 2.24996 8.5891 2.40356 8.69326C2.5585 8.79876 2.68797 8.93748 2.78254 9.09932C2.90239 9.31294 3.04695 9.47575 3.21624 9.58775C3.38552 9.69976 3.55609 9.75576 3.72793 9.75576C3.87725 9.7578 4.02641 9.74479 4.17312 9.7169C4.29459 9.69195 4.41264 9.65254 4.52473 9.59952C4.57162 9.25037 4.69931 8.98212 4.90782 8.79477C4.63684 8.76849 4.36827 8.72157 4.10444 8.6544C3.84797 8.58382 3.60133 8.48141 3.37029 8.34958C3.12825 8.218 2.91442 8.04015 2.74095 7.82613C2.57421 7.6178 2.4374 7.34417 2.3305 7.00524C2.2236 6.6663 2.1707 6.27584 2.1718 5.83383C2.1718 5.20357 2.37757 4.66708 2.7891 4.22435C2.59629 3.75006 2.61453 3.21885 2.84383 2.63073C2.99487 2.58385 3.21879 2.61897 3.51559 2.73608C3.81239 2.85319 4.02983 2.95352 4.16792 3.03707C4.30601 3.12025 4.41665 3.19058 4.49983 3.24804C5.48153 2.9773 6.51821 2.9773 7.49991 3.24804L7.79679 3.0606C8.0249 2.92356 8.26549 2.80849 8.51535 2.71693C8.79135 2.61276 9.00231 2.58412 9.14825 2.63101C9.38248 3.21949 9.40327 3.7507 9.21064 4.22462C9.62199 4.66735 9.82776 5.20385 9.82795 5.83411C9.82795 6.27684 9.77459 6.66904 9.66787 7.01071C9.56116 7.35238 9.42325 7.62601 9.25415 7.8316C9.07785 8.04326 8.86311 8.21966 8.62124 8.35149C8.39008 8.48329 8.14337 8.5857 7.88682 8.65632C7.62412 8.72277 7.35674 8.76915 7.087 8.79505C7.35698 9.02927 7.49206 9.3994 7.49225 9.90543V11.5527C7.49115 11.5964 7.49929 11.6398 7.51612 11.6802C7.53295 11.7206 7.5581 11.7569 7.58993 11.7869C7.65505 11.8493 7.75794 11.8675 7.89858 11.8416C9.10693 11.4403 10.0926 10.7177 10.8557 9.67367C11.6188 8.62968 12.0003 7.4539 12.0003 6.14632C11.9997 5.05873 11.7313 4.05497 11.195 3.13503V3.13503Z",
      fill: "black"
    }
  ) }),
  /* @__PURE__ */ jsxRuntime.jsx("defs", { children: /* @__PURE__ */ jsxRuntime.jsx("clipPath", { id: "clip0", children: /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "12", height: "12", fill: "white" }) }) })
] }), Saml = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "17", height: "9", viewBox: "0 0 17 9", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M0.0691681 5.98162C0.115833 7.24157 1.07247 8.00221 2.59841 8.00221C4.17102 8.00221 5.12299 7.19957 5.12299 5.86962C5.12299 4.83832 4.55367 4.25501 3.25172 3.96569L2.56108 3.80703C1.8331 3.64837 1.53445 3.38704 1.53445 2.91106C1.53445 2.40708 1.94977 2.09442 2.61708 2.09442C3.27505 2.09442 3.6997 2.43508 3.75103 2.99039H5.00166C4.95966 1.78643 4.01236 0.997795 2.60308 0.997795C1.14713 0.997795 0.218496 1.79577 0.218496 3.05105C0.218496 4.04968 0.815808 4.69366 2.03376 4.96898L2.73374 5.13231C3.51304 5.30497 3.8117 5.54763 3.8117 6.00495C3.8117 6.55093 3.34972 6.90092 2.62174 6.90092C1.85644 6.90092 1.38045 6.56493 1.31979 5.98162H0.0691681Z" }),
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M5.97695 5.98162C6.02362 7.24157 6.98025 8.00221 8.5062 8.00221C10.0788 8.00221 11.0308 7.19957 11.0308 5.86962C11.0308 4.83832 10.4615 4.25501 9.15951 3.96569L8.46886 3.80703C7.74089 3.64837 7.44223 3.38704 7.44223 2.91106C7.44223 2.40708 7.85755 2.09442 8.52486 2.09442C9.18284 2.09442 9.60749 2.43508 9.65882 2.99039H10.9094C10.8674 1.78643 9.92015 0.997795 8.51086 0.997795C7.05492 0.997795 6.12628 1.79577 6.12628 3.05105C6.12628 4.04968 6.72359 4.69366 7.94155 4.96898L8.64153 5.13231C9.42083 5.30497 9.71949 5.54763 9.71949 6.00495C9.71949 6.55093 9.2575 6.90092 8.52953 6.90092C7.76422 6.90092 7.28824 6.56493 7.22758 5.98162H5.97695Z" }),
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M16.9852 5.01565V3.98435C16.9852 2.11309 16.0099 0.997795 14.3953 0.997795C12.7807 0.997795 11.8054 2.11309 11.8054 3.98435V5.01565C11.8054 6.88692 12.7807 8.00221 14.3953 8.00221C16.0099 8.00221 16.9852 6.88692 16.9852 5.01565ZM14.3953 6.82625C13.5833 6.82625 13.154 6.21494 13.154 5.00165V3.99835C13.154 2.78506 13.5833 2.17375 14.3953 2.17375C15.2073 2.17375 15.6366 2.78506 15.6366 3.99835V5.00165C15.6366 6.21494 15.2073 6.82625 14.3953 6.82625Z" })
] }), LoginProviderLogo = ({ provider }) => {
  const isSaml = provider == null ? void 0 : provider.startsWith("saml-");
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$5, { "data-logo": isSaml ? "saml" : provider, children: [
    provider === "google" && Google,
    provider === "github" && GitHub,
    provider === "sanity" && /* @__PURE__ */ jsxRuntime.jsx(logos.SanityMonogram, {}),
    isSaml && Saml
  ] });
};
function ManageMenu() {
  const { currentUser, projectId } = useWorkspace(), isAdmin = !!(currentUser && userHasRole(currentUser, "administrator")), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        "aria-label": t2("user-menu.action.manage-project-aria-label"),
        href: `https://sanity.io/manage/project/${projectId}`,
        target: "_blank",
        text: t2("user-menu.action.manage-project"),
        icon: icons.CogIcon
      }
    ),
    isAdmin && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuItem,
      {
        as: "a",
        "aria-label": t2("user-menu.action.invite-members-aria-label"),
        href: `https://sanity.io/manage/project/${projectId}/members`,
        target: "_blank",
        text: t2("user-menu.action.invite-members"),
        icon: icons.UsersIcon
      }
    )
  ] });
}
const StyledMenu = styled__default.default(ui.Menu)`
  min-width: 200px;
  max-width: 300px;
`, AvatarBox = styled__default.default(ui.Box)`
  position: relative;
  min-width: ${({ theme: theme2 }) => theme2.sanity.avatar.sizes[2].size}px;
  min-height: ${({ theme: theme2 }) => theme2.sanity.avatar.sizes[2].size}px;
`;
function UserMenu() {
  const { currentUser, auth } = useWorkspace(), scheme = useColorSchemeValue(), setScheme = useColorSchemeSetValue(), providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider), { t: t2 } = useTranslation(), popoverProps = React.useMemo(
    () => ({
      placement: "bottom",
      portal: !0,
      preventOverflow: !0,
      scheme,
      constrainSize: !0
    }),
    [scheme]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "bleed", padding: 0, radius: "full", children: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: "me" }) }),
      id: "user-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Tooltip,
            {
              disabled: !providerTitle,
              portal: !0,
              content: t2("user-menu.login-provider", { providerTitle }),
              children: /* @__PURE__ */ jsxRuntime.jsxs(AvatarBox, { marginRight: 3, children: [
                /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 2, user: "me" }),
                (currentUser == null ? void 0 : currentUser.provider) && /* @__PURE__ */ jsxRuntime.jsx(LoginProviderLogo, { provider: currentUser.provider })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, flex: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.name }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.email })
          ] })
        ] }) }),
        setScheme && /* @__PURE__ */ jsxRuntime.jsx(AppearanceMenu, { setScheme }),
        /* @__PURE__ */ jsxRuntime.jsx(LocaleMenu, {}),
        /* @__PURE__ */ jsxRuntime.jsx(ManageMenu, {}),
        auth.logout && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              iconRight: icons.LeaveIcon,
              text: t2("user-menu.action.sign-out"),
              disabled: !auth.logout,
              ...auth.logout && { onClick: auth.logout }
            }
          )
        ] })
      ] }),
      popover: popoverProps
    }
  );
}
const EMPTY_ARRAY$2 = [], RootLayer = styled__default.default(ui.Layer)`
  min-height: auto;
  position: relative;

  &[data-search-open='true'] {
    top: 0;
    position: sticky;
  }
`, RootCard = styled__default.default(ui.Card)`
  line-height: 0;
`, NavGrid = styled__default.default(ui.Grid)`
  grid-template-columns: auto auto auto;
  @media screen and (min-width: ${({ theme: theme2 }) => `${theme2.sanity.media[3]}px`}) {
    grid-template-columns: 1fr auto 1fr;
  }
`;
function StudioNavbar(props2) {
  const {
    // eslint-disable-next-line camelcase
    __internal_actions: actions = EMPTY_ARRAY$2
  } = props2, { name, tools } = useWorkspace(), routerState = router.useRouterState(), mediaIndex = ui.useMediaIndex(), activeToolName = typeof routerState.tool == "string" ? routerState.tool : void 0, newDocumentOptions = useNewDocumentOptions(), { t: t2 } = useTranslation(), {
    onSearchFullscreenOpenChange,
    onSearchOpenChange,
    searchFullscreenOpen,
    searchFullscreenPortalEl,
    searchOpen
  } = React.useContext(NavbarContext), ToolMenu = useToolMenuComponent(), [drawerOpen, setDrawerOpen] = React.useState(!1), routerStateRef = React.useRef(routerState), workspaceNameRef = React.useRef(name);
  React.useEffect(() => {
    (routerStateRef.current.tool !== routerState.tool || name !== workspaceNameRef.current) && setDrawerOpen(!1), routerStateRef.current = routerState, workspaceNameRef.current = name;
  }, [name, routerState]);
  const [drawerButtonEl, setDrawerButtonEl] = React.useState(null), [searchOpenButtonEl, setSearchOpenButtonEl] = React.useState(null), shouldRender = React.useMemo(
    () => ({
      resources: mediaIndex > 1,
      collapsedPresenceMenu: mediaIndex <= 1,
      loginStatus: mediaIndex > 1,
      searchFullscreen: mediaIndex <= 1,
      configIssues: mediaIndex > 1 && isDev,
      newDocumentFullscreen: mediaIndex <= 1,
      tools: mediaIndex >= 3
    }),
    [mediaIndex]
  );
  React.useEffect(() => {
    onSearchFullscreenOpenChange(searchFullscreenOpen);
  }, [searchFullscreenOpen, onSearchFullscreenOpenChange]), React.useEffect(() => {
    shouldRender.searchFullscreen ? onSearchOpenChange(!1) : onSearchFullscreenOpenChange(!1);
  }, [onSearchFullscreenOpenChange, onSearchOpenChange, shouldRender.searchFullscreen]);
  const handleOpenSearch = React.useCallback(() => {
    onSearchOpenChange(!0);
  }, [onSearchOpenChange]), handleOpenSearchFullscreen = React.useCallback(() => {
    onSearchFullscreenOpenChange(!0);
  }, [onSearchFullscreenOpenChange]), handleCloseSearch = React.useCallback(() => {
    onSearchOpenChange(!1);
  }, [onSearchOpenChange]), handleCloseSearchFullscreen = React.useCallback(() => {
    onSearchFullscreenOpenChange(!1), searchOpenButtonEl == null || searchOpenButtonEl.focus();
  }, [onSearchFullscreenOpenChange, searchOpenButtonEl]), handleCloseDrawer = React.useCallback(() => {
    setDrawerOpen(!1), drawerButtonEl == null || drawerButtonEl.focus();
  }, [drawerButtonEl]), handleOpenDrawer = React.useCallback(() => {
    setDrawerOpen(!0);
  }, []), actionNodes = React.useMemo(() => {
    var _a2;
    return shouldRender.tools ? (_a2 = actions == null ? void 0 : actions.filter((v) => v.location === "topbar")) == null ? void 0 : _a2.map((action) => /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        iconRight: action == null ? void 0 : action.icon,
        mode: "bleed",
        onClick: action == null ? void 0 : action.onAction,
        selected: action.selected,
        text: action.title
      },
      action.name
    )) : null;
  }, [actions, shouldRender.tools]);
  return /* @__PURE__ */ jsxRuntime.jsx(FreeTrialProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(RootLayer, { zOffset: 100, "data-search-open": searchFullscreenOpen, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      RootCard,
      {
        borderBottom: !0,
        "data-testid": "studio-navbar",
        "data-ui": "Navbar",
        padding: 3,
        sizing: "border",
        children: /* @__PURE__ */ jsxRuntime.jsxs(NavGrid, { gap: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "flex-start", children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
              !shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
                getJsonStream.Button,
                {
                  mode: "bleed",
                  icon: icons.MenuIcon,
                  onClick: handleOpenDrawer,
                  ref: setDrawerButtonEl,
                  tooltipProps: { content: t2("user-menu.open-menu"), placement: "bottom" }
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
                /* @__PURE__ */ jsxRuntime.jsx(HomeButton, {}),
                /* @__PURE__ */ jsxRuntime.jsx(WorkspaceMenuButton, {})
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntime.jsx(
              NewDocumentButton,
              {
                ...newDocumentOptions,
                modal: shouldRender.newDocumentFullscreen ? "dialog" : "popover"
              }
            ),
            !shouldRender.searchFullscreen && /* @__PURE__ */ jsxRuntime.jsx(SearchButton, { onClick: handleOpenSearch, ref: setSearchOpenButtonEl })
          ] }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", children: shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
            ToolMenu,
            {
              activeToolName,
              closeSidebar: handleCloseDrawer,
              context: "topbar",
              isSidebarOpen: !1,
              tools
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "flex-end", children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(SearchProvider, { fullscreen: shouldRender.searchFullscreen, children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: document.body, children: shouldRender.searchFullscreen ? /* @__PURE__ */ jsxRuntime.jsx(ui.PortalProvider, { element: searchFullscreenPortalEl, children: /* @__PURE__ */ jsxRuntime.jsx(
                SearchDialog,
                {
                  onClose: handleCloseSearchFullscreen,
                  onOpen: handleOpenSearchFullscreen,
                  open: searchFullscreenOpen
                }
              ) }) : /* @__PURE__ */ jsxRuntime.jsx(
                SearchPopover,
                {
                  onClose: handleCloseSearch,
                  onOpen: handleOpenSearch,
                  open: searchOpen
                }
              ) }) }) }),
              shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(FreeTrial, { type: "topbar" }),
              shouldRender.configIssues && /* @__PURE__ */ jsxRuntime.jsx(ConfigIssuesButton, {}),
              shouldRender.resources && /* @__PURE__ */ jsxRuntime.jsx(ResourcesButton, {}),
              /* @__PURE__ */ jsxRuntime.jsx(PresenceMenu, {}),
              shouldRender.searchFullscreen && /* @__PURE__ */ jsxRuntime.jsx(
                SearchButton,
                {
                  onClick: handleOpenSearchFullscreen,
                  ref: setSearchOpenButtonEl
                }
              ),
              actionNodes
            ] }),
            shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(UserMenu, {}) })
          ] }) })
        ] })
      }
    ),
    !shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
      NavDrawer,
      {
        __internal_actions: actions,
        activeToolName,
        isOpen: drawerOpen,
        onClose: handleCloseDrawer,
        tools
      }
    )
  ] }) });
}
function _isReactElement(node) {
  return !!node;
}
const OptionObserveElement = styled__default.default(ObserveElement)`
  list-style: none;
  white-space: nowrap;
  flex-shrink: 0;
  opacity: 0;
  visibility: hidden;
`, HiddenRow = styled__default.default(ui.Flex)`
  opacity: 0;
  height: 0.1px;
  overflow: hidden;
`, CollapseTabList = React.forwardRef(function(props2, ref) {
  const {
    children: childrenProp,
    gap,
    menuButtonProps,
    disableRestoreFocusOnClose,
    onMenuClose,
    collapsed,
    ...rest
  } = props2, [rootEl, setRootEl] = React.useState(null), [hiddenElements, setHiddenElements] = React.useState([]), [showChildren, setShowChildren] = React.useState(!1), children = React.useMemo(
    () => React.Children.toArray(childrenProp).filter(_isReactElement),
    [childrenProp]
  ), displayChildren = React.useMemo(() => collapsed || !showChildren ? null : children.filter((c) => !hiddenElements.some((h) => h.key === c.key)), [children, collapsed, hiddenElements, showChildren]), intersectionOptions = React.useMemo(
    () => ({
      root: rootEl,
      threshold: 1,
      rootMargin: "1px"
    }),
    [rootEl]
  ), menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  ), menuOptionsArray = React.useMemo(
    () => collapsed ? children : (
      // eslint-disable-next-line max-nested-callbacks
      children.filter(({ key }) => hiddenElements.find((o) => o.key === key))
    ),
    [children, hiddenElements, collapsed]
  ), handleIntersection = React.useCallback(
    (e, child) => {
      const isHidden = hiddenElements.some((el) => el.key === child.key);
      showChildren || setShowChildren(!0);
      const isIntersecting = e.isIntersecting;
      !isHidden && !isIntersecting && setHiddenElements((prev) => [...prev, child]), isHidden && isIntersecting && setHiddenElements((prev) => prev.filter((el) => el.key !== child.key));
    },
    [hiddenElements, showChildren, setShowChildren, setHiddenElements]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", ref, sizing: "border", style: { position: "relative" }, ...rest, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "center", gap, flex: 1, children: [
      displayChildren,
      (hiddenElements.length > 0 || collapsed) && /* @__PURE__ */ jsxRuntime.jsx(
        CollapseOverflowMenu,
        {
          disableRestoreFocusOnClose,
          menuButton,
          menuButtonProps,
          menuOptions: menuOptionsArray,
          onMenuClose
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(HiddenRow, { justify: "flex-start", gap, ref: setRootEl, "data-hidden": !0, "aria-hidden": "true", children: [
      React.cloneElement(menuButton, {
        disabled: !0,
        "aria-hidden": !0
      }),
      children == null ? void 0 : children.map((child) => /* @__PURE__ */ jsxRuntime.jsx(
        OptionObserveElement,
        {
          options: intersectionOptions,
          onIntersectionChange: (e) => handleIntersection(e[0], child),
          children: React.cloneElement(child, {
            disabled: !0,
            "aria-hidden": !0,
            tabIndex: -1
          })
        },
        `${child.key}_observer`
      ))
    ] })
  ] });
}), ToolLink = React.forwardRef(function(props2, ref) {
  const { name, ...rest } = props2, state = router.useRouterState(
    React.useCallback(
      () => ({
        tool: name,
        // make sure to clear tool state when navigating to another tool
        [name]: void 0
      }),
      [name]
    )
  );
  return /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, { state, ...rest, ref });
});
function ToolCollapseMenu(props2) {
  const { activeToolName, tools } = props2, { scheme } = useColorScheme(), [collapseMenuEl, setCollapseMenuEl] = React.useState(null);
  useRovingFocus({
    rootElement: collapseMenuEl,
    navigation: ["arrows"]
  });
  const menuButtonProps = React.useMemo(
    () => ({
      popover: {
        constrainSize: !0,
        portal: !0,
        scheme
      }
    }),
    [scheme]
  ), children = React.useMemo(
    () => tools.map((tool, index) => {
      const title = (tool == null ? void 0 : tool.title) || startCase__default.default(tool.name), Link2 = React.forwardRef(function(linkProps, ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(ToolLink, { ...linkProps, ref, name: tool.name, children: linkProps.children });
      });
      return /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          as: Link2,
          "data-as": "a",
          mode: "bleed",
          selected: activeToolName === tool.name,
          text: title
        },
        `${tool.name}-${index}`
      );
    }),
    [activeToolName, tools]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", marginX: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
    CollapseTabList,
    {
      "data-testid": "tool-collapse-menu",
      gap: 1,
      menuButtonProps,
      ref: setCollapseMenuEl,
      children
    }
  ) });
}
function ToolVerticalMenu(props2) {
  const { activeToolName, isVisible, tools } = props2;
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 1, children: tools.map((tool) => {
      const title = (tool == null ? void 0 : tool.title) || startCase__default.default(tool.name), Link2 = React.forwardRef(function(linkProps, ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(ToolLink, { ...linkProps, ref, name: tool.name, children: linkProps.children });
      });
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          as: Link2,
          justify: "flex-start",
          mode: "bleed",
          selected: activeToolName === tool.name,
          size: "large",
          tabIndex: isVisible ? 0 : -1,
          text: title
        }
      ) }, tool.name);
    }) }),
    [activeToolName, isVisible, tools]
  );
}
function StudioToolMenu(props2) {
  const { context, isSidebarOpen, tools, ...restProps } = props2;
  return tools.length <= 1 ? null : context === "sidebar" ? /* @__PURE__ */ jsxRuntime.jsx(ToolVerticalMenu, { isVisible: isSidebarOpen, tools, ...restProps }) : /* @__PURE__ */ jsxRuntime.jsx(ToolCollapseMenu, { tools, ...restProps });
}
const SCROLLBAR_SIZE = 12, SCROLLBAR_BORDER_SIZE = 4;
function buildResizeHandleDataUri(hexColor) {
  const encodedStrokeColor = encodeURIComponent(hexColor);
  return `url("data:image/svg+xml,${`%3Csvg width='9' height='9' viewBox='0 0 9 9' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 8L8 1' stroke='${encodedStrokeColor}' stroke-linecap='round'/%3E%3Cpath d='M5 8L8 5' stroke='${encodedStrokeColor}' stroke-linecap='round'/%3E%3C/svg%3E%0A`}")`;
}
const GlobalStyle = styled.createGlobalStyle((props2) => {
  const { color: color2, font } = theme.getTheme_v2(props2.theme);
  return styled.css`
    ::-webkit-resizer {
      background-image: ${buildResizeHandleDataUri(color2.icon)};
      background-repeat: no-repeat;
      background-position: bottom right;
    }

    ::-webkit-scrollbar {
      width: ${SCROLLBAR_SIZE}px;
      height: ${SCROLLBAR_SIZE}px;
    }

    ::-webkit-scrollbar-corner {
      background-color: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background-clip: content-box;
      background-color: var(--card-border-color, ${color2.border});
      border: ${SCROLLBAR_BORDER_SIZE}px solid transparent;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: var(--card-muted-fg-color, ${color2.muted.fg});
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    *::selection {
      background-color: ${theme.rgba(color2.focusRing, 0.3)};
    }

    html {
      background-color: ${color2.bg};
    }

    body {
      scrollbar-gutter: stable;
    }

    #sanity {
      font-family: ${font.text.family};
    }

    b {
      font-weight: ${font.text.weights.medium};
    }

    strong {
      font-weight: ${font.text.weights.medium};
    }
  `;
}), errorChannel = globalScope.__sanityErrorChannel;
function ErrorLogger() {
  const { push: pushToast } = ui.useToast();
  return React.useEffect(() => {
    if (errorChannel)
      return errorChannel.subscribe((msg) => {
        msg.error && (isKnownError(msg.error) || (console.error(msg.error), pushToast({
          // Use the error message as the ID in order to prevent duplicates from showing
          // A bit of a hack, but serves
          id: msg.error.message,
          closable: !0,
          description: msg.error.message,
          duration: 5e3,
          title: "Uncaught error",
          status: "error"
        })));
      });
  }, [pushToast]), null;
}
function isKnownError(err) {
  return err instanceof SchemaError || err instanceof CorsOriginError || err instanceof ConfigResolutionError;
}
function AuthBoundary({
  children,
  AuthenticateComponent = AuthenticateScreen,
  LoadingComponent = LoadingBlock,
  NotAuthenticatedComponent = NotAuthenticatedScreen
}) {
  const [error, handleError] = React.useState(null);
  if (error)
    throw error;
  const [loggedIn, setLoggedIn] = React.useState(
    "loading"
  ), { activeWorkspace } = useActiveWorkspace();
  return React.useEffect(() => {
    var _a2, _b;
    (_b = (_a2 = activeWorkspace.auth).handleCallbackUrl) == null || _b.call(_a2).catch(handleError);
  }, [activeWorkspace.auth]), React.useEffect(() => {
    const subscription = activeWorkspace.auth.state.subscribe({
      next: ({ authenticated, currentUser }) => {
        var _a2;
        if (((_a2 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a2.length) === 0) {
          setLoggedIn("unauthorized");
          return;
        }
        setLoggedIn(authenticated ? "logged-in" : "logged-out");
      },
      error: handleError
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]), loggedIn === "loading" ? /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {}) : loggedIn === "unauthorized" ? /* @__PURE__ */ jsxRuntime.jsx(NotAuthenticatedComponent, {}) : loggedIn === "logged-out" ? /* @__PURE__ */ jsxRuntime.jsx(AuthenticateComponent, {}) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
const Z_OFFSET = {
  toast: [100, 11e3]
}, sessionId = telemetry.createSessionId();
function StudioTelemetryProvider(props2) {
  const client2 = useClient({ apiVersion: "v2023-12-18" }), projectId = client2.config().projectId, store = React.useMemo(() => telemetry.createBatchedStore(sessionId, {
    // submit any pending events every <n> ms
    flushInterval: 3e4,
    // implements user consent resolving
    resolveConsent: () => client2.request({ uri: "/intake/telemetry-status" }),
    // implements sending events to backend
    sendEvents: (batch) => client2.request({
      uri: "/intake/batch",
      method: "POST",
      json: !0,
      body: { projectId, batch }
    }),
    // opts into a different strategy for sending events when the browser close, reload or navigate away from the current page
    sendBeacon: (batch) => navigator.sendBeacon(client2.getUrl("/intake/batch"), JSON.stringify({ projectId, batch }))
  }), [client2, projectId]);
  return React.useEffect(() => {
    store.logger.updateUserProperties({
      userAgent: navigator.userAgent,
      screen: {
        density: window.devicePixelRatio,
        height: window.screen.height,
        width: window.screen.width,
        innerHeight: window.innerHeight,
        innerWidth: window.innerWidth
      },
      studioVersion: SANITY_VERSION,
      plugins: arrify__default.default(props2.config).flatMap(
        (config) => {
          var _a2;
          return ((_a2 = config.plugins) == null ? void 0 : _a2.flatMap((plugin) => ({
            name: plugin.name || "<unnamed>"
          }))) || [];
        }
      )
    });
  }, [props2.config, store.logger]), /* @__PURE__ */ jsxRuntime.jsx(react.TelemetryProvider, { store, children: props2.children });
}
const defaultTheme = theme.buildTheme(), isThemerTheme = (theme2) => theme2.__themer === !0;
function getThemeValues(theme2) {
  var _a2, _b;
  return {
    ...defaultTheme,
    v2: theme2.v2,
    fonts: isThemerTheme(theme2) ? defaultTheme.fonts : (_a2 = theme2.fonts) != null ? _a2 : defaultTheme.fonts,
    color: (_b = theme2.color) != null ? _b : defaultTheme.color
  };
}
function StudioThemeProvider({ children }) {
  const theme2 = useActiveWorkspace().activeWorkspace.theme;
  if (theme2.__legacy) {
    const scheme = theme2.__dark ? "dark" : "light";
    return /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeSetValueContext.Provider, { value: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { scheme, theme: getThemeValues(theme2), children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children }) }) }) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { theme: getThemeValues(theme2), children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children }) });
}
const ListItem = styled__default.default(ui.Flex)``, ErrorMessageRoot = styled__default.default(ui.Box).attrs({ padding: 4 })``;
function ErrorMessage({ error, message, path, stack }) {
  React.useEffect(() => {
    console.error(error);
  }, [error]);
  const last = path[path.length - 1];
  return /* @__PURE__ */ jsxRuntime.jsxs(ErrorMessageRoot, { forwardedAs: ui.Flex, direction: "column", gap: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { weight: "medium", size: 3, children: [
      startCase__default.default(last.type),
      " Error"
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "critical", overflow: "auto", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: message }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { as: "ul", direction: "column", gap: 2, children: path.map(({ name, type }, index) => /* @__PURE__ */ jsxRuntime.jsxs(ListItem, { forwardedAs: "li", gap: 2, align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: name }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: type }) })
    ] }, index)) }),
    stack && /* @__PURE__ */ jsxRuntime.jsxs("details", { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "summary", children: "Stack Trace" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: stack }) })
    ] })
  ] });
}
function createRouter(opts) {
  const { basePath = "/", tools } = opts, toolRoute = router.route.create("/:tool", (toolParams) => {
    let tool = tools.find((current) => current.name === toolParams.tool);
    return !tool && toolParams.tool === "desk" && (tool = tools.find((current) => current.name === "structure")), tool ? router.route.scope(tool.name, "/", tool.router) : router.route.create("/");
  });
  return router.route.create(basePath, [router.route.intents("/intent"), toolRoute]);
}
function getOrderedTools(tools) {
  const config = {}.toolSwitcher || {}, order = config.order || [], hidden = config.hidden || [];
  if (!order.length && !hidden.length)
    return tools;
  const keyed = tools.reduce((target, tool) => {
    const title = tool.title || "<unknown>";
    if (!tool.name)
      return console.warn(`Tool "${title}" does not have the required "name" property`), target;
    if (target[tool.name]) {
      const existing = target[tool.name].tool.title;
      return console.warn(`Tools with duplicate name "${tool.name}" found ("${title}" and "${existing}")`), target;
    }
    const toolIndex = order.indexOf(tool.name);
    return target[tool.name] = {
      tool,
      index: toolIndex === -1 ? 1 / 0 : toolIndex
    }, target;
  }, {}), isVisible = (tool) => hidden.indexOf(tool.name) === -1, ret = tools.filter(isVisible);
  return ret.sort((tool1, tool2) => {
    const toolA = keyed[tool1.name], toolB = keyed[tool2.name], indexA = toolA ? toolA.index : 1 / 0, indexB = toolB ? toolB.index : 1 / 0;
    return indexA === indexB ? 0 : indexA - indexB;
  }), ret;
}
const WEIGHTED_CREATE_INTENT_PARAMS = ["template"], WEIGHTED_EDIT_INTENT_PARAMS = ["mode"];
function resolveUrlStateWithDefaultTool(tools, state) {
  const defaultTool = getOrderedTools(tools)[0];
  return !state || state.tool || !defaultTool ? state : Object.assign({}, state, {
    tool: defaultTool.name
  });
}
function makeBackwardsCompatible(tools, state) {
  return state && (getOrderedTools(tools).find((tool) => tool.name === state.space) ? { ...state, tool: state.space, space: void 0 } : state);
}
function resolveDefaultState(tools, state) {
  return resolveUrlStateWithDefaultTool(
    tools,
    makeBackwardsCompatible(tools, state)
  );
}
function resolveIntentState(tools, prevState, nextState) {
  var _a2;
  const { intent, params, payload } = nextState;
  if (typeof intent != "string")
    throw new Error("intent must be a string");
  if (!isRecord$4(params))
    throw new Error("intent params must be a string");
  const orderedTools = getOrderedTools(tools), currentTool = prevState != null && prevState.tool ? orderedTools.find((tool) => tool.name === prevState.tool) : null, otherTools = currentTool ? orderedTools.filter((tool) => tool !== currentTool) : orderedTools;
  let weightedParams = [];
  intent === "create" ? weightedParams = WEIGHTED_CREATE_INTENT_PARAMS : intent === "edit" && (weightedParams = WEIGHTED_EDIT_INTENT_PARAMS);
  const initialMatch = { score: -1, tool: null }, { tool: matchingTool } = (currentTool ? [currentTool, ...otherTools] : orderedTools).reduce(
    (prev, tool) => {
      if (!tool || typeof tool.canHandleIntent != "function")
        return prev;
      const canHandle = tool.canHandleIntent(intent, params, prevState && prevState[tool.name]);
      if (typeof canHandle == "boolean")
        return canHandle && prev.score < 0 ? { score: 0, tool } : prev;
      if (!isRecord$4(canHandle))
        return prev;
      const score = weightedParams.reduce((prevScore, weightedParam) => weightedParam in params && canHandle[weightedParam] === !0 ? prevScore + 1 : prevScore, 0);
      return score > prev.score ? { score, tool } : prev;
    },
    initialMatch
  );
  if (matchingTool != null && matchingTool.getIntentState) {
    const _toolState = matchingTool.getIntentState(
      intent,
      params,
      prevState && prevState[matchingTool.name],
      payload
    ), { _searchParams, ...toolState } = _toolState, nextUrlState = {
      ...prevState,
      tool: matchingTool.name,
      [matchingTool.name]: toolState
    };
    return (_a2 = matchingTool.router) != null && _a2.__unsafe_disableScopedSearchParams ? nextUrlState._searchParams = _searchParams : toolState._searchParams = _searchParams, {
      type: "state",
      isNotFound: !1,
      state: nextUrlState
    };
  }
  return {
    type: "intent",
    isNotFound: !0,
    intent: { name: intent, params }
  };
}
function decodeUrlState(rootRouter, pathname) {
  return {
    type: "state",
    state: rootRouter.decode(pathname) || {},
    isNotFound: rootRouter.isNotFound(pathname)
  };
}
function WorkspaceRouterProvider({
  children,
  LoadingComponent,
  workspace
}) {
  const { basePath, tools } = workspace, history2 = useRouterHistory(), router$1 = React.useMemo(() => createRouter({ basePath, tools }), [basePath, tools]), [state, onNavigate] = useRouterFromWorkspaceHistory(history2, router$1, tools);
  return state ? /* @__PURE__ */ jsxRuntime.jsx(router.RouterProvider, { onNavigate, router: router$1, state, children }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
}
function useRouterFromWorkspaceHistory(history2, router2, tools) {
  var _a2;
  const store = React.useMemo(() => {
    const routerBasePath = router2.getBasePath(), routerBasePathRegex = new RegExp(`^${escapeRegExp__default.default(routerBasePath)}(\\/|$)`, "i"), shouldHandle = (pathname) => (
      // this is necessary to prevent emissions intended for other workspaces.
      routerBasePath === "/" ? !0 : routerBasePathRegex.test(pathname)
    );
    return {
      subscribe: (onStoreChange) => history2.listen(onStoreChange),
      getSnapshot: () => `${history2.location.pathname}${history2.location.search || ""}`,
      // Always return null for the server snapshot, as we can't know how to resolve intents until after authentication is done, which is browser-only
      getServerSnapshot: () => null,
      selector: (pathname) => typeof pathname == "string" && shouldHandle(pathname) ? decodeUrlState(router2, pathname) : null
    };
  }, [history2, router2]), event = withSelector.useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getSnapshot,
    store.getServerSnapshot,
    store.selector,
    isEqual__default.default
  ), prevEvent = React.useRef(event);
  React.useEffect(() => {
    var _a22;
    if ((event == null ? void 0 : event.type) === "state" && !((_a22 = event.state) != null && _a22.intent)) {
      const defaultState = resolveDefaultState(tools, event.state);
      defaultState && defaultState !== event.state && history2.replace(router2.encode(defaultState));
    }
  }, [event == null ? void 0 : event.state, event == null ? void 0 : event.type, history2, router2, tools]), React.useEffect(() => {
    const resolvedIntent = maybeResolveIntent(event, router2, tools, prevEvent);
    resolvedIntent ? history2.replace(resolvedIntent) : prevEvent.current = event;
  }, [event, history2, router2, tools]);
  const handleNavigate = React.useMemo(() => ({ path, replace }) => {
    const predictedEvent = store.selector(path), resolvedIntent = maybeResolveIntent(predictedEvent, router2, tools, prevEvent), resolvedPath = typeof resolvedIntent == "string" ? resolvedIntent : path;
    replace ? history2.replace(resolvedPath) : history2.push(resolvedPath);
  }, [history2, router2, store, tools]);
  return [(_a2 = event == null ? void 0 : event.state) != null ? _a2 : null, handleNavigate];
}
function maybeResolveIntent(event, router2, tools, prevEvent) {
  var _a2, _b;
  if ((event == null ? void 0 : event.type) === "state" && (_a2 = event.state) != null && _a2.intent) {
    const redirectState = resolveIntentState(
      tools,
      ((_b = prevEvent.current) == null ? void 0 : _b.type) === "state" ? prevEvent.current.state : {},
      event.state
    );
    if ((redirectState == null ? void 0 : redirectState.type) === "state")
      return router2.encode(redirectState.state);
  }
  return null;
}
function useWorkspaceLoader(activeWorkspace) {
  const [error, handleError] = React.useState(null);
  if (error)
    throw error;
  const [workspace, setWorkspace] = React.useState(null);
  return React.useEffect(() => {
    const subscription = rxjs.combineLatest(
      activeWorkspace.__internal.sources.map(
        ({ source }) => source.pipe(
          operators.catchError((err) => {
            if (err instanceof ConfigResolutionError)
              return rxjs.of(err);
            throw err;
          })
        )
      )
    ).pipe(
      operators.map((results) => {
        const errors = results.filter((result) => result instanceof ConfigResolutionError);
        if (errors.length)
          throw new ConfigResolutionError({
            name: activeWorkspace.name,
            causes: errors,
            type: "workspace"
          });
        return results;
      }),
      operators.map(
        ([rootSource, ...restOfSources]) => ({
          ...activeWorkspace,
          ...rootSource,
          unstable_sources: [rootSource, ...restOfSources],
          type: "workspace"
        })
      )
    ).subscribe({
      next: setWorkspace,
      error: handleError
    });
    return () => subscription.unsubscribe();
  }, [activeWorkspace]), workspace;
}
function WorkspaceLoader({
  children,
  LoadingComponent
}) {
  const { activeWorkspace } = useActiveWorkspace(), workspace = useWorkspaceLoader(activeWorkspace);
  return workspace ? /* @__PURE__ */ jsxRuntime.jsx(WorkspaceProvider, { workspace, children: /* @__PURE__ */ jsxRuntime.jsx(
    SourceProvider,
    {
      source: workspace.unstable_sources[0],
      children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceRouterProvider, { LoadingComponent, workspace, children })
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
}
function WorkspaceLoaderBoundary({ ConfigErrorsComponent, ...props2 }) {
  const [{ error }, setError] = React.useState({ error: null });
  if (error)
    throw error;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceLoader, { ...props2 }) });
}
Refractor__default.default.registerLanguage(bash__default.default);
Refractor__default.default.registerLanguage(javascript__default.default);
Refractor__default.default.registerLanguage(json__default.default);
Refractor__default.default.registerLanguage(jsx2__default.default);
Refractor__default.default.registerLanguage(typescript__default.default);
function StudioProvider({
  children,
  config,
  basePath,
  onSchemeChange,
  scheme,
  unstable_history: history2,
  unstable_noAuthBoundary: noAuthBoundary
}) {
  const _children = /* @__PURE__ */ jsxRuntime.jsx(WorkspaceLoaderBoundary, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children: /* @__PURE__ */ jsxRuntime.jsx(StudioTelemetryProvider, { config, children: /* @__PURE__ */ jsxRuntime.jsx(LocaleProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ResourceCacheProvider, { children }) }) }) });
  return /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeProvider, { onSchemeChange, scheme, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.ToastProvider, { paddingY: 7, zOffset: Z_OFFSET.toast, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ErrorLogger, {}),
    /* @__PURE__ */ jsxRuntime.jsx(StudioErrorBoundary, { children: /* @__PURE__ */ jsxRuntime.jsx(WorkspacesProvider, { config, basePath, children: /* @__PURE__ */ jsxRuntime.jsx(
      ActiveWorkspaceMatcher,
      {
        unstable_history: history2,
        NotFoundComponent: NotFoundScreen,
        LoadingComponent: LoadingBlock,
        children: /* @__PURE__ */ jsxRuntime.jsx(StudioThemeProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(UserColorManagerProvider, { children: noAuthBoundary ? _children : /* @__PURE__ */ jsxRuntime.jsx(
          AuthBoundary,
          {
            LoadingComponent: LoadingBlock,
            AuthenticateComponent: AuthenticateScreen,
            NotAuthenticatedComponent: NotAuthenticatedScreen,
            children: _children
          }
        ) }) })
      }
    ) }) })
  ] }) });
}
function useClient(clientOptions) {
  const source = useSource();
  return clientOptions ? source.getClient(clientOptions) : (console.warn(
    'Calling `useClient()` without specifying an API version is deprecated and will stop working in the next dev-preview release - please migrate to use `useClient({apiVersion: "2021-06-07"})`.'
  ), source.getClient({ apiVersion: "2021-06-07" }));
}
function useDataset() {
  return useSource().dataset;
}
function useDocumentOperation(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.editOperations(publishedDocId, docTypeName),
    [docTypeName, documentStore.pair, publishedDocId]
  );
}
const EMPTY_ARRAY$1 = [], INITIAL_LOADING_STATE = {
  enabled: !0,
  error: null,
  features: EMPTY_ARRAY$1,
  isLoading: !0
};
function fetchFeatures({ versionedClient }) {
  return versionedClient.observable.request({
    uri: "/features",
    tag: "features"
  });
}
const cachedFeatureRequest = /* @__PURE__ */ new Map();
function useFeatureEnabled(featureKey) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { projectId } = useSource();
  if (!cachedFeatureRequest.get(projectId)) {
    const features = fetchFeatures({ versionedClient }).pipe(operators.shareReplay());
    cachedFeatureRequest.set(projectId, features);
  }
  return reactRx.useMemoObservable(
    () => (cachedFeatureRequest.get(projectId) || rxjs.of(EMPTY_ARRAY$1)).pipe(
      operators.map((features = []) => ({
        isLoading: !1,
        enabled: !!(features != null && features.includes(featureKey)),
        features,
        error: null
      })),
      operators.startWith(INITIAL_LOADING_STATE),
      operators.catchError((error) => rxjs.of({ isLoading: !1, enabled: !1, features: EMPTY_ARRAY$1, error }))
    ),
    [featureKey, projectId],
    INITIAL_LOADING_STATE
  );
}
function useProjectId() {
  return useSource().projectId;
}
const FIVE_SECONDS = 1e3 * 5, TWENTY_SECONDS = 1e3 * 20, ONE_MINUTE = 1e3 * 60, ONE_HOUR = ONE_MINUTE * 60, NO_YEAR_DATE_ONLY_FORMAT = {
  month: "short",
  day: "numeric"
}, DATE_ONLY_FORMAT = {
  ...NO_YEAR_DATE_ONLY_FORMAT,
  year: "numeric"
}, FULL_DATE_FORMAT = {
  ...DATE_ONLY_FORMAT,
  hour: "numeric",
  minute: "numeric"
};
function useRelativeTime(time, options = {}) {
  const resolved = useFormatRelativeTime(time, options), [, forceUpdate] = React.useReducer((x) => x + 1, 0);
  return React.useEffect(() => {
    let timerId;
    function tick(interval) {
      timerId = window.setTimeout(() => {
        forceUpdate(), timerId = window.setTimeout(() => tick(interval), interval);
      }, interval);
    }
    return resolved.refreshInterval !== null && tick(resolved.refreshInterval), () => {
      timerId !== null && clearTimeout(timerId);
    };
  }, [forceUpdate, resolved.refreshInterval]), resolved.timestamp;
}
function useFormatRelativeTime(date, opts = {}) {
  const { t: t2 } = useTranslation(), currentLocale = getJsonStream.useCurrentLocale().id, { timeZone, minimal } = opts, parsedDate = date instanceof Date ? date : new Date(date), useTemporalPhrase = !!opts.useTemporalPhrase, format = React.useCallback(
    function(count, unit) {
      const isNextOrPrevDay = unit === "day" && Math.abs(count) === 1, isNextOrPrevWeek = unit === "week" && Math.abs(count) === 1;
      return useTemporalPhrase || isNextOrPrevDay ? intlCache.relativeTimeFormat(currentLocale, {
        // Force 'long' formatting for dates within the next/previous week as `Intl.RelativeTimeFormat`
        // will display these as `next wk.` or `last wk.` – which we don't want!
        // Idiomatic dates should always be displayed in full. There may be a more elegant way to handle this.
        style: minimal && !isNextOrPrevWeek ? "short" : "long",
        numeric: "auto"
      }).format(count, unit) : intlCache.numberFormat(currentLocale, { style: "unit", unit, unitDisplay: minimal ? "short" : "long" }).format(Math.abs(count));
    },
    [currentLocale, useTemporalPhrase, minimal]
  );
  if (!parsedDate.getTime())
    return {
      timestamp: "",
      refreshInterval: null
    };
  const now = opts.relativeTo || Date.now(), diffMonths = dateFns.differenceInMonths(now, parsedDate), diffYears = dateFns.differenceInYears(now, parsedDate);
  if (diffMonths || diffYears)
    return opts.minimal && diffYears === 0 ? {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...NO_YEAR_DATE_ONLY_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    } : opts.minimal ? {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...DATE_ONLY_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    } : {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...FULL_DATE_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    };
  const diffWeeks = dateFns.differenceInWeeks(parsedDate, now);
  if (diffWeeks)
    return {
      timestamp: format(diffWeeks, "week"),
      refreshInterval: ONE_HOUR
    };
  const diffDays = dateFns.differenceInDays(parsedDate, now);
  if (diffDays)
    return {
      timestamp: format(diffDays, "day"),
      refreshInterval: ONE_HOUR
    };
  const diffHours = dateFns.differenceInHours(parsedDate, now);
  if (diffHours)
    return {
      timestamp: format(diffHours, "hour"),
      refreshInterval: ONE_MINUTE
    };
  const diffMins = dateFns.differenceInMinutes(parsedDate, now);
  if (diffMins)
    return {
      timestamp: format(diffMins, "minute"),
      refreshInterval: TWENTY_SECONDS
    };
  const diffSeconds = dateFns.differenceInSeconds(parsedDate, now);
  return Math.abs(diffSeconds) > 10 ? {
    timestamp: format(diffSeconds, "second"),
    refreshInterval: FIVE_SECONDS
  } : { timestamp: t2("relative-time.just-now"), refreshInterval: FIVE_SECONDS };
}
function useSchema() {
  return useSource().schema;
}
function useTemplates() {
  return useSource().templates;
}
const StyledText = styled__default.default(ui.Text)`
  white-space: nowrap;
`;
function DocumentStatus({ absoluteDate, draft, published, singleLine }) {
  const { t: t2 } = useTranslation(), draftUpdatedAt = draft && "_updatedAt" in draft ? draft._updatedAt : "", publishedUpdatedAt = published && "_updatedAt" in published ? published._updatedAt : "", intlDateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: "short"
  }), draftDateAbsolute = draftUpdatedAt && intlDateFormat.format(new Date(draftUpdatedAt)), publishedDateAbsolute = publishedUpdatedAt && intlDateFormat.format(new Date(publishedUpdatedAt)), draftUpdatedTimeAgo = useRelativeTime(draftUpdatedAt || "", {
    minimal: !0,
    useTemporalPhrase: !0
  }), publishedUpdatedTimeAgo = useRelativeTime(publishedUpdatedAt || "", {
    minimal: !0,
    useTemporalPhrase: !0
  }), publishedDate = absoluteDate ? publishedDateAbsolute : publishedUpdatedTimeAgo, updatedDate = absoluteDate ? draftDateAbsolute : draftUpdatedTimeAgo;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: singleLine ? "center" : "flex-start",
      direction: singleLine ? "row" : "column",
      gap: 2,
      wrap: "nowrap",
      children: [
        !publishedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { size: 1, weight: "medium", children: t2("document-status.not-published") }),
        publishedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { size: 1, weight: "medium", children: t2("document-status.published", { date: publishedDate }) }),
        updatedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { muted: !0, size: 1, wrap: "nowrap", children: t2("document-status.edited", { date: updatedDate }) })
      ]
    }
  );
}
function useShallowCompareMemoize(value) {
  const ref = React.useRef(void 0);
  return shallowEquals__default.default(value, ref.current) || (ref.current = value), [ref.current];
}
function useShallowCompareEffect(callback, dependencies) {
  React.useEffect(callback, useShallowCompareMemoize(dependencies));
}
const HookStateContainer = React.memo(
  function(props2) {
    const { hook, args, id: id2, onNext, onReset, onRequestUpdate } = props2, hookState = hook({
      ...args,
      onComplete: () => {
        onReset(id2);
      }
    });
    return useShallowCompareEffect(() => (onNext(id2, hookState), onRequestUpdate(), () => {
      onNext(id2, null), onRequestUpdate();
    }), hookState), null;
  },
  (prev, next) => prev.args === next.args
), EMPTY_ARRAY = [];
function InsufficientPermissionsMessage({
  currentUser,
  context
}) {
  const { t: t2 } = useTranslation(), list = useListFormat({ style: "short", type: "unit" }), roles = (currentUser == null ? void 0 : currentUser.roles) || EMPTY_ARRAY, Roles = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: list.formatToParts(roles.map((role) => role.title || startCase__default.default(role.name))).map(
      (i, index) => i.type === "element" ? (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsxRuntime.jsx("code", { children: i.value }, `${i.value}-${index}`)
      ) : (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: i.value }, `${i.value}-${index}`)
      )
    ) }),
    [roles, list]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("insufficient-permissions-message.title") })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        i18nKey: "insufficient-permissions-message.not-authorized-explanation",
        t: t2,
        context
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { marginTop: 4, marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { i18nKey: "insufficient-permissions-message.roles", t: t2, components: { Roles } }) }) })
  ] });
}
const StyledContainer = styled__default.default(ui.Container)((props2) => {
  const { theme: theme2 } = props2, { container, media } = theme2.sanity;
  return ui._responsive(media, props2.$width, (val) => ({
    // Make sure that the Container gets the correct width when used inside a popover.
    width: val === "auto" ? "none" : ui.rem(container[val]),
    // Make sure that the Container width is constrained by available space.
    maxWidth: "100%"
  }));
}), PopoverContainer = React.forwardRef(function(props2, ref) {
  const { width, ...restProps } = props2, widthArr = ui.useArrayProp(width);
  return /* @__PURE__ */ jsxRuntime.jsx(StyledContainer, { ...restProps, "data-ui": "PopoverContainer", $width: widthArr, ref });
}), StyledPopover = styled__default.default(getJsonStream.Popover)(() => styled.css`
    // Make the popover scrollable if it overflows the viewport
    [data-ui='Popover__wrapper'] {
      overflow: auto;
    }
  `), StickyLayer = styled__default.default(ui.Layer)((props2) => {
  const radii = props2.theme.sanity.radius[3];
  return styled.css`
    position: sticky;
    top: 0;
    width: 100%;
    background: var(--card-bg-color);
    border-bottom: 1px solid var(--card-border-color);
    border-top-left-radius: ${radii}px;
    border-top-right-radius: ${radii}px;
  `;
});
function PopoverDialog(props2) {
  const { children, header, onClose, referenceElement, containerRef, width } = props2, handleClose = React.useCallback(() => {
    onClose(), referenceElement == null || referenceElement.focus();
  }, [onClose, referenceElement]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover,
    {
      portal: !0,
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverContainer, { width, children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { ref: containerRef, children: [
        /* @__PURE__ */ jsxRuntime.jsx(StickyLayer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, paddingLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: header }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              icon: icons.CloseIcon,
              mode: "bleed",
              onClick: handleClose,
              tooltipProps: { content: "Close" }
            }
          )
        ] }) }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children })
      ] }) }) }),
      open: !0,
      referenceElement
    }
  );
}
const StyledCard = styled__default.default(ui.Card)(() => styled.css`
    /* TextWithTone uses its own logic to set color, and we therefore need */
    /* to override this logic in order to set the correct color in different states */
    &[data-selected],
    &[data-pressed],
    &:active {
      [data-ui='TextWithTone'] {
        color: inherit;
      }
    }
  `), PreviewCardContext = React.createContext({ selected: !1 });
function usePreviewCard() {
  const context = React.useContext(PreviewCardContext);
  if (!context)
    throw new Error("PreviewCard: missing context value");
  return context;
}
const PreviewCard = React.forwardRef(function(props2, ref) {
  const { children, selected, as, ...restProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(StyledCard, { "data-ui": "PreviewCard", ...restProps, forwardedAs: as, ref, selected, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewCardContext.Provider, { value: { selected }, children }) });
}), PREVIEW_SIZES = {
  block: {
    icon: 25,
    media: { width: 33, height: 33 }
  },
  blockImage: {
    icon: 25,
    media: { width: 600, height: 400 }
  },
  compact: {
    icon: 21,
    media: { width: 25, height: 25 }
  },
  default: {
    icon: 21,
    media: { width: 33, height: 33 }
  },
  detail: {
    icon: 25,
    media: { width: 73, height: 73 }
  },
  inline: {
    icon: 15,
    media: { width: 15, height: 15 }
  },
  media: {
    icon: 25,
    media: { width: 160, height: 160 }
  }
}, MediaWrapper = styled__default.default.span((props2) => {
  const { $dimensions, $layout, $radius, $responsive } = props2, width = $dimensions.width || 0, height = $dimensions.width || 0, iconSize = PREVIEW_SIZES[$layout].icon;
  return styled.css`
    position: relative;
    width: ${$responsive ? "100%" : ui.rem(width)};
    height: ${$responsive ? "100%" : ui.rem(height)};
    min-width: ${$responsive ? void 0 : ui.rem(width)};
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[$radius])};
    display: flex;
    overflow: hidden;
    overflow: clip;
    align-items: center;
    justify-content: center;

    & img {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: inherit;
    }

    & svg {
      // Shared styles for SVG icons
      color: var(--card-icon-color);
      display: block;
      flex: 1;

      // Specific styles for non Sanity icons
      &:not([data-sanity-icon]) {
        height: 1em;
        width: 1em;
        max-width: 1em;
        max-height: 1em;
      }

      // Specific styles for Sanity icons
      &[data-sanity-icon] {
        display: block;
        font-size: calc(${iconSize} / 16 * 1em);
      }
    }

    & > span[data-border] {
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      box-shadow: inset 0 0 0 1px var(--card-fg-color);
      opacity: 0.1;
      border-radius: inherit;
      pointer-events: none;
    }
  `;
});
MediaWrapper.displayName = "MediaWrapper";
function Media(props2) {
  const { border = !0, dimensions, layout, media, radius = 1, responsive = !1, styles } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    MediaWrapper,
    {
      $dimensions: dimensions,
      $layout: layout,
      $radius: radius,
      $responsive: responsive,
      className: styles == null ? void 0 : styles.media,
      "data-testid": "Media",
      children: [
        renderMedia({ dimensions, layout, media }),
        border && /* @__PURE__ */ jsxRuntime.jsx("span", { "data-border": !0 })
      ]
    }
  );
}
function renderMedia(props2) {
  const { dimensions, layout, media, styles } = props2;
  return reactIs.isValidElementType(media) ? React.createElement(media, { dimensions, layout }) : typeof media == "string" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "span", className: styles == null ? void 0 : styles.mediaString, size: 1, children: media }) : React.isValidElement(media) ? media : null;
}
function renderPreviewMedia(value, layout, dimensions) {
  return reactIs.isValidElementType(value) ? React.createElement(value, { layout, dimensions }) : typeof value == "string" ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: value }) : value;
}
function renderPreviewNode(value, layout, fallbackNode) {
  return typeof value == "string" ? value : reactIs.isValidElementType(value) ? React.createElement(value, { layout }) : value || fallbackNode;
}
const DEFAULT_MEDIA_DIMENSIONS$6 = {
  ...PREVIEW_SIZES.compact.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root$4 = styled__default.default(ui.Flex)`
  height: ${ui.rem(PREVIEW_SIZES.compact.media.height)};
  box-sizing: content-box;
`, TitleSkeleton$3 = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`;
function CompactPreview(props2) {
  const { children, isPlaceholder, media, status, title } = props2, { t: t2 } = useTranslation(), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-testid": "compact-preview__status", paddingLeft: 4, paddingRight: 1, children: renderPreviewNode(status, "compact") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    Root$4,
    {
      align: "center",
      "data-testid": "default-preview",
      paddingLeft: media ? 1 : 2,
      paddingRight: 2,
      paddingY: 1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, radius: 2, style: PREVIEW_SIZES.compact.media }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-testid": "compact-preview__heading", flex: 1, space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$3, {}) }),
        statusNode
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(
    Root$4,
    {
      align: "center",
      "data-testid": "compact-preview",
      paddingLeft: media ? 1 : 2,
      paddingRight: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
          media && /* @__PURE__ */ jsxRuntime.jsx(
            Media,
            {
              border: !1,
              dimensions: DEFAULT_MEDIA_DIMENSIONS$6,
              layout: "compact",
              media
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-testid": "compact-preview__header", flex: 1, space: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, style: { color: "inherit" }, textOverflow: "ellipsis", weight: "medium", children: [
            title && renderPreviewNode(title, "compact"),
            !title && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("preview.default.title-fallback") })
          ] }) }),
          statusNode
        ] }),
        children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children })
      ]
    }
  );
}
const DEFAULT_MEDIA_DIMENSIONS$5 = {
  ...PREVIEW_SIZES.default.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root$3 = styled__default.default(ui.Flex)`
  height: ${ui.rem(PREVIEW_SIZES.default.media.height)};
  box-sizing: content-box;
`, TitleSkeleton$2 = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`, SubtitleSkeleton$2 = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)};
  width: 60%;
`;
function DefaultPreview(props2) {
  const { title, subtitle, media, status, isPlaceholder, children, styles } = props2, { t: t2 } = useTranslation(), rootClassName = classNames__default.default(styles == null ? void 0 : styles.root, !!subtitle && (styles == null ? void 0 : styles.hasSubtitle)), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { className: styles == null ? void 0 : styles.status, "data-testid": "default-preview__status", children: renderPreviewNode(status, "default") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    Root$3,
    {
      align: "center",
      className: styles == null ? void 0 : styles.placeholder,
      "data-testid": "default-preview",
      padding: 2,
      paddingLeft: media ? 2 : 3,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, radius: 1, style: PREVIEW_SIZES.default.media }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-testid": "default-preview__heading", flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$2, {}),
          /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton$2, {})
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: statusNode })
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    Root$3,
    {
      align: "center",
      className: rootClassName,
      "data-testid": "default-preview",
      padding: 2,
      paddingLeft: media ? 2 : 3,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
          Media,
          {
            dimensions: DEFAULT_MEDIA_DIMENSIONS$5,
            layout: "default",
            media,
            styles
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { className: styles == null ? void 0 : styles.heading, "data-testid": "default-preview__header", flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(
            ui.Text,
            {
              className: styles == null ? void 0 : styles.title,
              size: 1,
              style: { color: "inherit" },
              textOverflow: "ellipsis",
              weight: "medium",
              children: [
                title && renderPreviewNode(title, "default"),
                !title && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("preview.default.title-fallback") })
              ]
            }
          ),
          subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", className: styles == null ? void 0 : styles.subtitle, children: renderPreviewNode(subtitle, "default") })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: statusNode }),
        children && /* @__PURE__ */ jsxRuntime.jsx("div", { className: styles == null ? void 0 : styles.children, children })
      ] })
    }
  );
}
const RootFlex = styled__default.default(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.detail.media.height)};
`, StatusBox = styled__default.default(ui.Box)`
  white-space: nowrap;
`, MediaSkeleton$1 = styled__default.default(ui.Skeleton).attrs({ animated: !0, radius: 2 })`
  width: ${ui.rem(PREVIEW_SIZES.detail.media.width)};
  height: ${ui.rem(PREVIEW_SIZES.detail.media.height)};
`, TitleSkeleton$1 = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)}; /* 80% of 200px */
  width: 80%;
`, SubtitleSkeleton$1 = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)}; /* 60% of 200px */
  width: 60%;
`, DescriptionSkeleton = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(180)}; /* 90% of 200px */
  width: 90%;
`, DescriptionText = styled__default.default(ui.Text)(({ theme: theme2 }) => {
  const { fonts } = theme2.sanity, textSize1 = fonts.text.sizes[1], maxLines = 2, maxHeight = textSize1.lineHeight * maxLines;
  return styled.css`
    & > span {
      max-height: ${ui.rem(maxHeight)};

      /* Multi-line text overflow */
      display: -webkit-box;
      overflow: hidden;
      overflow: clip;
      text-overflow: ellipsis;
      -webkit-line-clamp: ${maxLines};
      -webkit-box-orient: vertical;
    }
  `;
}), DEFAULT_MEDIA_DIMENSIONS$4 = {
  ...PREVIEW_SIZES.detail.media,
  fit: "crop",
  aspect: 1,
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function DetailPreview(props2) {
  const {
    title,
    subtitle,
    description,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$4,
    media,
    status,
    children,
    isPlaceholder
  } = props2, { t: t2 } = useTranslation(), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(StatusBox, { marginLeft: 3, paddingRight: 1, children: renderPreviewNode(status, "detail") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    RootFlex,
    {
      "data-testid": "detail-preview",
      paddingLeft: media ? 2 : 3,
      paddingRight: 2,
      paddingY: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 3, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(MediaSkeleton$1, { "data-testid": "detail-preview__media" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", "data-testid": "detail-preview__header", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$1, {}),
          /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton$1, {}),
          description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(DescriptionSkeleton, {}) })
        ] }) }),
        statusNode
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    RootFlex,
    {
      "data-testid": "detail-preview",
      paddingLeft: media ? 2 : 3,
      paddingRight: 2,
      paddingY: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 3, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "detail", media }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", "data-testid": "detail-preview__header", flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { textOverflow: "ellipsis", size: 1, style: { color: "inherit" }, weight: "medium", children: [
              title && renderPreviewNode(title, "detail"),
              !title && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("preview.default.title-fallback") })
            ] }),
            subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "detail") }),
            description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(DescriptionText, { muted: !0, size: 1, children: renderPreviewNode(description, "detail") }) })
          ] }),
          statusNode
        ] }),
        children
      ] })
    }
  );
}
const SIZE = 43, STROKE_WIDTH$1 = 3, Root$2 = styled__default.default.svg`
  width: ${SIZE}px;
  height: ${SIZE}px;
  transform: rotate(-90deg);
`, BgCircle = styled__default.default.circle(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styled.css`
    fill: none;
    stroke: ${color.hues.gray[color$1.dark ? 900 : 100].hex};
    stroke-width: ${STROKE_WIDTH$1}px;
  `;
}), ProgressCircle = styled__default.default.circle(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styled.css`
    fill: none;
    stroke: ${color.hues.blue[color$1.dark ? 400 : 500].hex};
    stroke-width: ${STROKE_WIDTH$1}px;
    transition: stroke-dashoffset 75ms;
  `;
});
function CircularProgress(props2) {
  const { value: valueProp } = props2, value = Math.min(Math.max(valueProp, 0), 100), radius = SIZE / 2 - STROKE_WIDTH$1 / 2, circ = 2 * Math.PI * radius, offset = (100 - value) / 100 * circ, viewBox = `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$2, { viewBox, children: [
    /* @__PURE__ */ jsxRuntime.jsx(BgCircle, { cx: SIZE, cy: SIZE, r: radius }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ProgressCircle,
      {
        cx: SIZE,
        cy: SIZE,
        r: radius,
        style: {
          strokeDasharray: circ,
          strokeDashoffset: `${offset}px`
        }
      }
    )
  ] });
}
const STROKE_WIDTH = 0.5, Root$1 = styled__default.default(ui.Card)`
  overflow: hidden;
  overflow: clip;
`, Bar = styled__default.default(ui.Card)(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styled.css`
    height: ${STROKE_WIDTH}rem;
    background: ${color.hues.blue[color$1.dark ? 400 : 500].hex};
    transition: transform 75ms;
  `;
});
function LinearProgress(props2) {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$1, { radius: 5, children: /* @__PURE__ */ jsxRuntime.jsx(Bar, { radius: 5, style: { transform: `translate3d(${value - 100}%, 0, 0)` } }) });
}
const RootBox$1 = styled__default.default(ui.Box)`
  position: relative;
`, MediaFlex = styled__default.default(ui.Flex).attrs({ align: "center", justify: "center" })`
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
`, MediaSkeleton = styled__default.default(ui.Skeleton).attrs({ animated: !0, radius: 2 })`
  width: 100%;
  height: 100%;
`, ProgressFlex = styled__default.default(ui.Flex).attrs({ align: "center", justify: "center" })`
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;

  &:before {
    background-color: var(--card-bg-color);
    opacity: 0.75;
    content: '';
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
  }

  > svg {
    position: relative;
    z-index: 2;
  }
`, TooltipContentStack = styled__default.default(ui.Stack).attrs({ space: 2 })`
  max-width: ${ui.rem(200)};
`, DEFAULT_MEDIA_DIMENSIONS$3 = {
  ...PREVIEW_SIZES.media.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function MediaPreview(props2) {
  const {
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$3,
    children,
    isPlaceholder,
    progress = -1,
    subtitle,
    title,
    withBorder = !0,
    withRadius = !0
  } = props2, aspect = mediaDimensions.aspect || 1, STYLES_PADDER = React.useMemo(() => ({ paddingBottom: `${100 / aspect}%` }), [aspect]), tooltipContent = React.useMemo(() => !title || !subtitle ? null : /* @__PURE__ */ jsxRuntime.jsxs(TooltipContentStack, { children: [
    title && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, weight: "medium", children: renderPreviewNode(title, "media") }),
    subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: renderPreviewNode(subtitle, "media") })
  ] }), [subtitle, title]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(RootBox$1, { "data-testid": "media-preview", flex: 1, overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: STYLES_PADDER }),
    /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: tooltipContent, disabled: !tooltipContent, placement: "top", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(MediaFlex, { children: [
      isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(MediaSkeleton, {}) : /* @__PURE__ */ jsxRuntime.jsx(
        Media,
        {
          border: withBorder,
          dimensions: mediaDimensions,
          layout: "media",
          media,
          radius: withRadius ? 1 : 0,
          responsive: !0
        }
      ),
      typeof progress == "number" && progress > -1 && /* @__PURE__ */ jsxRuntime.jsx(ProgressFlex, { children: /* @__PURE__ */ jsxRuntime.jsx(CircularProgress, { value: progress }) })
    ] }) }),
    children
  ] }) });
}
const HeaderFlex$2 = styled__default.default(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.block.media.height)};
  white-space: nowrap;
  position: relative;
  z-index: 1;
`, MediaCard = styled__default.default(ui.Card)`
  overflow: hidden;
  position: relative;
  padding-bottom: ${({ $ratio }) => $ratio}%;

  & > span {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
`, RootBox = styled__default.default(ui.Box).attrs({ overflow: "hidden" })`
  border-radius: ${({ theme: theme2 }) => theme2.sanity.radius[1]}px;
`, DEFAULT_MEDIA_DIMENSIONS$2 = {
  ...PREVIEW_SIZES.blockImage.media,
  fit: "fillmax",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, getRatio = (dimensions) => {
  const { height, width } = dimensions;
  return !height || !width ? 1 : height / width * 100;
};
function BlockImagePreview(props2) {
  const {
    actions,
    title,
    subtitle,
    description,
    fallbackTitle = "Untitled",
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$2,
    media,
    children,
    status
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootBox, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$2, { paddingBottom: 3, paddingLeft: 2, paddingRight: 1, paddingTop: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
          (title || fallbackTitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title ? renderPreviewNode(title, "block") : fallbackTitle }),
          subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingLeft: 1, children: [
          status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }),
          actions
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(
        MediaCard,
        {
          $ratio: getRatio(mediaDimensions),
          __unstable_checkered: !0,
          display: "flex",
          sizing: "border",
          radius: 2,
          tone: "inherit",
          children: /* @__PURE__ */ jsxRuntime.jsx(
            Media,
            {
              border: !1,
              dimensions: mediaDimensions,
              layout: "blockImage",
              media,
              radius: 0,
              responsive: !0
            }
          )
        }
      )
    ] }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: renderPreviewNode(description, "block") }) }),
    children && /* @__PURE__ */ jsxRuntime.jsx("div", { children })
  ] });
}
const DEFAULT_MEDIA_DIMENSIONS$1 = {
  ...PREVIEW_SIZES.block.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, HeaderFlex$1 = styled__default.default(ui.Flex).attrs({ align: "center" })`
  min-height: ${ui.rem(PREVIEW_SIZES.block.media.height)};
`;
function BlockPreview(props2) {
  const {
    actions,
    title,
    subtitle,
    description,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$1,
    media,
    status,
    children
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-testid": "block-preview", space: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$1, { "data-testid": "block-preview__header", children: [
      media && /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "block", media }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, paddingLeft: media ? 2 : 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title ? renderPreviewNode(title, "block") : "Untitled" }),
        subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") }) }),
        description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(description, "block") }) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingLeft: 1, children: [
        status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }),
        actions
      ] })
    ] }),
    children && /* @__PURE__ */ jsxRuntime.jsx("div", { "data-testid": "block-preview__children", children })
  ] });
}
const RootSpan = styled__default.default.span`
  display: inline-flex;
  align-items: center;
  vertical-align: top;
  height: calc(1em - 1px);
  max-width: 100%;
`, MediaSpan = styled__default.default.span`
  position: relative;
  display: inline-block;
  width: calc(1em - 1px);
  height: calc(1em - 1px);
  min-width: calc(1em - 1px);

  & img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
  }

  & img + span {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    box-shadow: inset 0 0 0 1px var(--card-fg-color);
    opacity: 0.2;
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
  }

  & svg {
    display: block;
    font-size: calc(14 / 16 * 1em);
    margin: 1px 0;

    &[data-sanity-icon] {
      font-size: calc(18 / 16 * 1em);
      margin: calc(1px + (2 / 18 * -1em)) 0;
    }
  }
`, TextSpan = styled__default.default(ui.Text).attrs({ forwardedAs: "span" })(({ theme: theme2 }) => {
  const textFont = theme2.sanity.fonts.text, textSize = textFont.sizes[1];
  return styled.css`
    font-size: calc(${textSize.fontSize} / 16 * 1em);
    font-weight: ${textFont.weights.medium};
    box-sizing: border-box;
    display: inline-block;
    vertical-align: top;
    line-height: ${textSize.lineHeight / textSize.fontSize};
    padding-left: 0.5em;
    padding-right: calc(0.5em - 2px);
    min-width: 0;

    & > span {
      display: block;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      overflow: clip;
    }
  `;
}), DEFAULT_MEDIA_DIMENSIONS = {
  ...PREVIEW_SIZES.inline.media,
  fit: "crop",
  aspect: 1,
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function InlinePreview(props2) {
  const {
    title,
    fallbackTitle = "Untitled",
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootSpan, { "data-testid": "inline-preview", children: [
    media && /* @__PURE__ */ jsxRuntime.jsxs(MediaSpan, { "data-testid": "inline-preview-media", children: [
      renderPreviewMedia(media, "inline", mediaDimensions),
      /* @__PURE__ */ jsxRuntime.jsx("span", {})
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(TextSpan, { "data-testid": "inline-preview-title", size: 1, children: renderPreviewNode(title, "inline", fallbackTitle) })
  ] });
}
const DEFAULT_MEDIA_DIMENSION = {
  ...PREVIEW_SIZES.default.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root = styled__default.default(ui.Box)`
  height: 100%;

  a {
    color: currentColor;
    text-decoration: none;
  }

  svg[data-sanity-icon] {
    margin: 0;
  }
`, HeaderFlex = styled__default.default(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.default.media.height)};
`, TitleSkeleton = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`, SubtitleSkeleton = styled__default.default(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)};
  width: 60%;
`;
function TemplatePreview(props2) {
  const {
    description,
    isPlaceholder,
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSION,
    subtitle,
    title = "Untitled"
  } = props2;
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(Root, { children: /* @__PURE__ */ jsxRuntime.jsx(HeaderFlex, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton, {}),
    /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton, {})
  ] }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(Root, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
        reactIs.isValidElementType(title) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: React.createElement(title, { layout: "default" }) }),
        React.isValidElement(title) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: title }),
        reactIs.isValidElementType(subtitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: React.createElement(subtitle, { layout: "default" }) }),
        React.isValidElement(subtitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: subtitle })
      ] }),
      media && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-start", paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "default", media }) })
    ] }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: { whiteSpace: "break-spaces" }, children: description }) })
  ] });
}
const MUTATION_ATTRIBUTE_FILTER = ["aria-hidden", "disabled", "href"], FOCUSABLE = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
function getFocusableElements(element) {
  return [...element.querySelectorAll(FOCUSABLE)].filter(
    (el) => !el.hasAttribute("disabled") && el.getAttribute("aria-hidden") !== "true"
  );
}
function useRovingFocus(props2) {
  const {
    direction = "horizontal",
    initialFocus,
    loop = !0,
    navigation = ["arrows"],
    pause = !1,
    rootElement
  } = props2, [focusedIndex, setFocusedIndex] = React.useState(-1), [focusableElements, setFocusableElements] = React.useState([]), focusableLen = focusableElements.length, lastFocusableIndex = focusableLen - 1, nextKey = direction === "horizontal" ? "ArrowRight" : "ArrowDown", prevKey = direction === "horizontal" ? "ArrowLeft" : "ArrowUp", handleSetElements = React.useCallback(() => {
    if (rootElement) {
      const els = getFocusableElements(rootElement);
      setFocusableElements(els);
    }
  }, [rootElement]), handleFocus = React.useCallback((index) => {
    setFocusedIndex(index);
  }, []), handleKeyDown = React.useCallback(
    (event) => {
      if (pause)
        return;
      const focusPrev = () => {
        event.preventDefault(), setFocusedIndex((prevIndex) => {
          const next = (prevIndex + lastFocusableIndex) % focusableLen;
          return !loop && next === lastFocusableIndex ? prevIndex : next;
        });
      }, focusNext = () => {
        event.preventDefault(), setFocusedIndex((prevIndex) => {
          const next = (prevIndex + 1) % focusableLen;
          return !loop && next === 0 ? prevIndex : next;
        });
      };
      event.key === "Tab" && navigation.includes("tab") && (event.shiftKey ? focusPrev() : focusNext()), navigation.includes("arrows") && (event.key === prevKey && focusPrev(), event.key === nextKey && focusNext());
    },
    [pause, prevKey, navigation, nextKey, lastFocusableIndex, focusableLen, loop]
  );
  React.useEffect(() => {
    handleSetElements();
  }, [handleSetElements, initialFocus, direction]), React.useEffect(() => {
    const mo = new MutationObserver(handleSetElements);
    return rootElement && mo.observe(rootElement, {
      childList: !0,
      subtree: !0,
      attributeFilter: MUTATION_ATTRIBUTE_FILTER
    }), () => {
      mo.disconnect();
    };
  }, [focusableElements, handleSetElements, rootElement]), React.useEffect(() => {
    var _a2;
    focusableElements.forEach((el, index) => {
      index === focusedIndex ? (el.setAttribute("tabIndex", "0"), el.setAttribute("aria-selected", "true"), el.focus(), el.onfocus = () => handleFocus(index), el.onblur = () => handleFocus(-1)) : (el.setAttribute("tabIndex", "-1"), el.setAttribute("aria-selected", "false"), el.onfocus = () => handleFocus(index));
    }), focusedIndex === -1 && focusableElements && ((_a2 = focusableElements[initialFocus === "last" ? lastFocusableIndex : 0]) == null || _a2.setAttribute("tabIndex", "0"));
  }, [focusableElements, focusedIndex, handleFocus, initialFocus, lastFocusableIndex]), React.useEffect(() => (rootElement == null || rootElement.addEventListener("keydown", handleKeyDown), () => {
    rootElement == null || rootElement.removeEventListener("keydown", handleKeyDown);
  }), [handleKeyDown, rootElement]);
}
const StyledButton = styled__default.default(getJsonStream.Button)`
  position: relative;
  // The children in button is rendered inside a span, we need to absolutely position it.
  & > span:nth-child(2) {
    position: absolute;
    top: 6px;
    right: 6px;
    padding: 0;
  }
`, Dot = styled__default.default.div({
  width: 4,
  height: 4,
  borderRadius: 3,
  boxShadow: "0 0 0 1px var(--card-bg-color)"
}), StatusButton = React.forwardRef(function(props2, ref) {
  const { disabled: disabledProp, icon, label, mode = "bleed", text, tone, ...restProps } = props2, theme2 = ui.useTheme(), { t: t2 } = reactI18next.useTranslation(), toneColor = tone && theme2.sanity.color.solid[tone], dotStyle = React.useMemo(() => ({ backgroundColor: toneColor == null ? void 0 : toneColor.enabled.bg }), [toneColor]), disabled = !!disabledProp;
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledButton,
    {
      "data-ui": "StatusButton",
      ...restProps,
      "aria-label": label || t2("status-button.aria-label"),
      disabled,
      mode,
      ref,
      text,
      icon,
      children: tone && /* @__PURE__ */ jsxRuntime.jsx(Dot, { style: dotStyle })
    }
  );
}), TooltipOfDisabled = React.forwardRef(function({ children, content: content2, disabled, ...restProps }, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { ...restProps, content: content2, disabled: disabled || !content2, ref, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children }) });
}), ImperativeToast = React.forwardRef((_, ref) => {
  const { push } = ui.useToast();
  return React.useImperativeHandle(ref, () => ({ push })), null;
});
ImperativeToast.displayName = "ImperativeToast";
const defaults = {
  navbar: 200,
  navbarPopover: 5e5,
  navbarDialog: 500001,
  // pane
  pane: 100,
  paneHeader: [110, 15e3],
  paneFooter: [120, 2e4],
  paneResizer: [130, 25e3],
  paneDialog: [140, 5e3],
  //
  popover: 200,
  modal: 200,
  movingItem: 1e4,
  drawershade: 1e6,
  drawer: 1000001,
  fullscreen: 12e5,
  toast: [100, 11e3],
  // NOT IN USE
  portal: 200,
  dropdown: 200,
  navbarFixed: 1010,
  fullscreenEdit: 1050,
  popoverBackground: 1060,
  tooltip: 200,
  modalBackground: 2e3,
  spinner: 3e3
}, ZIndexContext = React.createContext(defaults);
function useZIndex() {
  return React.useContext(ZIndexContext);
}
function LegacyLayerProvider({
  children,
  zOffset: zOffsetKey
}) {
  const zOffset = useZIndex()[zOffsetKey];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset, children });
}
const TransformPatches = React.memo(function(props2) {
  const { transform } = props2, callbacks = useFormCallbacks(), handleChange = React.useCallback(
    (patchEvent) => {
      const patches = patchEvent.patches, transformedPatches = transform(patches);
      callbacks.onChange(PatchEvent.from(transformedPatches));
    },
    [callbacks, transform]
  ), contextValue = React.useMemo(
    () => ({ ...callbacks, onChange: handleChange }),
    [callbacks, handleChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
exports.ActiveWorkspaceMatcher = ActiveWorkspaceMatcher;
exports.ActiveWorkspaceMatcherContext = ActiveWorkspaceMatcherContext;
exports.AddonDatasetContext = AddonDatasetContext;
exports.ArrayOfObjectOptionsInput = ArrayOfObjectOptionsInput;
exports.ArrayOfObjectsFunctions = ArrayOfObjectsFunctions;
exports.ArrayOfObjectsInput = ArrayOfObjectsInput;
exports.ArrayOfObjectsItem = ArrayOfObjectsItem;
exports.ArrayOfOptionsInput = ArrayOfOptionsInput;
exports.ArrayOfPrimitiveOptionsInput = ArrayOfPrimitiveOptionsInput;
exports.ArrayOfPrimitivesFunctions = ArrayOfPrimitivesFunctions;
exports.ArrayOfPrimitivesInput = ArrayOfPrimitivesInput;
exports.ArrayOfPrimitivesItem = ArrayOfPrimitivesItem;
exports.AutoCollapseMenu = AutoCollapseMenu;
exports.BlockImagePreview = BlockImagePreview;
exports.BlockPreview = BlockPreview;
exports.BooleanInput = BooleanInput;
exports.CONNECTING = CONNECTING;
exports.ChangeBreadcrumb = ChangeBreadcrumb;
exports.ChangeIndicator = ChangeIndicator;
exports.ChangeIndicatorContext = ChangeIndicatorContext;
exports.ChangeList = ChangeList;
exports.ChangeResolver = ChangeResolver;
exports.ChangeTitleSegment = ChangeTitleSegment;
exports.Checkbox = Checkbox;
exports.CircularProgress = CircularProgress;
exports.CollapseMenu = CollapseMenu;
exports.CollapseMenuButton = CollapseMenuButton;
exports.ColorSchemeCustomProvider = ColorSchemeCustomProvider;
exports.ColorSchemeLocalStorageProvider = ColorSchemeLocalStorageProvider;
exports.ColorSchemeProvider = ColorSchemeProvider;
exports.ColorSchemeSetValueContext = ColorSchemeSetValueContext;
exports.ColorSchemeValueContext = ColorSchemeValueContext;
exports.CommandList = CommandList;
exports.CompactPreview = CompactPreview;
exports.ConfigPropertyError = ConfigPropertyError;
exports.ConfigResolutionError = ConfigResolutionError;
exports.Connector = Connector;
exports.ConnectorContext = ConnectorContext;
exports.ContextMenuButton = ContextMenuButton;
exports.CorsOriginError = CorsOriginError;
exports.DEBUG_LAYER_BOUNDS = DEBUG_LAYER_BOUNDS;
exports.DEFAULT_MAX_RECURSION_DEPTH = DEFAULT_MAX_RECURSION_DEPTH;
exports.DEFAULT_STUDIO_CLIENT_OPTIONS = DEFAULT_STUDIO_CLIENT_OPTIONS;
exports.DRAFTS_FOLDER = DRAFTS_FOLDER;
exports.DateInput = DateInput;
exports.DateTimeInput = DateTimeInput;
exports.DatetimeFieldDiff = DatetimeFieldDiff;
exports.DefaultMarkers = DefaultMarkers;
exports.DefaultPreview = DefaultPreview;
exports.DetailPreview = DetailPreview;
exports.DiffCard = DiffCard;
exports.DiffContext = DiffContext;
exports.DiffErrorBoundary = DiffErrorBoundary;
exports.DiffFromTo = DiffFromTo;
exports.DiffInspectWrapper = DiffInspectWrapper;
exports.DiffString = DiffString;
exports.DiffStringSegment = DiffStringSegment;
exports.DiffTooltip = DiffTooltip;
exports.DocumentChangeContext = DocumentChangeContext;
exports.DocumentFieldActionsProvider = DocumentFieldActionsProvider;
exports.DocumentIdProvider = DocumentIdProvider;
exports.DocumentPreviewPresence = DocumentPreviewPresence;
exports.DocumentStatus = DocumentStatus;
exports.DocumentStatusIndicator = DocumentStatusIndicator;
exports.EMPTY_ARRAY = EMPTY_ARRAY$b;
exports.EMPTY_OBJECT = EMPTY_OBJECT;
exports.EmailInput = EmailInput;
exports.ErrorMessage = ErrorMessage;
exports.FallbackDiff = FallbackDiff;
exports.FieldActionMenu = FieldActionMenu;
exports.FieldActionsProvider = FieldActionsProvider;
exports.FieldActionsResolver = FieldActionsResolver;
exports.FieldChange = FieldChange;
exports.FieldPresence = FieldPresence;
exports.FieldPresenceInner = FieldPresenceInner;
exports.FieldPresenceWithOverlay = FieldPresenceWithOverlay;
exports.FieldPresenceWithoutOverlay = FieldPresenceWithoutOverlay;
exports.FormBuilderContext = FormBuilderContext;
exports.FormCallbacksContext = FormCallbacksContext;
exports.FormCallbacksProvider = FormCallbacksProvider;
exports.FormField = FormField;
exports.FormFieldHeaderText = FormFieldHeaderText;
exports.FormFieldPresenceContext = FormFieldPresenceContext;
exports.FormFieldSet = FormFieldSet;
exports.FormFieldStatus = FormFieldStatus;
exports.FormFieldValidationStatus = FormFieldValidationStatus;
exports.FormInput = FormInput;
exports.FormValueProvider = FormValueProvider;
exports.FromTo = FromTo;
exports.FromToArrow = FromToArrow;
exports.GetFormValueProvider = GetFormValueProvider;
exports.GlobalStyle = GlobalStyle;
exports.GroupChange = GroupChange;
exports.HookStateContainer = HookStateContainer;
exports.HoveredFieldContext = HoveredFieldContext;
exports.ImperativeToast = ImperativeToast;
exports.InlinePreview = InlinePreview;
exports.InsufficientPermissionsMessage = InsufficientPermissionsMessage;
exports.LegacyLayerProvider = LegacyLayerProvider;
exports.LinearProgress = LinearProgress;
exports.LoadingBlock = LoadingBlock;
exports.LocaleProvider = LocaleProvider;
exports.LocaleProviderBase = LocaleProviderBase;
exports.MediaPreview = MediaPreview;
exports.MemberField = MemberField;
exports.MemberFieldError = MemberFieldError;
exports.MemberFieldSet = MemberFieldSet;
exports.MemberItemError = MemberItemError;
exports.MetaInfo = MetaInfo;
exports.NavbarContext = NavbarContext;
exports.NoChanges = NoChanges;
exports.NumberInput = NumberInput;
exports.ObjectInput = ObjectInput;
exports.ObjectInputMember = ObjectInputMember;
exports.ObjectInputMembers = ObjectInputMembers;
exports.ObjectMembers = ObjectMembers;
exports.OverlayDisabled = OverlayDisabled;
exports.PatchEvent = PatchEvent;
exports.PopoverDialog = PopoverDialog;
exports.PortableTextInput = PortableTextInput;
exports.PresenceOverlay = PresenceOverlay;
exports.PresenceProvider = PresenceProvider;
exports.Preview = Preview;
exports.PreviewCard = PreviewCard;
exports.PreviewLoader = PreviewLoader;
exports.ReferenceInputOptionsProvider = ReferenceInputOptionsProvider;
exports.ResourceCacheProvider = ResourceCacheProvider;
exports.RevertChangesButton = RevertChangesButton;
exports.ReviewChangesContext = ReviewChangesContext;
exports.SANITY_PATCH_TYPE = SANITY_PATCH_TYPE;
exports.SANITY_VERSION = SANITY_VERSION;
exports.SESSION_ID = SESSION_ID;
exports.SanityDefaultPreview = SanityDefaultPreview;
exports.SchemaError = SchemaError;
exports.ScrollContainer = ScrollContainer;
exports.ScrollContext = ScrollContext;
exports.SearchButton = SearchButton;
exports.SearchContext = SearchContext;
exports.SearchDialog = SearchDialog;
exports.SearchPopover = SearchPopover;
exports.SearchProvider = SearchProvider;
exports.SearchResultItemPreview = SearchResultItemPreview;
exports.SelectInput = SelectInput;
exports.SlugInput = SlugInput;
exports.SlugPreview = SlugPreview;
exports.SourceProvider = SourceProvider;
exports.StatusButton = StatusButton;
exports.StringInput = StringInput;
exports.StringPreview = StringPreview;
exports.StudioCrossDatasetReferenceInput = StudioCrossDatasetReferenceInput;
exports.StudioFileInput = StudioFileInput;
exports.StudioImageInput = StudioImageInput;
exports.StudioLayout = StudioLayout;
exports.StudioLayoutComponent = StudioLayoutComponent;
exports.StudioNavbar = StudioNavbar;
exports.StudioProvider = StudioProvider;
exports.StudioReferenceInput = StudioReferenceInput;
exports.StudioToolMenu = StudioToolMenu;
exports.SvgWrapper = SvgWrapper;
exports.TagsArrayInput = TagsArrayInput;
exports.TemplatePreview = TemplatePreview;
exports.TextInput = TextInput;
exports.TextWithTone = TextWithTone;
exports.Timeline = Timeline;
exports.TimelineController = TimelineController;
exports.ToolLink = ToolLink;
exports.TooltipOfDisabled = TooltipOfDisabled;
exports.Tracker = Tracker$1;
exports.TransformPatches = TransformPatches;
exports.Translate = Translate;
exports.UniversalArrayInput = UniversalArrayInput;
exports.UpsellDescriptionSerializer = UpsellDescriptionSerializer;
exports.UpsellDialogDismissed = UpsellDialogDismissed;
exports.UpsellDialogLearnMoreCtaClicked = UpsellDialogLearnMoreCtaClicked;
exports.UpsellDialogUpgradeCtaClicked = UpsellDialogUpgradeCtaClicked;
exports.UpsellDialogViewed = UpsellDialogViewed;
exports.UrlInput = UrlInput;
exports.UserAvatar = UserAvatar;
exports.UserColorManagerProvider = UserColorManagerProvider;
exports.ValidationProvider = ValidationProvider;
exports.ValueError = ValueError;
exports.VirtualizerScrollInstanceContext = VirtualizerScrollInstanceContext;
exports.VirtualizerScrollInstanceProvider = VirtualizerScrollInstanceProvider;
exports.WorkspaceLoaderBoundary = WorkspaceLoaderBoundary;
exports.WorkspaceProvider = WorkspaceProvider;
exports.WorkspacesContext = WorkspacesContext;
exports.WorkspacesProvider = WorkspacesProvider;
exports.ZIndexContext = ZIndexContext;
exports.__tmp_wrap_presenceStore = __tmp_wrap_presenceStore;
exports._createAuthStore = _createAuthStore;
exports._useColorSchemeInternalValue = _useColorSchemeInternalValue;
exports.asLoadable = asLoadable;
exports.checkoutPair = checkoutPair;
exports.collate = collate;
exports.createAuthStore = createAuthStore;
exports.createBufferedDocument = createBufferedDocument;
exports.createConnectionStatusStore = createConnectionStatusStore;
exports.createDocumentPreviewStore = createDocumentPreviewStore;
exports.createDocumentStore = createDocumentStore;
exports.createDraftFrom = createDraftFrom;
exports.createGrantsStore = createGrantsStore;
exports.createHistoryStore = createHistoryStore;
exports.createHookFromObservableFactory = createHookFromObservableFactory;
exports.createKeyValueStore = createKeyValueStore;
exports.createObservableBufferedDocument = createObservableBufferedDocument;
exports.createProjectStore = createProjectStore;
exports.createPublishedFrom = createPublishedFrom;
exports.createSchema = createSchema;
exports.createSearch = createSearch;
exports.createSharedResizeObserver = createSharedResizeObserver;
exports.createTrackerScope = createTrackerScope;
exports.createUseReporter = createUseReporter;
exports.createUserColorManager = createUserColorManager;
exports.createUserStore = createUserStore;
exports.dec = dec;
exports.defaultLocale = defaultLocale;
exports.defaultResolveAnnotationComponent = defaultResolveAnnotationComponent;
exports.defaultResolveBlockComponent = defaultResolveBlockComponent;
exports.defaultResolveFieldComponent = defaultResolveFieldComponent;
exports.defaultResolveInlineBlockComponent = defaultResolveInlineBlockComponent;
exports.defaultResolveInputComponent = defaultResolveInputComponent;
exports.defaultResolveItemComponent = defaultResolveItemComponent;
exports.defaultTheme = defaultTheme;
exports.defaults = defaults;
exports.defineLocale = defineLocale;
exports.defineLocaleResourceBundle = defineLocaleResourceBundle;
exports.defineLocalesResources = defineLocalesResources;
exports.defineSearchFilter = defineSearchFilter;
exports.defineSearchFilterOperators = defineSearchFilterOperators;
exports.defineSearchOperator = defineSearchOperator;
exports.diffMatchPatch = diffMatchPatch;
exports.documentFieldActionsReducer = documentFieldActionsReducer;
exports.documentIdEquals = documentIdEquals;
exports.editState = editState;
exports.emitOperation = emitOperation;
exports.escapeField = escapeField;
exports.fieldNeedsEscape = fieldNeedsEscape;
exports.findIndex = findIndex;
exports.flattenConfig = flattenConfig;
exports.getAnnotationAtPath = getAnnotationAtPath;
exports.getAnnotationColor = getAnnotationColor;
exports.getDiffAtPath = getDiffAtPath;
exports.getDocumentPairPermissions = getDocumentPairPermissions;
exports.getDocumentValuePermissions = getDocumentValuePermissions;
exports.getDraftId = getDraftId;
exports.getFieldLevel = getFieldLevel;
exports.getIdPair = getIdPair;
exports.getInitialValueStream = getInitialValueStream;
exports.getItemKey = getItemKey;
exports.getItemKeySegment = getItemKeySegment;
exports.getNamelessWorkspaceIdentifier = getNamelessWorkspaceIdentifier;
exports.getPairListener = getPairListener;
exports.getPreviewPaths = getPreviewPaths;
exports.getPreviewStateObservable = getPreviewStateObservable;
exports.getPreviewValueWithFallback = getPreviewValueWithFallback;
exports.getProviderTitle = getProviderTitle;
exports.getPublishedId = getPublishedId;
exports.getSchemaTypeTitle = getSchemaTypeTitle;
exports.getSearchableTypes = getSearchableTypes;
exports.getTemplatePermissions = getTemplatePermissions;
exports.getValueAtPath = getValueAtPath;
exports.getValueError = getValueError;
exports.getWorkspaceIdentifier = getWorkspaceIdentifier;
exports.globalScope = globalScope;
exports.grantsPermissionOn = grantsPermissionOn;
exports.immutableReconcile = immutableReconcile;
exports.inc = inc;
exports.initialDocumentFieldActions = initialDocumentFieldActions;
exports.insert = insert;
exports.intlCache = intlCache;
exports.isAddedItemDiff = isAddedItemDiff;
exports.isArrayOfBlocksInputProps = isArrayOfBlocksInputProps;
exports.isArrayOfObjectsInputProps = isArrayOfObjectsInputProps;
exports.isArrayOfPrimitivesInputProps = isArrayOfPrimitivesInputProps;
exports.isAuthStore = isAuthStore;
exports.isBooleanInputProps = isBooleanInputProps;
exports.isBuilder = isBuilder;
exports.isCookielessCompatibleLoginMethod = isCookielessCompatibleLoginMethod;
exports.isDev = isDev;
exports.isDraft = isDraft;
exports.isDraftId = isDraftId;
exports.isEmptyObject = isEmptyObject$1;
exports.isFieldChange = isFieldChange;
exports.isGroupChange = isGroupChange;
exports.isMemberArrayOfObjects = isMemberArrayOfObjects;
exports.isMemberObject = isMemberObject;
exports.isNonNullable = isNonNullable$2;
exports.isNumberInputProps = isNumberInputProps;
exports.isObjectInputProps = isObjectInputProps;
exports.isObjectItemProps = isObjectItemProps;
exports.isProd = isProd;
exports.isPublishedId = isPublishedId;
exports.isRecord = isRecord$4;
exports.isRemovedItemDiff = isRemovedItemDiff;
exports.isString = isString;
exports.isStringInputProps = isStringInputProps;
exports.isUnchangedDiff = isUnchangedDiff;
exports.joinPath = joinPath;
exports.listenQuery = listenQuery;
exports.matchWorkspace = matchWorkspace;
exports.memoize = memoize;
exports.memoizeKeyGen = memoizeKeyGen;
exports.memoizedPair = memoizedPair;
exports.newDraftFrom = newDraftFrom;
exports.noop = noop$2;
exports.normalizeIndexSegment = normalizeIndexSegment;
exports.normalizeIndexTupleSegment = normalizeIndexTupleSegment;
exports.normalizeKeySegment = normalizeKeySegment;
exports.normalizePathSegment = normalizePathSegment;
exports.onRetry = onRetry;
exports.operationEvents = operationEvents;
exports.operatorDefinitions = operatorDefinitions;
exports.pathToString = pathToString$1;
exports.pathsAreEqual = pathsAreEqual;
exports.prefixPath = prefixPath;
exports.prepareConfig = prepareConfig;
exports.prepareForPreview = prepareForPreview;
exports.removeDupes = removeDupes;
exports.removeMissingReferences = removeMissingReferences;
exports.removeUndefinedLocaleResources = removeUndefinedLocaleResources;
exports.resizeObserver = resizeObserver;
exports.resolveDiffComponent = resolveDiffComponent;
exports.resolveInitialObjectValue = resolveInitialObjectValue;
exports.resolveInitialValue = resolveInitialValue;
exports.resolveInitialValueForType = resolveInitialValueForType;
exports.resolveSchemaTypes = resolveSchemaTypes;
exports.set = set;
exports.setIfMissing = setIfMissing;
exports.sliceString = sliceString;
exports.snapshotPair = snapshotPair;
exports.stringToPath = stringToPath;
exports.supportsTouch = supportsTouch;
exports.truncateString = truncateString;
exports.unset = unset;
exports.usEnglishLocale = usEnglishLocale;
exports.useActiveWorkspace = useActiveWorkspace;
exports.useAnnotationColor = useAnnotationColor;
exports.useAnnotationComponent = useAnnotationComponent;
exports.useBlockComponent = useBlockComponent;
exports.useClient = useClient;
exports.useColorScheme = useColorScheme;
exports.useColorSchemeOptions = useColorSchemeOptions;
exports.useColorSchemeSetValue = useColorSchemeSetValue;
exports.useColorSchemeValue = useColorSchemeValue;
exports.useConnectionStatusStore = useConnectionStatusStore;
exports.useCurrentUser = useCurrentUser;
exports.useDataset = useDataset;
exports.useDateTimeFormat = useDateTimeFormat;
exports.useDidUpdate = useDidUpdate;
exports.useDiffAnnotationColor = useDiffAnnotationColor;
exports.useDocumentChange = useDocumentChange;
exports.useDocumentOperation = useDocumentOperation;
exports.useDocumentPairPermissions = useDocumentPairPermissions;
exports.useDocumentPairPermissionsFromHookFactory = useDocumentPairPermissionsFromHookFactory;
exports.useDocumentPresence = useDocumentPresence;
exports.useDocumentPreview = useDocumentPreview;
exports.useDocumentPreviewStore = useDocumentPreviewStore;
exports.useDocumentStore = useDocumentStore;
exports.useDocumentValuePermissions = useDocumentValuePermissions;
exports.useDocumentValuePermissionsFromHookFactory = useDocumentValuePermissionsFromHookFactory;
exports.useDocumentValues = useDocumentValues;
exports.useFeatureEnabled = useFeatureEnabled;
exports.useFieldActions = useFieldActions;
exports.useFieldComponent = useFieldComponent;
exports.useFormBuilder = useFormBuilder;
exports.useFormCallbacks = useFormCallbacks;
exports.useFormValue = useFormValue;
exports.useGetI18nText = useGetI18nText;
exports.useGlobalPresence = useGlobalPresence;
exports.useGrantsStore = useGrantsStore;
exports.useHistoryStore = useHistoryStore;
exports.useHoveredField = useHoveredField;
exports.useI18nText = useI18nText;
exports.useInitialValue = useInitialValue;
exports.useInitialValueResolverContext = useInitialValueResolverContext;
exports.useInlineBlockComponent = useInlineBlockComponent;
exports.useInputComponent = useInputComponent;
exports.useItemComponent = useItemComponent;
exports.useKeyValueStore = useKeyValueStore;
exports.useListFormat = useListFormat;
exports.useLoadable = useLoadable;
exports.useMiddlewareComponents = useMiddlewareComponents;
exports.usePresenceStore = usePresenceStore;
exports.usePreviewCard = usePreviewCard;
exports.usePreviewComponent = usePreviewComponent;
exports.useProjectId = useProjectId;
exports.useProjectStore = useProjectStore;
exports.useReferenceInputOptions = useReferenceInputOptions;
exports.useReferringDocuments = useReferringDocuments;
exports.useRelativeTime = useRelativeTime;
exports.useReportedValues = useReportedValues$1;
exports.useReporter = useReporter$1;
exports.useResolveInitialValueForType = useResolveInitialValueForType;
exports.useResourceCache = useResourceCache;
exports.useRovingFocus = useRovingFocus;
exports.useSchema = useSchema;
exports.useSearchMaxFieldDepth = useSearchMaxFieldDepth;
exports.useSearchState = useSearchState;
exports.useSource = useSource;
exports.useTemplatePermissions = useTemplatePermissions;
exports.useTemplatePermissionsFromHookFactory = useTemplatePermissionsFromHookFactory;
exports.useTemplates = useTemplates;
exports.useTranslation = useTranslation;
exports.useUnique = useUnique;
exports.useUnitFormatter = useUnitFormatter;
exports.useUser = useUser;
exports.useUserColor = useUserColor;
exports.useUserColorManager = useUserColorManager;
exports.useUserStore = useUserStore;
exports.useVirtualizerScrollInstance = useVirtualizerScrollInstance;
exports.useWorkspace = useWorkspace;
exports.useWorkspaceLoader = useWorkspaceLoader;
exports.useWorkspaces = useWorkspaces;
exports.useZIndex = useZIndex;
exports.userHasRole = userHasRole;
exports.validateBasePaths = validateBasePaths;
exports.validateDocument = validateDocument;
exports.validateNames = validateNames;
exports.validateTemplates = validateTemplates;
exports.validateWorkspaces = validateWorkspaces;
exports.validation = validation;
exports.visitDiff = visitDiff;
//# sourceMappingURL=TransformPatches.js.map
