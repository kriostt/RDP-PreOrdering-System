import viteReact from "@vitejs/plugin-react";
import debug$4 from "debug";
import path from "path";
import readPkgUp from "read-pkg-up";
import { mergeConfig } from "vite";
import { getStudioEnvironmentVariables } from "../cli.esm.js";
import "resolve-from";
import history from "connect-history-api-fallback";
import fs from "fs";
import fs$1 from "fs/promises";
import chokidar from "chokidar";
import chalk from "chalk";
import importFresh from "import-fresh";
import { createElement } from "react";
import { renderToStaticMarkup } from "react-dom/server";
import { isMainThread, parentPort, workerData, Worker } from "worker_threads";
const debug$3 = debug$4("sanity:server");
function getAliases(opts) {
  const { monorepo } = opts;
  if (!(monorepo != null && monorepo.path))
    return {};
  const aliasesPath = path.resolve(monorepo.path, "dev/aliases.cjs"), devAliases = require(aliasesPath);
  return Object.fromEntries(
    Object.entries(devAliases).map(([key, modulePath]) => [key, path.resolve(monorepo.path, modulePath)])
  );
}
function normalizeBasePath(pathName) {
  return `/${pathName}/`.replace(/^\/+/, "/").replace(/\/+$/, "/");
}
async function loadSanityMonorepo(cwd) {
  let p = cwd;
  for (; p !== "/"; ) {
    const readResult = await readPkgUp({ cwd: p });
    if (!readResult)
      return;
    if (readResult.packageJson.isSanityMonorepo)
      return { path: path.dirname(readResult.path) };
    p = path.dirname(path.dirname(readResult.path));
  }
}
const debug$2 = debug$3.extend("renderDocument"), useThreads = typeof process.env.JEST_WORKER_ID > "u", hasWarnedAbout = /* @__PURE__ */ new Set(), defaultProps = {
  entryPath: "./.sanity/runtime/app.js"
}, autoGeneratedWarning = `
This file is auto-generated from "sanity dev".
Modifications to this file are automatically discarded.
`.trim();
function renderDocument(options) {
  return new Promise((resolve, reject) => {
    if (!useThreads) {
      resolve(getDocumentHtml(options.studioRootPath, options.props));
      return;
    }
    debug$2("Starting worker thread for %s", __filename);
    const worker = new Worker(__filename, {
      execArgv: void 0,
      workerData: { ...options, dev: !1, shouldWarn: !0 },
      // eslint-disable-next-line no-process-env
      env: process.env
    });
    worker.on("message", (msg) => {
      if (msg.type === "warning") {
        if (hasWarnedAbout.has(msg.warnKey))
          return;
        Array.isArray(msg.message) ? msg.message.forEach(
          (warning) => console.warn(`${chalk.yellow("[warn]")} ${warning}`)
        ) : console.warn(`${chalk.yellow("[warn]")} ${msg.message}`), hasWarnedAbout.add(msg.warnKey);
        return;
      }
      if (msg.type === "error") {
        debug$2("Error from worker: %s", msg.error || "Unknown error"), reject(new Error(msg.error || "Document rendering worker stopped with an unknown error"));
        return;
      }
      msg.type === "result" && (debug$2("Document HTML rendered, %d bytes", msg.html.length), resolve(msg.html));
    }), worker.on("error", (err) => {
      debug$2("Worker errored: %s", err.message), reject(err);
    }), worker.on("exit", (code) => {
      code !== 0 && (debug$2("Worker stopped with code %d", code), reject(new Error(`Document rendering worker stopped with exit code ${code}`)));
    });
  });
}
function decorateIndexWithAutoGeneratedWarning(template) {
  return template.replace(/<head/, `
<!--
${autoGeneratedWarning}
-->
<head`);
}
function getPossibleDocumentComponentLocations(studioRootPath) {
  return [path.join(studioRootPath, "_document.js"), path.join(studioRootPath, "_document.tsx")];
}
function _prefixUrlWithBasePath(url, basePath) {
  const normalizedBasePath = basePath.startsWith("/") ? basePath : `/${basePath}`;
  return url.startsWith("/") ? normalizedBasePath.endsWith("/") ? `${normalizedBasePath.slice(0, -1)}${url}` : `${normalizedBasePath}${url}` : normalizedBasePath.endsWith("/") ? `${normalizedBasePath}${url}` : `${normalizedBasePath}/${url}`;
}
!isMainThread && parentPort && renderDocumentFromWorkerData();
function renderDocumentFromWorkerData() {
  var _a;
  if (!parentPort || !workerData)
    throw new Error("Must be used as a Worker with a valid options object in worker data");
  const { monorepo, studioRootPath, props } = workerData || {};
  if ((_a = workerData) != null && _a.dev && (global.__DEV__ = !0), typeof studioRootPath != "string") {
    parentPort.postMessage({ type: "error", message: "Missing/invalid `studioRootPath` option" });
    return;
  }
  if (props && typeof props != "object") {
    parentPort.postMessage({ type: "error", message: "`props` must be an object if provided" });
    return;
  }
  debug$2("Registering potential aliases"), require("module-alias").addAliases(getAliases({ monorepo })), debug$2("Registering esbuild for node %s", process.version);
  const { unregister } = require("esbuild-register/dist/node").register({
    target: `node${process.version.slice(1)}`,
    jsx: "automatic",
    extensions: [".jsx", ".ts", ".tsx", ".mjs"]
  });
  debug$2("Registering esbuild for .js files using jsx loader");
  const { unregister: unregisterJs } = require("esbuild-register/dist/node").register({
    target: `node${process.version.slice(1)}`,
    extensions: [".js"],
    jsx: "automatic",
    loader: "jsx"
  }), html = getDocumentHtml(studioRootPath, props);
  parentPort.postMessage({ type: "result", html }), unregister(), unregisterJs();
}
function getDocumentHtml(studioRootPath, props) {
  var _a;
  const Document = getDocumentComponent(studioRootPath), css = (_a = props == null ? void 0 : props.css) == null ? void 0 : _a.map((url) => {
    try {
      return new URL(url).toString();
    } catch {
      return _prefixUrlWithBasePath(url, props.basePath);
    }
  });
  return debug$2("Rendering document component using React"), `<!DOCTYPE html>${renderToStaticMarkup(createElement(Document, { ...defaultProps, ...props, css }))}`;
}
function getDocumentComponent(studioRootPath) {
  var _a;
  debug$2("Loading default document component from `sanity` module");
  const { DefaultDocument } = require("sanity");
  debug$2("Attempting to load user-defined document component from %s", studioRootPath);
  const userDefined = tryLoadDocumentComponent(studioRootPath);
  if (!userDefined)
    return debug$2("Using default document component"), DefaultDocument;
  debug$2("Found user defined document component at %s", userDefined.path);
  const DocumentComp = userDefined.component.default || userDefined.component;
  if (typeof DocumentComp == "function")
    return debug$2("User defined document component is a function, assuming valid"), DocumentComp;
  debug$2("User defined document component did not have a default export");
  const userExports = Object.keys(userDefined.component).join(", ") || "None", relativePath = path.relative(process.cwd(), userDefined.path), typeHint = typeof userDefined.component.default > "u" ? "" : ` (type was ${typeof userDefined.component.default})`, warnKey = `${relativePath}/${userDefined.modified}`;
  return (_a = parentPort) == null || _a.postMessage({
    type: "warning",
    message: [
      `${relativePath} did not have a default export that is a React component${typeHint}`,
      `Named exports/properties found: ${userExports}`.trim(),
      'Using default document component from "sanity".'
    ],
    warnKey
  }), DefaultDocument;
}
function tryLoadDocumentComponent(studioRootPath) {
  var _a;
  const locations = getPossibleDocumentComponentLocations(studioRootPath);
  for (const componentPath of locations) {
    debug$2("Trying to load document component from %s", componentPath);
    try {
      return {
        // eslint-disable-next-line import/no-dynamic-require
        component: importFresh(componentPath),
        path: componentPath,
        // eslint-disable-next-line no-sync
        modified: Math.floor((_a = fs.statSync(componentPath)) == null ? void 0 : _a.mtimeMs)
      };
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND")
        throw debug$2("Failed to load document component: %s", err.message), err;
      debug$2("Document component not found at %s", componentPath);
    }
  }
  return null;
}
const entryChunkId = ".sanity/runtime/app.js";
function sanityBuildEntries(options) {
  const { cwd, monorepo, basePath } = options;
  return {
    name: "sanity/server/build-entries",
    apply: "build",
    buildStart() {
      this.emitFile({
        type: "chunk",
        id: entryChunkId,
        name: "sanity"
      });
    },
    async generateBundle(_options, outputBundle) {
      var _a;
      const bundle = outputBundle, entryFile = Object.values(bundle).find(
        (file) => {
          var _a2;
          return file.type === "chunk" && file.name === "sanity" && ((_a2 = file.facadeModuleId) == null ? void 0 : _a2.endsWith(entryChunkId));
        }
      );
      if (!entryFile)
        throw new Error(`Failed to find entry file in bundle (${entryChunkId})`);
      if (entryFile.type !== "chunk")
        throw new Error("Entry file is not a chunk");
      const entryFileName = entryFile.fileName, entryPath = [basePath.replace(/\/+$/, ""), entryFileName].join("/");
      let css = [];
      if ((_a = entryFile.viteMetadata) != null && _a.importedCss) {
        css = [...entryFile.viteMetadata.importedCss];
        for (const key of entryFile.imports) {
          const entry = bundle[key], importedCss = entry && entry.type === "chunk" ? entry.viteMetadata.importedCss : void 0;
          importedCss && css.push(...importedCss);
        }
      }
      this.emitFile({
        type: "asset",
        fileName: "index.html",
        source: await renderDocument({
          monorepo,
          studioRootPath: cwd,
          props: {
            basePath,
            entryPath,
            css
          }
        })
      });
    }
  };
}
function sanityDotWorkaroundPlugin() {
  return {
    name: "sanity/server/dot-workaround",
    configureServer(server) {
      const { root } = server.config;
      return () => {
        const handler = history({
          disableDotRule: !0,
          rewrites: [
            {
              from: /\/index.html$/,
              to: ({ parsedUrl }) => {
                const pathname = parsedUrl.pathname;
                return pathname && fs.existsSync(path.join(root, pathname)) ? pathname : "/index.html";
              }
            }
          ]
        });
        server.middlewares.use((req, res, next) => {
          handler(req, res, next);
        });
      };
    }
  };
}
function generateWebManifest(basePath) {
  return {
    icons: [
      { src: `${basePath}/favicon-192.png`, type: "image/png", sizes: "192x192" },
      { src: `${basePath}/favicon-512.png`, type: "image/png", sizes: "512x512" }
    ]
  };
}
const mimeTypes = {
  ".ico": "image/x-icon",
  ".svg": "image/svg+xml",
  ".png": "image/png"
};
function sanityFaviconsPlugin({
  defaultFaviconsPath,
  customFaviconsPath,
  staticUrlPath
}) {
  const cache = {};
  async function getFavicons() {
    return cache.favicons || (cache.favicons = await fs$1.readdir(defaultFaviconsPath)), cache.favicons;
  }
  async function hasCustomFavicon() {
    try {
      return await fs$1.access(path.join(customFaviconsPath, "favicon.ico")), !0;
    } catch {
      return !1;
    }
  }
  return {
    name: "sanity/server/sanity-favicons",
    apply: "serve",
    configureServer(viteDevServer) {
      const webManifest = JSON.stringify(generateWebManifest(staticUrlPath), null, 2), webManifestPath = `${staticUrlPath}/manifest.webmanifest`;
      return () => {
        viteDevServer.middlewares.use(async (req, res, next) => {
          var _a;
          if ((_a = req.url) != null && _a.endsWith(webManifestPath)) {
            res.writeHead(200, "OK", { "content-type": "application/manifest+json" }), res.write(webManifest), res.end();
            return;
          }
          const pathName = (req._parsedUrl || new URL(req.url || "/", "http://localhost:3333")).pathname || "", fileName = path.basename(pathName || ""), icons = await getFavicons();
          if (!(pathName.startsWith("/favicon.ico") || icons.includes(fileName) && pathName.includes(staticUrlPath))) {
            next();
            return;
          }
          const faviconPath = fileName === "favicon.ico" && await hasCustomFavicon() ? path.join(customFaviconsPath, "favicon.ico") : path.join(defaultFaviconsPath, fileName), mimeType = mimeTypes[path.extname(fileName)] || "application/octet-stream";
          res.writeHead(200, "OK", { "content-type": mimeType }), res.write(await fs$1.readFile(faviconPath)), res.end();
        });
      };
    }
  };
}
function sanityRuntimeRewritePlugin() {
  return {
    name: "sanity/server/sanity-runtime-rewrite",
    apply: "serve",
    configureServer(viteDevServer) {
      return () => {
        viteDevServer.middlewares.use((req, res, next) => {
          req.url === "/index.html" && (req.url = "/.sanity/runtime/index.html"), next();
        });
      };
    }
  };
}
async function getViteConfig(options) {
  var _a;
  const {
    cwd,
    mode,
    outputDir,
    // default to `true` when `mode=development`
    sourceMap = options.mode === "development",
    server,
    minify,
    basePath: rawBasePath = "/"
  } = options, monorepo = await loadSanityMonorepo(cwd), basePath = normalizeBasePath(rawBasePath), sanityPkgPath = (_a = await readPkgUp({ cwd: __dirname })) == null ? void 0 : _a.path;
  if (!sanityPkgPath)
    throw new Error("Unable to resolve `sanity` module root");
  const customFaviconsPath = path.join(cwd, "static"), defaultFaviconsPath = path.join(path.dirname(sanityPkgPath), "static", "favicons"), staticPath = `${basePath}static`, viteConfig = {
    // Define a custom cache directory so that sanity's vite cache
    // does not conflict with any potential local vite projects
    cacheDir: "node_modules/.sanity/vite",
    root: cwd,
    base: basePath,
    build: {
      outDir: outputDir || path.resolve(cwd, "dist"),
      sourcemap: sourceMap
    },
    server: {
      host: server == null ? void 0 : server.host,
      port: (server == null ? void 0 : server.port) || 3333,
      strictPort: !0
    },
    configFile: !1,
    mode,
    plugins: [
      viteReact(),
      sanityFaviconsPlugin({ defaultFaviconsPath, customFaviconsPath, staticUrlPath: staticPath }),
      sanityDotWorkaroundPlugin(),
      sanityRuntimeRewritePlugin(),
      sanityBuildEntries({ basePath, cwd, monorepo })
    ],
    envPrefix: "SANITY_STUDIO_",
    logLevel: mode === "production" ? "silent" : "info",
    resolve: {
      alias: getAliases({ monorepo })
    },
    define: {
      // eslint-disable-next-line no-process-env
      __SANITY_STAGING__: process.env.SANITY_INTERNAL_ENV === "staging",
      "process.env.MODE": JSON.stringify(mode),
      ...getStudioEnvironmentVariables({ prefix: "process.env.", jsonEncode: !0 })
    }
  };
  return mode === "production" && (viteConfig.build = {
    ...viteConfig.build,
    assetsDir: "static",
    minify: minify ? "esbuild" : !1,
    emptyOutDir: !1,
    // Rely on CLI to do this
    rollupOptions: {
      input: {
        sanity: path.join(cwd, ".sanity", "runtime", "app.js")
      }
    }
  }), viteConfig;
}
function finalizeViteConfig(config) {
  var _a, _b;
  if (typeof ((_b = (_a = config.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) != "object")
    throw new Error(
      "Vite config must contain `build.rollupOptions.input`, and it must be an object"
    );
  if (!config.root)
    throw new Error(
      "Vite config must contain `root` property, and must point to the Sanity root directory"
    );
  return mergeConfig(config, {
    build: {
      rollupOptions: {
        input: {
          sanity: path.join(config.root, ".sanity", "runtime", "app.js")
        }
      }
    }
  });
}
async function extendViteConfigWithUserConfig(env, defaultConfig, userConfig) {
  let config = defaultConfig;
  return typeof userConfig == "function" ? (debug$4("Extending vite config using user-specified function"), config = await userConfig(config, env)) : typeof userConfig == "object" && (debug$4("Merging vite config using user-specified object"), config = mergeConfig(config, userConfig)), config;
}
const entryModule = `
// This file is auto-generated on 'sanity dev'
// Modifications to this file is automatically discarded
import {renderStudio} from "sanity"
import studioConfig from %STUDIO_CONFIG_LOCATION%

renderStudio(
  document.getElementById("sanity"),
  studioConfig,
  {reactStrictMode: %STUDIO_REACT_STRICT_MODE%, basePath: %STUDIO_BASE_PATH%}
)
`, noConfigEntryModule = `
// This file is auto-generated on 'sanity dev'
// Modifications to this file is automatically discarded
import {renderStudio} from "sanity"

const studioConfig = {missingConfigFile: true}

renderStudio(
  document.getElementById("sanity"),
  studioConfig,
  {reactStrictMode: %STUDIO_REACT_STRICT_MODE%, basePath: %STUDIO_BASE_PATH%}
)
`;
function getEntryModule(options) {
  const { reactStrictMode, relativeConfigLocation, basePath } = options;
  return (relativeConfigLocation ? entryModule : noConfigEntryModule).replace(/%STUDIO_REACT_STRICT_MODE%/, JSON.stringify(!!reactStrictMode)).replace(/%STUDIO_CONFIG_LOCATION%/, JSON.stringify(relativeConfigLocation)).replace(/%STUDIO_BASE_PATH%/, JSON.stringify(basePath || "/"));
}
const debug$1 = debug$3.extend("config");
async function getSanityStudioConfigPath(studioRootPath) {
  const configPaths = [
    path.join(studioRootPath, "sanity.config.mjs"),
    path.join(studioRootPath, "sanity.config.js"),
    path.join(studioRootPath, "sanity.config.ts"),
    path.join(studioRootPath, "sanity.config.jsx"),
    path.join(studioRootPath, "sanity.config.tsx")
  ];
  debug$1("Looking for configuration file in %d possible locations", configPaths.length);
  const availableConfigs = (await Promise.all(
    configPaths.map(async (configPath) => ({
      path: configPath,
      exists: await fileExists(configPath)
    }))
  )).filter((config) => config.exists);
  return debug$1("Found %d available configuration files", availableConfigs.length), availableConfigs.length === 0 ? (console.warn("No `sanity.config.js`/`sanity.config.ts` found - using default studio config"), null) : (availableConfigs.length > 1 && (console.warn("Found multiple potential studio configs:"), availableConfigs.forEach((config) => console.warn(` - ${config.path}`)), console.warn(`Using ${availableConfigs[0].path}`)), availableConfigs[0].path);
}
function fileExists(filePath) {
  return fs$1.stat(filePath).then(
    () => !0,
    () => !1
  );
}
const debug = debug$3.extend("runtime");
async function writeSanityRuntime({
  cwd,
  reactStrictMode,
  watch,
  basePath
}) {
  debug("Resolving Sanity monorepo information");
  const monorepo = await loadSanityMonorepo(cwd), runtimeDir = path.join(cwd, ".sanity", "runtime");
  debug("Making runtime directory"), await fs$1.mkdir(runtimeDir, { recursive: !0 });
  async function renderAndWriteDocument() {
    debug("Rendering document template");
    const indexHtml = decorateIndexWithAutoGeneratedWarning(
      await renderDocument({
        studioRootPath: cwd,
        monorepo,
        props: {
          entryPath: `/${path.relative(cwd, path.join(runtimeDir, "app.js"))}`,
          basePath: basePath || "/"
        }
      })
    );
    debug("Writing index.html to runtime directory"), await fs$1.writeFile(path.join(runtimeDir, "index.html"), indexHtml);
  }
  watch && chokidar.watch(getPossibleDocumentComponentLocations(cwd)).on("all", () => renderAndWriteDocument()), await renderAndWriteDocument(), debug("Writing app.js to runtime directory");
  const studioConfigPath = await getSanityStudioConfigPath(cwd), relativeConfigLocation = studioConfigPath ? path.relative(runtimeDir, studioConfigPath) : null;
  await fs$1.writeFile(
    path.join(runtimeDir, "app.js"),
    getEntryModule({ reactStrictMode, relativeConfigLocation, basePath })
  );
}
export {
  generateWebManifest as a,
  debug$3 as d,
  extendViteConfigWithUserConfig as e,
  finalizeViteConfig as f,
  getViteConfig as g,
  writeSanityRuntime as w
};
//# sourceMappingURL=runtime.js.map
