import { promises } from "fs";
import path from "path";
import tar from "tar-fs";
import zlib from "zlib";
import buildSanityStudio from "./buildAction.js";
async function deployStudio(args, context) {
  const { apiClient, workDir, chalk, output, prompt } = context, flags = { build: !0, ...args.extOptions }, destFolder = args.argsWithoutOptions[0], sourceDir = path.resolve(process.cwd(), destFolder || path.join(workDir, "dist"));
  if (destFolder === "graphql")
    throw new Error("Did you mean `sanity graphql deploy`?");
  if (destFolder) {
    let relativeOutput = path.relative(process.cwd(), sourceDir);
    if (relativeOutput[0] !== "." && (relativeOutput = `./${relativeOutput}`), !(await dirIsEmptyOrNonExistent(sourceDir) || await prompt.single({
      type: "confirm",
      message: `"${relativeOutput}" is not empty, do you want to proceed?`,
      default: !1
    }))) {
      output.print("Cancelled.");
      return;
    }
    output.print(`Building to ${relativeOutput}
`);
  }
  const client = apiClient({
    requireUser: !0,
    requireProject: !0
  });
  let spinner = output.spinner("Checking project info").start();
  const project = await client.projects.getById(client.config().projectId);
  let studioHostname = project && project.studioHost;
  if (spinner.succeed(), studioHostname || (output.print("Your project has not been assigned a studio hostname."), output.print("To deploy your Sanity Studio to our hosted Sanity.Studio service,"), output.print("you will need one. Please enter the part you want to use."), studioHostname = await prompt.single({
    type: "input",
    filter: (inp) => inp.replace(/\.sanity\.studio$/i, ""),
    message: "Studio hostname (<value>.sanity.studio):",
    validate: (name) => validateHostname(name, client)
  })), flags.build) {
    const buildArgs = [destFolder].filter(Boolean), { didCompile } = await buildSanityStudio(
      { ...args, extOptions: flags, argsWithoutOptions: buildArgs },
      context,
      { basePath: "/" }
    );
    if (!didCompile)
      return;
  }
  spinner = output.spinner("Verifying local content").start();
  try {
    await checkDir(sourceDir), spinner.succeed();
  } catch (err) {
    throw spinner.fail(), err;
  }
  const parentDir = path.dirname(sourceDir), base = path.basename(sourceDir), tarball = tar.pack(parentDir, { entries: [base] }).pipe(zlib.createGzip());
  spinner = output.spinner("Deploying to Sanity.Studio").start();
  try {
    const response = await client.request({
      method: "POST",
      url: "/deploy",
      body: tarball,
      maxRedirects: 0
    });
    spinner.succeed(), output.print(`
Success! Studio deployed to ${chalk.cyan(response.location)}`);
  } catch (err) {
    throw spinner.fail(), err;
  }
}
async function dirIsEmptyOrNonExistent(sourceDir) {
  try {
    if (!(await promises.stat(sourceDir)).isDirectory())
      throw new Error(`Directory ${sourceDir} is not a directory`);
  } catch (err) {
    if (err.code === "ENOENT")
      return !0;
    throw err;
  }
  return (await promises.readdir(sourceDir)).length === 0;
}
async function checkDir(sourceDir) {
  try {
    if (!(await promises.stat(sourceDir)).isDirectory())
      throw new Error(`Directory ${sourceDir} is not a directory`);
  } catch (err) {
    throw err.code === "ENOENT" ? new Error(`Directory "${sourceDir}" does not exist`) : err;
  }
  try {
    await promises.stat(path.join(sourceDir, "index.html"));
  } catch (err) {
    throw err.code === "ENOENT" ? new Error(
      [
        `"${sourceDir}/index.html" does not exist -`,
        "[SOURCE_DIR] must be a directory containing",
        'a Sanity studio built using "sanity build"'
      ].join(" ")
    ) : err;
  }
}
async function validateHostname(value, client) {
  var _a, _b;
  const uri = `/projects/${client.config().projectId}`, studioHost = value || "";
  if (!/^[a-z0-9_-]+$/i.test(studioHost))
    return "Hostname can contain only A-Z, 0-9, _ and -";
  try {
    return await client.request({ uri, method: "PATCH", body: { studioHost } }), !0;
  } catch (error) {
    if ((_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.body) != null && _b.message)
      return error.response.body.message;
    throw error;
  }
}
export {
  deployStudio as default
};
//# sourceMappingURL=deployAction.js.map
