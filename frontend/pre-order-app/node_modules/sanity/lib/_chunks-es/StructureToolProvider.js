import { jsxs, jsx, Fragment as Fragment$1 } from "react/jsx-runtime";
import { Stack, Box, Flex, Text, rem, Inline, useToast, Card, ErrorBoundary, Layer, useForwardedRef, BoundaryElementProvider, MenuDivider, Menu, TextSkeleton, rgba, useElementRect, LayerProvider, Avatar, ThemeColorProvider, DialogProvider, Badge, useClickOutside, focusLastDescendant, focusFirstDescendant, Grid, Button as Button$1, useLayer, Container, useBoundaryElement, usePortal, _raf2, TextInput, TabList, TabPanel, Code, Heading, Spinner, PortalProvider, Popover as Popover$1, useGlobalKeyDown, Dialog as Dialog$1, AvatarStack, Hotkeys, Skeleton, MenuItem as MenuItem$1, Switch, Checkbox, useMediaIndex } from "@sanity/ui";
import * as React from "react";
import React__default, { useMemo, Fragment, useCallback, forwardRef, createContext, useState, useRef, memo, useEffect, useReducer, useContext, isValidElement, useId, useImperativeHandle, cloneElement, createElement, useLayoutEffect, startTransition, lazy } from "react";
import { ChevronRightIcon, InfoOutlineIcon, UnknownIcon, WarningOutlineIcon, DocumentsIcon, ChevronDownIcon, CopyIcon, CheckmarkIcon, AddIcon, DocumentIcon, FolderIcon, CheckmarkCircleIcon, UndoIcon, EditIcon, TrashIcon, LinkIcon, LinkRemovedIcon, LaunchIcon, CloseIcon, AddCommentIcon, CommentIcon as CommentIcon$1, SearchIcon, ReadOnlyIcon, ErrorOutlineIcon, SyncIcon, AddCircleIcon, PublishIcon, UnpublishIcon, ArrowLeftIcon, SplitVerticalIcon, ResetIcon, RestoreIcon, JsonIcon, EarthAmericasIcon, SpinnerIcon, SortIcon, StackCompactIcon, StackIcon, CircleIcon, UserIcon, CalendarIcon, ChevronLeftIcon, TaskIcon, PanelRightIcon, MasterDetailIcon } from "@sanity/icons";
import { defineLocaleResourceBundle, useTranslation, TextWithTone, getValueAtPath, resolveConditionalProperty, getSchemaTypeTitle, isPortableTextTextBlock, isPortableTextSpan, getPublishedId, useAddonDataset, useEditState, useSchema, useCurrentUser, useWorkspace, useUserListWithPermissions, useProjectId, useClient, DEFAULT_STUDIO_CLIENT_OPTIONS, UpsellDialogLearnMoreCtaClicked, UpsellDialogUpgradeCtaClicked, UpsellDialogViewed, UpsellDialogDismissed, unstable_useValuePreview, isRecord, getPreviewStateObservable, SanityDefaultPreview, getPreviewValueWithFallback, DocumentPreviewPresence, DocumentStatusIndicator, DocumentStatus, useUnique, useDocumentPresence, useDocumentPreviewStore, PreviewCard, Translate, createHookFromObservableFactory, getDraftId, useDocumentStore, LoadingBlock, LegacyLayerProvider, useGetI18nText, useI18nText, TooltipOfDisabled, ContextMenuButton, StatusButton, InsufficientPermissionsMessage, useTemplates, useTemplatePermissions, EMPTY_ARRAY as EMPTY_ARRAY$k, EMPTY_OBJECT, GetHookCollectionState, useTools, useFeatureEnabled, useSource, useUser, CommandList, useDidUpdate, useListFormat, useRelativeTime, useDateTimeFormat, UpsellDescriptionSerializer, isArrayOfBlocksSchemaType, BetaBadge, defineDocumentInspector, AddonDatasetProvider, definePlugin, isDev, useDocumentOperationEvent, useKeyValueStore, isString as isString$1, useDocumentOperation, isDeprecatedSchemaType, createPatchChannel, PresenceOverlay, FormBuilder, fromMutationPatches, ScrollContainer, useTimelineSelector, VirtualizerScrollInstanceProvider, UserAvatar, useFieldActions, useDocumentPairPermissions, useValidationStatus, useSyncState, resizeObserver, ChangeConnectorRoot, useZIndex, FieldActionsResolver, FieldActionsProvider, useMiddlewareComponents, usePresenceStore, useInitialValue, useConnectionState, useTimelineStore, toMutationPatches, setAtPath, useDocumentValuePermissions, useFormState, getExpandOperations, SourceProvider, useDocumentType, ReferenceInputOptionsProvider, collate, getConfigContextFromSource, set, useFormValue, unset, WorkspaceLoader, FormFieldHeaderText, SearchProvider, SearchPopover, SearchResultItemPreview, TransformPatches, defineType, defineField as defineField$1, prepareConfig, useWorkspaceLoader, WorkspaceProvider, ResourceCacheProvider, visitDiff, ChangeFieldWrapper, DiffTooltip, NoChanges, DocumentChangeContext, ChangeList, isArray, isValidationError, isValidationWarning, useConfigContextFromSource } from "sanity";
import { uuid } from "@sanity/uuid";
import { motion, AnimatePresence } from "framer-motion";
import styled, { css, keyframes } from "styled-components";
import { T as Tooltip, D as Dialog, b as TooltipDelayGroupProvider, B as Button, M as MenuGroup, c as MenuItem, d as MenuButton, P as Popover, C as ConditionalWrapper, e as Tab, g as getCalendarLabels, f as DatePicker, h as getJsonStream } from "./getJsonStream.js";
import { StateLink, useIntentLink, IntentLink, useRouterState, useRouter, route, encodeJsonParams, decodeJsonParams } from "sanity/router";
import orderBy from "lodash/orderBy.js";
import isEqual from "lodash/isEqual.js";
import { useTelemetry } from "@sanity/telemetry/react";
import template from "lodash/template.js";
import { toPlainText, PortableText } from "@portabletext/react";
import { hues, white } from "@sanity/color";
import { isArraySchemaType, isObjectSchemaType, isPortableTextTextBlock as isPortableTextTextBlock$1, isPortableTextSpan as isPortableTextSpan$1, isKeySegment, isSanityDocument as isSanityDocument$1, defineField, defineArrayMember, isValidationErrorMarker, isIndexSegment, isReferenceSchemaType } from "@sanity/types";
import { useTranslation as useTranslation$1 } from "react-i18next";
import { usePortableTextEditor, PortableTextEditor, usePortableTextEditorSelection, PortableTextEditable, keyGenerator } from "@sanity/portable-text-editor";
import { Schema } from "@sanity/schema";
import { getTheme_v2 } from "@sanity/ui/theme";
import deburr from "lodash/deburr.js";
import { useMemoObservable, useAsObservable, useObservableCallback } from "react-rx";
import { catchError, of, fromEvent, timer, EMPTY, merge, concat, firstValueFrom, filter, from, defer, mergeMap, throwError, share, partition, take, throttleTime, asyncScheduler, map as map$1, Subject, tap as tap$1, debounce as debounce$1 } from "rxjs";
import CopyToClipboard from "react-copy-to-clipboard";
import isNumber from "lodash/isNumber.js";
import isString from "lodash/isString.js";
import * as PathUtils from "@sanity/util/paths";
import { toString, fromString, get, resolveKeyedPath } from "@sanity/util/paths";
import omit from "lodash/omit.js";
import { switchMap, startWith, map, distinctUntilChanged, shareReplay, catchError as catchError$1, mapTo, delay, debounceTime, tap, take as take$1, mergeMap as mergeMap$1, scan } from "rxjs/operators";
import uniqBy from "lodash/uniqBy.js";
import negate from "lodash/negate.js";
import throttle from "lodash/throttle.js";
import scrollIntoView from "scroll-into-view-if-needed";
import findIndex from "lodash/findIndex.js";
import { makeDiff, cleanupEfficiency, makePatches, applyPatches, DIFF_EQUAL, DIFF_DELETE, DIFF_INSERT } from "@sanity/diff-match-patch";
import isHotkey from "is-hotkey";
import JSONInspector from "@rexxars/react-json-inspector";
import HLRU from "hashlru";
import { defineEvent } from "@sanity/telemetry";
import { isActionEnabled } from "@sanity/schema/_internal";
import shallowEquals from "shallow-equals";
import { getSearchableTypes, createSearch, useSearchMaxFieldDepth } from "sanity/_internalBrowser";
import { exhaustMapWithTrailing } from "rxjs-exhaustmap-with-trailing";
import camelCase from "lodash/camelCase.js";
import speakingurl from "speakingurl";
import uniqueId from "lodash/uniqueId.js";
import { isValidElementType } from "react-is";
import uniq from "lodash/uniq.js";
import kebabCase from "lodash/kebabCase.js";
import { generateHelpUrl } from "@sanity/generate-help-url";
import find from "lodash/find.js";
import startCase from "lodash/startCase.js";
import { format, DEFAULT_DATE_FORMAT, parse } from "@sanity/util/legacyDateFormat";
import FocusLock from "react-focus-lock";
import { applyPatch } from "mendoza";
import { isImageSource } from "@sanity/asset-utils";
import imageUrlBuilder from "@sanity/image-url";
import deepCompare from "react-fast-compare";
import { isToday, isThisISOWeek } from "date-fns";
import debounce from "lodash/debounce.js";
const commentsLocaleNamespace = "comments", commentsUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: commentsLocaleNamespace,
  resources: () => import("./resources.js")
}), DOCUMENT_PANEL_MIN_WIDTH = 320, DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600, DOCUMENT_INSPECTOR_MIN_WIDTH = 320, DOCUMENT_INSPECTOR_MAX_WIDTH = 540, EMPTY_PARAMS$2 = {}, INSPECT_ACTION_PREFIX = "inspect:", DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }], HISTORY_INSPECTOR_NAME = "sanity/structure/history", VALIDATION_INSPECTOR_NAME = "sanity/structure/validation", COMMENTS_INSPECTOR_NAME = "sanity/structure/comments", separator = /* @__PURE__ */ jsx(Text, { muted: !0, children: /* @__PURE__ */ jsx(ChevronRightIcon, {}) }), renderItem = (item, index) => /* @__PURE__ */ jsx(Box, { as: "li", children: /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, `${item}-${index}`);
function CommentBreadcrumbs(props) {
  const { titlePath, maxLength } = props, items = useMemo(() => {
    const len = titlePath.length, beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    return maxLength && len > maxLength ? [
      ...titlePath.slice(0, beforeLength - 1),
      titlePath.slice(beforeLength - 1, len - afterLength),
      ...titlePath.slice(len - afterLength)
    ] : titlePath;
  }, [maxLength, titlePath]), nodes = useMemo(() => items.map((item, index) => {
    const key = `${item}-${index}`, showSeparator = index < items.length - 1;
    return Array.isArray(item) ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        Tooltip,
        {
          content: /* @__PURE__ */ jsx(Stack, { space: 2, padding: 2, children: item.map(renderItem) }),
          children: /* @__PURE__ */ jsx(Box, { children: renderItem("...", index) })
        }
      ),
      showSeparator && separator
    ] }, key) : /* @__PURE__ */ jsxs(Fragment, { children: [
      renderItem(item, index),
      showSeparator && separator
    ] }, key);
  }), [items]);
  return /* @__PURE__ */ jsx(Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
function getDialogCopy(t) {
  return {
    thread: {
      title: t("delete-thread.title"),
      body: t("delete-thread.body"),
      confirmButtonText: t("delete-thread.confirm")
    },
    comment: {
      title: t("delete-comment.title"),
      body: t("delete-comment.body"),
      confirmButtonText: t("delete-comment.confirm")
    }
  };
}
function CommentDeleteDialog(props) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props, { t } = useTranslation(commentsLocaleNamespace), dialogCopy = getDialogCopy(t), { title, body, confirmButtonText } = dialogCopy[isParent ? "thread" : "comment"], handleDelete = useCallback(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return /* @__PURE__ */ jsx(
    Dialog,
    {
      footer: {
        cancelButton: {
          onClick: onClose
        },
        confirmButton: {
          loading,
          onClick: handleDelete,
          text: confirmButtonText,
          tone: "critical"
        }
      },
      header: title,
      id: "delete-comment-dialog",
      onClose,
      width: 0,
      children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
        /* @__PURE__ */ jsx(Text, { size: 1, children: body }),
        error && /* @__PURE__ */ jsx(TextWithTone, { tone: "critical", children: t("delete-dialog.error") })
      ] })
    }
  );
}
const CommentDisabledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "comment-disabled",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.92627 14.5381H7.92627V18.5381L11.9263 14.5381H15.9263C17.0308 14.5381 17.9263 13.6427 17.9263 12.5381V6.53809C17.9263 5.43352 17.0308 4.53809 15.9263 4.53809H5.92627C4.8217 4.53809 3.92627 5.43352 3.92627 6.53809V12.5381C3.92627 13.6427 4.8217 14.5381 5.92627 14.5381Z",
            stroke: "currentColor",
            strokeWidth: "1.2",
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M2.77256 2.66835C2.54413 2.51319 2.23317 2.57259 2.07802 2.80103L1.40378 3.7937C1.32927 3.9034 1.30139 4.0382 1.32627 4.16845C1.35115 4.29871 1.42676 4.41374 1.53646 4.48825L19.5861 16.7479C19.8146 16.903 20.1255 16.8436 20.2807 16.6152L20.9549 15.6225C21.0294 15.5128 21.0573 15.378 21.0324 15.2478C21.0076 15.1175 20.9319 15.0025 20.8222 14.928L2.77256 2.66835Z",
            fill: "currentColor",
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
}), CommentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "comment",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z",
          stroke: "currentColor",
          strokeLinejoin: "round",
          strokeWidth: "1.2"
        }
      )
    }
  );
}), MentionIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "mention",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
}), ReactionIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "add-reaction",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10.1044 10.4011L10.1044 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14.2393 10.4011L14.2393 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.12128 14.1151C7.70803 15.0226 9.66113 16.8377 11.7735 16.8377C13.8859 16.8377 15.6713 15.0226 16.4257 14.1151",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.703 6.43905C15.3486 5.36511 13.6357 4.72374 11.773 4.72374C7.38731 4.72374 3.83203 8.27902 3.83203 12.6647C3.83203 17.0503 7.38731 20.6056 11.773 20.6056C16.0995 20.6056 19.618 17.1455 19.712 12.8415",
            stroke: "currentColor",
            strokeWidth: 1.2
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.1135 9.03425L19.1135 11.4903L20.3135 11.4903L20.3135 9.03425L22.7693 9.03425L22.7693 7.83425L20.3135 7.83425L20.3135 5.37941L19.1135 5.37941L19.1135 7.83425L16.6584 7.83425L16.6584 9.03425L19.1135 9.03425Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}), SendIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "send",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          clipRule: "evenodd",
          d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
}), CommentsAuthoringPathContext = createContext(
  null
);
function CommentsAuthoringPathProvider(props) {
  const { children } = props, [authoringPath, setAuthoringPath] = useState(null), handleSetAuthoringPath = useCallback((nextAuthoringPath) => {
    setAuthoringPath(nextAuthoringPath);
  }, []), value = useMemo(
    () => ({
      authoringPath,
      setAuthoringPath: handleSetAuthoringPath
    }),
    [authoringPath, handleSetAuthoringPath]
  );
  return /* @__PURE__ */ jsx(CommentsAuthoringPathContext.Provider, { value, children });
}
const CommentsContext = createContext(null);
function getSchemaField(schemaType, fieldPath) {
  var _a;
  const paths = PathUtils.fromString(fieldPath), firstPath = paths[0];
  if (firstPath && isObjectSchemaType(schemaType)) {
    const field = (_a = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = PathUtils.toString(paths.slice(1));
      return nextPath ? getSchemaField(field.type, nextPath) : field;
    }
  }
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex(array, pathSegment);
  return index === -1 ? !1 : index;
}
function buildCommentBreadcrumbs(props) {
  const { currentUser, schemaType, fieldPath, documentValue } = props, paths = PathUtils.fromString(fieldPath), fieldPaths = [];
  let currentSchemaType = null;
  return paths.forEach((seg, index) => {
    var _a, _b, _c, _d, _e;
    const currentPath = paths.slice(0, index + 1), previousPath = paths.slice(0, index), field = getSchemaField(schemaType, PathUtils.toString(currentPath)), isKeySegment2 = seg.hasOwnProperty("_key"), parentValue = getValueAtPath(documentValue, previousPath), currentValue = getValueAtPath(documentValue, currentPath), conditionalContext = {
      document: documentValue,
      currentUser,
      parent: parentValue,
      value: currentValue
    };
    if (isKeySegment2 && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg), isNumber2 = typeof arrayItemIndex == "number";
      fieldPaths.push({
        invalid: arrayItemIndex === !1,
        isArrayItem: !0,
        title: isNumber2 ? `#${Number(arrayItemIndex) + 1}` : "Unknown array item"
      });
      return;
    }
    if (field != null && field.type) {
      const hidden = resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({
        invalid: hidden,
        isArrayItem: !1,
        title: getSchemaTypeTitle(field.type)
      }), currentSchemaType = field.type;
      return;
    }
    if (isArraySchemaType(currentSchemaType)) {
      const arrayValue = getValueAtPath(documentValue, previousPath), objectType = arrayValue == null ? void 0 : arrayValue._type, objectField = (_a = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a.find(
        (type) => type.name === objectType
      ), currentField = (_b = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b.find(
        (f) => f.name === seg
      );
      if (!objectType && currentValue) {
        const allCurrentFields = (_c = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat(), anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg), hidden = resolveConditionalProperty((_d = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d.hidden, conditionalContext);
        anonymousField && (fieldPaths.push({
          invalid: hidden,
          isArrayItem: !1,
          title: getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type)
        }), currentSchemaType = anonymousField == null ? void 0 : anonymousField.type);
        return;
      }
      if (!currentField) {
        fieldPaths.push({
          invalid: !0,
          isArrayItem: !1,
          title: "Unknown field"
        });
        return;
      }
      const currentTitle = getSchemaTypeTitle(currentField == null ? void 0 : currentField.type), objectFieldHidden = resolveConditionalProperty(
        (_e = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e.hidden,
        conditionalContext
      ), currentFieldHidden = resolveConditionalProperty(
        currentField == null ? void 0 : currentField.type.hidden,
        conditionalContext
      ), isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({
        invalid: isHidden,
        isArrayItem: !1,
        title: currentTitle
      }), currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({
      invalid: !0,
      isArrayItem: !1,
      title: "Unknown field"
    });
  }), fieldPaths;
}
function useCommentHasChanged(message) {
  const prevMessage = useRef(message);
  return useMemo(() => !isEqual(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  return value ? value == null ? void 0 : value.some(
    (block) => {
      var _a;
      return isPortableTextTextBlock(block) && ((_a = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a.some((c) => isPortableTextSpan(c) ? c.text : c.userId));
    }
  ) : !1;
}
function commentIntentIfDiffers(parent, comment) {
  var _a, _b;
  const parentIntent = (_a = parent == null ? void 0 : parent.context) == null ? void 0 : _a.intent, intent = (_b = comment == null ? void 0 : comment.context) == null ? void 0 : _b.intent;
  if (intent && (!parentIntent || "preview" in intent.params && "preview" in parentIntent.params && intent.params.preview !== parentIntent.params.preview))
    return intent;
}
function isTextSelectionComment(comment) {
  var _a, _b, _c, _d, _e, _f;
  return comment ? !!(((_c = (_b = (_a = comment == null ? void 0 : comment.target) == null ? void 0 : _a.path) == null ? void 0 : _b.selection) == null ? void 0 : _c.type) === "text" && (_f = (_e = (_d = comment == null ? void 0 : comment.target) == null ? void 0 : _d.path) == null ? void 0 : _e.selection) != null && _f.value) : !1;
}
const EMPTY_ARRAY$j = [];
function buildCommentThreadItems(props) {
  const { comments: comments2, currentUser, documentValue, schemaType, type } = props, parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  return type === "task" ? parentComments.map((parentComment) => {
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
    return {
      commentsCount: [parentComment, ...replies].length,
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue: !1,
      breadcrumbs: EMPTY_ARRAY$j,
      fieldPath: ""
    };
  }) : type === "field" ? parentComments.map((parentComment) => {
    var _a, _b, _c;
    const crumbs = buildCommentBreadcrumbs({
      currentUser,
      documentValue,
      fieldPath: ((_a = parentComment.target.path) == null ? void 0 : _a.field) || "",
      schemaType
    });
    let hasTextSelection = !1;
    if (isTextSelectionComment(parentComment) && (hasTextSelection = !!((_b = parentComment.target.path) != null && _b.selection && parentComment.target.path.selection.value.some((v) => v.text))), crumbs.some((bc) => bc.invalid))
      return;
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id), commentsCount = [parentComment, ...replies].length, hasReferencedValue = hasTextSelection;
    return {
      breadcrumbs: crumbs,
      commentsCount,
      fieldPath: ((_c = parentComment.target.path) == null ? void 0 : _c.field) || "",
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue
    };
  }).filter(Boolean) : EMPTY_ARRAY$j;
}
const DMP_MARGIN = 15;
function diffText(current, next) {
  const diff = makeDiff(current, next), diffs = cleanupEfficiency(diff), levenshtein = diffsLevenshtein(diffs);
  return { patches: makePatches(current, diffs, { margin: DMP_MARGIN }), levenshtein };
}
function diffApply(current, patches) {
  return applyPatches(patches, current, {
    allowExceedingIndices: !0,
    margin: DMP_MARGIN
  })[0];
}
const CHILD_SYMBOL = "\uF0D0";
function toPlainTextWithChildSeparators(inputBlock) {
  return inputBlock.children.map((child) => isPortableTextSpan$1(child) ? child.text.replaceAll(CHILD_SYMBOL, " ") : "").join(CHILD_SYMBOL);
}
const COMMENT_INDICATORS = ["\uF000", "\uF001"], COMMENT_INDICATORS_REGEX = new RegExp(`[${COMMENT_INDICATORS.join("")}]`, "g"), EMPTY_ARRAY$i = [];
function buildRangeDecorationSelectionsFromComments(props) {
  const { value, comments: comments2 } = props;
  if (!value || value.length === 0)
    return EMPTY_ARRAY$i;
  const textSelections = comments2.filter(isTextSelectionComment), decorators = [];
  return textSelections.forEach((comment) => {
    var _a, _b;
    (_b = (_a = comment.target.path) == null ? void 0 : _a.selection) == null || _b.value.forEach((selectionMember) => {
      const matchedBlock = value.find((block) => block._key === selectionMember._key);
      if (!matchedBlock || !isPortableTextTextBlock$1(matchedBlock))
        return;
      const selectionText = selectionMember.text.replaceAll(COMMENT_INDICATORS_REGEX, ""), textWithChildSeparators = toPlainTextWithChildSeparators(matchedBlock), { patches } = diffText(selectionText, selectionMember.text), diffedText = diffApply(textWithChildSeparators, patches), startIndex = diffedText.indexOf(COMMENT_INDICATORS[0]), endIndex = diffedText.replaceAll(COMMENT_INDICATORS[0], "").indexOf(COMMENT_INDICATORS[1]), textWithoutCommentTags = diffedText.replaceAll(COMMENT_INDICATORS_REGEX, ""), oldCommentedText = selectionMember.text.substring(
        selectionMember.text.indexOf(COMMENT_INDICATORS[0]) + 1,
        selectionMember.text.indexOf(COMMENT_INDICATORS[1])
      ), newCommentedText = textWithoutCommentTags.substring(startIndex, endIndex), { levenshtein } = diffText(newCommentedText, oldCommentedText), threshold = Math.round(newCommentedText.length + oldCommentedText.length / 2);
      let nullSelection = !1;
      if (newCommentedText.length === 0 && (nullSelection = !0), levenshtein > threshold && (nullSelection = !0), startIndex + 1 === endIndex && (nullSelection = !0), startIndex !== -1 && endIndex !== -1) {
        let childIndexAnchor = 0, anchorOffset = 0, childIndexFocus = 0, focusOffset = 0;
        for (let i = 0; i < textWithoutCommentTags.length && (textWithoutCommentTags[i] === CHILD_SYMBOL && (i <= startIndex && (anchorOffset = -1, childIndexAnchor++), focusOffset = -1, childIndexFocus++), i < startIndex && anchorOffset++, i < startIndex + newCommentedText.length && focusOffset++, i !== startIndex + newCommentedText.length); i++)
          ;
        decorators.push({
          selection: {
            anchor: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexAnchor]._key }
              ],
              offset: anchorOffset
            },
            focus: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexFocus]._key }
              ],
              offset: focusOffset
            }
          },
          comment,
          range: { _key: matchedBlock._key, text: nullSelection ? "" : diffedText }
        });
      }
    });
  }), decorators.length === 0 ? EMPTY_ARRAY$i : decorators;
}
function diffsLevenshtein(diffs) {
  let levenshtein = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
    }
  }
  return levenshtein += Math.max(insertions, deletions), levenshtein;
}
const CommentRangeDecoration = memo(function(props) {
  const {
    children,
    commentId,
    currentHoveredCommentId,
    onClick,
    onHoverEnd,
    onHoverStart,
    selectedThreadId,
    threadId
  } = props, decoratorRef = useRef(null), isNestedRef = useRef(!1), parentCommentId = useRef(null);
  useEffect(() => {
    var _a, _b;
    const prevEl = (_a = decoratorRef.current) == null ? void 0 : _a.previousSibling, nextEl = (_b = decoratorRef.current) == null ? void 0 : _b.nextSibling;
    if (!prevEl || !nextEl) {
      isNestedRef.current = !1;
      return;
    }
    const [key] = Object.keys(applyInlineCommentIdAttr("")), prevId = prevEl.getAttribute(key), nextId = nextEl.getAttribute(key), isNestedDecorator = !!(prevId && nextId && prevId === nextId);
    parentCommentId.current = isNestedDecorator ? prevId : null, isNestedRef.current = isNestedDecorator;
  }, []);
  const handleMouseEnter = useCallback(() => onHoverStart(commentId), [commentId, onHoverStart]), handleMouseLeave = useCallback(() => onHoverEnd(null), [onHoverEnd]), handleClick = useCallback(() => onClick(commentId), [commentId, onClick]), hovered = currentHoveredCommentId === commentId || currentHoveredCommentId === parentCommentId.current && isNestedRef.current;
  return /* @__PURE__ */ jsx(
    CommentInlineHighlightSpan,
    {
      isAdded: !0,
      isHovered: hovered || selectedThreadId === threadId,
      isNested: isNestedRef.current,
      onClick: handleClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: decoratorRef,
      ...applyInlineCommentIdAttr(threadId),
      children
    }
  );
});
function buildRangeDecorations(props) {
  const {
    comments: comments2,
    currentHoveredCommentId,
    onDecorationClick,
    onDecorationHoverEnd,
    onDecorationHoverStart,
    onDecorationMoved,
    selectedThreadId,
    value
  } = props;
  return buildRangeDecorationSelectionsFromComments({ comments: comments2, value }).map(({ selection, comment, range }) => ({
    component: ({ children }) => /* @__PURE__ */ jsx(
      CommentRangeDecoration,
      {
        commentId: comment._id,
        currentHoveredCommentId,
        onClick: onDecorationClick,
        onHoverEnd: onDecorationHoverEnd,
        onHoverStart: onDecorationHoverStart,
        selectedThreadId,
        threadId: comment.threadId,
        children
      }
    ),
    onMoved: onDecorationMoved,
    selection,
    payload: {
      commentId: comment._id,
      range
    }
  }));
}
function buildTextSelectionFromFragment(props) {
  const { fragment, value, selection } = props;
  if (!selection)
    throw new Error("Selection is required");
  const normalizedSelection = selection.backward ? { backward: !1, anchor: selection.focus, focus: selection.anchor } : selection;
  return {
    type: "text",
    value: fragment.map((fragmentBlock) => {
      const originalBlock = value.find((b) => b._key === fragmentBlock._key);
      if (!isPortableTextTextBlock$1(originalBlock))
        return {
          _key: fragmentBlock._key,
          text: ""
        };
      const anchorBlockKey = isKeySegment(normalizedSelection.anchor.path[0]) && normalizedSelection.anchor.path[0]._key, focusBlockKey = isKeySegment(normalizedSelection.focus.path[0]) && normalizedSelection.focus.path[0]._key, fragmentBlockText = toPlainText([fragmentBlock]), fragmentStartSpan = isPortableTextTextBlock$1(fragmentBlock) ? fragmentBlock.children[0] : void 0, fragmentEndSpan = isPortableTextTextBlock$1(fragmentBlock) ? fragmentBlock.children[fragmentBlock.children.length - 1] : void 0;
      let originalTextBeforeSelection = "", startChildIndex = -1;
      if (anchorBlockKey === originalBlock._key)
        for (const child of originalBlock.children) {
          if (startChildIndex++, child._key === (fragmentStartSpan == null ? void 0 : fragmentStartSpan._key)) {
            originalTextBeforeSelection += isPortableTextSpan$1(child) && child.text.substring(0, normalizedSelection.anchor.offset) || "";
            break;
          }
          originalTextBeforeSelection += child.text;
        }
      let originalTextAfterSelection = "";
      if (focusBlockKey === originalBlock._key)
        for (const child of originalBlock.children.slice(startChildIndex).reverse()) {
          if (child._key === (fragmentEndSpan == null ? void 0 : fragmentEndSpan._key)) {
            originalTextAfterSelection = (isPortableTextSpan$1(child) && child.text.substring(normalizedSelection.focus.offset, child.text.length) || "") + originalTextAfterSelection;
            break;
          }
          originalTextAfterSelection = child.text + originalTextAfterSelection;
        }
      return {
        _key: originalBlock._key,
        text: `${originalTextBeforeSelection}${COMMENT_INDICATORS[0]}${fragmentBlockText}${COMMENT_INDICATORS[1]}${originalTextAfterSelection}`
      };
    })
  };
}
function mergeCommentReactions(reactionsA, reactionsB) {
  const mergedReactions = {};
  for (const reaction of reactionsA)
    mergedReactions[reaction._key] = { ...reaction };
  for (const reaction of reactionsB)
    mergedReactions[reaction._key] = { ...mergedReactions[reaction._key], ...reaction };
  return Object.values(mergedReactions);
}
function createCommentsSet(comments2) {
  return comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
}
function commentsReducer(state2, action) {
  var _a;
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return {
        ...state2,
        comments: commentsById
      };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload, nextCommentValue = nextCommentResult, nextComment = {
        [nextCommentResult._id]: {
          ...state2.comments[nextCommentResult._id],
          ...nextCommentValue,
          _state: nextCommentResult._state || void 0,
          // If the comment is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the comments correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the comment.
          // Once the comment is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          ...nextComment
        }
      };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [nextCommentResult._id]: nextCommentResult
        }
      };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state2.comments;
      return Object.keys(restComments).forEach((commentId) => {
        restComments[commentId].parentCommentId === action.id && delete restComments[commentId];
      }), {
        ...state2,
        comments: restComments
      };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload, id = updatedComment._id, comment = state2.comments[id], optimisticReactions = ((_a = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a.filter((v) => v == null ? void 0 : v._optimisticState)) || [], incomingReactions = updatedComment.reactions || [], nextReactions = mergeCommentReactions(optimisticReactions, incomingReactions), nextComment = {
        // Add existing comment data
        ...comment,
        // Add incoming comment data
        ...updatedComment,
        // Add reactions merged with optimistic reactions
        reactions: nextReactions
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [id]: nextComment
        }
      };
    }
    default:
      return state2;
  }
}
const INITIAL_STATE$2 = {
  comments: {}
}, LISTEN_OPTIONS$1 = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD$1 = "_createdAt", SORT_ORDER$1 = "desc", QUERY_FILTERS$1 = ['_type == "comment"', "target.document._ref == $documentId"], QUERY_PROJECTION$1 = `{
  _createdAt,
  _id,
  authorId,
  contentSnapshot,
  context,
  lastEditedAt,
  message,
  parentCommentId,
  reactions,
  status,
  target,
  threadId
}`, QUERY_SORT_ORDER$1 = `order(${SORT_FIELD$1} ${SORT_ORDER$1})`, QUERY$1 = `*[${QUERY_FILTERS$1.join(" && ")}] ${QUERY_PROJECTION$1} | ${QUERY_SORT_ORDER$1}`;
function useCommentsStore(opts) {
  const { client, documentId, onLatestTransactionIdReceived, transactionsIdMap } = opts, [state2, dispatch] = useReducer(commentsReducer, INITIAL_STATE$2), [loading, setLoading] = useState(client !== null), [error, setError] = useState(null), didInitialFetch = useRef(!1), params = useMemo(() => ({ documentId: getPublishedId(documentId) }), [documentId]), initialFetch = useCallback(async () => {
    if (!client) {
      setLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY$1, params);
      dispatch({ type: "COMMENTS_SET", comments: res }), setLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = useCallback(
    async (event) => {
      var _a;
      if (event.type === "welcome" && !didInitialFetch.current && (setLoading(!0), await initialFetch(), setLoading(!1), didInitialFetch.current = !0), event.type === "reconnect" && (setLoading(!0), didInitialFetch.current = !1), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextComment = event.result;
          nextComment && dispatch({
            type: "COMMENT_RECEIVED",
            payload: nextComment
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "COMMENT_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedComment = event.result, id = ((_a = event.result) == null ? void 0 : _a._id) || "", transactionId = event.transactionId, latestTransactionId = transactionsIdMap.get(id), isLatestTransaction = transactionId === latestTransactionId;
          if (!isLatestTransaction && latestTransactionId)
            return;
          updatedComment && (dispatch({
            type: "COMMENT_UPDATED",
            payload: updatedComment
          }), isLatestTransaction && onLatestTransactionIdReceived(id));
        }
      }
    },
    [initialFetch, onLatestTransactionIdReceived, transactionsIdMap]
  ), listener$ = useMemo(() => client ? client.observable.listen(QUERY$1, params, LISTEN_OPTIONS$1).pipe(
    catchError((err) => (setError(err), of(err)))
  ) : of(), [client, params]);
  return useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: useMemo(() => Object.values(state2.comments), [state2.comments]),
    dispatch,
    error,
    loading
  };
}
const EMPTY_ARRAY$h = [], EMPTY_COMMENTS_DATA = {
  open: EMPTY_ARRAY$h,
  resolved: EMPTY_ARRAY$h
}, CommentsProvider = memo(function(props) {
  const { children, documentId, documentType, isCommentsOpen, onCommentsOpen, sortOrder, type } = props, commentsEnabled = useCommentsEnabled(), [status, setStatus] = useState("open"), { client, createAddonDataset, isCreatingDataset } = useAddonDataset(), publishedId = getPublishedId(documentId), editState = useEditState(publishedId, documentType, "low"), schemaType = useSchema().get(documentType), currentUser = useCurrentUser(), { name: workspaceName, dataset, projectId } = useWorkspace(), documentValue = useMemo(() => editState.draft || editState.published, [editState.draft, editState.published]), documentRevisionId = useMemo(() => documentValue == null ? void 0 : documentValue._rev, [documentValue]), transactionsIdMap = useMemo(() => /* @__PURE__ */ new Map(), []), handleOnLatestTransactionIdReceived = useCallback(
    (commentDocumentId) => {
      transactionsIdMap.delete(commentDocumentId);
    },
    [transactionsIdMap]
  ), {
    dispatch,
    data = EMPTY_ARRAY$h,
    error,
    loading
  } = useCommentsStore({
    documentId: publishedId,
    client,
    transactionsIdMap,
    onLatestTransactionIdReceived: handleOnLatestTransactionIdReceived
  }), handleOnTransactionStart = useCallback(
    (commentDocumentId, transactionId) => {
      transactionsIdMap.set(commentDocumentId, transactionId);
    },
    [transactionsIdMap]
  ), handleSetStatus = useCallback(
    (newStatus) => commentsEnabled.mode === "upsell" && newStatus === "resolved" ? null : setStatus(newStatus),
    [setStatus, commentsEnabled]
  ), mentionOptions = useUserListWithPermissions(
    useMemo(() => ({ documentValue, permission: "read" }), [documentValue])
  ), threadItemsByStatus = useMemo(() => {
    if (!schemaType || !currentUser)
      return EMPTY_COMMENTS_DATA;
    const sorted = orderBy(data, ["_createdAt"], [sortOrder]), items = buildCommentThreadItems({
      comments: sorted,
      currentUser,
      documentValue,
      schemaType,
      type
    });
    return {
      open: items.filter((item) => item.parentComment.status === "open"),
      resolved: items.filter((item) => item.parentComment.status === "resolved")
    };
  }, [currentUser, data, documentValue, schemaType, sortOrder, type]), getThreadLength = useCallback(
    (threadId) => threadItemsByStatus.open.filter((item) => item.threadId === threadId).length,
    [threadItemsByStatus.open]
  ), getComment = useCallback((id) => data == null ? void 0 : data.find((c) => c._id === id), [data]), handleOnCreate = useCallback(
    (payload) => {
      var _a, _b;
      const hasError = ((_b = (_a = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a._state) == null ? void 0 : _b.type) === "createError";
      dispatch({
        type: "COMMENT_ADDED",
        payload: {
          ...payload,
          _state: hasError ? { type: "createRetrying" } : void 0
        }
      });
    },
    [data, dispatch]
  ), handleOnUpdate = useCallback(
    (id, payload) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          ...payload
        }
      });
    },
    [dispatch]
  ), handleOnCreateError = useCallback(
    (id, err) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          _state: {
            error: err,
            type: "createError"
          }
        }
      });
    },
    [dispatch]
  ), { operation } = useCommentOperations(
    useMemo(
      () => ({
        client,
        currentUser,
        dataset,
        documentId: publishedId,
        documentRevisionId,
        documentType,
        getComment,
        getThreadLength,
        projectId,
        schemaType,
        workspace: workspaceName,
        // This function runs when the first comment creation is executed.
        // It is used to create the addon dataset and configure a client for
        // the addon dataset.
        createAddonDataset,
        // The following callbacks runs when the comment operation are executed.
        // They are used to update the local state of the comments immediately after
        // a comment operation has been executed. This is done to avoid waiting for
        // the real time listener to update the comments and make the UI feel more
        // responsive. The comment will be updated again when we receive an mutation
        // event from the real time listener.
        onCreate: handleOnCreate,
        onCreateError: handleOnCreateError,
        onUpdate: handleOnUpdate,
        onTransactionStart: handleOnTransactionStart
      }),
      [
        client,
        currentUser,
        dataset,
        documentRevisionId,
        documentType,
        getComment,
        createAddonDataset,
        getThreadLength,
        handleOnCreate,
        handleOnCreateError,
        handleOnTransactionStart,
        handleOnUpdate,
        projectId,
        publishedId,
        schemaType,
        workspaceName
      ]
    )
  ), ctxValue = useMemo(
    () => ({
      isCreatingDataset,
      status,
      setStatus: handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      comments: {
        data: threadItemsByStatus,
        error,
        loading: loading || isCreatingDataset
      },
      operation: {
        create: operation.create,
        react: operation.react,
        remove: operation.remove,
        update: operation.update
      },
      mentionOptions
    }),
    [
      isCreatingDataset,
      status,
      handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      threadItemsByStatus,
      error,
      loading,
      operation.create,
      operation.react,
      operation.remove,
      operation.update,
      mentionOptions
    ]
  );
  return /* @__PURE__ */ jsx(CommentsContext.Provider, { value: ctxValue, children });
}), CommentsEnabledContext = createContext(null), CommentsEnabledProvider = React.memo(function(props) {
  const { children, documentId, documentType } = props, value = useResolveCommentsEnabled(documentId, documentType);
  return /* @__PURE__ */ jsx(CommentsEnabledContext.Provider, { value, children });
}), CommentsIntentContext = createContext(
  void 0
), CommentsIntentProvider = memo(function(props) {
  const { children, getIntent: getIntent2 } = props;
  return /* @__PURE__ */ jsx(CommentsIntentContext.Provider, { value: getIntent2, children });
}), CommentsOnboardingContext = createContext(null), VERSION = 1, LOCAL_STORAGE_KEY = `sanityStudio:comments:inspector:onboarding:dismissed:v${VERSION}`, setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(value));
  } catch {
  }
}, getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    return value ? JSON.parse(value) : !1;
  } catch {
    return !1;
  }
};
function CommentsOnboardingProvider(props) {
  const { children } = props, [dismissed, setDismissed] = useState(getLocalStorage()), handleDismiss = useCallback(() => {
    setDismissed(!0), setLocalStorage(!0);
  }, [setDismissed]), ctxValue = useMemo(
    () => ({
      setDismissed: handleDismiss,
      isDismissed: dismissed
    }),
    [handleDismiss, dismissed]
  );
  return /* @__PURE__ */ jsx(CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
const CommentsSelectedPathContext = createContext(
  null
), CommentsSelectedPathProvider = React__default.memo(function(props) {
  const { children } = props, [selectedPath, setSelectedPath] = useState(null), handleSelectPath = useCallback(
    (nextPath) => {
      isEqual(selectedPath, nextPath) || setSelectedPath(nextPath);
    },
    [selectedPath]
  ), ctxValue = useMemo(
    () => ({
      selectedPath,
      setSelectedPath: handleSelectPath
    }),
    [selectedPath, handleSelectPath]
  );
  return /* @__PURE__ */ jsx(CommentsSelectedPathContext.Provider, { value: ctxValue, children });
}), CommentsUpsellContext = createContext(null), UPSELL_CLIENT_OPTIONS = {
  apiVersion: "2023-12-11",
  useProjectHostname: !1,
  withCredentials: !1,
  useCdn: !0
}, FEATURE = "comments", TEMPLATE_OPTIONS = { interpolate: /{{([\s\S]+?)}}/g }, BASE_URL = "www.sanity.io";
function CommentsUpsellProvider(props) {
  const [upsellDialogOpen, setUpsellDialogOpen] = useState(!1), [upsellData, setUpsellData] = useState(null), projectId = useProjectId(), telemetry = useTelemetry(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), telemetryLogs = useMemo(
    () => ({
      dialogSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      panelViewed: (source) => telemetry.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry.log(UpsellDialogDismissed, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      })
    }),
    [telemetry]
  ), handlePrimaryButtonClick = useCallback(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = useCallback(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = useCallback(() => {
    setUpsellDialogOpen(!1), telemetry.log(UpsellDialogDismissed, {
      feature: FEATURE,
      type: "modal"
    });
  }, [telemetry]);
  useEffect(() => {
    const sub = client.withConfig(UPSELL_CLIENT_OPTIONS).observable.request({
      uri: "/journey/comments"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = template(data.ctaButton.url, TEMPLATE_OPTIONS);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL, projectId });
            const secondaryUrl = template(data.secondaryButton.url, TEMPLATE_OPTIONS);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client, projectId]);
  const handleOpenDialog = useCallback(
    (source) => {
      setUpsellDialogOpen(!0), telemetry.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "modal",
        source
      });
    },
    [telemetry]
  ), ctxValue = useMemo(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return /* @__PURE__ */ jsxs(CommentsUpsellContext.Provider, { value: ctxValue, children: [
    props.children,
    upsellData && upsellDialogOpen && /* @__PURE__ */ jsx(
      CommentsUpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function useCommentsIntent() {
  return useContext(CommentsIntentContext);
}
const structureLocaleNamespace = "structure", structureUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: structureLocaleNamespace,
  resources: () => import("./resources2.js")
});
function DocTitle(props) {
  const { document: documentValue } = props, schemaType = useSchema().get(documentValue._type), { t } = useTranslation(structureLocaleNamespace), { error, value } = unstable_useValuePreview({
    schemaType,
    value: documentValue
  });
  return schemaType ? error ? /* @__PURE__ */ jsx(Fragment$1, { children: t("doc-title.error.text", { errorMessage: error.message }) }) : /* @__PURE__ */ jsx(Fragment$1, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) }) : /* @__PURE__ */ jsx("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
}
const ChevronWrapper = styled(Box)`
  margin-left: auto;
`, CrossDatasetReferencesDetails = styled.details`
  flex: none;

  &[open] ${ChevronWrapper} {
    transform: rotate(180deg);
  }
`, CrossDatasetReferencesSummary = styled.summary`
  list-style: none;

  &::-webkit-details-marker {
    display: none;
  }
`, Table = styled.table`
  width: 100%;
  text-align: left;
  padding: 0 ${({ theme }) => rem(theme.sanity.space[2])};
  border-collapse: collapse;

  th {
    padding: ${({ theme }) => rem(theme.sanity.space[1])};
  }

  td {
    padding: 0 ${({ theme }) => rem(theme.sanity.space[1])};
  }

  tr > *:last-child {
    text-align: right;
  }
`, DocumentIdFlex = styled(Flex)`
  min-height: 33px;
`, OtherReferenceCount = (props) => {
  const { t } = useTranslation(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  return difference ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsxs(Inline, { space: 2, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }),
    /* @__PURE__ */ jsx(
      Tooltip,
      {
        portal: !0,
        placement: "top",
        content: t("confirm-delete-dialog.other-reference-count.tooltip"),
        children: /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsx(InfoOutlineIcon, {}) })
      }
    )
  ] }) }) : null;
};
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props, title = isRecord(value.title) && isValidElement(value.title) || isString(value.title) || isNumber(value.title) ? value.title : null, { draft, published, isLoading } = useMemoObservable(
    () => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title),
    [props.documentPreviewStore, schemaType, value._id, title]
  ), status = isLoading ? null : /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsx(DocumentPreviewPresence, { presence }),
    /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft, published })
  ] }) }), tooltip = /* @__PURE__ */ jsx(DocumentStatus, { draft, published });
  return /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({ value, draft, published }),
      isPlaceholder: isLoading,
      icon,
      layout,
      status,
      tooltip
    }
  );
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
const PaneRouterContext = createContext({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: !1,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrentAndAfter: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext(),
  createPathWithParams: () => missingContext()
}), BackLink = forwardRef(function(props, ref) {
  const { routerPanesState, groupIndex } = useContext(PaneRouterContext), panes = useMemo(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]), state2 = useMemo(() => ({ panes }), [panes]);
  return /* @__PURE__ */ jsx(StateLink, { ...props, ref, state: state2 });
}), PaneLayoutContext = createContext(null);
function usePaneLayout() {
  const pane = useContext(PaneLayoutContext);
  if (!pane)
    throw new Error("PaneLayout: missing context value");
  return pane;
}
const ChildLink = forwardRef(function(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props, { routerPanesState, groupIndex } = useContext(PaneRouterContext);
  return /* @__PURE__ */ jsx(
    StateLink,
    {
      ...rest,
      ref,
      state: {
        panes: [
          ...routerPanesState.slice(0, groupIndex + 1),
          [{ id: childId, params: childParameters, payload: childPayload }]
        ]
      }
    }
  );
}), ParameterizedLink = forwardRef(function(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = useContext(PaneRouterContext), { params, payload, ...rest } = props, nextParams = useUnique(params), nextPayload = useUnique(payload), nextState = useMemo(() => {
    const currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    }, nextGroup = [
      ...currentGroup.slice(0, siblingIndex),
      nextSibling,
      ...currentGroup.slice(siblingIndex + 1)
    ];
    return { panes: [
      ...currentPanes.slice(0, groupIndex),
      nextGroup,
      ...currentPanes.slice(groupIndex + 1)
    ] };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return /* @__PURE__ */ jsx(StateLink, { ref, ...rest, state: nextState });
}), ReferenceChildLink = forwardRef(function({ documentId, documentType, parentRefPath, children, template: template2, ...rest }, ref) {
  return /* @__PURE__ */ jsx(
    ChildLink,
    {
      ...rest,
      ref,
      childId: documentId,
      childPayload: template2 == null ? void 0 : template2.params,
      childParameters: {
        type: documentType,
        parentRefPath: toString(parentRefPath),
        ...template2 && { template: template2 == null ? void 0 : template2.id }
      },
      children
    }
  );
});
function usePaneRouter() {
  return useContext(PaneRouterContext);
}
const EMPTY_ARRAY$g = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props, publishedId = getPublishedId(value == null ? void 0 : value._id), documentPresence = useDocumentPresence(publishedId), documentPreviewStore = useDocumentPreviewStore(), { ReferenceChildLink: ReferenceChildLink2 } = usePaneRouter(), Link2 = useCallback(
    function(linkProps) {
      return /* @__PURE__ */ jsx(
        ReferenceChildLink2,
        {
          documentId: value == null ? void 0 : value._id,
          documentType: type == null ? void 0 : type.name,
          parentRefPath: EMPTY_ARRAY$g,
          ...linkProps
        }
      );
    },
    [ReferenceChildLink2, type == null ? void 0 : type.name, value == null ? void 0 : value._id]
  );
  return /* @__PURE__ */ jsx(PreviewCard, { __unstable_focusRing: !0, as: Link2, "data-as": "a", onClick, radius: 2, children: /* @__PURE__ */ jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "compact",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$g,
      schemaType: type,
      value
    }
  ) });
}
function ConfirmDeleteDialogBody({
  crossDatasetReferences,
  internalReferences,
  documentTitle,
  totalCount,
  action,
  datasetNames,
  hasUnknownDatasetNames,
  onReferenceLinkClick
}) {
  const schema2 = useSchema(), toast = useToast(), { t } = useTranslation(structureLocaleNamespace), renderPreviewItem = useCallback(
    (item) => {
      const type = schema2.get(item._type);
      return type ? /* @__PURE__ */ jsx(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : (
        // Padding added to match the ReferencePreviewLink styling
        /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(
          SanityDefaultPreview,
          {
            icon: UnknownIcon,
            title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"),
            subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
              documentId: item._id
            }),
            layout: "default"
          }
        ) })
      );
    },
    [schema2, t, onReferenceLinkClick]
  );
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0)
    return /* @__PURE__ */ jsx(Text, { as: "p", size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        t,
        i18nKey: "confirm-delete-dialog.confirmation.text",
        context: action,
        components: { DocumentTitle: () => /* @__PURE__ */ jsx("strong", { children: documentTitle }) }
      }
    ) });
  const normalizedDatasetNames = [
    ...datasetNames,
    ...hasUnknownDatasetNames ? ["unavailable"] : []
  ], datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", {
    count: normalizedDatasetNames.length,
    datasets: normalizedDatasetNames.join(", "),
    context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : ""
  });
  return /* @__PURE__ */ jsxs(Flex, { direction: "column", gap: 4, children: [
    /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: /* @__PURE__ */ jsxs(Flex, { children: [
      /* @__PURE__ */ jsx(Text, { "aria-hidden": "true", size: 1, children: /* @__PURE__ */ jsx(WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsx(Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
        Translate,
        {
          i18nKey: "confirm-delete-dialog.referring-document-count.text",
          components: { DocumentTitle: () => documentTitle },
          t,
          values: { count: totalCount }
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) }),
    /* @__PURE__ */ jsx(Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: /* @__PURE__ */ jsxs(Flex, { direction: "column", children: [
      internalReferences.totalCount > 0 && /* @__PURE__ */ jsxs(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [
        internalReferences == null ? void 0 : internalReferences.references.map((item) => /* @__PURE__ */ jsx(Box, { as: "li", children: renderPreviewItem(item) }, item._id)),
        internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */ jsx(Box, { as: "li", padding: 3, children: /* @__PURE__ */ jsx(OtherReferenceCount, { ...internalReferences }) })
      ] }),
      crossDatasetReferences.totalCount > 0 && /* @__PURE__ */ jsxs(
        CrossDatasetReferencesDetails,
        {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [
            /* @__PURE__ */ jsx(CrossDatasetReferencesSummary, { children: /* @__PURE__ */ jsx(
              Card,
              {
                as: "a",
                marginTop: internalReferences.totalCount > 0 ? 2 : 0,
                radius: 2,
                shadow: 1,
                paddingY: 1,
                children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
                  /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DocumentsIcon, {}) }),
                  /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
                    /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", {
                      count: normalizedDatasetNames.length,
                      documentCount: t("confirm-delete-dialog.cdr-summary.document-count", {
                        count: crossDatasetReferences.totalCount
                      })
                    }) }),
                    /* @__PURE__ */ jsx(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: !0, children: datasetSubtitle })
                  ] }),
                  /* @__PURE__ */ jsx(ChevronWrapper, { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronDownIcon, {}) }) })
                ] })
              }
            ) }),
            /* @__PURE__ */ jsxs(Box, { overflow: "auto", paddingTop: 2, children: [
              /* @__PURE__ */ jsxs(Table, { children: [
                /* @__PURE__ */ jsx("thead", { children: /* @__PURE__ */ jsxs("tr", { children: [
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }),
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }),
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })
                ] }) }),
                /* @__PURE__ */ jsx("tbody", { children: crossDatasetReferences.references.filter((reference) => "projectId" in reference).map(({ projectId, datasetName, documentId }, index) => (
                  // eslint-disable-next-line react/no-array-index-key
                  /* @__PURE__ */ jsxs("tr", { children: [
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: projectId }) }),
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: datasetName || "unavailable" }) }),
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsxs(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
                      /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }),
                      documentId && /* @__PURE__ */ jsx(
                        CopyToClipboard,
                        {
                          text: documentId,
                          onCopy: () => {
                            toast.push({
                              title: t(
                                "confirm-delete-dialog.cdr-table.id-copied-toast.title"
                              ),
                              status: "success"
                            });
                          },
                          children: /* @__PURE__ */ jsx(
                            Button,
                            {
                              mode: "bleed",
                              icon: CopyIcon,
                              tooltipProps: {
                                content: t(
                                  "confirm-delete-dialog.cdr-table.copy-id-button.tooltip"
                                )
                              }
                            }
                          )
                        }
                      )
                    ] }) })
                  ] }, `${documentId}-${index}`)
                )) })
              ] }),
              /* @__PURE__ */ jsx(OtherReferenceCount, { ...crossDatasetReferences })
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) })
  ] });
}
function isClientError(e) {
  return typeof e != "object" || !e ? !1 : "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  startWith(null),
  map(() => document.visibilityState === "visible"),
  distinctUntilChanged(),
  switchMap(
    (visible) => visible ? (
      // using timer instead of interval since timer will emit on creation
      timer(0, POLL_INTERVAL)
    ) : EMPTY
  ),
  shareReplay({ refCount: !0, bufferSize: 1 })
)), visiblePoll$);
function getDocumentExistence(documentId, { versionedClient }) {
  const draftId = getDraftId(documentId), publishedId = getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: !0,
    query: { excludeContent: "true" },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(
    map(({ omitted }) => {
      const nonExistant = omitted.filter((doc) => doc.reason === "existence");
      if (nonExistant.length !== 2)
        return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
    })
  );
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(
    switchMap(() => getDocumentExistence(documentId, context)),
    switchMap((checkDocumentId) => {
      if (!checkDocumentId)
        return of({ totalCount: 0, references: [] });
      const currentDataset = versionedClient.config().dataset;
      return versionedClient.observable.request({
        url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
        tag: "use-referring-documents.external"
      }).pipe(
        catchError$1((e) => {
          if (isClientError(e) && e.statusCode === 404)
            return of({ totalCount: 0, references: [] });
          throw e;
        })
      );
    })
  );
}
const useInternalReferences = createHookFromObservableFactory(
  ([documentId, documentStore]) => documentStore.listenQuery(
    { fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}', listen: "*[references($documentId)]" },
    { documentId },
    { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 }
  )
), useCrossDatasetReferences = createHookFromObservableFactory(
  ([documentId, versionedClient]) => getVisiblePoll$().pipe(
    switchMap(
      () => fetchCrossDatasetReferences(documentId, {
        versionedClient
      })
    )
  )
);
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = useDocumentStore(), publishedId = getPublishedId(documentId), [internalReferences, isInternalReferencesLoading] = useInternalReferences(
    useMemo(() => [publishedId, documentStore], [documentStore, publishedId])
  ), [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(
    useMemo(() => [publishedId, versionedClient], [publishedId, versionedClient])
  ), projectIds = useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean)
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), datasetNames = useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => !!datasetName && datasetName !== "")
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), hasUnknownDatasetNames = useMemo(() => !!(crossDatasetReferences != null && crossDatasetReferences.references.some(
    (crossDatasetReference) => typeof crossDatasetReference.datasetName != "string"
  )), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
const DialogBody = styled(Box)`
  box-sizing: border-box;
`, LoadingContainer = styled(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function ConfirmDeleteDialog({
  id,
  type,
  action = "delete",
  onCancel,
  onConfirm
}) {
  const { t } = useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${useId()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id), documentTitle = /* @__PURE__ */ jsx(DocTitle, { document: useMemo(() => ({ _id: id, _type: type }), [id, type]) }), showConfirmButton = !isLoading;
  return /* @__PURE__ */ jsx(
    Dialog,
    {
      width: 1,
      id: dialogId,
      header: t("confirm-delete-dialog.header.text", { context: action }),
      footer: {
        cancelButton: {
          onClick: onCancel,
          text: t("confirm-delete-dialog.cancel-button.text")
        },
        confirmButton: showConfirmButton ? {
          text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }),
          onClick: onConfirm
        } : void 0
      },
      onClose: onCancel,
      onClickOutside: onCancel,
      children: /* @__PURE__ */ jsx(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */ jsx(
        ConfirmDeleteDialogBody,
        {
          crossDatasetReferences,
          internalReferences,
          documentTitle,
          isLoading,
          totalCount,
          action,
          projectIds,
          datasetNames,
          hasUnknownDatasetNames,
          onReferenceLinkClick: onCancel
        }
      ) : /* @__PURE__ */ jsx(LoadingContainer, { "data-testid": "loading-container", children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: t("confirm-delete-dialog.loading.text") }) }) })
    }
  );
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = useTranslation(structureLocaleNamespace), id = useId(), [error, setError] = useState(null), handleRetry = useCallback(() => setError(null), []);
  return error ? /* @__PURE__ */ jsx(
    Dialog,
    {
      id: `dialog-error-${id}`,
      "data-testid": "confirm-delete-error-dialog",
      header: t("confirm-delete-dialog.error.title.text"),
      footer: {
        confirmButton: {
          text: t("confirm-delete-dialog.error.retry-button.text"),
          onClick: handleRetry,
          tone: "default"
        }
      },
      onClose: props.onCancel,
      children: /* @__PURE__ */ jsx(Box, { padding: 4, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) })
    }
  ) : /* @__PURE__ */ jsx(ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsx(ConfirmDeleteDialog, { ...props }) });
}
function Delay({
  children,
  ms = 0
}) {
  const [ready, setReady] = useState(ms <= 0);
  return useEffect(() => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(!0), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]), !ready || !children ? /* @__PURE__ */ jsx(Fragment$1, {}) : typeof children == "function" ? children() : children;
}
const PANE_DEBUG = !1, PANE_COLLAPSED_WIDTH = 51, PANE_DEFAULT_MIN_WIDTH = 204, PaneContext = createContext(null), Root$g = styled(Layer)`
  position: relative;
  width: 1px;
  min-width: 1px;

  &:before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--card-border-color);
  }

  &:not([data-disabled]) {
    cursor: ew-resize;
    width: 9px;
    min-width: 9px;
    margin: 0 -4px;

    &:before {
      left: 4px;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    &[data-dragging]:after,
    &:hover:after {
      opacity: 0.2;
    }
  }
`;
function PaneDivider({
  disabled,
  element
}) {
  const { resize } = usePaneLayout(), [dragging, setDragging] = useState(!1), handleMouseDown = useCallback(
    (event) => {
      if (!element)
        return;
      setDragging(!0), event.preventDefault();
      const startX = event.pageX;
      resize("start", element, 0);
      const handleMouseMove = (e) => {
        e.preventDefault();
        const deltaX = e.pageX - startX;
        resize("move", element, deltaX);
      }, handleMouseUp = (e) => {
        e.preventDefault(), setDragging(!1), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [element, resize]
  );
  return /* @__PURE__ */ jsx(
    Root$g,
    {
      "data-disabled": disabled ? "" : void 0,
      "data-dragging": dragging ? "" : void 0,
      onMouseDown: handleMouseDown
    }
  );
}
const Root$f = styled(Card)`
  outline: none;

  // NOTE: This will render a border to the right side of each pane
  // without taking up physical space.
  box-shadow: 1px 0 0 var(--card-border-color);
`, Pane = forwardRef(function(props, ref) {
  var _a, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = !1,
    ...restProps
  } = props, [rootElement, setRootElement] = useState(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout(), pane = panes.find((p) => p.element === rootElement), paneIndex = pane && panes.indexOf(pane), nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, collapsed = layoutCollapsed ? !1 : (pane == null ? void 0 : pane.collapsed) || !1, nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || !1, forwardedRef = useForwardedRef(ref), flex = (_a = pane == null ? void 0 : pane.flex) != null ? _a : flexProp, currentMinWidth = (_b = pane == null ? void 0 : pane.currentMinWidth) != null ? _b : currentMinWidthProp, currentMaxWidth = (_c = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c : currentMaxWidthProp, setRef = useCallback(
    (refValue) => {
      setRootElement(refValue), forwardedRef.current = refValue;
    },
    [forwardedRef]
  );
  useEffect(() => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, [
    currentMinWidthProp,
    currentMaxWidthProp,
    flexProp,
    id,
    minWidthProp,
    maxWidthProp,
    mount,
    rootElement
  ]);
  const handleCollapse = useCallback(() => {
    rootElement && collapse(rootElement);
  }, [collapse, rootElement]), handleExpand = useCallback(() => {
    rootElement && expand(rootElement);
  }, [expand, rootElement]), contextValue = useMemo(
    () => ({
      collapse: handleCollapse,
      collapsed: layoutCollapsed ? !1 : collapsed,
      expand: handleExpand,
      index: paneIndex,
      isLast,
      rootElement
    }),
    [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]
  ), minWidth = useMemo(() => {
    if (!layoutCollapsed)
      return collapsed ? PANE_COLLAPSED_WIDTH : currentMinWidth === 0 || isLast ? minWidthProp || PANE_DEFAULT_MIN_WIDTH : currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]), maxWidth = useMemo(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (!(layoutCollapsed && isLast))
      return isLast ? maxWidthProp ? currentMaxWidth != null ? currentMaxWidth : maxWidthProp : void 0 : currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]), hidden = layoutCollapsed && !isLast, divider = useMemo(
    () => !isLast && !layoutCollapsed && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneResizer", children: /* @__PURE__ */ jsx(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }),
    [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]
  ), style = useMemo(
    () => ({
      flex,
      minWidth,
      maxWidth: maxWidth === 1 / 0 ? void 0 : maxWidth
    }),
    [flex, minWidth, maxWidth]
  );
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "pane", children: /* @__PURE__ */ jsx(PaneContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxs(
      Root$f,
      {
        "data-testid": "pane",
        "data-ui": "Pane",
        tone: "inherit",
        hidden,
        id,
        overflow: layoutCollapsed ? void 0 : "hidden",
        ...restProps,
        "data-pane-collapsed": collapsed ? "" : void 0,
        "data-pane-index": paneIndex,
        "data-pane-selected": selected ? "" : void 0,
        ref: setRef,
        style,
        children: [
          PANE_DEBUG,
          /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: !hidden && /* @__PURE__ */ jsx(Flex, { direction: "column", height: "fill", children }) })
        ]
      }
    ) }) }),
    divider
  ] });
}), Root$e = styled(Card)`
  position: relative;
  outline: none;
`;
Root$e.displayName = "PaneContent__root";
function usePane() {
  const pane = useContext(PaneContext);
  if (!pane)
    throw new Error("Pane: missing context value");
  return pane;
}
const PaneContent = forwardRef(function(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props, { collapsed } = usePane(), { collapsed: layoutCollapsed } = usePaneLayout();
  return /* @__PURE__ */ jsx(
    Root$e,
    {
      "data-testid": "pane-content",
      forwardedAs: as,
      ...restProps,
      flex: 1,
      hidden: collapsed,
      overflow: layoutCollapsed ? void 0 : overflow,
      padding,
      ref,
      tone: "inherit",
      children
    }
  );
}), MENU_GROUP_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "left-start",
  portal: !0
};
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props, getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider")
    return /* @__PURE__ */ jsx(MenuDivider, {});
  const { title } = getI18nText(node);
  return node.type === "group" ? node.children.length === 0 ? null : node.expanded ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    node.children.map((child, childIndex) => {
      var _a;
      return /* @__PURE__ */ jsx(
        PaneMenuButtonItem,
        {
          disabled: disabled || !!node.disabled,
          isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
          node: child
        },
        child.key
      );
    })
  ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    /* @__PURE__ */ jsx(
      MenuGroup,
      {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */ jsx(
            PaneMenuButtonItem,
            {
              disabled: disabled || !!node.disabled,
              isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
              node: child
            },
            child.key
          );
        })
      }
    )
  ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    /* @__PURE__ */ jsx(PaneContextMenuItemResolver, { disabled, node })
  ] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  return node.intent ? /* @__PURE__ */ jsx(PaneContextIntentMenuItem, { ...props, intent: node.intent }) : /* @__PURE__ */ jsx(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a;
  const { disabled, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsx(
    MenuItem,
    {
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const { disabled, intent, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), intentLink = useIntentLink({ intent: intent.type, params: intent.params }), handleClick = useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsx(
    MenuItem,
    {
      as: "a",
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const { nodes, actionsNodes } = props, id = useId(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution");
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        ContextMenuButton,
        {
          tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0,
          "data-testid": "pane-context-menu-button"
        }
      ),
      id,
      menu: /* @__PURE__ */ jsxs(Menu, { children: [
        actionsNodes && /* @__PURE__ */ jsxs(Fragment$1, { children: [
          actionsNodes,
          /* @__PURE__ */ jsx(MenuDivider, {})
        ] }),
        nodes.map((node, nodeIndex) => {
          var _a;
          const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
          return /* @__PURE__ */ jsx(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
        })
      ] }),
      popover: CONTEXT_MENU_POPOVER_PROPS
    }
  );
}
const Root$d = styled(Layer)`
  position: sticky;
  bottom: 0;

  &:before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-bottom: 1px solid var(--card-border-color);
  }
`, RootCard$2 = styled(Card)`
  padding-bottom: env(safe-area-inset-bottom);
`, PaneFooter = forwardRef(function(props, ref) {
  const { children, padding } = props, { collapsed } = usePane();
  return /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(Root$d, { "data-testid": "pane-footer", hidden: collapsed, ref, children: /* @__PURE__ */ jsx(RootCard$2, { tone: "inherit", children: /* @__PURE__ */ jsx(Box, { padding, children }) }) }) });
}), Root$c = styled(Layer)(({ $border }) => css`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `), Layout = styled(Flex)`
  transform-origin: calc(51px / 2);

  [data-collapsed] > div > & {
    transform: rotate(90deg);
  }
`, TitleCard = styled(Card)(({ theme }) => {
  const { fg, bg } = theme.sanity.color.card.enabled;
  return css`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
}), TitleTextSkeleton = styled(TextSkeleton)`
  width: 66%;
  max-width: 175px;
`, TitleText = styled(Text)`
  cursor: default;
  outline: none;
`, TabsBox = styled(Box)(({ theme }) => {
  const { color, space } = theme.sanity;
  return css`
    overflow: hidden;
    overflow: clip;
    position: relative;

    & > div {
      white-space: nowrap;
      overflow: auto;
      /* Hide scrollbars */
      scrollbar-width: none;
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    /* right padding */
    & > div:after {
      content: '';
      display: inline-block;
      top: 0;
      right: 0;
      bottom: 0;
      width: ${space[3]}px;
      height: 1px;
    }

    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */
    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to right, ${rgba(color.base.bg, 0)}, var(--card-bg-color));
      width: ${space[3]}px;
      pointer-events: none;
    }
  `;
}), PaneHeader = forwardRef(function(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props, { collapse, collapsed, expand, rootElement: paneElement } = usePane(), paneRect = useElementRect(paneElement || null), layoutStyle = useMemo(
    () => ({
      width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
    }),
    [collapsed, paneRect]
  ), handleTitleClick = useCallback(() => {
    collapsed || collapse();
  }, [collapse, collapsed]), handleLayoutClick = useCallback(() => {
    collapsed && expand();
  }, [collapsed, expand]);
  return /* @__PURE__ */ jsx(LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsx(
    Root$c,
    {
      $border: border,
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: /* @__PURE__ */ jsxs(Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [
        /* @__PURE__ */ jsxs(
          Layout,
          {
            gap: 1,
            onClick: handleLayoutClick,
            padding: 3,
            paddingBottom: collapsed ? 3 : 2,
            sizing: "border",
            style: layoutStyle,
            children: [
              backButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: backButton }),
              /* @__PURE__ */ jsxs(
                TitleCard,
                {
                  __unstable_focusRing: !0,
                  flex: 1,
                  forwardedAs: "button",
                  onClick: handleTitleClick,
                  paddingLeft: backButton ? 1 : 2,
                  padding: 2,
                  tabIndex,
                  children: [
                    loading && /* @__PURE__ */ jsx(TitleTextSkeleton, { animated: !0, radius: 1, size: 1 }),
                    !loading && /* @__PURE__ */ jsx(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })
                  ]
                }
              ),
              actions && /* @__PURE__ */ jsx(Flex, { align: "center", hidden: collapsed, children: /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })
            ]
          }
        ),
        !!(!collapsed && (tabs || subActions)) && /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            children: [
              /* @__PURE__ */ jsx(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
              subActions && subActions
            ]
          }
        ),
        !collapsed && contentAfter && contentAfter
      ] }) })
    }
  ) });
});
function getDisabledReason$1(node) {
  var _a;
  if (!node.disabled)
    return { disabledReason: void 0, ariaLabel: void 0, isDisabled: !1 };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof ((_a = node.disabled) == null ? void 0 : _a.reason) == "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: !!node.disabled };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  return node.type === "item" ? /* @__PURE__ */ jsx(PaneHeaderMenuItemActionButton, { node }) : node.type === "group" ? /* @__PURE__ */ jsx(PaneHeaderMenuGroupActionButton, { node }) : (console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null);
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props, { title } = useI18nText(node);
  if (node.intent)
    return /* @__PURE__ */ jsx(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsx(
    StatusButton,
    {
      disabled: isDisabled,
      icon: node.icon,
      onClick: node.onAction,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : title
      }
    }
  );
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props, intentLink = useIntentLink({ intent: intent.type, params: intent.params }), handleClick = useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsx(
    StatusButton,
    {
      forwardedAs: "a",
      disabled: isDisabled,
      href: intentLink.href,
      icon: node.icon,
      onClick: handleClick,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : node.title,
        placement: "bottom",
        portal: !0
      }
    }
  );
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const { node } = props, { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        Button,
        {
          disabled: !!node.disabled,
          icon: (_a = node.icon) != null ? _a : UnknownIcon,
          label: title,
          mode: "bleed",
          tooltipProps: { content: node.title, portal: !0 }
        }
      ),
      id: useId(),
      menu: /* @__PURE__ */ jsx(Menu, { children: node.children.map((child, idx) => {
        var _a2;
        return /* @__PURE__ */ jsx(
          PaneMenuButtonItem,
          {
            disabled: !!node.disabled,
            isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          },
          child.key
        );
      }) })
    }
  );
}
const Root$b = styled(Card)`
  transition: opacity 200ms;
  position: relative;
  z-index: 1;
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  opacity: 0;

  &:not([hidden]) {
    display: flex;
  }

  &:not([data-collapsed]) {
    overflow: auto;
  }

  &[data-mounted] {
    opacity: 1;
  }

  &[data-resizing] {
    pointer-events: none;
  }
`;
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH, rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum.width * sum.flex, rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement)
      return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map2.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = !1;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, { ...options, original: options }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = !0, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(
          cache,
          leftOptions,
          rightOptions,
          deltaX
        );
        resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW }), resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW }), _notifyObservers();
      }
      if (type === "end") {
        resizing = !1;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : 1 / 0,
          flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : 1 / 0,
          flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? !1 : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props, controller = useMemo(() => createPaneLayoutController(), []), [rootElement, setRootElement] = useState(null), rootRect = useElementRect(rootElement), width = (rootRect == null ? void 0 : rootRect.width) || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth, [state2, setState] = useState({
    expandedElement: null,
    panes: [],
    resizing: !1
  });
  useEffect(() => controller.setRootElement(rootElement), [controller, rootElement]), useEffect(() => controller.setRootWidth(width), [controller, width]), useEffect(() => controller.subscribe(setState), [controller]), useEffect(() => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = useMemo(
    () => ({
      collapse: controller.collapse,
      collapsed,
      expand: controller.expand,
      expandedElement: state2.expandedElement,
      mount: controller.mount,
      panes: state2.panes,
      resize: controller.resize,
      resizing: state2.resizing
    }),
    [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]
  );
  return /* @__PURE__ */ jsx(PaneLayoutContext.Provider, { value: paneLayout, children: /* @__PURE__ */ jsx(
    Root$b,
    {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state2.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    }
  ) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const { fieldActions = [], menuItems, menuItemGroups } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: !0,
      renderAsButton: !1,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      expanded: !0,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: !1
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_a = item.showAsAction) != null ? _a : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_b = item.showAsAction) != null ? _b : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map(
      (child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)
    ),
    disabled: a.disabled,
    expanded: (_a = a.expanded) != null ? _a : !0,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: (_b = a.renderAsButton) != null ? _b : !1
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : !1,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
const IntentButton = forwardRef(function(props, ref) {
  const { intent, ...restProps } = props, Link2 = useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      forwardRef(function(linkProps, linkRef) {
        return /* @__PURE__ */ jsx(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
      })
    ),
    [intent]
  );
  return props.disabled ? /* @__PURE__ */ jsx(Button, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsx(
    Button,
    {
      ...restProps,
      as: Link2,
      "data-as": "a",
      ref
    }
  );
});
function InsufficientPermissionsMessageTooltip({
  reveal,
  context,
  loading,
  children
}) {
  const currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace);
  return reveal ? /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context, currentUser }),
      portal: !0,
      children: /* @__PURE__ */ jsx("div", { children })
    }
  ) : /* @__PURE__ */ jsx(Fragment$1, { children });
}
const POPOVER_PROPS$1 = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
}, getIntent = (schema2, templates, item) => {
  var _a;
  const typeName = (_a = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName)
    return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton({ templateItems }) {
  const schema2 = useSchema(), templates = useTemplates(), { t } = useTranslation(structureLocaleNamespace), getI18nText = useGetI18nText([...templateItems, ...templates]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), nothingGranted = useMemo(() => !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted)), [isTemplatePermissionsLoading, templatePermissions]), permissionsById = useMemo(() => templatePermissions ? templatePermissions.reduce(
    (acc, permission) => (acc[permission.id] = permission, acc),
    {}
  ) : {}, [templatePermissions]);
  if (nothingGranted)
    return /* @__PURE__ */ jsx(
      InsufficientPermissionsMessageTooltip,
      {
        context: "create-document-type",
        reveal: !0,
        loading: isTemplatePermissionsLoading,
        children: /* @__PURE__ */ jsx(
          Button,
          {
            "aria-label": t("pane-header.disabled-created-button.aria-label"),
            icon: AddIcon,
            "data-testid": "action-intent-button",
            disabled: !0,
            mode: "bleed",
            tooltipProps: null
          }
        )
      }
    );
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], permissions = permissionsById[firstItem.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, firstItem);
    return intent ? /* @__PURE__ */ jsx(
      InsufficientPermissionsMessageTooltip,
      {
        reveal: disabled,
        loading: isTemplatePermissionsLoading,
        context: "create-document-type",
        children: /* @__PURE__ */ jsx(
          IntentButton,
          {
            "aria-label": getI18nText(firstItem).title,
            icon: firstItem.icon || AddIcon,
            intent,
            mode: "bleed",
            disabled,
            "data-testid": "action-intent-button",
            tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") }
          }
        )
      }
    ) : null;
  }
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        Button,
        {
          icon: AddIcon,
          mode: "bleed",
          "data-testid": "multi-action-intent-button",
          tooltipProps: { content: t("pane-header.create-new-button.tooltip") }
        }
      ),
      id: "create-menu",
      menu: /* @__PURE__ */ jsx(Menu, { children: templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, item), template2 = templates.find((i) => i.id === item.templateId);
        if (!template2 || !intent)
          return null;
        const Link2 = forwardRef(
          (linkProps, linkRef) => disabled ? /* @__PURE__ */ jsx("button", { type: "button", disabled: !0, ...linkProps, ref: linkRef }) : /* @__PURE__ */ jsx(
            IntentLink,
            {
              ...linkProps,
              intent: intent.type,
              params: intent.params,
              ref: linkRef
            }
          )
        );
        Link2.displayName = "Link";
        const { title } = getI18nText({
          ...item,
          // replace the title with the template title
          title: item.title || getI18nText(template2).title
        });
        return /* @__PURE__ */ jsx(
          InsufficientPermissionsMessageTooltip,
          {
            context: "create-document-type",
            reveal: disabled,
            loading: isTemplatePermissionsLoading,
            children: /* @__PURE__ */ jsx(
              MenuItem,
              {
                as: Link2,
                "data-as": disabled ? "button" : "a",
                text: title,
                "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title,
                disabled,
                "data-testid": `action-intent-button-${itemIndex}`
              }
            )
          },
          item.id
        );
      }) }),
      popover: POPOVER_PROPS$1
    }
  );
}
function isNonNullable(value) {
  return value != null;
}
const hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
}, PaneHeaderActions = memo(function(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$k,
    menuItems = EMPTY_ARRAY$k,
    menuItemGroups = EMPTY_ARRAY$k,
    actionHandlers = EMPTY_OBJECT
  } = props, templates = useTemplates(), handleAction = useCallback(
    (item) => {
      if (typeof item.action == "string" && !(item.action in actionHandlers))
        return console.warn("No handler for action:", item.action), !1;
      const handler = (
        // eslint-disable-next-line no-nested-ternary
        typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null
      );
      return handler ? (handler(item.params), !0) : !1;
    },
    [actionHandlers]
  ), menuNodes = useMemo(
    () => resolveMenuNodes({
      actionHandler: handleAction,
      menuItemGroups,
      menuItems: menuItems.filter((item) => {
        var _a;
        return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
      })
    }),
    [handleAction, menuItemGroups, menuItems]
  ), actionNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), initialValueTemplateItemFromMenuItems = useMemo(() => menuItems.map((item, menuItemIndex) => {
    var _a;
    if (((_a = item.intent) == null ? void 0 : _a.type) !== "create")
      return null;
    const { params } = item.intent;
    if (!params)
      return null;
    const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
    if (!templateId)
      return null;
    const template2 = templates.find((t) => t.id === templateId);
    if (!template2)
      return null;
    const initialDocumentId = intentParams.id;
    return {
      item,
      template: template2,
      templateParams,
      menuItemIndex,
      initialDocumentId
    };
  }).filter(isNonNullable).map(({ initialDocumentId, item, template: template2, menuItemIndex, templateParams }) => ({
    id: `menuItem${menuItemIndex}`,
    initialDocumentId,
    templateId: template2.id,
    type: "initialValueTemplateItem",
    title: item.title || template2.title,
    i18n: item.i18n || template2.i18n,
    icon: item.icon,
    description: template2.description,
    parameters: templateParams,
    schemaType: template2.schemaType
  })), [menuItems, templates]), combinedInitialValueTemplates = useMemo(() => uniqBy(
    [...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure],
    (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters])
  ), [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    combinedInitialValueTemplates.length > 0 && /* @__PURE__ */ jsx(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }),
    actionNodes.map((node) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node }, node.key)),
    contextMenuNodes.length > 0 && /* @__PURE__ */ jsx(PaneContextMenuButton, { nodes: contextMenuNodes })
  ] });
});
function MissingSchemaType(props) {
  const { t } = useTranslation(structureLocaleNamespace), { layout, value } = props;
  return /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      title: /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.title",
          components: { Code: "code" },
          values: { documentType: value._type }
        }
      ) }),
      subtitle: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.subtitle",
          components: { Code: "code" },
          values: { documentId: value._id }
        }
      ),
      media: () => /* @__PURE__ */ jsx(WarningOutlineIcon, {}),
      layout
    }
  );
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === !1 ? !1 : icon || schemaType && schemaType.icon || defaultIcon || !1;
}
function PaneItem(props) {
  const {
    icon,
    id,
    layout = "default",
    pressed,
    schemaType,
    selected,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, schema2 = useSchema(), documentPreviewStore = useDocumentPreviewStore(), { ChildLink: ChildLink2 } = usePaneRouter(), documentPresence = useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema2.get(schemaType.name)), [clicked, setClicked] = useState(!1), preview = useMemo(() => value && isSanityDocument$1(value) ? !schemaType || !hasSchemaType ? /* @__PURE__ */ jsx(MissingSchemaType, { value }) : /* @__PURE__ */ jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: getIconWithFallback(icon, schemaType, DocumentIcon),
      layout,
      schemaType,
      value,
      presence: documentPresence
    }
  ) : /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      status: /* @__PURE__ */ jsx(Box, { style: { opacity: 0.5 }, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronRightIcon, {}) }) }),
      icon: getIconWithFallback(icon, schemaType, FolderIcon),
      layout: "compact",
      title
    }
  ), [
    documentPreviewStore,
    hasSchemaType,
    icon,
    layout,
    schemaType,
    title,
    value,
    documentPresence
  ]), Link2 = useMemo(
    () => function(linkProps) {
      return /* @__PURE__ */ jsx(ChildLink2, { ...linkProps, childId: id });
    },
    [ChildLink2, id]
  ), handleClick = useCallback((e) => {
    if (e.metaKey) {
      setClicked(!1);
      return;
    }
    setClicked(!0);
  }, []);
  return useEffect(() => setClicked(!1), [selected]), /* @__PURE__ */ jsx(
    PreviewCard,
    {
      __unstable_focusRing: !0,
      as: Link2,
      "data-as": "a",
      margin,
      marginBottom,
      marginTop,
      onClick: handleClick,
      pressed,
      radius: 2,
      selected: selected || clicked,
      sizing: "border",
      tabIndex: -1,
      tone: "inherit",
      children: preview
    }
  );
}
const RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete, group } = props;
  return /* @__PURE__ */ jsx(
    GetHookCollectionState,
    {
      onReset: onActionComplete,
      hooks: actions,
      args: actionProps,
      group,
      children
    }
  );
}, RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return /* @__PURE__ */ jsx(GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function useNotificationTarget(opts) {
  const { documentId, documentType } = opts || {}, schemaType = useSchema().get(documentType), { title: workspaceTitle } = useWorkspace(), { createPathWithParams, params } = usePaneRouter(), documentPreviewStore = useDocumentPreviewStore(), previewState = useMemoObservable(() => !documentId || !schemaType ? of(null) : getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  return {
    getNotificationValue: useCallback(
      ({ commentId }) => {
        const path = createPathWithParams({
          ...params,
          comment: commentId,
          inspect: COMMENTS_INSPECTOR_NAME
        }), url = `${window.location.origin}${path}`;
        return { documentTitle, url, workspaceTitle };
      },
      [createPathWithParams, documentTitle, params, workspaceTitle]
    )
  };
}
async function createOperation(props) {
  const {
    activeTool,
    client,
    comment,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getIntent: getIntent2,
    getNotificationValue,
    getThreadLength,
    onCreate,
    onCreateError,
    projectId,
    createAddonDataset,
    workspace
  } = props, commentId = (comment == null ? void 0 : comment.id) || uuid(), authorId = currentUser.id, currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
  let nextComment;
  if (comment.type === "task" && (nextComment = {
    _id: commentId,
    _type: "comment",
    authorId,
    message: comment.message,
    lastEditedAt: void 0,
    parentCommentId: comment.parentCommentId,
    status: comment.status,
    threadId: comment.threadId,
    reactions: comment.reactions,
    context: {
      payload: {
        workspace
      },
      notification: comment.context.notification,
      tool: (activeTool == null ? void 0 : activeTool.name) || ""
    },
    target: {
      document: {
        _ref: documentId,
        _type: "reference",
        _weak: !0
      },
      documentType
    }
  }), comment.type === "field") {
    const {
      documentTitle = "",
      url = "",
      workspaceTitle = ""
    } = getNotificationValue({ commentId }) || {}, notification = {
      currentThreadLength,
      documentTitle,
      url,
      workspaceTitle
    }, intent = getIntent2 == null ? void 0 : getIntent2({ id: documentId, type: documentType, path: comment.fieldPath });
    nextComment = {
      _id: commentId,
      _type: "comment",
      authorId,
      message: comment.message,
      lastEditedAt: void 0,
      parentCommentId: comment.parentCommentId,
      status: comment.status,
      threadId: comment.threadId,
      reactions: comment.reactions,
      context: {
        payload: {
          workspace
        },
        intent,
        notification,
        tool: (activeTool == null ? void 0 : activeTool.name) || ""
      },
      contentSnapshot: comment.contentSnapshot,
      target: {
        documentRevisionId: documentRevisionId || "",
        path: {
          field: comment.fieldPath,
          selection: comment.selection
        },
        document: {
          _dataset: dataset,
          _projectId: projectId,
          _ref: documentId,
          _type: "crossDatasetReference",
          _weak: !0
        },
        documentType
      }
    };
  }
  if (nextComment) {
    if (onCreate == null || onCreate(nextComment), !client) {
      try {
        const newAddonClient = await createAddonDataset();
        if (!newAddonClient)
          throw new Error("Failed to create addon dataset client");
        await newAddonClient.create(nextComment);
      } catch (err) {
        throw onCreateError == null || onCreateError(nextComment._id, err), err;
      }
      return;
    }
    try {
      await client.create(nextComment);
    } catch (err) {
      throw onCreateError == null || onCreateError(nextComment._id, err), err;
    }
  }
}
function createReactionKey(userId, shortName) {
  return `${userId}-${shortName}`;
}
async function reactOperation(props) {
  var _a;
  const { client, currentUser, id, reaction, getComment, onUpdate } = props, reactions = ((_a = getComment == null ? void 0 : getComment(id)) == null ? void 0 : _a.reactions) || [], currentUserReactions = reactions.filter((r) => r.userId === currentUser.id), _key = createReactionKey(currentUser.id, reaction.shortName), currentReaction = currentUserReactions.find(
    (r) => r._key === _key && r._optimisticState !== "removed"
  );
  if (currentReaction) {
    const next = reactions.map((r) => r._key === currentReaction._key ? { ...r, _optimisticState: "removed" } : r);
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).unset([`reactions[_key=="${_key}"]`]).commit();
    return;
  }
  if (!currentReaction) {
    const reactionItem = {
      _key,
      addedAt: (/* @__PURE__ */ new Date()).toISOString(),
      shortName: reaction.shortName,
      userId: currentUser.id
    }, optimisticReactionItem = { ...reactionItem, _optimisticState: "added" }, next = reactions.concat(optimisticReactionItem).filter((r) => !(r._key === reactionItem._key && r._optimisticState === "removed"));
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).setIfMissing({ reactions: [] }).append("reactions", [reactionItem]).commit();
  }
}
async function removeOperation(props) {
  const { client, id, onRemove } = props;
  onRemove == null || onRemove(id), await Promise.all([
    client.delete({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }),
    client.delete(id)
  ]);
}
const THROTTLE_TIME_MS = 1e3, THROTTLE_SETTINGS = {
  trailing: !0,
  leading: !1
}, throttleFunctionsMap = /* @__PURE__ */ new Map();
function getThrottledFunction(id) {
  if (!throttleFunctionsMap.has(id)) {
    const throttledFunction = throttle(postCommentUpdate, THROTTLE_TIME_MS, THROTTLE_SETTINGS);
    return throttleFunctionsMap.set(id, throttledFunction), throttledFunction;
  }
  return throttleFunctionsMap.get(id);
}
async function postCommentUpdate(props) {
  const { client, id, comment, transactionId: transactionIdProp, onUpdate } = props, transactionId = transactionIdProp || uuid(), patch = client == null ? void 0 : client.patch(id).set(comment), transaction = client.transaction().transactionId(transactionId).patch(patch);
  onUpdate == null || onUpdate(id, comment), comment.status ? (await transaction.commit(), await client.patch({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }).set({
    status: comment.status
  }).commit()) : await transaction.commit(), throttleFunctionsMap.delete(id);
}
async function updateOperation(props) {
  const { id, comment, throttled: throttledProp } = props, hasEditedMessage = "message" in comment, editedComment = {
    ...comment,
    lastEditedAt: (/* @__PURE__ */ new Date()).toISOString()
  }, nextComment = hasEditedMessage ? editedComment : comment;
  if (!throttledProp) {
    await postCommentUpdate({
      ...props,
      comment: nextComment
    });
    return;
  }
  await getThrottledFunction(id)({
    ...props,
    comment: nextComment
  });
}
function useCommentOperations(opts) {
  const {
    client,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getComment,
    getThreadLength,
    onCreate,
    onCreateError,
    onRemove,
    onTransactionStart,
    onUpdate,
    projectId,
    createAddonDataset,
    workspace
  } = opts, getIntent2 = useCommentsIntent(), activeToolName = useRouterState(
    useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), tools = useTools(), activeTool = useMemo(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), { getNotificationValue } = useNotificationTarget({ documentId, documentType }), handleCreate = useCallback(
    async (comment) => {
      currentUser != null && currentUser.id && await createOperation({
        activeTool,
        client,
        comment,
        currentUser,
        dataset,
        documentId,
        documentRevisionId,
        documentType,
        getIntent: getIntent2,
        getNotificationValue,
        getThreadLength,
        onCreate,
        onCreateError,
        projectId,
        createAddonDataset,
        workspace
      });
    },
    [
      activeTool,
      client,
      currentUser,
      dataset,
      documentId,
      documentRevisionId,
      documentType,
      getIntent2,
      getNotificationValue,
      getThreadLength,
      onCreate,
      onCreateError,
      projectId,
      createAddonDataset,
      workspace
    ]
  ), handleRemove = useCallback(
    async (id) => {
      client && await removeOperation({
        client,
        id,
        onRemove
      });
    },
    [client, onRemove]
  ), handleUpdate = useCallback(
    async (id, comment, updateOpts) => {
      if (!client)
        return;
      const { throttled } = updateOpts || {}, nextTransactionId = uuid();
      onTransactionStart(id, nextTransactionId), await updateOperation({
        client,
        comment,
        throttled,
        id,
        onUpdate,
        transactionId: nextTransactionId
      });
    },
    [client, onTransactionStart, onUpdate]
  ), handleReact = useCallback(
    async (id, reaction) => {
      !client || !(currentUser != null && currentUser.id) || await reactOperation({
        client,
        currentUser,
        id,
        reaction,
        getComment,
        onUpdate
      });
    },
    [client, currentUser, getComment, onUpdate]
  );
  return useMemo(
    () => ({
      operation: {
        create: handleCreate,
        react: handleReact,
        remove: handleRemove,
        update: handleUpdate
      }
    }),
    [handleCreate, handleRemove, handleUpdate, handleReact]
  );
}
function useComments() {
  const value = useContext(CommentsContext);
  if (!value)
    throw new Error("useComments must be used within a CommentsProvider");
  return value;
}
function useCommentsAuthoringPath() {
  const value = useContext(CommentsAuthoringPathContext);
  if (!value)
    throw new Error("useCommentsAuthoringPath: missing context value");
  return value;
}
function useCommentsEnabled() {
  const ctx = useContext(CommentsEnabledContext);
  if (ctx === null)
    throw new Error("useCommentsEnabled: missing context value");
  return ctx;
}
function useCommentsOnboarding() {
  const ctx = useContext(CommentsOnboardingContext);
  if (!ctx)
    throw new Error("useCommentsOnboarding: missing context value");
  return ctx;
}
const BASE_SCROLL_OPTIONS = {
  behavior: "smooth",
  inline: "center",
  scrollMode: "if-needed"
}, GROUP_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "start"
}, INLINE_COMMENT_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_FIELD_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_COMMENT_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_OPTIONS_BY_TYPE = {
  comment: SCROLL_TO_COMMENT_OPTIONS,
  field: SCROLL_TO_FIELD_OPTIONS,
  group: GROUP_SCROLL_OPTIONS,
  "inline-comment": INLINE_COMMENT_SCROLL_OPTIONS
};
function generateValidAttrValue(id) {
  const symbolsToRemove = /[[\]_"_=.]/g;
  return id.replace(symbolsToRemove, "");
}
function applyCommentIdAttr(id) {
  return {
    "data-comments-comment-id": generateValidAttrValue(id)
  };
}
function applyCommentsFieldAttr(id) {
  return {
    "data-comments-field-id": generateValidAttrValue(id)
  };
}
function applyCommentsGroupAttr(id) {
  return {
    "data-comments-group-id": generateValidAttrValue(id)
  };
}
function applyInlineCommentIdAttr(id) {
  return {
    "data-comments-inline-comment-id": generateValidAttrValue(id)
  };
}
function useCommentsScroll(opts) {
  const { boundaryElement } = opts || {}, [scrollTarget, setScrollTarget] = useState(null), scrollOpts = useMemo(() => ({
    ...SCROLL_OPTIONS_BY_TYPE[(scrollTarget == null ? void 0 : scrollTarget.type) || "comment"],
    boundary: boundaryElement
  }), [boundaryElement, scrollTarget == null ? void 0 : scrollTarget.type]), handleScrollToComment = useCallback((commentId) => {
    setScrollTarget({ type: "comment", id: commentId });
  }, []), handleScrollToGroup = useCallback((threadId) => {
    setScrollTarget({ type: "group", id: threadId });
  }, []), handleScrollToField = useCallback((fieldPath) => {
    setScrollTarget({ type: "field", id: fieldPath });
  }, []), handleScrollToInlineComment = useCallback((commentId) => {
    setScrollTarget({ type: "inline-comment", id: commentId });
  }, []);
  return useEffect(() => {
    const raf = requestAnimationFrame(() => {
      if (!scrollTarget)
        return;
      const { type, id } = scrollTarget, element = document == null ? void 0 : document.querySelector(
        `[data-comments-${type}-id="${generateValidAttrValue(id)}"]`
      );
      element && scrollIntoView(element, scrollOpts);
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [scrollOpts, scrollTarget]), useMemo(
    () => ({
      scrollToComment: handleScrollToComment,
      scrollToField: handleScrollToField,
      scrollToGroup: handleScrollToGroup,
      scrollToInlineComment: handleScrollToInlineComment
    }),
    [handleScrollToComment, handleScrollToField, handleScrollToGroup, handleScrollToInlineComment]
  );
}
function useCommentsSelectedPath() {
  const ctx = useContext(CommentsSelectedPathContext);
  if (!ctx)
    throw new Error("useCommentsSelectedPath: missing context value");
  return ctx;
}
function useCommentsUpsell() {
  return useContext(CommentsUpsellContext) || {
    upsellData: null,
    handleOpenDialog: () => null,
    upsellDialogOpen: !1,
    telemetryLogs: {
      dialogSecondaryClicked: () => null,
      dialogPrimaryClicked: () => null,
      panelViewed: () => null,
      panelDismissed: () => null,
      panelPrimaryClicked: () => null,
      panelSecondaryClicked: () => null
    }
  };
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading, error } = useFeatureEnabled("studioComments"), { enabled } = useSource().document.unstable_comments, enabledFromConfig = useMemo(
    () => enabled({ documentType, documentId: getPublishedId(documentId) }),
    [documentId, documentType, enabled]
  );
  return useMemo(() => isLoading || !enabledFromConfig || error ? { enabled: !1, mode: null } : {
    enabled: !0,
    mode: featureEnabled ? "default" : "upsell"
  }, [isLoading, enabledFromConfig, error, featureEnabled]);
}
const StyledAvatar = styled(Avatar)`
  svg > ellipse {
    stroke: transparent;
  }
`, SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu, WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function CommentsAvatar(props) {
  const { user: userProp, ...restProps } = props, user = userProp, initials = useMemo(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  return user ? /* @__PURE__ */ jsx(
    StyledAvatar,
    {
      initials,
      src: user == null ? void 0 : user.imageUrl,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  ) : /* @__PURE__ */ jsx(StyledAvatar, { ...restProps });
}
const SpacerAvatar = styled.div((props) => {
  var _a;
  const theme = getTheme_v2(props.theme), { $size = 1 } = props;
  return css`
    min-width: ${(_a = theme.avatar.sizes[$size]) == null ? void 0 : _a.size}px;
  `;
}), mentionObject = defineField({
  name: "mention",
  type: "object",
  fields: [
    {
      name: "userId",
      type: "string"
    }
  ]
}), blockType = defineField({
  type: "block",
  name: "block",
  of: [mentionObject],
  marks: {
    annotations: []
  },
  styles: [{ title: "Normal", value: "normal" }],
  lists: []
}), portableTextType = defineArrayMember({
  type: "array",
  name: "body",
  of: [blockType]
}), schema = Schema.compile({
  name: "comments",
  types: [portableTextType]
}), editorSchemaType = schema.get("body"), Span$1 = styled.span(({ theme }) => {
  var _a, _b, _c;
  const { regular } = ((_a = theme.sanity.fonts) == null ? void 0 : _a.text.weights) || {}, { hovered } = ((_b = theme.sanity.color) == null ? void 0 : _b.card) || {}, { bg } = ((_c = theme.sanity.color.selectable) == null ? void 0 : _c.caution.pressed) || {};
  return css`
    font-weight: ${regular};
    color: var(--card-link-fg-color);
    border-radius: 2px;
    background-color: ${hovered.bg};
    padding: 1px;
    box-sizing: border-box;

    &[data-active='true'] {
      background-color: ${bg};
    }
  `;
});
function MentionInlineBlock(props) {
  const { selected, userId } = props, [user, loading] = useUser(userId), currentUser = useCurrentUser();
  return !user || loading ? /* @__PURE__ */ jsx(
    TextSkeleton,
    {
      "data-testid": "comment-mentions-loading-skeleton",
      style: { width: "10ch" },
      size: 0,
      muted: !0,
      radius: 1,
      animated: !0
    }
  ) : /* @__PURE__ */ jsx(
    Tooltip,
    {
      portal: !0,
      content: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsx(Flex, { children: /* @__PURE__ */ jsx(CommentsAvatar, { user }) }),
        /* @__PURE__ */ jsx(Text, { size: 1, children: user.displayName })
      ] }),
      children: /* @__PURE__ */ jsxs(Span$1, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: [
        "@",
        user.displayName
      ] })
    }
  );
}
const NormalText$1 = styled(Text)`
  word-break: break-word;
`;
function NormalBlock(props) {
  const { children } = props;
  return /* @__PURE__ */ jsx(NormalText$1, { size: 1, children });
}
const renderBlock$1 = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsx(NormalBlock, { children });
}, renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  return value._type === "mention" && value.userId ? /* @__PURE__ */ jsx(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId }) : children;
}, Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props) {
  const { t } = useTranslation(commentsLocaleNamespace), { onClose, onConfirm } = props, handleCancelClick = useCallback(
    (e) => {
      e.stopPropagation(), onClose();
    },
    [onClose]
  ), handleConfirmClick = useCallback(
    (e) => {
      e.stopPropagation(), onConfirm();
    },
    [onConfirm]
  );
  return /* @__PURE__ */ jsx(ThemeColorProvider, { tone: "default", children: /* @__PURE__ */ jsx(DialogProvider, { zOffset: Z_OFFSET, children: /* @__PURE__ */ jsx(
    Dialog,
    {
      header: t("discard.header"),
      id: "discard-comment-dialog",
      onClose,
      width: 0,
      onClickOutside: onClose,
      footer: {
        cancelButton: {
          onClick: handleCancelClick
        },
        confirmButton: {
          onClick: handleConfirmClick,
          text: t("discard.button-confirm"),
          tone: "critical"
        }
      },
      children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("discard.text") })
    }
  ) }) });
}
const InnerFlex = styled(Flex)``, SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props) {
  const { user, onSelect } = props, [loadedUser] = useUser(user.id), { t } = useTranslation(commentsLocaleNamespace), avatar = /* @__PURE__ */ jsx(CommentsAvatar, { user: loadedUser, status: user.granted ? void 0 : "inactive" }), text = loadedUser ? /* @__PURE__ */ jsx(Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : /* @__PURE__ */ jsx(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 }), handleSelect = useCallback(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return /* @__PURE__ */ jsx(Card, { as: "button", disabled: !user.granted, onClick: handleSelect, padding: 2, radius: 2, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxs(InnerFlex, { align: "center", gap: 2, flex: 1, children: [
      avatar,
      /* @__PURE__ */ jsx(Box, { children: text })
    ] }),
    !user.granted && /* @__PURE__ */ jsx(Badge, { fontSize: 1, mode: "outline", children: t("mentions.unauthorized-user") })
  ] }) });
}
const EMPTY_ARRAY$f = [], Root$a = styled(Stack)({
  maxWidth: "220px"
  // todo: improve
}), ITEM_HEIGHT = 41, LIST_PADDING = 4, MAX_ITEMS = 7, FlexWrap = styled(Flex)({
  maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2
}), MentionsMenu$1 = React.forwardRef(function(props, ref) {
  const { t } = useTranslation(commentsLocaleNamespace), { loading, onSelect, options = [], inputElement } = props, [searchTerm, setSearchTerm] = useState(""), commandListRef = useRef(null);
  useImperativeHandle(
    ref,
    () => ({
      setSearchTerm(term) {
        setSearchTerm(term);
      }
    }),
    []
  );
  const renderItem2 = useCallback(
    (itemProps) => /* @__PURE__ */ jsx(MentionsMenuItem, { user: itemProps, onSelect }),
    [onSelect]
  ), getItemDisabled = useCallback(
    (index) => {
      var _a;
      return !((_a = options == null ? void 0 : options[index]) != null && _a.granted);
    },
    [options]
  ), filteredOptions = useMemo(() => {
    var _a;
    if (!searchTerm)
      return options || EMPTY_ARRAY$f;
    const deburredSearchTerm = deburr(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      displayName: deburr(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a2;
      return (_a2 = option == null ? void 0 : option.displayName) == null ? void 0 : _a2.includes(deburredSearchTerm);
    })) == null ? void 0 : _a.sort((a, b) => {
      var _a2, _b;
      const matchA = (_a2 = a.displayName) == null ? void 0 : _a2.startsWith(deburredSearchTerm), matchB = (_b = b.displayName) == null ? void 0 : _b.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || EMPTY_ARRAY$f;
  }, [options, searchTerm]);
  if (loading)
    return /* @__PURE__ */ jsx(Root$a, { children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) });
  const _inputElement = inputElement || void 0;
  return /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [
    filteredOptions.length === 0 && /* @__PURE__ */ jsx(Box, { padding: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", size: 1, muted: !0, children: t("mentions.no-users-found") }) }),
    filteredOptions.length > 0 && /* @__PURE__ */ jsx(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: /* @__PURE__ */ jsx(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: t("mentions.user-list-aria-label"),
        fixedHeight: !0,
        getItemDisabled,
        inputElement: _inputElement,
        itemHeight: 41,
        items: filteredOptions,
        padding: 1,
        ref: commandListRef,
        renderItem: renderItem2
      }
    ) })
  ] });
}), CommentInputContext = React__default.createContext(null);
function CommentInputProvider(props) {
  const {
    children,
    expandOnFocus = !1,
    focused,
    focusOnMount = !1,
    mentionOptions,
    onMentionMenuOpenChange,
    value,
    readOnly
  } = props, editor = usePortableTextEditor(), [mentionsMenuOpen, setMentionsMenuOpen] = useState(!1), [mentionsSearchTerm, setMentionsSearchTerm] = useState(""), [selectionAtMentionInsert, setSelectionAtMentionInsert] = useState(null), canSubmit = useMemo(() => hasCommentMessageValue(value), [value]), hasChanges = useCommentHasChanged(value), focusEditor = useCallback(() => {
    readOnly || PortableTextEditor.focus(editor);
  }, [editor, readOnly]), closeMentions = useCallback(() => {
    setMentionsMenuOpen(!1), setMentionsSearchTerm(""), setSelectionAtMentionInsert(null);
  }, []), openMentions = useCallback(() => {
    setMentionsMenuOpen(!0), setMentionsSearchTerm(""), setMentionsMenuOpen(!0), setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]), onBeforeInput = useCallback(
    (event) => {
      const selection = PortableTextEditor.getSelection(editor), cursorOffset = selection ? selection.focus.offset : 0, focusChild = PortableTextEditor.focusChild(editor), focusSpan = isPortableTextSpan$1(focusChild) && focusChild || void 0, isInsertText = event.inputType === "insertText", isDeleteText = event.inputType === "deleteContentBackward", isInsertingAtChar = isInsertText && event.data === "@", lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.substring(0, cursorOffset).lastIndexOf("@")) || 0, isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.substring(cursorOffset - 1, cursorOffset)) === " ", filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
      if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
        openMentions();
        return;
      }
      if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
        closeMentions();
        return;
      }
      if (isPortableTextSpan$1(focusChild)) {
        let term = focusChild.text.substring(lastIndexOfAt + 1, cursorOffset);
        isInsertText && (term += event.data), isDeleteText && (term = term.substring(0, term.length - 1)), setMentionsSearchTerm(term);
      }
    },
    [closeMentions, editor, mentionsSearchTerm, openMentions]
  ), insertAtChar = useCallback(() => {
    setMentionsMenuOpen(!0), PortableTextEditor.focus(editor), PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: "@" }), setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = useCallback(
    (userId) => {
      var _a;
      const mentionSchemaType = editor.schemaTypes.inlineObjects.find((t) => t.name === "mention"), [span, spanPath] = selectionAtMentionInsert && PortableTextEditor.findByPath(editor, selectionAtMentionInsert.focus.path) || [];
      if (span && isPortableTextSpan$1(span) && spanPath && mentionSchemaType) {
        PortableTextEditor.focus(editor);
        const offset = (_a = PortableTextEditor.getSelection(editor)) == null ? void 0 : _a.focus.offset;
        typeof offset < "u" && (PortableTextEditor.delete(
          editor,
          {
            anchor: { path: spanPath, offset: span.text.lastIndexOf("@") },
            focus: { path: spanPath, offset }
          },
          { mode: "selected" }
        ), PortableTextEditor.insertChild(editor, mentionSchemaType, {
          userId
        }), PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: " " }));
      }
    },
    [editor, selectionAtMentionInsert]
  ), ctxValue = useMemo(
    () => ({
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly: !!readOnly,
      value
    }),
    [
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly,
      value
    ]
  );
  return /* @__PURE__ */ jsx(CommentInputContext.Provider, { value: ctxValue, children });
}
function useCommentInput() {
  const ctx = useContext(CommentInputContext);
  if (!ctx)
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  return ctx;
}
const EVENT_LISTENER_OPTIONS = { passive: !0 };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts, [cursorRect, setCursorRect] = useState(null), cursorElement = useMemo(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]), handleSelectionChange = useCallback(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0)
      return;
    const range = sel.getRangeAt(0);
    if (!(rootElement != null && rootElement.contains(range.commonAncestorContainer))) {
      setCursorRect(null);
      return;
    }
    const rect = range == null ? void 0 : range.getBoundingClientRect();
    rect && setCursorRect(rect);
  }, [disabled, rootElement]);
  return useEffect(() => (document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]), cursorElement;
}
const POPOVER_FALLBACK_PLACEMENTS$4 = ["bottom", "top"], INLINE_STYLE = { outline: "none" }, EMPTY_ARRAY$e = [], PlaceholderWrapper = styled.span((props) => {
  const { color } = getTheme_v2(props.theme);
  return css`
    color: ${color.input.default.enabled.placeholder};
    overflow: hidden;
    text-overflow: ellipsis;
    text-wrap: nowrap;
    display: block;
  `;
}), StyledPopover$1 = styled(Popover)(({ theme }) => {
  const { space, radius } = theme.sanity;
  return css`
    &[data-placement='bottom'] {
      transform: translateY(${space[1]}px);
    }

    &[data-placement='top'] {
      transform: translateY(-${space[1]}px);
    }

    [data-ui='Popover__wrapper'] {
      border-radius: ${radius[3]}px;
      display: flex;
      flex-direction: column;
      overflow: clip;
      overflow: hidden;
      position: relative;
      width: 300px; // todo: improve
    }
  `;
});
function Editable(props) {
  const { t } = useTranslation(commentsLocaleNamespace), {
    focusLock,
    onFocus,
    onBlur,
    onKeyDown,
    onSubmit,
    placeholder = t("compose.create-comment-placeholder"),
    renderBlock: renderBlock2
  } = props, [popoverElement, setPopoverElement] = useState(null), rootElementRef = useRef(null), editableRef = useRef(null), mentionsMenuRef = useRef(null), selection = usePortableTextEditorSelection(), {
    canSubmit,
    closeMentions,
    insertMention,
    mentionOptions,
    mentionsMenuOpen,
    mentionsSearchTerm,
    onBeforeInput,
    value
  } = useCommentInput(), cursorElement = useCursorElement({
    disabled: !mentionsMenuOpen,
    rootElement: rootElementRef.current
  }), renderPlaceholder = useCallback(
    () => /* @__PURE__ */ jsx(PlaceholderWrapper, { children: placeholder }),
    [placeholder]
  ), handleClickOutside = useCallback(() => {
    mentionsMenuOpen && closeMentions();
  }, [closeMentions, mentionsMenuOpen]);
  useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = useCallback(
    (event) => {
      switch (event.key) {
        case "Enter":
          if (event.shiftKey)
            break;
          if (mentionsMenuOpen) {
            event.preventDefault(), event.stopPropagation(), closeMentions();
            break;
          }
          onSubmit && canSubmit && (event.preventDefault(), event.stopPropagation(), onSubmit());
          break;
        case "Escape":
        case "ArrowLeft":
        case "ArrowRight":
          mentionsMenuOpen && (event.preventDefault(), event.stopPropagation(), closeMentions());
          break;
      }
      onKeyDown && onKeyDown(event);
    },
    [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]
  ), initialSelectionAtEndOfContent = useMemo(() => {
    if (selection)
      return;
    const lastBlock = (value || EMPTY_ARRAY$e).slice(-1)[0], lastChild = isPortableTextTextBlock$1(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild)
      return;
    const point = {
      path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }],
      offset: isPortableTextSpan$1(lastChild) ? lastChild.text.length : 0
    };
    return {
      focus: point,
      anchor: point
    };
  }, [value, selection]);
  useEffect(() => {
    var _a;
    (_a = mentionsMenuRef.current) == null || _a.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]), useEffect(() => {
    mentionsMenuOpen && selection && !isEqual(selection.anchor, selection.focus) && closeMentions();
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = /* @__PURE__ */ jsx(
    MentionsMenu$1,
    {
      inputElement: editableRef.current,
      loading: mentionOptions.loading,
      onSelect: insertMention,
      options: mentionOptions.data || EMPTY_ARRAY$e,
      ref: mentionsMenuRef
    }
  );
  return /* @__PURE__ */ jsxs("div", { ref: rootElementRef, children: [
    /* @__PURE__ */ jsx(
      StyledPopover$1,
      {
        arrow: !1,
        constrainSize: !0,
        content: popoverContent,
        disabled: !mentionsMenuOpen,
        fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$4,
        open: mentionsMenuOpen,
        placement: "bottom",
        ref: setPopoverElement,
        referenceElement: cursorElement
      }
    ),
    /* @__PURE__ */ jsx(
      PortableTextEditable,
      {
        "data-testid": "comment-input-editable",
        "data-ui": "EditableElement",
        onBeforeInput,
        onBlur,
        onFocus,
        onKeyDown: handleKeyDown,
        ref: editableRef,
        renderBlock: renderBlock2,
        renderChild,
        renderPlaceholder,
        selection: initialSelectionAtEndOfContent,
        style: INLINE_STYLE,
        tabIndex: focusLock ? 0 : void 0
      }
    )
  ] });
}
const EditableWrap = styled(Box)`
  max-height: 20vh;
  overflow-y: auto;
`, ButtonDivider = styled(MenuDivider)({
  height: 20,
  width: 1
});
function focusRingBorderStyle(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
const RootCard$1 = styled(Card)(({ theme }) => {
  const { color, input, radius } = getTheme_v2(theme), radii = radius[2];
  return css`
    border-radius: ${radii}px;
    box-shadow: var(--input-box-shadow);

    --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

    &:not([data-expand-on-focus='false'], :focus-within) {
      background: transparent;
      box-shadow: unset;
    }

    &[data-focused='true']:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }

      /* box-shadow: inset 0 0 0 1px var(--card-focus-ring-color); */
      --input-box-shadow: ${focusRingBorderStyle({
    color: "var(--card-focus-ring-color)",
    width: input.border.width
  })};
    }

    &:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='false'] {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='true'] {
      [data-ui='CommentInputActions']:not([hidden]) {
        display: none;
      }

      &:focus-within {
        [data-ui='CommentInputActions'] {
          display: flex;
        }
      }
    }
    &:hover {
      --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
    }
  `;
}), AvatarContainer = styled.div((props) => {
  var _a;
  return `
    min-height: ${(_a = getTheme_v2(props.theme).avatar.sizes[1]) == null ? void 0 : _a.size}px;
    display: flex;
    align-items: center;
  `;
});
function CommentInputInner(props) {
  const {
    avatarSize = 1,
    currentUser,
    focusLock,
    onBlur,
    onFocus,
    onKeyDown,
    onSubmit,
    placeholder,
    renderBlock: renderBlock2,
    withAvatar
  } = props, [user] = useUser(currentUser.id), { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput(), { t } = useTranslation(commentsLocaleNamespace), avatar = withAvatar ? /* @__PURE__ */ jsx(AvatarContainer, { children: /* @__PURE__ */ jsx(CommentsAvatar, { user, size: avatarSize }) }) : null, handleMentionButtonClicked = useCallback(
    (e) => {
      e.stopPropagation(), insertAtChar(), openMentions();
    },
    [insertAtChar, openMentions]
  );
  return /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 2, children: [
    avatar,
    /* @__PURE__ */ jsx(
      RootCard$1,
      {
        id: "comment-input-root",
        "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false",
        "data-focused": focused ? "true" : "false",
        flex: 1,
        sizing: "border",
        tone: readOnly ? "transparent" : "default",
        children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(EditableWrap, { paddingX: 1, paddingY: 2, sizing: "border", "data-ui": "editable-wrap", children: /* @__PURE__ */ jsx(
            Editable,
            {
              focusLock,
              onBlur,
              onFocus,
              onKeyDown,
              onSubmit,
              placeholder,
              renderBlock: renderBlock2
            }
          ) }),
          /* @__PURE__ */ jsx(Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: /* @__PURE__ */ jsxs(TooltipDelayGroupProvider, { children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                "aria-label": t("compose.mention-user-aria-label"),
                "data-testid": "comment-input-mention-button",
                disabled: readOnly,
                icon: MentionIcon,
                mode: "bleed",
                type: "button",
                onClick: handleMentionButtonClicked,
                tooltipProps: { content: t("compose.mention-user-tooltip") }
              }
            ),
            onSubmit && /* @__PURE__ */ jsxs(Fragment$1, { children: [
              /* @__PURE__ */ jsx(ButtonDivider, {}),
              /* @__PURE__ */ jsx(
                Button,
                {
                  "aria-label": t("compose.send-comment-aria-label"),
                  "data-testid": "comment-input-send-button",
                  disabled: !canSubmit || !hasChanges || readOnly,
                  icon: SendIcon,
                  mode: hasChanges && canSubmit ? "default" : "bleed",
                  onClick: onSubmit,
                  tone: hasChanges && canSubmit ? "primary" : "default",
                  tooltipProps: { content: t("compose.send-comment-tooltip") }
                }
              )
            ] })
          ] }) })
        ] })
      }
    )
  ] });
}
const EMPTY_ARRAY$d = [], SCROLL_INTO_VIEW_OPTIONS = {
  behavior: "smooth",
  block: "center",
  inline: "center"
}, CommentInput = forwardRef(
  function(props, ref) {
    const {
      avatarSize,
      currentUser,
      expandOnFocus,
      focusLock = !1,
      focusOnMount,
      mentionOptions,
      onBlur,
      onChange,
      onDiscardCancel,
      onDiscardConfirm,
      onFocus,
      onKeyDown,
      onMentionMenuOpenChange,
      onSubmit,
      placeholder,
      readOnly,
      renderBlock: renderBlock2 = renderBlock$1,
      value = EMPTY_ARRAY$d,
      withAvatar = !0
    } = props, [focused, setFocused] = useState(!1), editorRef = useRef(null), editorContainerRef = useRef(null), [showDiscardDialog, setShowDiscardDialog] = useState(!1), preDivRef = useRef(null), postDivRef = useRef(null), innerRef = useRef(null), [editorInstanceKey, setEditorInstanceKey] = useState(keyGenerator()), requestFocus = useCallback(() => {
      requestAnimationFrame(() => {
        editorRef.current && PortableTextEditor.focus(editorRef.current);
      });
    }, []), resetEditorInstance = useCallback(() => {
      setEditorInstanceKey(keyGenerator());
    }, []), handleChange = useCallback(
      (change) => {
        if (change.type === "ready" && focusOnMount && requestFocus(), change.type === "focus" && setFocused(!0), change.type === "blur" && setFocused(!1), change.type === "patch" && editorRef.current) {
          const editorStateValue = PortableTextEditor.getValue(editorRef.current);
          onChange(editorStateValue || EMPTY_ARRAY$d);
        }
      },
      [focusOnMount, onChange, requestFocus]
    ), scrollToEditor = useCallback(() => {
      var _a;
      (_a = editorContainerRef.current) == null || _a.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
    }, []), handleSubmit = useCallback(() => {
      onSubmit == null || onSubmit(), resetEditorInstance(), requestFocus(), scrollToEditor();
    }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]), handleDiscardConfirm = useCallback(() => {
      onDiscardConfirm(), resetEditorInstance();
    }, [onDiscardConfirm, resetEditorInstance]), discardDialogController = useMemo(() => ({
      open: () => {
        setShowDiscardDialog(!0);
      },
      close: () => {
        setShowDiscardDialog(!1), requestFocus();
      }
    }), [requestFocus]);
    useImperativeHandle(
      ref,
      () => ({
        focus: requestFocus,
        blur() {
          editorRef.current && PortableTextEditor.blur(editorRef.current);
        },
        scrollTo: scrollToEditor,
        reset: resetEditorInstance,
        discardDialogController
      }),
      [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]
    );
    const handleFocus = useCallback(
      (event) => {
        if (!focusLock)
          return;
        const target = event.target, innerEl = innerRef.current;
        if (innerEl && target === preDivRef.current) {
          focusLastDescendant(innerEl);
          return;
        }
        innerEl && target === postDivRef.current && focusFirstDescendant(innerEl);
      },
      [focusLock]
    );
    return /* @__PURE__ */ jsxs(Fragment$1, { children: [
      showDiscardDialog && onDiscardCancel && /* @__PURE__ */ jsx(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }),
      /* @__PURE__ */ jsx(Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: /* @__PURE__ */ jsx(
        PortableTextEditor,
        {
          onChange: handleChange,
          readOnly,
          ref: editorRef,
          schemaType: editorSchemaType,
          value: value || EMPTY_ARRAY$d,
          children: /* @__PURE__ */ jsxs(
            CommentInputProvider,
            {
              expandOnFocus,
              focused,
              focusOnMount,
              mentionOptions,
              onMentionMenuOpenChange,
              readOnly,
              value,
              children: [
                focusLock && /* @__PURE__ */ jsx("div", { ref: preDivRef, tabIndex: 0 }),
                /* @__PURE__ */ jsx(Stack, { ref: innerRef, children: /* @__PURE__ */ jsx(
                  CommentInputInner,
                  {
                    avatarSize,
                    currentUser,
                    focusLock,
                    onBlur,
                    onFocus,
                    onKeyDown,
                    onSubmit: onSubmit && handleSubmit,
                    placeholder,
                    renderBlock: renderBlock2,
                    withAvatar
                  }
                ) }),
                focusLock && /* @__PURE__ */ jsx("div", { ref: postDivRef, tabIndex: 0 })
              ]
            }
          )
        },
        editorInstanceKey
      ) })
    ] });
  }
), COMMENTS_HIGHLIGHT_HUE_KEY = "yellow", COMMENT_REACTION_OPTIONS = [
  {
    shortName: ":+1:",
    title: "Thumbs up"
  },
  {
    shortName: ":-1:",
    title: "Thumbs down"
  },
  {
    shortName: ":heart:",
    title: "Heart"
  },
  {
    shortName: ":rocket:",
    title: "Rocket"
  },
  {
    shortName: ":heavy_plus_sign:",
    title: "Heavy plus sign"
  },
  {
    shortName: ":eyes:",
    title: "Eyes"
  }
], COMMENT_REACTION_EMOJIS = {
  ":-1:": "\u{1F44E}",
  ":+1:": "\u{1F44D}",
  ":eyes:": "\u{1F440}",
  ":heart:": "\u2764\uFE0F",
  ":heavy_plus_sign:": "\u2795",
  ":rocket:": "\u{1F680}"
}, HighlightSpan = styled.span(({ theme }) => {
  var _a;
  const isDark = (_a = theme.sanity.v2) == null ? void 0 : _a.color._dark, addedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 800 : 100].hex, addedBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 300].hex, addedHoverBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedHoverBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex, addedNestedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedNesterBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  return css`
    box-sizing: border-box;
    transition:
      background-color 100ms ease,
      border-color 100ms ease;

    // Make sure that child elements appropriately blend with the
    // background of the highlight span
    * {
      mix-blend-mode: ${isDark ? "screen" : "multiply"};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='true'] {
      background-color: ${addedNestedBg};
      border-bottom: 2px solid ${addedNesterBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'][data-hovered='true'] {
      background-color: ${addedHoverBg};
      border-bottom: 2px solid ${addedHoverBorder};
    }

    &[data-inline-comment-state='authoring'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }
  `;
}), CommentInlineHighlightSpan = forwardRef(function(props, ref) {
  const { children, isAdded, isAuthoring, isHovered, isNested, ...rest } = props;
  return /* @__PURE__ */ jsx(
    HighlightSpan,
    {
      ...rest,
      "data-hovered": isHovered ? "true" : "false",
      "data-inline-comment-nested": isNested ? "true" : "false",
      "data-inline-comment-state": isAdded ? "added" : isAuthoring ? "authoring" : void 0,
      ref,
      children
    }
  );
}), PortableTextWrap = styled(Stack)(() => css`
    & > [data-ui='Text']:not(:first-child) {
      margin-top: 1em; // todo: improve
    }

    & > [data-ui='Text']:has(> span:empty) {
      display: none;
    }
  `), EMPTY_ARRAY$c = [], components = {
  block: {
    normal: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    h1: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    h2: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    h3: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    h4: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    h5: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    h6: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    blockquote: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    code: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children })
  },
  listItem: {
    bullet: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    number: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsx(NormalBlock, { children })
  },
  marks: {
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    strong: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    em: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    code: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    underline: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    strikeThrough: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children }),
    link: ({ children }) => /* @__PURE__ */ jsx(Fragment$1, { children })
  },
  types: {
    mention: (props) => {
      var _a;
      return /* @__PURE__ */ jsx(MentionInlineBlock, { userId: (_a = props == null ? void 0 : props.value) == null ? void 0 : _a.userId, selected: !1 });
    }
  }
};
function CommentMessageSerializer(props) {
  const { blocks } = props;
  return /* @__PURE__ */ jsx(PortableTextWrap, { children: /* @__PURE__ */ jsx(PortableText, { value: blocks || EMPTY_ARRAY$c, components }) });
}
const FLEX_GAP = 3, EmojiText = styled(Text)`
  font-family: 'Twemoji Mozilla', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif;
`, GRID_COLUMNS = 6;
function CommentReactionsMenu(props) {
  const { options, onSelect } = props, { t } = useTranslation(commentsLocaleNamespace), [focusableElements, setFocusableElements] = useState([]), [rootElement, setRootElement] = useState(null), [focusedIndex, setFocusedIndex] = useState(0), handleRootKeyDown = useCallback(
    (event) => {
      const focusableLen = focusableElements.length;
      event.key === "ArrowRight" && setFocusedIndex((prev) => (prev + 1) % focusableLen), event.key === "ArrowLeft" && setFocusedIndex((prev) => (prev - 1 + focusableLen) % focusableLen);
    },
    [focusableElements.length]
  ), handleOptionClick = useCallback(
    (event) => {
      const index = focusableElements.indexOf(event.currentTarget);
      setFocusedIndex(index), onSelect(options[index]);
    },
    [focusableElements, onSelect, options]
  );
  return useEffect(() => {
    if (rootElement) {
      const buttons = rootElement.querySelectorAll("button");
      setFocusableElements(Array.from(buttons));
    }
  }, [rootElement]), useEffect(() => {
    focusableElements.length > 0 && focusableElements[focusedIndex].focus();
  }, [focusableElements, focusedIndex]), /* @__PURE__ */ jsx(
    Grid,
    {
      columns: GRID_COLUMNS,
      gap: 1,
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      role: "menu",
      children: options.map((o) => {
        const emoji = COMMENT_REACTION_EMOJIS[o.shortName];
        return /* @__PURE__ */ jsx(
          Button$1,
          {
            "aria-label": t("reactions.react-with-aria-label", {
              reactionName: o.title || o.shortName
            }),
            mode: "bleed",
            onClick: handleOptionClick,
            padding: 2,
            role: "menuitem",
            tabIndex: -1,
            children: /* @__PURE__ */ jsx(EmojiText, { align: "center", size: 2, children: emoji })
          },
          o.shortName
        );
      })
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS$3 = ["top", "bottom"];
function CommentReactionsMenuButton(props) {
  const { onMenuClose, onMenuOpen, onSelect, options, readOnly, renderMenuButton: renderMenuButton2, mode } = props, [buttonElement, setButtonElement] = useState(null), [popoverElement, setPopoverElement] = useState(null), [open, setOpen] = useState(!1), { t } = useTranslation(commentsLocaleNamespace), handleClick = useCallback(() => {
    const next = !open;
    setOpen(next), next ? onMenuOpen == null || onMenuOpen() : onMenuClose == null || onMenuClose();
  }, [onMenuClose, onMenuOpen, open]), handleClose = useCallback(() => {
    open && (setOpen(!1), onMenuClose == null || onMenuClose(), buttonElement == null || buttonElement.focus());
  }, [buttonElement, onMenuClose, open]), handleClickOutside = useCallback(handleClose, [handleClose]), handleKeyDown = useCallback(
    (event) => {
      const { key, shiftKey } = event;
      (shiftKey && key === "Tab" || key === "Escape" || key === "Tab") && handleClose();
    },
    [handleClose]
  );
  useClickOutside(handleClickOutside, [popoverElement, buttonElement]);
  const handleSelect = useCallback(
    (option) => {
      onSelect(option), handleClose();
    },
    [handleClose, onSelect]
  ), button = useMemo(() => {
    const btn = renderMenuButton2({
      open,
      tooltipContent: t(mode === "upsell" ? "list-item.context-menu-add-reaction-upsell" : "list-item.context-menu-add-reaction"),
      t
    });
    return cloneElement(btn, {
      "aria-expanded": open,
      "aria-haspopup": "true",
      disabled: readOnly || mode === "upsell",
      id: "reactions-menu-button",
      onClick: handleClick,
      ref: setButtonElement
    });
  }, [handleClick, open, readOnly, renderMenuButton2, t, mode]);
  return /* @__PURE__ */ jsx(
    Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsx(
        Card,
        {
          "aria-labelledby": "reactions-menu-button",
          onKeyDown: handleKeyDown,
          padding: 1,
          radius: 3,
          tone: "default",
          children: /* @__PURE__ */ jsx(CommentReactionsMenu, { onSelect: handleSelect, options })
        }
      ),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$3,
      open,
      placement: "bottom",
      portal: !0,
      ref: setPopoverElement,
      tone: "default",
      children: button
    }
  );
}
const TEXT_SIZE = 1, ContentStack$1 = styled(Stack)`
  max-width: 180px;
`, TextGroup = styled.div`
  display: inline-block;
`, InlineText = styled(Text).attrs({ size: TEXT_SIZE })`
  display: inline-block !important;

  & > span {
    white-space: break-spaces;
  }
`, TextBox = styled(Box)`
  line-height: 1;
  text-align: center;
`, LEADING_NON_WHITESPACE_RE = /^\S+/;
function UserDisplayName(props) {
  const { currentUserId, isFirst, userId } = props, [user] = useUser(userId), { t } = useTranslation(commentsLocaleNamespace);
  return currentUserId === userId ? t("reactions.user-list.you", { context: isFirst ? "leading" : void 0, replace: { name: user == null ? void 0 : user.displayName } }) : (user == null ? void 0 : user.displayName) || t("reactions.user-list.unknown-user-fallback-name");
}
function CommentReactionsUsersTooltip(props) {
  const { children, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: /* @__PURE__ */ jsx(CommentReactionsUsersTooltipContent, { ...restProps }),
      placement: "bottom",
      portal: !0,
      children: /* @__PURE__ */ jsx("div", { children })
    }
  );
}
function FormattedUserList({ currentUserId, userIds }) {
  const listFormat = useListFormat({ style: "long", type: "conjunction" });
  if (userIds.length === 0)
    return null;
  const parts = listFormat.formatToParts(userIds), elements = [];
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    if (item.type === "literal") {
      elements.push(/* @__PURE__ */ jsx(InlineText, { children: item.value }, `literal-${i}`));
      continue;
    }
    const nextItem = parts[i + 1];
    if (nextItem && nextItem.type === "literal" && LEADING_NON_WHITESPACE_RE.test(nextItem.value)) {
      const [nonWhitespace = ""] = nextItem.value.match(LEADING_NON_WHITESPACE_RE) || [];
      elements.push(
        // Key (value) is user ID, thus unique
        /* @__PURE__ */ jsxs(TextGroup, { children: [
          /* @__PURE__ */ jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }),
          /* @__PURE__ */ jsx(InlineText, { children: nonWhitespace })
        ] }, item.value)
      ), nextItem.value = nextItem.value.slice(nonWhitespace.length);
      continue;
    }
    elements.push(
      // Key (value) is user ID, thus unique
      /* @__PURE__ */ jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }, item.value)
    );
  }
  return elements;
}
function CommentReactionsUsersTooltipContent(props) {
  const { currentUser, reactionName, userIds } = props, { t } = useTranslation(commentsLocaleNamespace), UserList = useCallback(() => currentUser ? /* @__PURE__ */ jsx(FormattedUserList, { currentUserId: currentUser.id, userIds }) : null, [currentUser, userIds]);
  return /* @__PURE__ */ jsxs(ContentStack$1, { padding: 1, children: [
    /* @__PURE__ */ jsx(Flex, { justify: "center", paddingBottom: 2, paddingTop: 1, children: /* @__PURE__ */ jsx(EmojiText, { size: 4, children: COMMENT_REACTION_EMOJIS[reactionName] }) }),
    /* @__PURE__ */ jsx(TextBox, { children: /* @__PURE__ */ jsx(
      Translate,
      {
        t,
        i18nKey: "reactions.users-reacted-with-reaction",
        values: { reactionName },
        components: {
          UserList,
          ReactionName: () => /* @__PURE__ */ jsx(InlineText, { muted: !0, children: reactionName }),
          Text: ({ children }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsx(InlineText, { muted: !0, children }),
            " ",
            /* @__PURE__ */ jsx("wbr", {}),
            " "
          ] })
        }
      }
    ) })
  ] });
}
const TransparentCard = styled(Card)`
  background: none;
`;
function groupReactionsByName(reactions) {
  const grouped = reactions.reduce(
    (acc, reaction) => {
      const { shortName } = reaction;
      return acc[shortName] || (acc[shortName] = []), acc[shortName].push(reaction), acc;
    },
    {}
  );
  return Object.entries(grouped).sort(([nameA], [nameB]) => {
    const indexA = reactions.findIndex((r) => r.shortName === nameA), indexB = reactions.findIndex((r) => r.shortName === nameB);
    return indexA - indexB;
  });
}
const renderMenuButton$1 = ({ open, tooltipContent }) => /* @__PURE__ */ jsx(Button$1, { fontSize: 1, mode: "ghost", padding: 0, radius: "full", selected: open, children: /* @__PURE__ */ jsx(Flex, { paddingX: 3, paddingY: 2, children: /* @__PURE__ */ jsx(Tooltip, { animate: !0, content: tooltipContent, disabled: open, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(ReactionIcon, {}) }) }) }) }), CommentReactionsBar = React__default.memo(function(props) {
  const { currentUser, onSelect, reactions, readOnly, mode } = props, handleSelect = useCallback(
    (name) => {
      const option = COMMENT_REACTION_OPTIONS.find((o) => o.shortName === name);
      option && onSelect(option);
    },
    [onSelect]
  ), currentUserReactionNames = useMemo(() => reactions.filter((r) => r.userId === (currentUser == null ? void 0 : currentUser.id)).map((r) => r.shortName), [currentUser == null ? void 0 : currentUser.id, reactions]), groupedReactions = useMemo(() => groupReactionsByName(reactions).filter(([name]) => COMMENT_REACTION_EMOJIS[name]), [reactions]), sortOrder = useRef(Object.keys(Object.fromEntries(groupedReactions))), sortedReactions = useMemo(() => {
    const sorted = groupedReactions.sort(([nameA], [nameB]) => {
      const indexA = sortOrder.current.indexOf(nameA), indexB = sortOrder.current.indexOf(nameB);
      return indexA === -1 ? 1 : indexB === -1 ? -1 : indexA - indexB;
    });
    return sortOrder.current = sorted.map(([name]) => name), sorted;
  }, [groupedReactions]);
  return /* @__PURE__ */ jsx(Flex, { align: "center", gap: 1, wrap: "wrap", children: /* @__PURE__ */ jsxs(TooltipDelayGroupProvider, { children: [
    sortedReactions.map(([name, reactionsList]) => {
      const hasReacted = currentUserReactionNames.includes(name), userIds = reactionsList.map((r) => r.userId), emoji = COMMENT_REACTION_EMOJIS[name];
      return /* @__PURE__ */ jsx(
        CommentReactionsUsersTooltip,
        {
          currentUser,
          reactionName: name,
          userIds,
          children: /* @__PURE__ */ jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsx(
            Button$1,
            {
              disabled: readOnly || mode === "upsell",
              mode: "ghost",
              onClick: () => handleSelect(name),
              padding: 2,
              radius: "full",
              selected: hasReacted,
              tone: hasReacted ? "primary" : "default",
              children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
                /* @__PURE__ */ jsx(EmojiText, { size: 1, children: emoji }),
                /* @__PURE__ */ jsx(Text, { size: 0, weight: hasReacted ? "semibold" : "medium", children: reactionsList == null ? void 0 : reactionsList.length })
              ] })
            }
          ) })
        },
        name
      );
    }),
    /* @__PURE__ */ jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onSelect: (o) => handleSelect(o.shortName),
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton: renderMenuButton$1
      }
    ) })
  ] }) });
}), renderMenuButton = ({
  open,
  tooltipContent,
  t
}) => /* @__PURE__ */ jsx(
  Button,
  {
    "aria-label": t("list-item.context-menu-add-reaction-aria-label"),
    icon: ReactionIcon,
    mode: "bleed",
    selected: open,
    tooltipProps: { content: tooltipContent }
  }
), POPOVER_PROPS = {
  placement: "bottom-end"
}, FloatingCard = styled(Card)`
  &:empty {
    display: none;
  }
`;
function CommentsListItemContextMenu(props) {
  const {
    canDelete,
    canEdit,
    isParent,
    mode,
    onCopyLink,
    onDeleteStart,
    onEditStart,
    onMenuClose,
    onMenuOpen,
    onReactionSelect,
    onStatusChange,
    readOnly,
    status
  } = props, showMenuButton = !!(onCopyLink || onDeleteStart || onEditStart), { t } = useTranslation(commentsLocaleNamespace), hasContextMenuOptions = !!(canDelete || canEdit || onCopyLink);
  return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(Flex, { children: /* @__PURE__ */ jsxs(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [
    onReactionSelect && /* @__PURE__ */ jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onMenuClose,
        onMenuOpen,
        onSelect: onReactionSelect,
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton
      }
    ),
    isParent && onStatusChange && /* @__PURE__ */ jsx(
      Button,
      {
        "aria-label": t(status === "open" ? "list-item.resolved-tooltip-aria-label" : "list-item.re-open-resolved-aria-label"),
        "data-testid": "comments-list-item-status-button",
        disabled: readOnly,
        icon: status === "open" ? CheckmarkCircleIcon : UndoIcon,
        mode: "bleed",
        onClick: onStatusChange,
        tooltipProps: {
          content: t(status === "open" ? "list-item.resolved-tooltip-content" : "list-item.re-open-resolved")
        }
      }
    ),
    hasContextMenuOptions && /* @__PURE__ */ jsx(
      MenuButton,
      {
        id: "comment-actions-menu",
        button: /* @__PURE__ */ jsx(
          ContextMenuButton,
          {
            "aria-label": t("list-item.open-menu-aria-label"),
            disabled: readOnly,
            hidden: !showMenuButton
          }
        ),
        onOpen: onMenuOpen,
        onClose: onMenuClose,
        menu: /* @__PURE__ */ jsxs(Menu, { children: [
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              hidden: !canEdit,
              icon: EditIcon,
              onClick: onEditStart,
              text: t("list-item.edit-comment"),
              tooltipProps: mode === "upsell" ? { content: t("list-item.edit-comment-upsell") } : void 0,
              disabled: mode === "upsell"
            }
          ),
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              hidden: !canDelete,
              icon: TrashIcon,
              onClick: onDeleteStart,
              text: t("list-item.delete-comment"),
              tone: "critical"
            }
          ),
          onCopyLink && /* @__PURE__ */ jsx(MenuDivider, { hidden: !canDelete && !canEdit }),
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              hidden: !onCopyLink,
              icon: LinkIcon,
              onClick: onCopyLink,
              text: t("list-item.copy-link")
            }
          )
        ] }),
        popover: POPOVER_PROPS
      }
    )
  ] }) }) });
}
function truncate(str, length = 250) {
  return str.length <= length ? str : `${str.slice(0, length)}...`;
}
const InlineBox = styled(Box).attrs({ marginLeft: 1, marginRight: 2 })`
  &:not([data-hidden]) {
    display: inline;
  }
`, BlockQuoteStack = styled(Stack)(({ theme, $hasReferencedValue }) => {
  var _a;
  const isDark = (_a = theme.sanity.v2) == null ? void 0 : _a.color._dark, hue = $hasReferencedValue ? COMMENTS_HIGHLIGHT_HUE_KEY : "gray", borderColor = isDark ? hues[hue][700].hex : hues[hue][300].hex;
  return css`
    border-left: 2px solid ${borderColor};
    word-break: break-word;
  `;
});
function CommentsListItemReferencedValue(props) {
  const { hasReferencedValue, value } = props, { t } = useTranslation$1(commentsLocaleNamespace), tooltipText = t("list-item.missing-referenced-value-tooltip-content"), resolvedValue = useMemo(() => {
    if (Array.isArray(value) && (value == null ? void 0 : value.filter(isPortableTextTextBlock$1).length) > 0) {
      const text = value == null ? void 0 : value.map(toPlainText).join(" ");
      return truncate(text);
    }
    return null;
  }, [value]);
  return resolvedValue ? /* @__PURE__ */ jsx(
    BlockQuoteStack,
    {
      $hasReferencedValue: !!hasReferencedValue,
      "data-testid": "comments-list-item-referenced-value",
      flex: 1,
      forwardedAs: "blockquote",
      padding: 1,
      paddingLeft: 2,
      sizing: "border",
      children: /* @__PURE__ */ jsx(Flex, { align: "flex-start", children: /* @__PURE__ */ jsxs(Text, { size: 1, muted: !0, children: [
        !hasReferencedValue && /* @__PURE__ */ jsx(Tooltip, { content: tooltipText, children: /* @__PURE__ */ jsx(InlineBox, { children: /* @__PURE__ */ jsx(LinkRemovedIcon, {}) }) }),
        resolvedValue
      ] }) })
    }
  ) : null;
}
const stopPropagation = (e) => e.stopPropagation(), ContextMenuBox = styled(Box)``, SKELETON_INLINE_STYLE = { width: "50%" }, EMPTY_ARRAY$b = [], TimeText = styled(Text)(({ theme }) => {
  const isDark = theme.sanity.color.dark, fg = hues.gray[isDark ? 200 : 800].hex;
  return css`
    min-width: max-content;
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), HeaderFlex$1 = styled(Flex)((props) => {
  var _a;
  const theme = getTheme_v2(props.theme);
  return css`
    min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
}), IntentText = styled(Text)(({ theme }) => {
  const isDark = theme.sanity.color.dark, fg = hues.gray[isDark ? 200 : 800].hex;
  return css`
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), InnerStack = styled(Stack)`
  transition: opacity 200ms ease;

  &[data-muted='true'] {
    transition: unset;
    opacity: 0.5;
  }
`, ErrorFlex = styled(Flex)((props) => {
  var _a;
  const theme = getTheme_v2(props.theme);
  return css`
    min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
}), RetryCardButton = styled(Card)`
  // Add not on hover
  &:not(:hover) {
    background-color: transparent;
  }
`, RootStack$1 = styled(Stack)(({ theme }) => {
  const { space } = theme.sanity;
  return css`
    position: relative;

    // Only show the floating layer on hover when hover is supported.
    // Else, the layer is always visible.
    @media (hover: hover) {
      ${ContextMenuBox} {
        opacity: 0;
        position: absolute;
        right: 0;
        top: 0;
        transform: translate(${space[1]}px, -${space[1]}px);
      }

      ${ContextMenuBox} {
        &:focus-within {
          opacity: 1;
        }
      }

      &:hover {
        ${ContextMenuBox} {
          opacity: 1;
        }
      }
    }

    &[data-menu-open='true'] {
      ${ContextMenuBox} {
        opacity: 1;
      }
    }
  `;
}), RELATIVE_TIME_OPTIONS$1 = { useTemporalPhrase: !0 };
function CommentsListItemLayout(props) {
  var _a;
  const {
    avatarSize = 1,
    canDelete,
    canEdit,
    comment,
    currentUser,
    hasError,
    hasReferencedValue,
    intent,
    isParent,
    isRetrying,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onInputKeyDown,
    onReactionSelect,
    onStatusChange,
    readOnly,
    withAvatar = !0
  } = props, { _createdAt, authorId, message, _id, lastEditedAt } = comment, [user] = useUser(authorId), { t } = useTranslation(commentsLocaleNamespace), [value, setValue] = useState(message), [isEditing, setIsEditing] = useState(!1), [rootElement, setRootElement] = useState(null), startMessage = useRef(message), [menuOpen, setMenuOpen] = useState(!1), commentInputRef = useRef(null), hasChanges = useCommentHasChanged(value), hasValue = useMemo(() => hasCommentMessageValue(value), [value]), reactions = useMemo(
    () => {
      var _a2;
      return (((_a2 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a2.filter((r) => (r == null ? void 0 : r._optimisticState) !== "removed")) || EMPTY_ARRAY$b).filter(
        (r) => "userId" in r && "shortName" in r
      );
    },
    [comment == null ? void 0 : comment.reactions]
  ), hasReactions = !!(reactions != null && reactions.length), createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date(), editedDate = lastEditedAt ? new Date(lastEditedAt) : null, createdTimeAgo = useRelativeTime(createdDate, RELATIVE_TIME_OPTIONS$1), dateTimeFormat = useDateTimeFormat({ dateStyle: "full", timeStyle: "medium" }), formattedCreatedAt = dateTimeFormat.format(createdDate), formattedLastEditAt = editedDate ? dateTimeFormat.format(editedDate) : null, displayError = hasError || isRetrying;
  useEffect(() => {
    isEditing || (startMessage.current = message, setValue(message));
  }, [isEditing, message]);
  const handleMenuOpen = useCallback(() => setMenuOpen(!0), []), handleMenuClose = useCallback(() => setMenuOpen(!1), []), handleCopyLink = useCallback(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]), handleCreateRetry = useCallback(
    (e) => {
      e.stopPropagation(), onCreateRetry == null || onCreateRetry(_id);
    },
    [_id, onCreateRetry]
  ), handleDelete = useCallback(() => onDelete(_id), [_id, onDelete]), cancelEdit = useCallback(() => {
    setIsEditing(!1), setValue(startMessage.current);
  }, []), startDiscard = useCallback(() => {
    var _a2;
    if (!hasValue || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue]), handleInputKeyDown = useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onInputKeyDown && onInputKeyDown(event));
    },
    [onInputKeyDown, startDiscard]
  ), cancelDiscard = useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close(), cancelEdit();
  }, [cancelEdit]), handleReactionSelect = useCallback(
    (reaction) => {
      onReactionSelect == null || onReactionSelect(_id, reaction);
    },
    [_id, onReactionSelect]
  ), handleEditSubmit = useCallback(() => {
    onEdit(_id, { message: value }), setIsEditing(!1);
  }, [_id, onEdit, value]), handleOpenStatusChange = useCallback(() => {
    onStatusChange == null || onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]), toggleEdit = useCallback(() => {
    setIsEditing((v) => !v);
  }, []), handleCloseMenu = useCallback(() => setMenuOpen(!1), []), handleClickOutside = useCallback(() => {
    hasChanges || cancelEdit();
  }, [cancelEdit, hasChanges]), handleRootKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && !hasChanges && cancelEdit();
    },
    [cancelEdit, hasChanges]
  );
  useDidUpdate(isEditing, handleCloseMenu), useClickOutside(handleClickOutside, [rootElement]);
  const name = user != null && user.displayName ? /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : /* @__PURE__ */ jsx(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return /* @__PURE__ */ jsxs(
    RootStack$1,
    {
      "data-menu-open": menuOpen ? "true" : "false",
      "data-testid": "comments-list-item-layout",
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      space: 4,
      children: [
        /* @__PURE__ */ jsxs(InnerStack, { space: 1, "data-muted": displayError, children: [
          /* @__PURE__ */ jsxs(HeaderFlex$1, { align: "center", gap: FLEX_GAP, flex: 1, $size: avatarSize, children: [
            withAvatar && /* @__PURE__ */ jsx(CommentsAvatar, { user, size: avatarSize }),
            /* @__PURE__ */ jsxs(Flex, { direction: "column", gap: 2, paddingY: intent ? 2 : 0, children: [
              /* @__PURE__ */ jsx(
                Flex,
                {
                  align: "center",
                  paddingBottom: (_a = comment.context) != null && _a.intent ? 0 : 1,
                  sizing: "border",
                  flex: 1,
                  children: /* @__PURE__ */ jsxs(Flex, { align: "flex-end", gap: 2, children: [
                    /* @__PURE__ */ jsx(Box, { flex: 1, children: name }),
                    !displayError && /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
                      /* @__PURE__ */ jsx(TimeText, { muted: !0, size: 0, children: /* @__PURE__ */ jsx("time", { dateTime: createdDate.toISOString(), title: formattedCreatedAt, children: createdTimeAgo }) }),
                      formattedLastEditAt && editedDate && /* @__PURE__ */ jsx(TimeText, { muted: !0, size: 0, title: formattedLastEditAt, children: /* @__PURE__ */ jsxs("time", { dateTime: editedDate.toISOString(), title: formattedLastEditAt, children: [
                        "(",
                        t("list-item.layout-edited"),
                        ")"
                      ] }) })
                    ] })
                  ] })
                }
              ),
              intent && /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(IntentText, { muted: !0, size: 0, textOverflow: "ellipsis", children: /* @__PURE__ */ jsx(
                Translate,
                {
                  t,
                  i18nKey: "list-item.layout-context",
                  values: { title: intent.title, intent: "edit" },
                  components: {
                    IntentLink: ({ children }) => intent ? /* @__PURE__ */ jsx(IntentLink, { params: intent.params, intent: intent.name, children }) : void 0
                  }
                }
              ) }) })
            ] }),
            !isEditing && !displayError && /* @__PURE__ */ jsx(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: stopPropagation, children: /* @__PURE__ */ jsx(
              CommentsListItemContextMenu,
              {
                canDelete,
                canEdit,
                isParent,
                mode,
                onCopyLink: onCopyLink ? handleCopyLink : void 0,
                onDeleteStart: handleDelete,
                onEditStart: toggleEdit,
                onMenuClose: handleMenuClose,
                onMenuOpen: handleMenuOpen,
                onReactionSelect: handleReactionSelect,
                onStatusChange: onStatusChange ? handleOpenStatusChange : void 0,
                readOnly,
                status: comment.status
              }
            ) })
          ] }),
          isTextSelectionComment(comment) && !!(comment != null && comment.contentSnapshot) && /* @__PURE__ */ jsxs(Flex, { gap: FLEX_GAP, marginBottom: 3, children: [
            withAvatar && /* @__PURE__ */ jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsx(
              CommentsListItemReferencedValue,
              {
                hasReferencedValue,
                value: comment == null ? void 0 : comment.contentSnapshot
              }
            )
          ] }),
          isEditing && /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 2, children: [
            withAvatar && /* @__PURE__ */ jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsx(Stack, { flex: 1, children: /* @__PURE__ */ jsx(
              CommentInput,
              {
                currentUser,
                focusOnMount: !0,
                mentionOptions,
                onChange: setValue,
                onDiscardCancel: cancelDiscard,
                onDiscardConfirm: confirmDiscard,
                onKeyDown: handleInputKeyDown,
                onSubmit: handleEditSubmit,
                readOnly,
                ref: commentInputRef,
                value,
                withAvatar: !1
              }
            ) })
          ] }),
          !isEditing && /* @__PURE__ */ jsxs(Flex, { gap: FLEX_GAP, children: [
            withAvatar && /* @__PURE__ */ jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsx(CommentMessageSerializer, { blocks: message })
          ] }),
          hasReactions && /* @__PURE__ */ jsxs(Flex, { gap: FLEX_GAP, marginTop: 2, children: [
            withAvatar && /* @__PURE__ */ jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsx(Box, { onClick: stopPropagation, children: /* @__PURE__ */ jsx(
              CommentReactionsBar,
              {
                currentUser,
                mode,
                onSelect: handleReactionSelect,
                reactions,
                readOnly
              }
            ) })
          ] })
        ] }),
        displayError && /* @__PURE__ */ jsxs(ErrorFlex, { gap: FLEX_GAP, $size: avatarSize, children: [
          withAvatar && /* @__PURE__ */ jsx(SpacerAvatar, { $size: avatarSize }),
          /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, flex: 1, children: [
            /* @__PURE__ */ jsxs(Text, { muted: !0, size: 1, children: [
              hasError && t("list-item.layout-failed-sent"),
              isRetrying && t("list-item.layout-posting")
            ] }),
            /* @__PURE__ */ jsx(Flex, { hidden: isRetrying, children: /* @__PURE__ */ jsx(
              RetryCardButton,
              {
                __unstable_focusRing: !0,
                display: "flex",
                forwardedAs: "button",
                onClick: handleCreateRetry,
                padding: 1,
                radius: 2,
                tone: "primary",
                children: /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("list-item.layout-retry") })
              }
            ) })
          ] })
        ] })
      ]
    }
  );
}
const ThreadCard = styled(Card).attrs({ padding: 3, radius: 3, sizing: "border" })(
  (props) => {
    const { theme } = props, isDark = theme.sanity.color.dark, activeBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 900 : 50].hex, defaultBg = hues.gray[isDark ? 900 : 50].hex;
    return css`
      background-color: ${defaultBg};

      &[data-active='true'] {
        background-color: ${activeBg};
      }
    `;
  }
), EMPTY_ARRAY$a = [], MAX_COLLAPSED_REPLIES = 5, DEFAULT_AVATAR_CONFIG = {
  avatarSize: 1,
  parentCommentAvatar: !0,
  replyAvatar: !0,
  threadCommentsAvatar: !0
}, StyledThreadCard = styled(ThreadCard)(() => css`
    position: relative;

    &:has(> [data-ui='GhostButton']:focus:focus-visible) {
      box-shadow:
        inset 0 0 0 1px var(--card-border-color),
        0 0 0 1px var(--card-bg-color),
        0 0 0 2px var(--card-focus-ring-color);
    }

    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class
    // since we want to show the hover styles when hovering over the menu items in the context menu as well.
    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over
    // the menu items.
    &:not([data-active='true']) {
      @media (hover: hover) {
        &[data-hovered='true'] {
          [data-root-menu='true'] {
            opacity: 1;
          }
        }
      }
    }
  `), ExpandButton = styled(Button)(({ theme }) => {
  const { medium } = theme.sanity.fonts.text.weights;
  return css`
    font-weight: ${medium};
  `;
}), GhostButton = styled.button`
  opacity: 0;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  left: 0;
`, CommentsListItem = React__default.memo(function(props) {
  var _a, _b, _c, _d, _e;
  const {
    avatarConfig = DEFAULT_AVATAR_CONFIG,
    canReply,
    currentUser,
    hasReferencedValue,
    innerPadding,
    isSelected,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onKeyDown,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    parentComment,
    readOnly,
    replies = EMPTY_ARRAY$a
  } = props, { t } = useTranslation(commentsLocaleNamespace), [value, setValue] = useState(EMPTY_ARRAY$a), [collapsed, setCollapsed] = useState(!0), didExpand = useRef(!1), replyInputRef = useRef(null), { isTopLayer } = useLayer(), hasValue = useMemo(() => hasCommentMessageValue(value), [value]), [mouseOver, setMouseOver] = useState(!1), handleMouseEnter = useCallback(() => setMouseOver(!0), []), handleMouseLeave = useCallback(() => setMouseOver(!1), []), handleReplySubmit = useCallback(() => {
    var _a2;
    const nextComment = {
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId,
      // A new comment will not have any reactions
      reactions: EMPTY_ARRAY$a,
      payload: {
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || ""
      }
    };
    onReply == null || onReply(nextComment), setValue(EMPTY_ARRAY$a);
  }, [
    onReply,
    parentComment._id,
    parentComment == null ? void 0 : parentComment.status,
    (_a = parentComment.target.path) == null ? void 0 : _a.field,
    parentComment.threadId,
    value
  ]), startDiscard = useCallback(() => {
    var _a2;
    if (!hasValue) {
      setValue(EMPTY_ARRAY$a);
      return;
    }
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.open();
  }, [hasValue]), handleInputKeyDown = useCallback(
    (event) => {
      event.isDefaultPrevented() || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), cancelDiscard = useCallback(() => {
    var _a2;
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = useCallback(() => {
    var _a2, _b2;
    setValue(EMPTY_ARRAY$a), (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close(), (_b2 = replyInputRef.current) == null || _b2.focus();
  }, []), handleThreadRootClick = useCallback(
    (e) => {
      var _a2;
      e.stopPropagation(), isTopLayer && (onPathSelect == null || onPathSelect({
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || "",
        origin: "inspector",
        threadId: parentComment.threadId
      }));
    },
    [isTopLayer, onPathSelect, (_b = parentComment.target.path) == null ? void 0 : _b.field, parentComment.threadId]
  ), handleExpand = useCallback((e) => {
    e.stopPropagation(), setCollapsed(!1), didExpand.current = !0;
  }, []), splicedReplies = useMemo(() => collapsed ? replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES) : replies, [replies, collapsed]), showCollapseButton = useMemo(() => replies ? replies.length > MAX_COLLAPSED_REPLIES : !1, [replies]), expandButtonText = useMemo(() => `${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES} more ${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments"}`, [replies == null ? void 0 : replies.length]);
  useEffect(() => {
    replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current && setCollapsed(!0);
  }, [replies]);
  const renderedReplies = useMemo(
    () => splicedReplies.map((reply) => {
      var _a2, _b2;
      return /* @__PURE__ */ jsx(Stack, { as: "li", ...applyCommentIdAttr(reply._id), children: /* @__PURE__ */ jsx(
        CommentsListItemLayout,
        {
          avatarSize: avatarConfig.avatarSize,
          canDelete: reply.authorId === currentUser.id,
          canEdit: reply.authorId === currentUser.id,
          comment: reply,
          currentUser,
          hasError: ((_a2 = reply._state) == null ? void 0 : _a2.type) === "createError",
          isRetrying: ((_b2 = reply._state) == null ? void 0 : _b2.type) === "createRetrying",
          intent: commentIntentIfDiffers(parentComment, reply),
          mentionOptions,
          mode,
          onCopyLink,
          onCreateRetry,
          onDelete,
          onEdit,
          onInputKeyDown: handleInputKeyDown,
          onReactionSelect,
          readOnly,
          withAvatar: avatarConfig.threadCommentsAvatar
        }
      ) }, reply._id);
    }),
    [
      avatarConfig.threadCommentsAvatar,
      avatarConfig.avatarSize,
      currentUser,
      handleInputKeyDown,
      mentionOptions,
      onCopyLink,
      onCreateRetry,
      onDelete,
      onEdit,
      onReactionSelect,
      parentComment,
      readOnly,
      splicedReplies,
      mode
    ]
  );
  return /* @__PURE__ */ jsxs(
    StyledThreadCard,
    {
      "data-active": isSelected ? "true" : "false",
      "data-hovered": mouseOver ? "true" : "false",
      "data-testid": "comments-list-item",
      onClick: handleThreadRootClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [
        /* @__PURE__ */ jsx(
          GhostButton,
          {
            "data-ui": "GhostButton",
            "aria-label": t("list-item.go-to-field-button.aria-label")
          }
        ),
        /* @__PURE__ */ jsxs(
          Stack,
          {
            as: "ul",
            padding: innerPadding,
            paddingBottom: canReply ? void 0 : 1,
            space: 4,
            children: [
              /* @__PURE__ */ jsx(Stack, { as: "li", ...applyCommentIdAttr(parentComment._id), children: /* @__PURE__ */ jsx(
                CommentsListItemLayout,
                {
                  avatarSize: avatarConfig.avatarSize,
                  canDelete: parentComment.authorId === currentUser.id,
                  canEdit: parentComment.authorId === currentUser.id,
                  comment: parentComment,
                  currentUser,
                  hasError: ((_c = parentComment._state) == null ? void 0 : _c.type) === "createError",
                  hasReferencedValue,
                  intent: (_d = parentComment.context) == null ? void 0 : _d.intent,
                  isParent: !0,
                  isRetrying: ((_e = parentComment._state) == null ? void 0 : _e.type) === "createRetrying",
                  mentionOptions,
                  mode,
                  onCopyLink,
                  onCreateRetry,
                  onDelete,
                  onEdit,
                  onInputKeyDown: onKeyDown,
                  onReactionSelect,
                  onStatusChange,
                  readOnly,
                  withAvatar: avatarConfig.parentCommentAvatar
                }
              ) }),
              showCollapseButton && !didExpand.current && /* @__PURE__ */ jsxs(Flex, { gap: 1, paddingY: 1, sizing: "border", children: [
                /* @__PURE__ */ jsx(SpacerAvatar, {}),
                /* @__PURE__ */ jsx(
                  ExpandButton,
                  {
                    iconRight: ChevronDownIcon,
                    mode: "bleed",
                    onClick: handleExpand,
                    text: expandButtonText
                  }
                )
              ] }),
              renderedReplies,
              canReply && /* @__PURE__ */ jsx(
                CommentInput,
                {
                  avatarSize: avatarConfig.avatarSize,
                  currentUser,
                  expandOnFocus: !0,
                  mentionOptions,
                  onChange: setValue,
                  onDiscardCancel: cancelDiscard,
                  onDiscardConfirm: confirmDiscard,
                  onKeyDown: handleInputKeyDown,
                  onSubmit: handleReplySubmit,
                  placeholder: t(mode === "upsell" ? "compose.reply-placeholder-upsell" : "compose.reply-placeholder"),
                  readOnly: readOnly || mode === "upsell",
                  ref: replyInputRef,
                  value,
                  withAvatar: avatarConfig.replyAvatar
                }
              )
            ]
          }
        )
      ]
    }
  );
});
function getEmptyStateMessages(t) {
  return {
    open: {
      title: t("list-status.empty-state-open-title"),
      message: t("list-status.empty-state-open-text")
    },
    resolved: {
      title: t("list-status.empty-state-resolved-title"),
      message: t("list-status.empty-state-resolved-text")
    }
  };
}
function CommentsListStatus(props) {
  const { status, error, loading, hasNoComments } = props, { t } = useTranslation(commentsLocaleNamespace), emptyStateMessages = getEmptyStateMessages(t);
  return error ? /* @__PURE__ */ jsx(Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: /* @__PURE__ */ jsx(Flex, { align: "center", children: /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("list-status.error") }) }) }) : loading ? /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: t("list-status.loading") }) : hasNoComments ? /* @__PURE__ */ jsx(Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: /* @__PURE__ */ jsx(Container, { width: 0, padding: 4, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsx(Text, { align: "center", size: 1, muted: !0, weight: "medium", children: emptyStateMessages[status].title }),
    /* @__PURE__ */ jsx(Text, { align: "center", size: 1, muted: !0, children: emptyStateMessages[status].message })
  ] }) }) }) : null;
}
function CreateNewThreadInput(props) {
  const {
    currentUser,
    fieldTitle,
    mentionOptions,
    mode,
    onBlur,
    onFocus,
    onKeyDown,
    onNewThreadCreate,
    readOnly
  } = props, { t } = useTranslation(commentsLocaleNamespace), [value, setValue] = useState(EMPTY_ARRAY$k), commentInputHandle = useRef(null), handleSubmit = useCallback(() => {
    onNewThreadCreate == null || onNewThreadCreate(value), setValue(EMPTY_ARRAY$k);
  }, [onNewThreadCreate, value]), hasValue = useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = useCallback(() => {
    var _a;
    hasValue && ((_a = commentInputHandle.current) == null || _a.discardDialogController.open());
  }, [hasValue]), handleInputKeyDown = useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onKeyDown && onKeyDown(event));
    },
    [onKeyDown, startDiscard]
  ), confirmDiscard = useCallback(() => {
    var _a, _b;
    setValue(EMPTY_ARRAY$k), (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), (_b = commentInputHandle.current) == null || _b.focus();
  }, []), cancelDiscard = useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), placeholder = mode === "upsell" ? t("compose.add-comment-input-placeholder-upsell") : /* @__PURE__ */ jsx(
    Translate,
    {
      t,
      i18nKey: "compose.add-comment-input-placeholder",
      values: { field: fieldTitle }
    }
  );
  return /* @__PURE__ */ jsx(
    CommentInput,
    {
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onBlur,
      onChange: setValue,
      onDiscardCancel: cancelDiscard,
      onDiscardConfirm: confirmDiscard,
      onKeyDown: handleInputKeyDown,
      onFocus,
      onSubmit: handleSubmit,
      placeholder,
      readOnly: readOnly || mode === "upsell",
      ref: commentInputHandle,
      value
    }
  );
}
const HeaderFlex = styled(Flex)`
  min-height: 25px;
`, BreadcrumbsButton = styled(Button$1)(({ theme }) => {
  const fg = theme.sanity.color.base.fg;
  return css`
    --card-fg-color: ${fg};

    // The width is needed to make the text ellipsis work
    // in the breadcrumbs component
    max-width: 100%;
  `;
});
function CommentThreadLayout(props) {
  const {
    breadcrumbs,
    canCreateNewThread,
    children,
    currentUser,
    fieldPath,
    isSelected,
    mentionOptions,
    mode,
    onNewThreadCreate,
    onPathSelect,
    readOnly
  } = props, { t } = useTranslation(commentsLocaleNamespace), handleNewThreadCreate = useCallback(
    (payload) => {
      const nextComment = {
        message: payload,
        parentCommentId: void 0,
        status: "open",
        // Since this is a new comment, we generate a new thread ID
        threadId: uuid(),
        // New comments have no reactions
        reactions: [],
        payload: {
          fieldPath
        }
      };
      onNewThreadCreate == null || onNewThreadCreate(nextComment);
    },
    [onNewThreadCreate, fieldPath]
  ), handleBreadcrumbsClick = useCallback(
    (e) => {
      e.stopPropagation(), onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      });
    },
    [fieldPath, onPathSelect]
  ), handleNewThreadClick = useCallback(
    (e) => {
      e.stopPropagation(), e.detail !== 0 && (onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      }));
    },
    [fieldPath, onPathSelect]
  ), crumbsTitlePath = useMemo(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]), lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
    /* @__PURE__ */ jsx(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: /* @__PURE__ */ jsx(Stack, { flex: 1, children: /* @__PURE__ */ jsx(Flex, { align: "center", children: /* @__PURE__ */ jsx(
      BreadcrumbsButton,
      {
        "aria-label": t("list-item.breadcrumb-button-go-to-field-aria-label", {
          field: lastCrumb
        }),
        mode: "bleed",
        onClick: handleBreadcrumbsClick,
        padding: 2,
        space: 2,
        children: /* @__PURE__ */ jsx(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath })
      }
    ) }) }) }),
    canCreateNewThread && /* @__PURE__ */ jsx(ThreadCard, { onClick: handleNewThreadClick, "data-active": isSelected, children: /* @__PURE__ */ jsx(
      CreateNewThreadInput,
      {
        currentUser,
        fieldTitle: lastCrumb,
        mentionOptions,
        mode,
        onNewThreadCreate: handleNewThreadCreate,
        readOnly
      }
    ) }),
    /* @__PURE__ */ jsx(Stack, { space: 2, children })
  ] });
}
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    return acc[field] || (acc[field] = []), acc[field].push(comment), acc;
  }, {});
}
const CommentsListInner = forwardRef(function(props, ref) {
  const {
    beforeListNode,
    comments: comments2,
    currentUser,
    error,
    loading,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onNewThreadCreate,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    readOnly,
    selectedPath,
    status
  } = props, [boundaryElement, setBoundaryElement] = useState(null), groupedThreads = useMemo(() => Object.entries(groupThreads(comments2)), [comments2]), showComments = !loading && !error && groupedThreads.length > 0;
  return /* @__PURE__ */ jsxs(
    Flex,
    {
      "data-testid": "comments-list",
      direction: "column",
      flex: 1,
      height: "fill",
      overflow: "hidden",
      ref: setBoundaryElement,
      sizing: "border",
      children: [
        mode !== "upsell" && /* @__PURE__ */ jsx(
          CommentsListStatus,
          {
            error,
            hasNoComments: groupedThreads.length === 0,
            loading,
            status
          }
        ),
        (showComments || beforeListNode) && /* @__PURE__ */ jsxs(
          Stack,
          {
            as: "ul",
            flex: 1,
            overflow: "auto",
            padding: 3,
            paddingTop: 1,
            paddingBottom: 6,
            sizing: "border",
            space: 1,
            ref,
            children: [
              beforeListNode,
              /* @__PURE__ */ jsx(BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map(([fieldPath, group]) => {
                const breadcrumbs = group[0].breadcrumbs, firstThreadId = group[0].threadId, newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
                return /* @__PURE__ */ jsx(
                  Stack,
                  {
                    as: "li",
                    paddingTop: 3,
                    ...applyCommentsGroupAttr(firstThreadId),
                    children: /* @__PURE__ */ jsx(
                      CommentThreadLayout,
                      {
                        breadcrumbs,
                        canCreateNewThread: status === "open",
                        currentUser,
                        fieldPath,
                        isSelected: newThreadSelected,
                        mentionOptions,
                        mode,
                        onNewThreadCreate,
                        onPathSelect,
                        readOnly,
                        children: group.map((item) => {
                          var _a, _b, _c;
                          const replies = item.replies.slice().reverse(), canReply = status === "open" && ((_a = item.parentComment._state) == null ? void 0 : _a.type) !== "createError" && ((_b = item.parentComment._state) == null ? void 0 : _b.type) !== "createRetrying", threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === ((_c = item.parentComment.target.path) == null ? void 0 : _c.field);
                          return /* @__PURE__ */ jsx(
                            CommentsListItem,
                            {
                              canReply,
                              currentUser,
                              hasReferencedValue: item.hasReferencedValue,
                              isSelected: threadIsSelected,
                              mentionOptions,
                              mode,
                              onCopyLink,
                              onCreateRetry,
                              onDelete,
                              onEdit,
                              onPathSelect,
                              onReactionSelect,
                              onReply,
                              onStatusChange,
                              parentComment: item.parentComment,
                              readOnly,
                              replies
                            },
                            item.parentComment._id
                          );
                        })
                      },
                      fieldPath
                    )
                  },
                  fieldPath
                );
              }) })
            ]
          }
        )
      ]
    }
  );
}), CommentsList = memo(CommentsListInner), Root$9 = styled(Box)`
  max-width: 280px;
`, fadeInKeyFrame = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`, StyledPopover = styled(Popover)`
  opacity: 0;
  // Fade in the popover after 500ms
  animation: ${fadeInKeyFrame} 200ms 500ms forwards;
`;
function CommentsOnboardingPopover(props) {
  const { onDismiss } = props, { t } = useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsx(
    StyledPopover,
    {
      content: /* @__PURE__ */ jsx(Root$9, { padding: 4, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
        /* @__PURE__ */ jsx(Text, { weight: "medium", size: 1, children: t("onboarding.header") }),
        /* @__PURE__ */ jsx(Text, { size: 1, children: t("onboarding.body") }),
        /* @__PURE__ */ jsx(Flex, { justify: "flex-end", marginTop: 2, children: /* @__PURE__ */ jsx(Button, { text: t("onboarding.dismiss"), tone: "primary", onClick: onDismiss }) })
      ] }) }),
      open: !0,
      portal: !0,
      ...props
    }
  );
}
const StyledButton$1 = styled(Button)(({ theme }) => {
  const { space } = getTheme_v2(theme);
  return `
      position: absolute;
      top: ${space[3]}px;
      right: ${space[3]}px;
      z-index: 20;
      background: transparent;
      border-radius: 9999px;
      box-shadow: none;
      color: ${white.hex};
      --card-fg-color: ${white.hex};
      :hover {
        --card-fg-color: ${white.hex};
      }
    `;
}), Image$1 = styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 200px;
`;
function CommentsUpsellDialog(props) {
  var _a, _b, _c;
  const { data, onClose, onPrimaryClick, onSecondaryClick } = props;
  return /* @__PURE__ */ jsxs(
    Dialog,
    {
      id: "comments-upsell",
      onClose,
      onClickOutside: onClose,
      __unstable_hideCloseButton: !0,
      bodyHeight: "fill",
      padding: !1,
      footer: {
        cancelButton: (_a = data.secondaryButton) != null && _a.text ? {
          text: data.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          iconRight: LaunchIcon,
          ...data.secondaryButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.secondaryButton.url
          },
          onClick: onSecondaryClick
        } : void 0,
        confirmButton: {
          text: (_b = data.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...data.ctaButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.ctaButton.url
          },
          onClick: onPrimaryClick
        }
      },
      children: [
        /* @__PURE__ */ jsx(
          StyledButton$1,
          {
            icon: CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: onClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        data.image && /* @__PURE__ */ jsx(Image$1, { src: data.image.asset.url, alt: (_c = data.image.asset.altText) != null ? _c : "" }),
        /* @__PURE__ */ jsx(Box, { padding: 3, marginTop: 2, children: /* @__PURE__ */ jsx(Stack, { space: 4, paddingBottom: 2, children: /* @__PURE__ */ jsx(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }) })
      ]
    }
  );
}
const Image = styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
`;
function CommentsUpsellPanel(props) {
  var _a;
  const { data, onPrimaryClick, onSecondaryClick } = props;
  return /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsx(Box, { marginBottom: 6, children: /* @__PURE__ */ jsxs(Card, { radius: 3, overflow: "hidden", border: !0, children: [
    data.image && /* @__PURE__ */ jsx(Image, { src: data.image.asset.url, alt: (_a = data.image.asset.altText) != null ? _a : "" }),
    /* @__PURE__ */ jsxs(Box, { padding: 3, marginTop: 2, children: [
      /* @__PURE__ */ jsx(Stack, { space: 4, children: /* @__PURE__ */ jsx(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }),
      /* @__PURE__ */ jsxs(Flex, { gap: 2, justify: "flex-end", marginTop: 5, children: [
        /* @__PURE__ */ jsx(
          Button,
          {
            mode: "bleed",
            text: data.secondaryButton.text,
            tone: "primary",
            iconRight: LaunchIcon,
            ...data.secondaryButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.secondaryButton.url
            },
            onClick: onSecondaryClick
          }
        ),
        /* @__PURE__ */ jsx(
          Button,
          {
            text: data.ctaButton.text,
            tone: "primary",
            ...data.ctaButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.ctaButton.url
            },
            onClick: onPrimaryClick
          }
        )
      ] })
    ] })
  ] }) }) });
}
function CommentsDocumentLayout(props) {
  const { documentId, documentType } = props;
  return /* @__PURE__ */ jsx(CommentsEnabledProvider, { documentId, documentType, children: /* @__PURE__ */ jsx(CommentsDocumentLayoutInner, { ...props }) });
}
function CommentsDocumentLayoutInner(props) {
  const { documentId, documentType } = props, commentsEnabled = useCommentsEnabled(), { openInspector, inspector } = useDocumentPane(), handleOpenCommentsInspector = useCallback(() => {
    (inspector == null ? void 0 : inspector.name) !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  return commentsEnabled.enabled ? /* @__PURE__ */ jsx(
    CommentsProvider,
    {
      documentId,
      documentType,
      isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME,
      onCommentsOpen: handleOpenCommentsInspector,
      sortOrder: "desc",
      type: "field",
      children: /* @__PURE__ */ jsx(CommentsSelectedPathProvider, { children: /* @__PURE__ */ jsx(CommentsAuthoringPathProvider, { children: props.renderDefault(props) }) })
    }
  ) : props.renderDefault(props);
}
const ContentStack = styled(Stack)`
  width: 320px;
`;
function CommentsFieldButton(props) {
  const {
    count,
    currentUser,
    fieldTitle,
    isCreatingDataset,
    mentionOptions,
    onChange,
    onClick,
    onClose,
    onCommentAdd,
    onDiscard,
    onInputKeyDown,
    open,
    value
  } = props, { t } = useTranslation(commentsLocaleNamespace), [popoverElement, setPopoverElement] = useState(null), [addCommentButtonElement, setAddCommentButtonElement] = useState(
    null
  ), commentInputHandle = useRef(null), hasComments = count > 0, closePopover = useCallback(() => {
    open && (onClose(), addCommentButtonElement == null || addCommentButtonElement.focus());
  }, [addCommentButtonElement, open, onClose]), handleSubmit = useCallback(() => {
    onCommentAdd(), closePopover();
  }, [closePopover, onCommentAdd]), hasValue = useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = useCallback(() => {
    var _a;
    if (!hasValue) {
      closePopover();
      return;
    }
    (_a = commentInputHandle.current) == null || _a.discardDialogController.open();
  }, [closePopover, hasValue]), handleInputKeyDown = useCallback(
    (event) => {
      event.isDefaultPrevented() || onInputKeyDown && onInputKeyDown(event);
    },
    [onInputKeyDown]
  ), handleDiscardCancel = useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), closePopover(), onDiscard();
  }, [closePopover, onDiscard]), handlePopoverKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), handleClickOutside = useCallback(() => {
    open && startDiscard();
  }, [open, startDiscard]);
  return useClickOutside(handleClickOutside, [popoverElement]), hasComments ? /* @__PURE__ */ jsx(Tooltip, { portal: !0, placement: "top", content: t("field-button.content", { count }), children: /* @__PURE__ */ jsx(
    Button$1,
    {
      "aria-label": t("field-button.aria-label-open"),
      mode: "bleed",
      onClick,
      padding: 2,
      space: 2,
      children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(CommentIcon, {}) }),
        /* @__PURE__ */ jsx(Text, { size: 0, children: count > 9 ? "9+" : count })
      ] })
    }
  ) }) : /* @__PURE__ */ jsx(
    Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsx(ContentStack, { padding: 2, space: 4, children: /* @__PURE__ */ jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onKeyDown: handleInputKeyDown,
          onSubmit: handleSubmit,
          placeholder: /* @__PURE__ */ jsx(
            Translate,
            {
              t,
              i18nKey: "compose.add-comment-input-placeholder",
              values: { field: fieldTitle }
            }
          ),
          readOnly: isCreatingDataset,
          ref: commentInputHandle,
          value
        }
      ) }),
      fallbackPlacements: ["bottom-end"],
      open,
      placement: "right-start",
      portal: !0,
      ref: setPopoverElement,
      onKeyDown: handlePopoverKeyDown,
      children: /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": t("field-button.aria-label-add"),
          disabled: isCreatingDataset,
          icon: AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setAddCommentButtonElement,
          selected: open,
          tooltipProps: {
            content: t("field-button.title"),
            placement: "top"
          }
        }
      ) })
    }
  );
}
const messageCache = /* @__PURE__ */ new Map(), EMPTY_ARRAY$9 = [], HIGHLIGHT_BLOCK_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
};
function CommentsField(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsx(CommentFieldInner, { ...props, mode }) : props.renderDefault(props);
}
const HighlightDiv = styled(motion.div)(({ theme }) => {
  const { radius, space, color } = theme.sanity, bg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][color.dark ? 900 : 50].hex;
  return css`
    mix-blend-mode: ${color.dark ? "screen" : "multiply"};
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    left: -${space[2]}px;
    bottom: -${space[2]}px;
    right: -${space[2]}px;
    pointer-events: none;
    position: absolute;
    z-index: 1;
    width: calc(100% + ${space[2] * 2}px);
    height: calc(100% + ${space[2] * 2}px);
    background-color: ${bg};
  `;
}), FieldStack = styled(Stack)`
  position: relative;
`;
function CommentFieldInner(props) {
  const { mode } = props, currentUser = useCurrentUser(), { element: boundaryElement } = useBoundaryElement(), rootRef = useRef(null), {
    comments: comments2,
    isCommentsOpen,
    isCreatingDataset,
    mentionOptions,
    onCommentsOpen,
    operation,
    setStatus,
    status
  } = useComments(), { upsellData, handleOpenDialog } = useCommentsUpsell(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { authoringPath, setAuthoringPath } = useCommentsAuthoringPath(), { scrollToGroup } = useCommentsScroll({
    boundaryElement
  }), fieldTitle = useMemo(() => getSchemaTypeTitle(props.schemaType), [props.schemaType]), stringPath = useMemo(() => PathUtils.toString(props.path), [props.path]), cachedValue = messageCache.get(stringPath) || null, [value, setValue] = useState(cachedValue), isOpen = useMemo(() => authoringPath === stringPath, [authoringPath, stringPath]), isSelected = useMemo(() => !isCommentsOpen || (selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url" ? !1 : (selectedPath == null ? void 0 : selectedPath.fieldPath) === stringPath, [isCommentsOpen, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin, stringPath]), isInlineCommentThread = useMemo(() => comments2.data.open.filter((c) => c.threadId === (selectedPath == null ? void 0 : selectedPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)), [comments2.data.open, selectedPath == null ? void 0 : selectedPath.threadId]), count = useMemo(() => comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0) || 0, [comments2.data.open, stringPath]), hasComments = count > 0, resetMessageValue = useCallback(() => {
    setValue(null), messageCache.delete(stringPath);
  }, [stringPath]), handleClick = useCallback(() => {
    var _a;
    if (hasComments) {
      status === "resolved" && setStatus("open"), setAuthoringPath(null), onCommentsOpen == null || onCommentsOpen();
      const scrollToThreadId = (_a = comments2.data.open.find(
        (c) => c.fieldPath === PathUtils.toString(props.path)
      )) == null ? void 0 : _a.threadId;
      scrollToThreadId && (setSelectedPath({
        threadId: scrollToThreadId,
        origin: "form",
        fieldPath: PathUtils.toString(props.path)
      }), scrollToGroup(scrollToThreadId));
      return;
    }
    if (mode === "upsell") {
      upsellData ? handleOpenDialog("field_action") : onCommentsOpen == null || onCommentsOpen();
      return;
    }
    setAuthoringPath(isOpen ? null : stringPath);
  }, [
    comments2.data.open,
    handleOpenDialog,
    hasComments,
    isOpen,
    mode,
    onCommentsOpen,
    props.path,
    scrollToGroup,
    setAuthoringPath,
    setSelectedPath,
    setStatus,
    status,
    stringPath,
    upsellData
  ]), handleCommentAdd = useCallback(() => {
    if (value) {
      const newThreadId = uuid(), nextComment = {
        type: "field",
        fieldPath: PathUtils.toString(props.path),
        message: value,
        parentCommentId: void 0,
        status: "open",
        threadId: newThreadId,
        // New comments have no reactions
        reactions: EMPTY_ARRAY$9
      };
      operation.create(nextComment), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), resetMessageValue(), setSelectedPath({
        threadId: newThreadId,
        origin: "form",
        fieldPath: PathUtils.toString(props.path)
      }), scrollToGroup(newThreadId);
    }
  }, [
    onCommentsOpen,
    operation,
    props.path,
    resetMessageValue,
    scrollToGroup,
    setSelectedPath,
    setStatus,
    status,
    value
  ]), handleClose = useCallback(() => setAuthoringPath(null), [setAuthoringPath]), handleOnChange = useCallback(
    (nextValue) => {
      setValue(nextValue), messageCache.set(stringPath, nextValue);
    },
    [stringPath]
  ), internalComments = useMemo(
    () => ({
      button: currentUser && /* @__PURE__ */ jsx(
        CommentsFieldButton,
        {
          count: Number(count),
          currentUser,
          fieldTitle,
          isCreatingDataset,
          mentionOptions,
          onChange: handleOnChange,
          onClick: handleClick,
          onClose: handleClose,
          onCommentAdd: handleCommentAdd,
          onDiscard: resetMessageValue,
          open: isOpen,
          value
        }
      ),
      hasComments,
      isAddingComment: isOpen
    }),
    [
      currentUser,
      count,
      fieldTitle,
      isCreatingDataset,
      mentionOptions,
      handleOnChange,
      handleClick,
      handleClose,
      handleCommentAdd,
      resetMessageValue,
      isOpen,
      value,
      hasComments
    ]
  );
  return /* @__PURE__ */ jsxs(FieldStack, { ...applyCommentsFieldAttr(PathUtils.toString(props.path)), ref: rootRef, children: [
    props.renderDefault({
      ...props,
      // eslint-disable-next-line camelcase
      __internal_comments: internalComments
    }),
    /* @__PURE__ */ jsx(AnimatePresence, { children: isSelected && !isInlineCommentThread && /* @__PURE__ */ jsx(
      HighlightDiv,
      {
        animate: "animate",
        exit: "exit",
        initial: "initial",
        variants: HIGHLIGHT_BLOCK_VARIANTS
      }
    ) })
  ] });
}
function createDomRectFromElements(elements) {
  if (!elements || !elements.length)
    return null;
  const rects = elements.map((el) => el.getBoundingClientRect()), minX = Math.min(...rects.map((r) => r.x)) || 0, minY = Math.min(...rects.map((r) => r.y)) || 0, maxRight = Math.max(...rects.map((r) => r.right)) || 0, maxBottom = Math.max(...rects.map((r) => r.bottom)) || 0;
  return {
    x: minX,
    y: minY,
    width: maxRight - minX,
    height: maxBottom - minY,
    top: minY,
    right: maxRight,
    bottom: maxBottom,
    left: minX
  };
}
function useRectFromElements(props) {
  const { scrollElement, disabled, selector } = props, [rect, setRect] = useState(null), handleSetRect = useCallback(() => {
    const elements = document == null ? void 0 : document.querySelectorAll(selector);
    if (!elements)
      return;
    const nextRect = createDomRectFromElements(Array.from(elements));
    setRect(nextRect);
  }, [selector]);
  return useEffect(() => {
    if (disabled)
      return;
    const timeout = setTimeout(() => {
      handleSetRect();
    }, 1);
    return () => {
      clearTimeout(timeout);
    };
  }, [handleSetRect, disabled]), useEffect(() => {
    if (!(disabled || !scrollElement))
      return scrollElement.addEventListener("wheel", handleSetRect), () => {
        scrollElement.removeEventListener("wheel", handleSetRect);
      };
  }, [handleSetRect, disabled, scrollElement]), rect;
}
function useAuthoringReferenceElement(props) {
  const { scrollElement, disabled, selector } = props, rect = useRectFromElements({
    scrollElement,
    disabled,
    selector
  });
  return useMemo(() => rect ? {
    getBoundingClientRect: () => rect
  } : null, [rect]);
}
function getSelectionBoundingRect() {
  const selection = window.getSelection(), range = selection == null ? void 0 : selection.getRangeAt(0);
  return (range == null ? void 0 : range.getBoundingClientRect()) || null;
}
const MotionPopover$1 = styled(motion(Popover))`
  user-select: none;
`, POPOVER_FALLBACK_PLACEMENTS$2 = ["bottom", "top"], VARIANTS$4 = {
  hidden: { opacity: 0, y: -4 },
  visible: { opacity: 1, y: 0 }
};
function FloatingButtonPopover(props) {
  const { disabled, onClick, onClickOutside, referenceElement } = props, [popoverElement, setPopoverElement] = useState(null), { t } = useTranslation$1(commentsLocaleNamespace);
  useClickOutside(onClickOutside, [popoverElement]);
  const disabledText = t("inline-add-comment-button.disabled-overlap-title"), enabledText = t("inline-add-comment-button.title");
  return /* @__PURE__ */ jsx(
    MotionPopover$1,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsx(
        Button,
        {
          "data-testid": "inline-comment-button",
          disabled,
          icon: disabled ? CommentDisabledIcon : AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setPopoverElement,
          text: disabled ? disabledText : enabledText
        }
      ),
      contentEditable: !1,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2,
      initial: "hidden",
      open: !0,
      padding: 1,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$4
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"], MotionPopover = motion(Popover), RootStack = styled(Stack)`
  width: 250px;
`, VARIANTS$3 = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};
function InlineCommentInputPopover(props) {
  const {
    currentUser,
    mentionOptions,
    onChange,
    onClickOutside,
    onDiscardConfirm,
    onSubmit,
    referenceElement,
    value
  } = props, commentInputRef = useRef(null), [contentElement, setContentElement] = useState(null), handleDiscardConfirm = useCallback(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close(), onDiscardConfirm();
  }, [onDiscardConfirm]), handleDiscardCancel = useCallback(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close();
  }, []), handleClickOutside = useCallback(() => {
    var _a;
    if (hasCommentMessageValue(value)) {
      (_a = commentInputRef.current) == null || _a.discardDialogController.open();
      return;
    }
    onClickOutside();
  }, [onClickOutside, value]);
  return useClickOutside(handleClickOutside, [contentElement]), /* @__PURE__ */ jsx(
    MotionPopover,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsx(RootStack, { padding: 2, ref: setContentElement, children: /* @__PURE__ */ jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onSubmit,
          ref: commentInputRef,
          value
        }
      ) }),
      "data-ui": "InlineCommentInputPopover",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1,
      initial: "hidden",
      open: !0,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$3
    }
  );
}
const EMPTY_ARRAY$8 = [], AI_ASSIST_TYPE = "sanity.assist.instruction.prompt";
function CommentsPortableTextInput(props) {
  const { enabled, mode } = useCommentsEnabled(), isAiAssist = props.schemaType.name === AI_ASSIST_TYPE;
  return !enabled || isAiAssist ? props.renderDefault(props) : /* @__PURE__ */ jsx(CommentsPortableTextInputInner, { ...props, mode });
}
const CommentsPortableTextInputInner = React__default.memo(function(props) {
  var _a, _b;
  const { mode } = props, currentUser = useCurrentUser(), portal = usePortal(), { comments: comments2, getComment, mentionOptions, onCommentsOpen, operation, setStatus, status } = useComments(), { setSelectedPath, selectedPath } = useCommentsSelectedPath(), { scrollToComment, scrollToGroup } = useCommentsScroll(), { handleOpenDialog } = useCommentsUpsell(), editorRef = useRef(null), mouseDownRef = useRef(!1), [nextCommentValue, setNextCommentValue] = useState(null), [nextCommentSelection, setNextCommentSelection] = useState(null), [currentSelection, setCurrentSelection] = useState(null), [currentSelectionRect, setCurrenSelectionRect] = useState(null), [currentHoveredCommentId, setCurrentHoveredCommentId] = useState(null), [canSubmit, setCanSubmit] = useState(!1), [rootElement, setRootElement] = useState(null), [isFullScreen, setIsFullScreen] = useState(!1), [addedCommentsDecorations, setAddedCommentsDecorations] = useState(EMPTY_ARRAY$8), stringFieldPath = useMemo(() => PathUtils.toString(props.path), [props.path]), handleSetCurrentSelectionRect = useCallback(() => {
    const rect = getSelectionBoundingRect();
    setCurrenSelectionRect(rect);
  }, []), resetStates = useCallback(() => {
    setCurrentSelection(null), setCurrenSelectionRect(null), setNextCommentSelection(null), setNextCommentValue(null), setCanSubmit(!1);
  }, []), handleSelectCurrentSelection = useCallback(() => {
    if (mode === "upsell") {
      handleOpenDialog("pte");
      return;
    }
    setNextCommentSelection(currentSelection);
  }, [currentSelection, handleOpenDialog, mode]), handleCommentDiscardConfirm = useCallback(() => {
    resetStates();
  }, [resetStates]), textComments = useMemo(() => comments2.data.open.filter((comment) => comment.fieldPath === stringFieldPath).filter((c) => isTextSelectionComment(c.parentComment)).map((c) => c.parentComment), [comments2.data.open, stringFieldPath]), getFragment = useCallback(() => editorRef.current ? PortableTextEditor.getFragment(editorRef.current) : EMPTY_ARRAY$8, []), handleSubmit = useCallback(() => {
    if (!nextCommentSelection || !editorRef.current)
      return;
    const fragment = getFragment() || EMPTY_ARRAY$8, editorValue = PortableTextEditor.getValue(editorRef.current);
    if (!editorValue)
      return;
    const textSelection = buildTextSelectionFromFragment({
      fragment,
      selection: nextCommentSelection,
      value: editorValue
    }), threadId = uuid();
    operation.create({
      type: "field",
      contentSnapshot: fragment,
      fieldPath: stringFieldPath,
      message: nextCommentValue,
      parentCommentId: void 0,
      reactions: EMPTY_ARRAY$8,
      selection: textSelection,
      status: "open",
      threadId
    }), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), setSelectedPath({
      fieldPath: stringFieldPath,
      threadId,
      origin: "form"
    }), scrollToGroup(threadId), resetStates();
  }, [
    nextCommentSelection,
    getFragment,
    operation,
    stringFieldPath,
    nextCommentValue,
    onCommentsOpen,
    status,
    setSelectedPath,
    scrollToGroup,
    resetStates,
    setStatus
  ]), handleDecoratorClick = useCallback(
    (commentId) => {
      var _a2;
      const comment = getComment(commentId);
      comment && (setSelectedPath({
        fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || "",
        threadId: comment.threadId,
        origin: "form"
      }), onCommentsOpen == null || onCommentsOpen(), scrollToComment(comment._id));
    },
    [getComment, onCommentsOpen, scrollToComment, setSelectedPath]
  ), handleSelectionChange = useCallback(
    (selection) => {
      const isRangeSelected = (selection == null ? void 0 : selection.anchor.offset) !== (selection == null ? void 0 : selection.focus.offset), fragment = getFragment();
      if (!(fragment != null && fragment.every(isPortableTextTextBlock)) || !isRangeSelected) {
        setCanSubmit(!1);
        return;
      }
      mouseDownRef.current || handleSetCurrentSelectionRect(), setCurrentSelection(selection), setCanSubmit(!0);
    },
    [getFragment, handleSetCurrentSelectionRect]
  ), debounceSelectionChange = useMemo(
    () => debounce(handleSelectionChange, 200),
    [handleSelectionChange]
  ), handleMouseDown = useCallback(() => {
    mouseDownRef.current = !0;
  }, []), handleMouseUp = useCallback(() => {
    mouseDownRef.current = !1, handleSetCurrentSelectionRect();
  }, [handleSetCurrentSelectionRect]), handleRangeDecorationMoved = useCallback((details) => {
    var _a2;
    const { rangeDecoration, newSelection } = details, commentId = (_a2 = rangeDecoration.payload) == null ? void 0 : _a2.commentId;
    setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a3;
      return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === commentId ? {
        ...rangeDecoration,
        selection: newSelection,
        payload: { ...rangeDecoration.payload, dirty: !0 }
      } : p;
    }));
  }, []), updateCommentRange = useCallback(() => {
    const decoratorsToUpdate = addedCommentsDecorations.filter(
      (decorator) => {
        var _a2;
        return (_a2 = decorator.payload) == null ? void 0 : _a2.dirty;
      }
    );
    decoratorsToUpdate.length !== 0 && (decoratorsToUpdate.forEach((decorator) => {
      var _a2, _b2, _c, _d, _e;
      const commentId = (_a2 = decorator.payload) == null ? void 0 : _a2.commentId, comment = getComment(commentId || "");
      if (!comment || !editorRef.current)
        return;
      const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8, [updatedDecoration] = buildRangeDecorationSelectionsFromComments({
        comments: [comment],
        value: editorValue
      }), nextRange = updatedDecoration != null && updatedDecoration.range ? [updatedDecoration.range] : EMPTY_ARRAY$8, nextValue = updatedDecoration ? [
        ...((_c = (_b2 = comment.target.path) == null ? void 0 : _b2.selection) == null ? void 0 : _c.value.filter((r) => {
          var _a3;
          return r._key !== ((_a3 = nextRange[0]) == null ? void 0 : _a3._key);
        }).concat(nextRange).flat()) || EMPTY_ARRAY$8
      ] : EMPTY_ARRAY$8, nextComment = {
        target: {
          ...comment.target,
          path: {
            ...((_d = comment.target) == null ? void 0 : _d.path) || {},
            field: ((_e = comment.target.path) == null ? void 0 : _e.field) || "",
            selection: {
              type: "text",
              value: nextValue
            }
          }
        }
      };
      operation.update(comment._id, nextComment);
    }), setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a2, _b2;
      return (_b2 = (_a2 = decoratorsToUpdate.find(
        (d) => {
          var _a3, _b3;
          return ((_a3 = d.payload) == null ? void 0 : _a3.commentId) === ((_b3 = p.payload) == null ? void 0 : _b3.commentId);
        }
      )) == null ? void 0 : _a2.payload) != null && _b2.dirty ? {
        ...p,
        payload: { ...p.payload, dirty: !1 }
      } : p;
    }).filter((p) => p.selection !== null)));
  }, [addedCommentsDecorations, getComment, operation]), handleBuildRangeDecorations = useCallback(
    (commentsToDecorate) => {
      if (!editorRef.current)
        return EMPTY_ARRAY$8;
      const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8;
      return buildRangeDecorations({
        comments: commentsToDecorate,
        currentHoveredCommentId,
        onDecorationClick: handleDecoratorClick,
        onDecorationHoverEnd: setCurrentHoveredCommentId,
        onDecorationHoverStart: setCurrentHoveredCommentId,
        onDecorationMoved: handleRangeDecorationMoved,
        selectedThreadId: (selectedPath == null ? void 0 : selectedPath.threadId) || null,
        value: editorValue
      });
    },
    [
      currentHoveredCommentId,
      handleDecoratorClick,
      handleRangeDecorationMoved,
      selectedPath == null ? void 0 : selectedPath.threadId
    ]
  ), onEditorChange = useCallback(
    (change) => {
      change.type === "mutation" && updateCommentRange(), change.type === "selection" && debounceSelectionChange(change.selection);
    },
    [debounceSelectionChange, updateCommentRange]
  ), authoringDecoration = useMemo(() => nextCommentSelection ? {
    component: ({ children }) => /* @__PURE__ */ jsx(CommentInlineHighlightSpan, { isAuthoring: !0, children }),
    selection: nextCommentSelection
  } : null, [nextCommentSelection]), rangeDecorations = useMemo(() => [
    // Existing range decorations
    ...(props == null ? void 0 : props.rangeDecorations) || EMPTY_ARRAY$8,
    // The range decoration when adding a comment
    ...authoringDecoration ? [authoringDecoration] : EMPTY_ARRAY$8,
    // The range decorations for existing comments
    ...addedCommentsDecorations
  ], [addedCommentsDecorations, authoringDecoration, props == null ? void 0 : props.rangeDecorations]), currentSelectionIsOverlapping = useMemo(() => !currentSelection || addedCommentsDecorations.length === 0 ? !1 : addedCommentsDecorations.some((d) => {
    if (!editorRef.current)
      return !1;
    const testA = PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      currentSelection,
      d.selection
    ), testB = PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      d.selection,
      currentSelection
    );
    return testA || testB;
  }), [addedCommentsDecorations, currentSelection]), scrollElement = isFullScreen ? document.body : ((_a = portal.elements) == null ? void 0 : _a.documentScrollElement) || document.body, boundaryElement = isFullScreen ? ((_b = portal.elements) == null ? void 0 : _b.documentScrollElement) || document.body : rootElement, popoverAuthoringReferenceElement = useAuthoringReferenceElement({
    scrollElement,
    disabled: !nextCommentSelection,
    selector: '[data-inline-comment-state="authoring"]'
  }), selectionReferenceElement = useMemo(() => currentSelectionRect ? {
    getBoundingClientRect: () => currentSelectionRect
  } : null, [currentSelectionRect]);
  useEffect(() => {
    if (currentSelection)
      return scrollElement == null || scrollElement.addEventListener("wheel", handleSetCurrentSelectionRect), () => {
        scrollElement == null || scrollElement.removeEventListener("wheel", handleSetCurrentSelectionRect);
      };
  }, [currentSelection, scrollElement, handleSetCurrentSelectionRect]), useEffect(() => {
    const nextDecorations = handleBuildRangeDecorations(textComments);
    setAddedCommentsDecorations((current) => nextDecorations.map((nextDecoration) => {
      var _a2;
      const prevDecoration = current.find(
        (p) => {
          var _a3, _b2;
          return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === ((_b2 = nextDecoration.payload) == null ? void 0 : _b2.commentId);
        }
      );
      return (_a2 = prevDecoration == null ? void 0 : prevDecoration.payload) != null && _a2.dirty ? {
        ...nextDecoration,
        payload: { ...nextDecoration.payload, dirty: prevDecoration.payload.dirty }
      } : nextDecoration;
    }));
  }, [handleBuildRangeDecorations, textComments]);
  const showFloatingButton = !!(currentSelection && canSubmit && selectionReferenceElement && !mouseDownRef.current), showFloatingInput = !!(nextCommentSelection && popoverAuthoringReferenceElement);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(BoundaryElementProvider, { element: boundaryElement, children: /* @__PURE__ */ jsxs(AnimatePresence, { children: [
      showFloatingInput && currentUser && /* @__PURE__ */ jsx(
        InlineCommentInputPopover,
        {
          currentUser,
          mentionOptions,
          onChange: setNextCommentValue,
          onClickOutside: resetStates,
          onDiscardConfirm: handleCommentDiscardConfirm,
          onSubmit: handleSubmit,
          referenceElement: popoverAuthoringReferenceElement,
          value: nextCommentValue
        }
      ),
      showFloatingButton && !showFloatingInput && /* @__PURE__ */ jsx(
        FloatingButtonPopover,
        {
          disabled: currentSelectionIsOverlapping,
          onClick: handleSelectCurrentSelection,
          onClickOutside: resetStates,
          referenceElement: selectionReferenceElement
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx(Stack, { ref: setRootElement, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, children: props.renderDefault({
      ...props,
      onEditorChange,
      editorRef,
      rangeDecorations,
      onFullScreenChange: setIsFullScreen
    }) })
  ] });
});
function isPortableTextInputProps(inputProps) {
  return isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function CommentsInput(props) {
  return isPortableTextInputProps(props) ? /* @__PURE__ */ jsx(CommentsPortableTextInput, { ...props }) : props.renderDefault(props);
}
const _DEBUG = !1, EMPTY_PARAMS$1 = {}, LOADING_PANE = Symbol("LOADING_PANE"), DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement", DocumentPaneContext = createContext(null);
function useDocumentPane() {
  const documentPane = useContext(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
const FEEDBACK_FORM_LINK = "https://snty.link/comments-beta-feedback", Span = styled.span`
  margin-right: 0.2em;
`, Link = styled.a`
  white-space: nowrap;
`, FooterCard = styled(Card)({
  position: "relative",
  zIndex: 1
});
function CommentsInspectorFeedbackFooter() {
  const { t } = useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsx(FooterCard, { padding: 4, children: /* @__PURE__ */ jsxs(Text, { muted: !0, size: 1, children: [
    t("feature-feedback.title"),
    " ",
    /* @__PURE__ */ jsxs(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [
      /* @__PURE__ */ jsxs(Span, { children: [
        t("feature-feedback.link"),
        " "
      ] }),
      " ",
      /* @__PURE__ */ jsx(LaunchIcon, {})
    ] })
  ] }) });
}
const Root$8 = styled(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
}), CommentsInspectorHeader = forwardRef(function(props, ref) {
  const { t } = useTranslation(commentsLocaleNamespace), { onClose, onViewChange, view, mode } = props, handleSetOpenView = useCallback(() => onViewChange("open"), [onViewChange]), handleSetResolvedView = useCallback(() => onViewChange("resolved"), [onViewChange]);
  return /* @__PURE__ */ jsx(Root$8, { ref, children: /* @__PURE__ */ jsxs(Flex, { padding: 2, children: [
    /* @__PURE__ */ jsxs(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: [
      /* @__PURE__ */ jsx(Text, { as: "h1", size: 1, weight: "medium", children: t("feature-name") }),
      /* @__PURE__ */ jsx(BetaBadge, {})
    ] }),
    /* @__PURE__ */ jsxs(Flex, { flex: "none", padding: 1, gap: 2, children: [
      /* @__PURE__ */ jsx(
        MenuButton,
        {
          id: "comment-status-menu-button",
          button: /* @__PURE__ */ jsx(
            Button,
            {
              text: t(view === "open" ? "status-filter.status-open" : "status-filter.status-resolved"),
              mode: "bleed",
              iconRight: ChevronDownIcon
            }
          ),
          menu: /* @__PURE__ */ jsxs(Menu, { style: { width: "180px" }, children: [
            /* @__PURE__ */ jsx(
              MenuItem,
              {
                iconRight: view === "open" ? CheckmarkIcon : void 0,
                onClick: handleSetOpenView,
                text: t("status-filter.status-open-full")
              }
            ),
            /* @__PURE__ */ jsx(
              MenuItem,
              {
                iconRight: view === "resolved" ? CheckmarkIcon : void 0,
                onClick: handleSetResolvedView,
                text: t("status-filter.status-resolved-full"),
                tooltipProps: mode === "upsell" ? { content: t("status-filter.status-resolved-full-upsell") } : void 0,
                disabled: mode === "upsell"
              }
            )
          ] }),
          popover: { placement: "bottom-end" }
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": t("close-pane-button-text-aria-label"),
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("close-pane-button-text") }
        }
      )
    ] })
  ] }) });
}), RootLayer = styled(Layer)`
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
`;
function CommentsInspector(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsx(RootLayer, { children: /* @__PURE__ */ jsx(CommentsInspectorInner, { ...props, mode }) }) : null;
}
function CommentsInspectorInner(props) {
  const { t } = useTranslation(commentsLocaleNamespace), { onClose, mode } = props, [showDeleteDialog, setShowDeleteDialog] = useState(!1), [commentToDelete, setCommentToDelete] = useState(null), [deleteLoading, setDeleteLoading] = useState(!1), [deleteError, setDeleteError] = useState(null), rootRef = useRef(null), currentUser = useCurrentUser(), { params, createPathWithParams, setParams } = usePaneRouter(), uniqueParams = useUnique(params) || EMPTY_PARAMS$1, commentIdParamRef = useRef(uniqueParams == null ? void 0 : uniqueParams.comment), didScrollToCommentFromParam = useRef(!1), pushToast = useToast().push, { isTopLayer } = useLayer(), { onPathOpen, connectionState } = useDocumentPane(), { scrollToComment, scrollToField, scrollToInlineComment } = useCommentsScroll(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { isDismissed, setDismissed } = useCommentsOnboarding(), { comments: comments2, getComment, isCreatingDataset, mentionOptions, setStatus, status, operation } = useComments(), { upsellData, telemetryLogs } = useCommentsUpsell(), currentComments = useMemo(() => comments2.data[status], [comments2, status]), loading = useMemo(() => comments2.loading || connectionState === "connecting", [comments2.loading, connectionState]);
  useEffect(() => (mode === "upsell" && ((selectedPath == null ? void 0 : selectedPath.origin) === "form" ? telemetryLogs.panelViewed("field_action") : commentIdParamRef.current ? telemetryLogs.panelViewed("link") : telemetryLogs.panelViewed("document_action")), () => {
    mode === "upsell" && telemetryLogs.panelDismissed();
  }), []);
  const handleChangeView = useCallback(
    (nextView) => {
      setStatus(nextView), setSelectedPath(null);
    },
    [setSelectedPath, setStatus]
  ), handleCloseInspector = useCallback(() => {
    onClose(), setSelectedPath(null);
  }, [onClose, setSelectedPath]), handleCopyLink = useCallback(
    (id) => {
      const path = createPathWithParams({
        ...params,
        comment: id
      }), url = `${window.location.origin}${path}`;
      navigator.clipboard.writeText(url).then(() => {
        pushToast({
          closable: !0,
          status: "info",
          title: t("copy-link-success-message")
        });
      }).catch(() => {
        pushToast({
          closable: !0,
          status: "error",
          title: t("copy-link-error-message")
        });
      });
    },
    [createPathWithParams, params, pushToast, t]
  ), handleCreateRetry = useCallback(
    (id) => {
      var _a;
      const comment = getComment(id);
      comment && operation.create({
        type: "field",
        fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || "",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || [],
        status: comment.status,
        threadId: comment.threadId
      });
    },
    [getComment, operation]
  ), closeDeleteDialog = useCallback(() => {
    deleteLoading || (setShowDeleteDialog(!1), setCommentToDelete(null));
  }, [deleteLoading]), handlePathSelect = useCallback(
    (nextPath) => {
      if (setSelectedPath(nextPath), nextPath != null && nextPath.fieldPath) {
        const path = PathUtils.fromString(nextPath.fieldPath);
        onPathOpen(path), scrollToField(nextPath.fieldPath), comments2.data.open.filter((c) => c.threadId === (nextPath == null ? void 0 : nextPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)) && nextPath.threadId && scrollToInlineComment(nextPath.threadId);
      }
    },
    [comments2.data.open, onPathOpen, scrollToField, scrollToInlineComment, setSelectedPath]
  ), handleNewThreadCreate = useCallback(
    (nextComment) => {
      var _a;
      const fieldPath = ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || "";
      operation.create({
        type: "field",
        fieldPath,
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: nextComment.reactions,
        status: nextComment.status,
        threadId: nextComment.threadId
      }), setSelectedPath({
        fieldPath,
        origin: "inspector",
        threadId: nextComment.threadId
      });
    },
    [operation, setSelectedPath]
  ), handleReply = useCallback(
    (nextComment) => {
      var _a;
      operation.create({
        ...nextComment,
        type: "field",
        fieldPath: ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || ""
      });
    },
    [operation]
  ), handleEdit = useCallback(
    (id, nextComment) => {
      operation.update(id, nextComment);
    },
    [operation]
  ), onDeleteStart = useCallback(
    (id) => {
      var _a;
      const parent = currentComments.find((c) => {
        var _a2;
        return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === id;
      }), isParent = !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
      setShowDeleteDialog(!0), setCommentToDelete({
        commentId: id,
        isParent
      });
    },
    [currentComments]
  ), handleDeleteConfirm = useCallback(
    async (id) => {
      try {
        setDeleteLoading(!0), await operation.remove(id), closeDeleteDialog();
      } catch (err) {
        setDeleteError(err);
      } finally {
        setDeleteLoading(!1);
      }
    },
    [closeDeleteDialog, operation]
  ), handleStatusChange = useCallback(
    (id, nextStatus) => {
      var _a;
      if (operation.update(id, {
        status: nextStatus
      }), nextStatus === "open") {
        setStatus("open");
        const comment = getComment(id);
        if (!comment)
          return;
        setSelectedPath({
          fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || null,
          origin: "inspector",
          threadId: comment.threadId || null
        }), scrollToComment(id);
      }
    },
    [getComment, operation, scrollToComment, setSelectedPath, setStatus]
  ), handleReactionSelect = useCallback(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeselectPath = useCallback(() => {
    selectedPath && isTopLayer && setSelectedPath(null);
  }, [isTopLayer, selectedPath, setSelectedPath]), handleClickOutside = useCallback(
    (e) => {
      var _a;
      e.target instanceof HTMLElement && ((_a = e.target) != null && _a.hasAttribute("data-slate-string")) || handleDeselectPath();
    },
    [handleDeselectPath]
  );
  useClickOutside(handleClickOutside, [rootRef.current]), useEffect(() => {
    var _a;
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    !loading && commentToScrollTo && didScrollToCommentFromParam.current === !1 && (setStatus(commentToScrollTo.status || "open"), setSelectedPath({
      fieldPath: ((_a = commentToScrollTo.target.path) == null ? void 0 : _a.field) || null,
      origin: "url",
      threadId: commentToScrollTo.threadId || null
    }), scrollToComment(commentToScrollTo._id), didScrollToCommentFromParam.current = !0, commentIdParamRef.current = void 0, setParams({
      ...params,
      comment: void 0
    }));
  }, [getComment, loading, params, scrollToComment, setParams, setSelectedPath, setStatus]);
  const beforeListNode = useMemo(() => mode === "upsell" && upsellData ? /* @__PURE__ */ jsx(
    CommentsUpsellPanel,
    {
      data: upsellData,
      onPrimaryClick: telemetryLogs.panelPrimaryClicked,
      onSecondaryClick: telemetryLogs.panelSecondaryClicked
    }
  ) : null, [mode, telemetryLogs.panelPrimaryClicked, telemetryLogs.panelSecondaryClicked, upsellData]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    commentToDelete && showDeleteDialog && /* @__PURE__ */ jsx(
      CommentDeleteDialog,
      {
        ...commentToDelete,
        error: deleteError,
        loading: deleteLoading,
        onClose: closeDeleteDialog,
        onConfirm: handleDeleteConfirm
      }
    ),
    /* @__PURE__ */ jsxs(
      Flex,
      {
        direction: "column",
        flex: 1,
        height: "fill",
        onClick: handleDeselectPath,
        overflow: "hidden",
        ref: rootRef,
        children: [
          /* @__PURE__ */ jsx(
            CommentsOnboardingPopover,
            {
              onDismiss: setDismissed,
              open: !isDismissed,
              placement: "left-start",
              children: /* @__PURE__ */ jsx(
                CommentsInspectorHeader,
                {
                  onClose: handleCloseInspector,
                  onViewChange: handleChangeView,
                  view: status,
                  mode
                }
              )
            }
          ),
          currentUser && /* @__PURE__ */ jsx(
            CommentsList,
            {
              beforeListNode,
              comments: currentComments,
              currentUser,
              error: comments2.error,
              loading,
              mentionOptions,
              mode,
              onCopyLink: handleCopyLink,
              onCreateRetry: handleCreateRetry,
              onDelete: onDeleteStart,
              onEdit: handleEdit,
              onNewThreadCreate: handleNewThreadCreate,
              onPathSelect: handlePathSelect,
              onReactionSelect: handleReactionSelect,
              onReply: handleReply,
              onStatusChange: handleStatusChange,
              readOnly: isCreatingDataset,
              selectedPath,
              status
            }
          ),
          mode === "default" && /* @__PURE__ */ jsx(CommentsInspectorFeedbackFooter, {})
        ]
      }
    )
  ] });
}
function useMenuItem$1() {
  const { t } = useTranslation(commentsLocaleNamespace), { enabled } = useCommentsEnabled();
  return {
    hidden: !enabled,
    icon: CommentIcon$1,
    showAsAction: !0,
    title: t("feature-name")
  };
}
const commentsInspector = defineDocumentInspector({
  name: COMMENTS_INSPECTOR_NAME,
  component: CommentsInspector,
  useMenuItem: useMenuItem$1
});
function CommentsStudioLayout(props) {
  const { enabled, isLoading } = useFeatureEnabled("studioComments");
  return /* @__PURE__ */ jsx(AddonDatasetProvider, { children: /* @__PURE__ */ jsx(CommentsOnboardingProvider, { children: /* @__PURE__ */ jsx(
    ConditionalWrapper,
    {
      condition: !enabled && !isLoading,
      wrapper: (children) => /* @__PURE__ */ jsx(CommentsUpsellProvider, { children }),
      children: props.renderDefault(props)
    }
  ) }) });
}
const comments = definePlugin({
  name: "sanity/structure/comments",
  document: {
    inspectors: [commentsInspector],
    components: {
      unstable_layout: CommentsDocumentLayout
    }
  },
  form: {
    components: {
      field: CommentsField,
      input: CommentsInput
    }
  },
  studio: {
    components: {
      layout: CommentsStudioLayout
    }
  },
  i18n: { bundles: [commentsUsEnglishLocaleBundle] }
});
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return /* @__PURE__ */ jsxs(
    Pane,
    {
      currentMinWidth,
      flex,
      id: paneKey,
      minWidth,
      tone,
      children: [
        /* @__PURE__ */ jsx(PaneHeader, { title }),
        /* @__PURE__ */ jsx(PaneContent, { overflow: "auto", children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children }) })
      ]
    }
  );
}
function getWaitMessages(path) {
  const thresholds = [
    { ms: 300, messageKey: "panes.resolving.default-message" },
    { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }
  ];
  if (isDev) {
    const message = [
      "Check console for errors?",
      "Is your observable/promise resolving?",
      path.length > 0 ? `Structure path: ${path.join(" \u279D ")}` : ""
    ];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = of(null);
  return merge(
    ...thresholds.map(
      (threshold) => src.pipe(
        mapTo(
          "messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }
        ),
        delay(threshold.ms)
      )
    )
  );
}
const DEFAULT_MESSAGE_KEY = "panes.resolving.default-message", Content$1 = styled(Flex)`
  opacity: 0;
  transition: opacity 200ms;

  &[data-mounted] {
    opacity: 1;
  }
`, LoadingPane = memo((props) => {
  const {
    delay: delay2 = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, { t } = useTranslation(structureLocaleNamespace), resolvedMessage = useMemo(() => typeof messageProp == "function" ? messageProp(path ? path.split(";") : []) : messageProp, [messageProp, path]), [currentMessage, setCurrentMessage] = useState(() => typeof resolvedMessage == "string" ? resolvedMessage : t(DEFAULT_MESSAGE_KEY));
  useEffect(() => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function")
      return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = useState(null), [mounted, setMounted] = useState(!1);
  return useEffect(() => {
    if (contentElement)
      return _raf2(() => setMounted(!0));
  }, [contentElement]), /* @__PURE__ */ jsx(Pane, { flex, id: paneKey, minWidth, selected, tone, children: /* @__PURE__ */ jsx(PaneContent, { children: /* @__PURE__ */ jsx(
    Content$1,
    {
      align: "center",
      "data-mounted": mounted ? "" : void 0,
      direction: "column",
      height: "fill",
      justify: "center",
      ref: setContentElement,
      children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: title || currentMessage })
    }
  ) }) });
});
LoadingPane.displayName = "LoadingPane";
const StructureToolContext = createContext(null);
function useStructureTool() {
  const structureTool2 = useContext(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
const InspectorMenuItem = memo(function(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props, node = useUnique(
    useMenuItem2({
      documentId,
      documentType
    })
  );
  return useEffect(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]), /* @__PURE__ */ jsx(Fragment$1, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props, len = inspectors2.length, lenRef = useRef(len), [menuItems, setMenuItems] = useState(
    () => Array.from(new Array(len))
  ), menuItemsRef = useRef(menuItems);
  useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItemsRef.current[i];
      lenRef.current = len, setMenuItems(() => (menuItemsRef.current = newFieldActions, newFieldActions));
    }
  }, [len]);
  const setMenuItem = useCallback((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, menuItemsRef.current = next, next;
    });
  }, []);
  return useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]), /* @__PURE__ */ jsx(Fragment$1, { children: inspectors2.map(
    (inspector, inspectorIndex) => inspector.useMenuItem && /* @__PURE__ */ jsx(
      InspectorMenuItem,
      {
        documentId,
        documentType,
        index: inspectorIndex,
        setMenuItem,
        useMenuItem: inspector.useMenuItem
      },
      inspector.name
    )
  ) });
}
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  return connectionState === "connecting" ? { error: void 0, title: void 0 } : title ? { error: void 0, title } : documentValue ? error ? { error: `Error: ${error.message}`, title: void 0 } : { error: void 0, title: value == null ? void 0 : value.title } : { error: void 0, title: `New ${(schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)}` };
}
const IGNORE_OPS = ["patch", "commit"], DocumentOperationResults = memo(function() {
  const { push: pushToast } = useToast(), { documentId, documentType } = useDocumentPane(), { title } = useDocumentTitle(), event = useDocumentOperationEvent(documentId, documentType), prevEvent = useRef(event), paneRouter = usePaneRouter(), { t } = useTranslation(structureLocaleNamespace), documentTitleBase = title || t("panes.document-operation-results.operation-undefined-title"), documentTitle = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase;
  return useEffect(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    return event.type === "error" && pushToast({
      closable: !0,
      duration: 3e4,
      // 30s
      status: "error",
      title: t("panes.document-operation-results.operation-error", { context: event.op }),
      description: /* @__PURE__ */ jsxs("details", { children: [
        /* @__PURE__ */ jsx("summary", { children: t("panes.document-operation-results.error.summary.title") }),
        event.error.message
      ] })
    }), event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: !0,
      status: "success",
      title: /* @__PURE__ */ jsx(
        Translate,
        {
          context: event.op,
          i18nKey: "panes.document-operation-results.operation-success",
          t,
          values: {
            title: documentTitle
          },
          components: {
            Strong: "strong"
          }
        }
      )
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t, documentTitle]), null;
}), Root$7 = styled(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props, { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxs(Root$7, { ...restProps, as: forwardedAs, children: [
    /* @__PURE__ */ jsxs(Flex, { padding: 2, children: [
      /* @__PURE__ */ jsx(Box, { flex: 1, padding: 3, children: /* @__PURE__ */ jsx(Text, { as: "h1", size: 1, weight: "medium", children: title }) }),
      /* @__PURE__ */ jsx(Box, { flex: "none", padding: 1, children: /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": closeButtonLabel,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("document-inspector.close-button.tooltip") }
        }
      ) })
    ] }),
    children
  ] });
}
const Root$6 = styled.div`
  position: absolute;
  top: 0;
  left: -4px;
  bottom: 0;
  width: 9px;
  z-index: 201;
  cursor: ew-resize;

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  /* Hover effect */
  & > span:nth-child(2) {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 9px;
    bottom: 0;
    background-color: var(--card-border-color);
    opacity: 0;
    transition: opacity 150ms;
  }

  @media (hover: hover) {
    &:hover > span:nth-child(2) {
      opacity: 0.2;
    }
  }
`;
function Resizer(props) {
  const { onResize, onResizeStart } = props, mouseXRef = useRef(0), handleMouseDown = useCallback(
    (event) => {
      event.preventDefault(), mouseXRef.current = event.pageX, onResizeStart();
      const handleMouseMove = (e) => {
        e.preventDefault(), onResize(e.pageX - mouseXRef.current);
      }, handleMouseUp = () => {
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [onResize, onResizeStart]
  );
  return /* @__PURE__ */ jsxs(Root$6, { onMouseDown: handleMouseDown, children: [
    /* @__PURE__ */ jsx("span", {}),
    /* @__PURE__ */ jsx("span", {})
  ] });
}
const Root$5 = styled(Box)`
  position: relative;
  flex: 1;
  padding-left: 1px;
`;
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props, [element, setElement] = useState(null), elementWidthRef = useRef(), [targetWidth, setTargetWidth] = useState(), handleResizeStart = useCallback(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]), handleResize = useCallback(
    (deltaX) => {
      const w = elementWidthRef.current;
      w && setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
    },
    [minWidth, maxWidth]
  ), style = useMemo(
    () => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth },
    [minWidth, maxWidth, targetWidth]
  );
  return /* @__PURE__ */ jsxs(Root$5, { as: forwardedAs, ...restProps, ref: setElement, style, children: [
    children,
    /* @__PURE__ */ jsx(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })
  ] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props, { collapsed } = usePane(), { closeInspector, inspector } = useDocumentPane(), { features } = useStructureTool(), handleClose = useCallback(() => {
    inspector && closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = createElement(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  return features.resizablePanes ? /* @__PURE__ */ jsx(
    Resizable,
    {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    }
  ) : /* @__PURE__ */ jsx(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
const STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const keyValueStore = useKeyValueStore(), [value, setValue] = useState(defaultValue), keyValueStoreKey = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean).join("."), settings = useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  useEffect(() => {
    const sub = settings.pipe(
      startWith(defaultValue),
      map((fetchedValue) => fetchedValue === null ? defaultValue : fetchedValue)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, keyValueStoreKey, settings]);
  const set2 = useCallback(
    (newValue) => {
      newValue !== value && (setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue));
    },
    [keyValueStore, keyValueStoreKey, value]
  );
  return useMemo(() => [value, set2], [set2, value]);
}
const VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" }, VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" }, VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW], lru = HLRU(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || isRecord(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const { path } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return isRecord(value) && isString$1(value._id) && isString$1(value._type);
}
const JSONInspectorWrapper = styled.div(({ theme }) => {
  const { color, fonts, space } = theme.sanity;
  return css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: '▸ ';
      margin-left: calc(0 - ${rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: '▾ ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '↔';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const { onChange, query } = props, handleChange = useCallback(
    (event) => onChange(event.target.value),
    [onChange]
  ), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    TextInput,
    {
      icon: SearchIcon,
      onChange: handleChange,
      placeholder: t("document-inspector.search.placeholder"),
      radius: 2,
      value: query || ""
    }
  );
}
function InspectDialog(props) {
  const { value } = props, { onInspectClose, paneKey } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting(
    "inspect-view-mode",
    null,
    "parsed"
  ), viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId), setParsedViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]), setRawViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    Dialog,
    {
      bodyHeight: "fill",
      id: `${dialogIdPrefix}dialog`,
      header: isDocumentLike(value) ? /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "document-inspector.dialog.title",
          components: {
            DocumentTitle: () => /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(DocTitle, { document: value }) })
          }
        }
      ) : /* @__PURE__ */ jsx("em", { children: t("document-inspector.dialog.title-no-value") }),
      onClose: onInspectClose,
      onClickOutside: onInspectClose,
      padding: !1,
      width: 2,
      children: /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", children: [
        /* @__PURE__ */ jsx(
          Card,
          {
            padding: 3,
            paddingTop: 0,
            shadow: 1,
            style: { position: "sticky", bottom: 0, zIndex: 3 },
            children: /* @__PURE__ */ jsxs(TabList, { space: 1, children: [
              /* @__PURE__ */ jsx(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`,
                  label: t(VIEW_MODE_PARSED.title),
                  onClick: setParsedViewMode,
                  selected: viewMode === VIEW_MODE_PARSED
                }
              ),
              /* @__PURE__ */ jsx(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`,
                  label: t(VIEW_MODE_RAW.title),
                  onClick: setRawViewMode,
                  selected: viewMode === VIEW_MODE_RAW
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsxs(
          TabPanel,
          {
            "aria-labelledby": `${dialogIdPrefix}tab-${viewModeId}`,
            flex: 1,
            id: `${dialogIdPrefix}tabpanel`,
            overflow: "auto",
            padding: 4,
            style: { outline: "none" },
            children: [
              viewMode === VIEW_MODE_PARSED && /* @__PURE__ */ jsx(JSONInspectorWrapper, { children: /* @__PURE__ */ jsx(
                JSONInspector,
                {
                  data: value,
                  isExpanded,
                  onClick: toggleExpanded,
                  search: Search
                }
              ) }),
              viewMode === VIEW_MODE_RAW && /* @__PURE__ */ jsx(
                Code,
                {
                  language: "json",
                  tabIndex: 0,
                  onKeyDown: maybeSelectAll,
                  onDoubleClick: select,
                  onFocus: select,
                  size: 1,
                  children: JSON.stringify(value, null, 2)
                }
              )
            ]
          }
        )
      ] })
    }
  );
}
function SpacerButton({ size }) {
  return /* @__PURE__ */ jsx(
    Button,
    {
      "aria-hidden": !0,
      disabled: !0,
      size,
      style: {
        pointerEvents: "none",
        visibility: "hidden",
        width: 0
      },
      text: "-"
    }
  );
}
function Banner(props) {
  const { action, content, icon: Icon, tone = "transparent", ...rest } = props;
  return /* @__PURE__ */ jsx(Card, { borderBottom: !0, paddingX: 4, paddingY: 2, tone, ...rest, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    Icon && /* @__PURE__ */ jsx(Text, { size: 0, children: /* @__PURE__ */ jsx(Icon, {}) }),
    /* @__PURE__ */ jsx(Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }),
    /* @__PURE__ */ jsx(SpacerButton, {}),
    action && /* @__PURE__ */ jsx(
      Button,
      {
        as: action == null ? void 0 : action.as,
        mode: "ghost",
        onClick: action == null ? void 0 : action.onClick,
        text: action.text,
        tone: action.tone || "default"
      }
    )
  ] }) });
}
function DeletedDocumentBanner({ revisionId }) {
  const { documentId, documentType } = useDocumentPane(), { restore } = useDocumentOperation(documentId, documentType), { navigateIntent } = useRouter(), handleRestore = useCallback(() => {
    revisionId && (restore.execute(revisionId), navigateIntent("edit", { id: documentId, type: documentType }));
  }, [documentId, documentType, navigateIntent, restore, revisionId]), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    Banner,
    {
      action: revisionId ? {
        onClick: handleRestore,
        text: t("banners.deleted-document-banner.restore-button.text")
      } : void 0,
      content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }),
      "data-testid": "deleted-document-banner",
      icon: ReadOnlyIcon
    }
  );
}
function DeprecatedDocumentTypeBanner() {
  const { schemaType } = useDocumentPane(), { t } = useTranslation(structureLocaleNamespace);
  return isDeprecatedSchemaType(schemaType) ? /* @__PURE__ */ jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsxs(Text, { size: 1, weight: "medium", children: [
        /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }),
        " ",
        schemaType.deprecated.reason
      ] }),
      "data-testid": "deprecated-document-type-banner",
      icon: ErrorOutlineIcon
    }
  ) : null;
}
function PermissionCheckBanner({ granted, requiredPermission }) {
  const currentUser = useCurrentUser(), listFormat = useListFormat({ style: "short" }), { t } = useTranslation(structureLocaleNamespace);
  if (granted)
    return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title), roles = listFormat.formatToParts(roleTitles).map(
    (part) => part.type === "element" ? /* @__PURE__ */ jsx("code", { children: part.value }, part.value) : part.value
  );
  return /* @__PURE__ */ jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "banners.permission-check-banner.missing-permission",
          components: { Roles: () => /* @__PURE__ */ jsx(Fragment$1, { children: roles }) },
          values: { count: roles.length, roles: roleTitles },
          context: requiredPermission
        }
      ) }),
      "data-testid": "permission-check-banner",
      icon: ReadOnlyIcon
    }
  );
}
const ReferenceChangedBanner = memo(() => {
  var _a, _b, _c, _d, _e, _f, _g;
  const documentPreviewStore = useDocumentPreviewStore(), { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink2 } = usePaneRouter(), routerReferenceId = (_a = routerPanesState[groupIndex]) == null ? void 0 : _a[0].id, parentGroup = routerPanesState[groupIndex - 1], parentSibling = parentGroup == null ? void 0 : parentGroup[0], parentId = parentSibling == null ? void 0 : parentSibling.id, hasHistoryOpen = !!((_b = parentSibling == null ? void 0 : parentSibling.params) != null && _b.rev), parentRefPath = useMemo(() => (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null, [params == null ? void 0 : params.parentRefPath]), { t } = useTranslation(structureLocaleNamespace), referenceInfo = useMemoObservable(
    () => {
      const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
      if (!parentId || !parentRefPathSegment || !parentRefPath)
        return of({ loading: !1 });
      const publishedId = getPublishedId(parentId), path = fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex(
        (p) => typeof p == "object" && "_key" in p
      );
      return concat(
        // emit a loading state instantly
        of({ loading: !0 }),
        // then emit the values from watching the published ID's path
        documentPreviewStore.unstable_observePathsDocumentPair(
          publishedId,
          keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)
        ).pipe(
          // this debounce time is needed to prevent flashing banners due to
          // the router state updating faster than the content-lake state. we
          // debounce to wait for more emissions because the value pulled
          // initially could be stale.
          debounceTime(750),
          map(
            ({ draft, published }) => {
              var _a2;
              return {
                loading: !1,
                result: {
                  availability: {
                    draft: draft.availability,
                    published: published.availability
                  },
                  refValue: (_a2 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a2._ref
                }
              };
            }
          )
        )
      );
    },
    [documentPreviewStore, parentId, parentRefPath],
    { loading: !0 }
  ), handleReloadReference = useCallback(() => {
    var _a2;
    referenceInfo.loading || (_a2 = referenceInfo.result) != null && _a2.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  return (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c = referenceInfo.result) != null && _c.availability.draft.available) && !((_d = referenceInfo.result) != null && _d.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId ? null : /* @__PURE__ */ jsx(
      Banner,
      {
        action: (_f = referenceInfo.result) != null && _f.refValue ? {
          onClick: handleReloadReference,
          icon: SyncIcon,
          text: t("banners.reference-changed-banner.reason-changed.reload-button.text")
        } : {
          as: BackLink2,
          icon: CloseIcon,
          text: t("banners.reference-changed-banner.reason-removed.close-button.text")
        },
        "data-testid": "reference-changed-banner",
        content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: (_g = referenceInfo.result) != null && _g.refValue ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }),
        icon: WarningOutlineIcon,
        tone: "caution"
      }
    )
  );
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
const TitleContainer = styled(Stack)`
  ${({ theme }) => css`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}
`, FormHeader = ({ documentId, schemaType, title }) => {
  var _a;
  const isSingleton = documentId === schemaType.name, { t } = useTranslation$1(structureLocaleNamespace);
  return schemaType.__experimental_formPreviewTitle === !1 ? null : /* @__PURE__ */ jsxs(TitleContainer, { marginBottom: 6, space: 4, children: [
    !isSingleton && /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: (_a = schemaType.title) != null ? _a : schemaType.name }),
    /* @__PURE__ */ jsx(Heading, { as: "h2", "data-heading": !0, muted: !title, children: title != null ? title : t("document-view.form-view.form-title-fallback") })
  ] });
};
function usePrevious(value) {
  const ref = useRef();
  return useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
const LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast(), wasEnabled = usePrevious(params.enabled);
  useEffect(() => {
    !wasEnabled && params.enabled && toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG }), wasEnabled && !params.enabled && toast.push({
      ...params,
      // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
      duration: 0.01
    });
  }, [params, toast, wasEnabled]);
}
const preventDefault = (ev) => ev.preventDefault(), FormView = forwardRef(function(props, ref) {
  var _a;
  const { hidden, margins } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), { title } = useDocumentTitle(), patchChannel = useMemo(() => createPatchChannel(), []), isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled, { t } = useTranslation(structureLocaleNamespace);
  useConditionalToast({
    id: `sync-lock-${documentId}`,
    status: "warning",
    enabled: isLocked,
    title: t("document-view.form-view.sync-lock-toast.title"),
    description: t("document-view.form-view.sync-lock-toast.description")
  }), useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!(value != null && value._rev);
  useEffect(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const [formRef, setFormRef] = useState(null);
  useEffect(() => {
    ready && !(formState != null && formState.focusPath.length) && formRef && focusFirstDescendant(formRef);
  }, [ready]);
  const setRef = useCallback(
    (node) => {
      setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
    },
    [ref]
  );
  return /* @__PURE__ */ jsx(
    Container,
    {
      hidden,
      paddingX: 4,
      paddingTop: 5,
      paddingBottom: 9,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */ jsx(PresenceOverlay, { margins, children: /* @__PURE__ */ jsx(Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: connectionState === "connecting" ? /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsxs(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
        /* @__PURE__ */ jsx(Spinner, { muted: !0 }),
        /* @__PURE__ */ jsx(Box, { marginTop: 3, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("document-view.form-view.loading") }) })
      ] }) }) : formState === null || hidden ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { children: t("document-view.form-view.form-hidden") }) }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(FormHeader, { documentId, schemaType: formState.schemaType, title }),
        /* @__PURE__ */ jsx(
          FormBuilder,
          {
            __internal_fieldActions: fieldActions,
            __internal_patchChannel: patchChannel,
            collapsedFieldSets,
            collapsedPaths,
            focusPath: formState.focusPath,
            changed: formState.changed,
            focused: formState.focused,
            groups: formState.groups,
            id: "root",
            members: formState.members,
            onChange,
            onFieldGroupSelect: onSetActiveFieldGroup,
            onPathBlur: onBlur,
            onPathFocus: onFocus,
            onPathOpen,
            onSetFieldSetCollapsed: onSetCollapsedFieldSet,
            onSetPathCollapsed: onSetCollapsedPath,
            presence,
            readOnly: connectionState === "reconnecting" || formState.readOnly,
            schemaType: formState.schemaType,
            validation,
            value: (
              // note: the form state doesn't have a typed concept of a "document" value
              // but these should be compatible
              formState.value
            )
          }
        )
      ] }) }) })
    }
  );
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(
      fromMutationPatches("local", localPatches)
    )
  };
}
const DocumentBox = styled(Box)({
  position: "relative"
}), Scroller$1 = styled(ScrollContainer)(({ $disabled }) => $disabled ? { height: "100%" } : css`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `), DocumentPanel = function(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views: views2,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore
  } = useDocumentPane(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed } = usePane(), parentPortal = usePortal(), { features } = useStructureTool(), portalRef = useRef(null), [documentScrollElement, setDocumentScrollElement] = useState(null), formContainerElement = useRef(null), requiredPermission = value._createdAt ? "update" : "create", activeView = useMemo(
    () => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" },
    [activeViewId, views2]
  ), portalElement = features.splitPanes && portalRef.current || parentPortal.element, margins = useMemo(() => layoutCollapsed ? [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0] : [0, 0, 2, 0], [layoutCollapsed, footerHeight, headerHeight]), formViewHidden = activeView.type !== "form", activeViewNode = useMemo(
    () => activeView.type === "component" && activeView.component && createElement(activeView.component, {
      document: {
        draft: (editState == null ? void 0 : editState.draft) || null,
        displayed: displayed || value,
        historical: displayed,
        published: (editState == null ? void 0 : editState.published) || null
      },
      documentId,
      options: activeView.options,
      schemaType
    }),
    [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]
  ), lastNonDeletedRevId = useTimelineSelector(
    timelineStore,
    (state2) => state2.lastNonDeletedRevId
  );
  useEffect(() => {
    documentScrollElement != null && documentScrollElement.scrollTo && documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]), useEffect(() => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = useMemo(() => isInspectOpen ? /* @__PURE__ */ jsx(InspectDialog, { value: displayed || value }) : null, [isInspectOpen, displayed, value]), showInspector = !!(!collapsed && inspector);
  return /* @__PURE__ */ jsx(PaneContent, { children: /* @__PURE__ */ jsxs(Flex, { height: "fill", children: [
    (features.resizablePanes || !showInspector) && /* @__PURE__ */ jsx(DocumentBox, { flex: 2, overflow: "hidden", children: /* @__PURE__ */ jsx(
      PortalProvider,
      {
        element: portalElement,
        __unstable_elements: { documentScrollElement },
        children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: documentScrollElement, children: /* @__PURE__ */ jsxs(
          VirtualizerScrollInstanceProvider,
          {
            scrollElement: documentScrollElement,
            containerElement: formContainerElement,
            children: [
              activeView.type === "form" && !isPermissionsLoading && ready && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                /* @__PURE__ */ jsx(
                  PermissionCheckBanner,
                  {
                    granted: !!(permissions != null && permissions.granted),
                    requiredPermission
                  }
                ),
                !isDeleting && isDeleted && /* @__PURE__ */ jsx(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }),
                /* @__PURE__ */ jsx(ReferenceChangedBanner, {}),
                /* @__PURE__ */ jsx(DeprecatedDocumentTypeBanner, {})
              ] }),
              /* @__PURE__ */ jsxs(
                Scroller$1,
                {
                  $disabled: layoutCollapsed || !1,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [
                    /* @__PURE__ */ jsx(
                      FormView,
                      {
                        hidden: formViewHidden,
                        margins,
                        ref: formContainerElement
                      },
                      documentId + (ready ? "_ready" : "_pending")
                    ),
                    activeViewNode
                  ]
                }
              ),
              inspectDialog,
              /* @__PURE__ */ jsx("div", { "data-testid": "document-panel-portal", ref: portalRef })
            ]
          }
        ) })
      }
    ) }),
    showInspector && /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: /* @__PURE__ */ jsx(
      DocumentInspectorPanel,
      {
        documentId,
        documentType: schemaType.name,
        flex: 1
      }
    ) })
  ] }) });
}, POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"], DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsx(
    Popover$1,
    {
      content: /* @__PURE__ */ jsx(ConfirmDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function ConfirmDialogContent(props) {
  const { dialog } = props, {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog, { t } = useTranslation(structureLocaleNamespace), { isTopLayer } = useLayer(), [element, setElement] = useState(null), handleClickOutside = useCallback(() => {
    isTopLayer && onCancel();
  }, [isTopLayer, onCancel]), handleGlobalKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onCancel();
    },
    [isTopLayer, onCancel]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsxs(Flex, { direction: "column", ref: setElement, style: { minWidth: 304, maxWidth: 400 }, children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, overflow: "auto", padding: 4, children: /* @__PURE__ */ jsx(Text, { children: message }) }),
    /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: /* @__PURE__ */ jsxs(Grid, { columns: 2, gap: 2, children: [
      /* @__PURE__ */ jsx(
        Button$1,
        {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text")
        }
      ),
      /* @__PURE__ */ jsx(
        Button$1,
        {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"),
          tone
        }
      )
    ] }) })
  ] });
}
function ModalDialog(props) {
  const { dialog } = props, dialogId = useId(), footer = dialog.footer && /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "fullscreen", children: /* @__PURE__ */ jsx(
    Dialog$1,
    {
      __unstable_hideCloseButton: dialog.showCloseButton === !1,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: /* @__PURE__ */ jsx(Box, { padding: 4, children: dialog.content })
    }
  ) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsx(
    Popover$1,
    {
      content: /* @__PURE__ */ jsx(PopoverDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function PopoverDialogContent(props) {
  const { dialog } = props, { content, onClose } = dialog, { isTopLayer } = useLayer(), [element, setElement] = useState(null), handleClickOutside = useCallback(() => {
    isTopLayer && onClose();
  }, [isTopLayer, onClose]), handleGlobalKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsx("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props, { element, elements } = usePortal(), portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return /* @__PURE__ */ jsx(PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props, modalId = useId();
  if (dialog.type === "confirm")
    return /* @__PURE__ */ jsx(ConfirmDialog, { dialog, referenceElement });
  if (dialog.type === "popover")
    return /* @__PURE__ */ jsx(PopoverDialog, { dialog, referenceElement });
  if (dialog.type === "dialog" || !dialog.type)
    return /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: /* @__PURE__ */ jsx(ModalDialog, { dialog }) });
  if (dialog.type === "custom")
    return /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  const unknownModal = dialog;
  return console.warn(`Unsupported modal type ${unknownModal.type}`), /* @__PURE__ */ jsx(
    Dialog,
    {
      id: modalId,
      onClose: unknownModal.onClose,
      onClickOutside: unknownModal.onClose,
      width: 1,
      children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
      /* @__PURE__ */ jsxs(Text, { size: 1, children: [
        "Unexpected modal type (",
        /* @__PURE__ */ jsx("code", { children: unknownModal.type }),
        ")"
      ] })
    }
  );
}
function ActionDialogWrapper({
  actionStates,
  children,
  referenceElement
}) {
  const [actionIndex, setActionIndex] = useState(-1), currentAction = actionStates[actionIndex], handleAction = useCallback((idx) => {
    setActionIndex(idx);
  }, []);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    currentAction && currentAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }),
    children({ handleAction })
  ] });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props, idPrefix = useId(), [referenceElement, setReferenceElement] = useState(null), popoverProps = useMemo(
    () => ({
      placement: "top-end",
      portal: !0,
      preventOverflow: !0
    }),
    []
  ), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsx(
    MenuButton,
    {
      id: `${idPrefix}-action-menu`,
      button: /* @__PURE__ */ jsx(
        ContextMenuButton,
        {
          "aria-label": t("buttons.action-menu-button.aria-label"),
          disabled,
          "data-testid": "action-menu-button",
          size: "large",
          tooltipProps: { content: t("buttons.action-menu-button.tooltip") }
        }
      ),
      menu: /* @__PURE__ */ jsx(Menu, { padding: 1, children: actionStates.map((actionState, idx) => /* @__PURE__ */ jsx(
        ActionMenuListItem,
        {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        },
        idx
      )) }),
      popover: popoverProps,
      ref: setReferenceElement
    }
  ) });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props, { onHandle } = actionState, handleClick = useCallback(() => {
    onAction(index), onHandle && onHandle();
  }, [index, onAction, onHandle]), hotkeys = useMemo(() => actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0, [actionState.shortcut]);
  return /* @__PURE__ */ jsx(
    MenuItem,
    {
      "data-testid": `action-${actionState.label.replace(" ", "")}`,
      disabled: disabled || !!actionState.disabled,
      hotkeys,
      icon: actionState.icon,
      onClick: handleClick,
      text: actionState.label,
      tone: actionState.tone,
      ...actionState.disabled && { tooltipProps: { content: actionState.title } }
    }
  );
}
const TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
const StackWrapper = styled(Stack)`
  max-width: 200px;
`, ListWrapper = styled(Flex)`
  max-height: calc(100vh - 198px);
  min-width: 244px;
`, Root$4 = styled(Box)(({ $visible }) => css`
    opacity: 0;
    pointer-events: none;

    ${$visible && css`
      opacity: 1;
      pointer-events: auto;
    `}
  `), TIMELINE_ITEM_I18N_KEY_MAPPING = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
}, IconWrapper = styled(Flex)(({ theme }) => {
  var _a;
  const borderColor = (_a = theme.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return css`
    --timeline-hairline-width: 1px;
    position: relative;
    z-index: 2;
    margin: 0;
    padding: 0;

    &::before {
      position: absolute;
      content: '';
      height: 100%;
      width: var(--timeline-hairline-width);
      background: ${borderColor};
      top: 0;
      left: calc((100% - var(--timeline-hairline-width)) / 2);
      z-index: 1;
    }
  `;
}), Root$3 = styled(Button$1)(({ $selected, $disabled }) => css`
    position: relative;
    width: 100%;

    /* Line styling */
    &[data-first] ${IconWrapper}::before {
      height: 50%;
      top: unset;
      bottom: 0;
    }

    &[data-last] ${IconWrapper}::before {
      height: 50%;
    }

    ${$selected && css`
      ${IconWrapper}::before {
        background: transparent;
      }
    `}

    ${$disabled && css`
      cursor: not-allowed;
    `}
  `), IconBox = styled(Box)`
  background: var(--card-bg-color);
  border-radius: 50px;
  position: relative;
  z-index: 2;
`, TimestampBox = styled(Box)`
  min-width: 1rem;
  margin-left: ${({ theme }) => `-${rem(theme.sanity.space[1])}`};
`;
function UserAvatarStack({ maxLength, userIds }) {
  return /* @__PURE__ */ jsx(AvatarStack, { maxLength, children: userIds.map((userId) => /* @__PURE__ */ jsx(UserAvatar, { user: userId, withTooltip: !0 }, userId)) });
}
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem({
  chunk,
  isFirst,
  isLast,
  isLatest,
  isSelected,
  onSelect,
  timestamp,
  type
}) {
  const { t } = useTranslation("studio"), iconComponent = getTimelineEventIconComponent(type), authorUserIds = Array.from(chunk.authors), isSelectable = type !== "delete", dateFormat = useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" }), formattedTimestamp = useMemo(() => {
    const parsedDate = new Date(timestamp);
    return dateFormat.format(parsedDate);
  }, [timestamp, dateFormat]), handleClick = useCallback(
    (evt) => {
      evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
    },
    [onSelect, chunk, isSelectable]
  );
  return /* @__PURE__ */ jsx(
    Root$3,
    {
      $selected: isSelected,
      $disabled: !isSelectable,
      "data-chunk-id": chunk.id,
      "data-first": isFirst ? !0 : void 0,
      "data-last": isLast ? !0 : void 0,
      "data-ui": "timelineItem",
      mode: isSelected ? "default" : "bleed",
      onClick: handleClick,
      padding: 0,
      radius: 2,
      tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
      children: /* @__PURE__ */ jsx(Box, { paddingX: 2, children: /* @__PURE__ */ jsxs(Flex, { align: "stretch", children: [
        /* @__PURE__ */ jsx(IconWrapper, { align: "center", children: /* @__PURE__ */ jsx(IconBox, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 2, children: iconComponent && createElement(iconComponent) }) }) }),
        /* @__PURE__ */ jsxs(Stack, { space: 2, margin: 2, children: [
          isLatest && /* @__PURE__ */ jsx(Flex, { children: /* @__PURE__ */ jsx(
            Card,
            {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 0, weight: "medium", children: t("timeline.latest") })
            }
          ) }),
          /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || /* @__PURE__ */ jsx("code", { children: type }) }) }),
          /* @__PURE__ */ jsx(TimestampBox, { paddingX: 1, children: /* @__PURE__ */ jsx(Text, { as: "time", size: 0, muted: !0, dateTime: timestamp, children: formattedTimestamp }) })
        ] }),
        /* @__PURE__ */ jsx(Flex, { flex: 1, justify: "flex-end", align: "center", children: /* @__PURE__ */ jsx(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })
      ] }) })
    }
  );
}
const Timeline = ({
  chunks,
  disabledBeforeFirstChunk,
  hasMoreChunks,
  lastChunk,
  onLoadMore,
  onSelect,
  firstChunk
}) => {
  const [mounted, setMounted] = useState(!1), { t } = useTranslation("studio"), filteredChunks = useMemo(() => chunks.filter((c) => disabledBeforeFirstChunk && firstChunk ? c.index < firstChunk.index : !0), [chunks, disabledBeforeFirstChunk, firstChunk]), selectedIndex = useMemo(
    () => lastChunk != null && lastChunk.id ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1,
    [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]
  ), renderItem2 = useCallback(
    (chunk, { activeIndex }) => {
      const isFirst = activeIndex === 0, isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || !1;
      return /* @__PURE__ */ jsxs(Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [
        /* @__PURE__ */ jsx(
          TimelineItem,
          {
            chunk,
            isFirst,
            isLast,
            isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
            isSelected: activeIndex === selectedIndex,
            onSelect,
            timestamp: chunk.endTimestamp,
            type: chunk.type
          }
        ),
        activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */ jsx(LoadingBlock, {})
      ] });
    },
    [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]
  );
  return useEffect(() => setMounted(!0), []), /* @__PURE__ */ jsxs(
    Root$4,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: [
        filteredChunks.length === 0 && /* @__PURE__ */ jsxs(StackWrapper, { padding: 3, space: 3, children: [
          /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
          /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
        ] }),
        filteredChunks.length > 0 && /* @__PURE__ */ jsx(ListWrapper, { direction: "column", children: /* @__PURE__ */ jsx(
          CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t("timeline.list.aria-label"),
            autoFocus: "list",
            initialIndex: selectedIndex,
            initialScrollAlign: "center",
            itemHeight: 40,
            items: filteredChunks,
            onEndReached: onLoadMore,
            onEndReachedIndexOffset: 20,
            overscan: 5,
            renderItem: renderItem2,
            wrapAround: !1
          }
        ) })
      ]
    }
  );
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = useTranslation("studio");
  return /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    /* @__PURE__ */ jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsx(ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
      /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }),
      /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })
    ] })
  ] });
}
const Root$2 = styled(Popover)`
  overflow: hidden;
  overflow: clip;
`;
function TimelineMenu({ chunk, mode, placement }) {
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane(), [open, setOpen] = useState(!1), [button, setButton] = useState(null), [popover, setPopover] = useState(null), toast = useToast(), chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks), loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading), hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks), realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), { t } = useTranslation("studio"), handleOpen = useCallback(() => {
    setTimelineMode(mode), setOpen(!0);
  }, [mode, setTimelineMode]), handleClose = useCallback(() => {
    setTimelineMode("closed"), setOpen(!1);
  }, [setTimelineMode]), handleClickOutside = useCallback(() => {
    open && handleClose();
  }, [handleClose, open]), handleGlobalKeyDown = useCallback(
    (event) => {
      open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button == null || button.focus());
    },
    [button, handleClose, open]
  );
  useClickOutside(handleClickOutside, [button, popover]), useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = useCallback(
    (revChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), selectSince = useCallback(
    (sinceChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), handleLoadMore = useCallback(() => {
    loading || timelineStore.loadMore();
  }, [loading, timelineStore]), content = timelineError ? /* @__PURE__ */ jsx(TimelineError, {}) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    mode === "rev" && /* @__PURE__ */ jsx(
      Timeline,
      {
        chunks,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: realRevChunk,
        onLoadMore: handleLoadMore,
        onSelect: selectRev
      }
    ),
    mode === "since" && /* @__PURE__ */ jsx(
      Timeline,
      {
        chunks,
        disabledBeforeFirstChunk: !0,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: sinceTime,
        onLoadMore: handleLoadMore,
        onSelect: selectSince
      }
    )
  ] }), formatParams = {
    timestamp: { dateStyle: "medium", timeStyle: "short" }
  }, revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], {
    context: "timestamp",
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.latest-version"), sinceLabel = chunk ? t("timeline.since", {
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.since-version-missing");
  return /* @__PURE__ */ jsx(
    Root$2,
    {
      constrainSize: !0,
      content: open && content,
      "data-ui": "versionMenu",
      open,
      placement,
      portal: !0,
      ref: setPopover,
      children: /* @__PURE__ */ jsx(
        Button,
        {
          disabled: !ready,
          mode: "bleed",
          iconRight: ChevronDownIcon,
          onClick: open ? handleClose : handleOpen,
          ref: setButton,
          selected: open,
          style: { maxWidth: "100%" },
          text: ready ? mode === "rev" ? revLabel : sinceLabel : t("timeline.loading-history")
        }
      )
    }
  );
}
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  return /* @__PURE__ */ jsx(TabList, { space: 1, children: views2.map((view, index) => {
    var _a;
    return /* @__PURE__ */ jsx(
      DocumentHeaderTab,
      {
        icon: view.icon,
        id: `${paneKey}tab-${view.id}`,
        isActive: activeViewId === view.id,
        label: view.title,
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      },
      view.id
    );
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props, { ready } = useDocumentPane(), { setView } = usePaneRouter(), handleClick = useCallback(() => setView(viewId), [setView, viewId]);
  return /* @__PURE__ */ jsx(
    Tab,
    {
      ...rest,
      "aria-controls": tabPanelId,
      disabled: !ready,
      icon,
      id,
      label,
      onClick: handleClick,
      selected: isActive
    }
  );
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  }), { t } = useTranslation(structureLocaleNamespace);
  return connectionState === "connecting" ? /* @__PURE__ */ jsx(Fragment$1, {}) : title ? /* @__PURE__ */ jsx(Fragment$1, { children: title }) : documentValue ? error ? /* @__PURE__ */ jsx(Fragment$1, { children: t("panes.document-header-title.error.text", { error: error.message }) }) : /* @__PURE__ */ jsx(Fragment$1, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) }) : /* @__PURE__ */ jsx(Fragment$1, { children: t("panes.document-header-title.new.text", {
    schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)
  }) });
}
const DocumentPanelHeader = memo(
  forwardRef(function(_props, ref) {
    const { menuItems } = _props, {
      actions,
      editState,
      onMenuAction,
      onPaneClose,
      onPaneSplit,
      menuItemGroups,
      schemaType,
      timelineStore,
      connectionState,
      views: views2,
      unstable_languageFilter
    } = useDocumentPane(), { features } = useStructureTool(), { index, BackLink: BackLink2, hasGroupSiblings } = usePaneRouter(), { actions: fieldActions } = useFieldActions(), [referenceElement, setReferenceElement] = useState(null), menuNodes = useMemo(
      () => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }),
      [onMenuAction, fieldActions, menuItemGroups, menuItems]
    ), menuButtonNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), showTabs = views2.length > 1, rev = useTimelineSelector(timelineStore, (state2) => state2.revTime), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, { t } = useTranslation(structureLocaleNamespace);
    return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(
      PaneHeader,
      {
        border: !0,
        ref,
        loading: connectionState === "connecting",
        title: /* @__PURE__ */ jsx(DocumentHeaderTitle, {}),
        tabs: showTabs && /* @__PURE__ */ jsx(DocumentHeaderTabs, {}),
        tabIndex,
        backButton: showBackButton && /* @__PURE__ */ jsx(
          Button,
          {
            as: BackLink2,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: t("pane-header.back-button.text") }
          }
        ),
        subActions: /* @__PURE__ */ jsx(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }),
        actions: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
          unstable_languageFilter.length > 0 && /* @__PURE__ */ jsx(Fragment$1, { children: unstable_languageFilter.map((languageFilterComponent, idx) => createElement(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: `language-filter-${idx}`,
            schemaType
          })) }),
          menuButtonNodes.map((item) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node: item }, item.key)),
          editState && /* @__PURE__ */ jsx(
            RenderActionCollectionState,
            {
              actions: actions || [],
              actionProps: editState,
              group: "paneActions",
              children: ({ states }) => /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates: states, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsx("div", { ref: setReferenceElement, children: /* @__PURE__ */ jsx(
                PaneContextMenuButton,
                {
                  nodes: contextMenuNodes,
                  actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => /* @__PURE__ */ jsx(
                    ActionMenuListItem,
                    {
                      actionState,
                      disabled: !!actionState.disabled,
                      index: actionIndex,
                      onAction: handleAction
                    },
                    actionState.label
                  )) : void 0
                },
                "context-menu"
              ) }) })
            }
          ),
          showSplitPaneButton && /* @__PURE__ */ jsx(
            Button,
            {
              "aria-label": t("buttons.split-pane-button.aria-label"),
              icon: SplitVerticalIcon,
              mode: "bleed",
              onClick: onPaneSplit,
              tooltipProps: { content: t("buttons.split-pane-button.tooltip") }
            },
            "split-pane-button"
          ),
          showSplitPaneCloseButton && /* @__PURE__ */ jsx(
            Button,
            {
              icon: CloseIcon,
              mode: "bleed",
              onClick: onPaneClose,
              tooltipProps: { content: t("buttons.split-pane-close-button.title") }
            },
            "close-view-button"
          ),
          showPaneGroupCloseButton && /* @__PURE__ */ jsx(
            Button,
            {
              icon: CloseIcon,
              mode: "bleed",
              tooltipProps: { content: t("buttons.split-pane-close-group-button.title") },
              as: BackLink2
            },
            "close-view-button"
          )
        ] })
      }
    ) });
  })
), BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner({ states }) {
  return states.length === 0 ? null : /* @__PURE__ */ jsx(Inline, { space: 1, children: states.map((badge, index) => /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: badge.title,
      disabled: !badge.title,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsx(
        Badge,
        {
          fontSize: 1,
          mode: "outline",
          paddingX: 2,
          paddingY: 1,
          radius: 4,
          tone: badge.color ? BADGE_TONES[badge.color] : void 0,
          style: { whiteSpace: "nowrap" },
          children: badge.label
        }
      )
    },
    String(index)
  )) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  return !editState || !badges ? null : /* @__PURE__ */ jsx(RenderBadgeCollectionState, { badges, badgeProps: editState, children: ({ states }) => /* @__PURE__ */ jsx(DocumentBadgesInner, { states }) });
}
const DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
}, DeleteAction = ({ id, type, draft, onComplete }) => {
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane(), { delete: deleteOp } = useDocumentOperation(id, type), [isDeleting, setIsDeleting] = useState(!1), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleCancel = useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = useCallback(() => {
    setIsDeleting(!0), setConfirmDialogOpen(!1), paneSetIsDeleting(!0), deleteOp.execute(), onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]), handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  }), currentUser = useCurrentUser();
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: TrashIcon,
    disabled: !0,
    label: t("action.delete.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "delete-document", currentUser })
  } : {
    tone: "critical",
    icon: TrashIcon,
    disabled: isDeleting || !!deleteOp.disabled || isPermissionsLoading,
    title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "",
    label: t(isDeleting ? "action.delete.running.label" : "action.delete.label"),
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */ jsx(
        ConfirmDeleteDialogContainer,
        {
          action: "delete",
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }
      )
    }
  };
};
DeleteAction.action = "delete";
const DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-changes",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
}, DiscardChangesAction = ({
  id,
  type,
  published,
  liveEdit,
  onComplete
}) => {
  const { discardChanges } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  }), currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace), handleConfirm = useCallback(() => {
    discardChanges.execute(), onComplete();
  }, [discardChanges, onComplete]), handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = useMemo(
    () => isConfirmDialogOpen && {
      type: "confirm",
      tone: "critical",
      onCancel: onComplete,
      onConfirm: handleConfirm,
      message: t("action.discard-changes.confirm-dialog.confirm-discard-changes")
    },
    [handleConfirm, isConfirmDialogOpen, onComplete, t]
  );
  return !published || liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: ResetIcon,
    disabled: !0,
    label: t("action.discard-changes.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "discard-changes", currentUser })
  } : {
    tone: "critical",
    icon: ResetIcon,
    disabled: !!discardChanges.disabled || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "",
    label: t("action.discard-changes.label"),
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
const DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
}, DuplicateAction = ({ id, type, onComplete }) => {
  const documentStore = useDocumentStore(), { duplicate } = useDocumentOperation(id, type), { navigateIntent } = useRouter(), [isDuplicating, setDuplicating] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  }), { t } = useTranslation(structureLocaleNamespace), currentUser = useCurrentUser(), handle = useCallback(async () => {
    const dupeId = uuid();
    setDuplicating(!0);
    const duplicateSuccess = firstValueFrom(
      documentStore.pair.operationEvents(id, type).pipe(filter((e) => e.op === "duplicate" && e.type === "success"))
    );
    duplicate.execute(dupeId), await duplicateSuccess, navigateIntent("edit", { id: dupeId, type }), onComplete();
  }, [documentStore.pair, duplicate, id, navigateIntent, onComplete, type]);
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    icon: CopyIcon,
    disabled: !0,
    label: t("action.duplicate.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser })
  } : {
    icon: CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading,
    label: t(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"),
    title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
const HistoryRestoreAction = ({ id, type, revision, onComplete }) => {
  const { restore } = useDocumentOperation(id, type), event = useDocumentOperationEvent(id, type), { navigateIntent } = useRouter(), prevEvent = useRef(event), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleConfirm = useCallback(() => {
    restore.execute(revision), onComplete();
  }, [restore, revision, onComplete]);
  useEffect(() => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", { id, type }), prevEvent.current = event);
  }, [event, id, navigateIntent, type]);
  const handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = useMemo(() => isConfirmDialogOpen ? {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: t("action.restore.confirm.message")
  } : null, [handleConfirm, isConfirmDialogOpen, onComplete, t]), isRevisionInitialVersion = revision === "@initial";
  return revision === void 0 ? null : {
    label: t("action.restore.label"),
    color: "primary",
    onHandle: handle,
    title: t(
      isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"
    ),
    icon: RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
const DocumentPublished = defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
}), DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
function getDisabledReason(reason, publishedAt, t) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? /* @__PURE__ */ jsx(AlreadyPublished, { publishedAt }) : t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished({ publishedAt }) {
  const { t } = useTranslation(structureLocaleNamespace), timeSincePublished = useRelativeTime(publishedAt);
  return /* @__PURE__ */ jsx("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
const PublishAction = (props) => {
  var _a;
  const { id, type, liveEdit, draft, published } = props, [publishState, setPublishState] = useState(null), { publish } = useDocumentOperation(id, type), validationStatus = useValidationStatus(id, type), syncState = useSyncState(id, type), { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane(), editState = useEditState(documentId, documentType), { t } = useTranslation(structureLocaleNamespace), revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev, hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker), [publishScheduled, setPublishScheduled] = useState(!1), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating, [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  }), currentUser = useCurrentUser(), title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "", hasDraft = !!draft, doPublish = useCallback(() => {
    publish.execute(), setPublishState("publishing");
  }, [publish]);
  useEffect(() => {
    const validationComplete = validationStatus.isValidating === !1 && validationStatus.revision !== revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors || doPublish(), setPublishScheduled(!1));
  }, [
    isSyncing,
    doPublish,
    hasValidationErrors,
    publishScheduled,
    validationStatus.revision,
    revision,
    isValidating,
    validationStatus.isValidating
  ]), useEffect(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    didPublish && changesOpen && onHistoryOpen();
    const nextState = didPublish ? "published" : null, timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const telemetry = useTelemetry(), handle = useCallback(() => {
    telemetry.log(DocumentPublished, {
      publishedImmediately: !(draft != null && draft._createdAt),
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(!0) : doPublish();
  }, [
    telemetry,
    draft == null ? void 0 : draft._createdAt,
    published,
    syncState.isSyncing,
    validationStatus.isValidating,
    validationStatus.revision,
    revision,
    doPublish
  ]);
  if (liveEdit)
    return {
      tone: "default",
      icon: PublishIcon,
      label: t("action.publish.live-edit.label"),
      title: t("action.publish.live-edit.tooltip"),
      disabled: !0
    };
  if (!isPermissionsLoading && !(permissions != null && permissions.granted))
    return {
      tone: "default",
      icon: PublishIcon,
      label: "Publish",
      title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "publish-document", currentUser }),
      disabled: !0
    };
  const disabled = !!(publishScheduled || (_a = editState == null ? void 0 : editState.transactionSyncLock) != null && _a.enabled || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      t(publishState === "published" ? "action.publish.published.label" : publishScheduled || publishState === "publishing" ? "action.publish.running.label" : "action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
const DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
}, UnpublishAction = ({
  id,
  type,
  draft,
  onComplete,
  liveEdit
}) => {
  const { unpublish } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  }), currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace), handleCancel = useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = useCallback(() => {
    setConfirmDialogOpen(!1), unpublish.execute(), onComplete();
  }, [onComplete, unpublish]), dialog = useMemo(() => isConfirmDialogOpen ? {
    type: "dialog",
    onClose: onComplete,
    content: /* @__PURE__ */ jsx(
      ConfirmDeleteDialogContainer,
      {
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        action: "unpublish",
        onCancel: handleCancel,
        onConfirm: handleConfirm
      }
    )
  } : null, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  return liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: UnpublishIcon,
    label: "Unpublish",
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: !0
  } : {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t("action.unpublish.label"),
    title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(!0),
    dialog
  };
};
UnpublishAction.action = "unpublish";
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props, { __internal_tasks } = useDocumentPane(), [firstActionState, ...menuActionStates] = states, [buttonElement, setButtonElement] = useState(null), tooltipContent = useMemo(() => !firstActionState || !firstActionState.title && !firstActionState.shortcut ? null : /* @__PURE__ */ jsxs(Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [
    firstActionState.title && /* @__PURE__ */ jsx(Text, { size: 1, children: firstActionState.title }),
    firstActionState.shortcut && /* @__PURE__ */ jsx(
      Hotkeys,
      {
        fontSize: 1,
        style: { marginTop: -4, marginBottom: -4 },
        keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
      }
    )
  ] }), [firstActionState]);
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    __internal_tasks && __internal_tasks.footerAction,
    firstActionState && /* @__PURE__ */ jsx(LayerProvider, { zOffset: 200, children: /* @__PURE__ */ jsx(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: /* @__PURE__ */ jsx(Stack, { children: /* @__PURE__ */ jsx(
      Button,
      {
        "data-testid": `action-${firstActionState.label}`,
        disabled: disabled || !!firstActionState.disabled,
        icon: firstActionState.icon,
        onClick: firstActionState.onHandle,
        ref: setButtonElement,
        size: "large",
        text: firstActionState.label,
        tone: firstActionState.tone || "primary"
      }
    ) }) }) }),
    showMenu && menuActionStates.length > 0 && /* @__PURE__ */ jsx(ActionMenuButton, { actionStates: menuActionStates, disabled }),
    firstActionState && firstActionState.dialog && /* @__PURE__ */ jsx(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })
  ] });
}
const DocumentStatusBarActions = memo(function() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  return !actions || !editState ? null : /* @__PURE__ */ jsx(
    RenderActionCollectionState,
    {
      actions,
      actionProps: editState,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected",
          showMenu: actions.length > 1,
          states
        },
        documentId
      )
    }
  );
}), HistoryStatusBarActions = memo(function() {
  const { connectionState, editState, timelineStore } = useDocumentPane(), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), revision = (revTime == null ? void 0 : revTime.id) || "", disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision, actionProps = useMemo(() => ({ ...editState || {}, revision }), [editState, revision]), historyActions = useMemo(() => [HistoryRestoreAction], []);
  return /* @__PURE__ */ jsx(
    RenderActionCollectionState,
    {
      actions: historyActions,
      actionProps,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected" || !!disabled,
          showMenu: !1,
          states
        }
      )
    }
  );
}), StyledMotionPath = styled(motion.path)`
  transform-origin: center;
`, Circle = (props) => /* @__PURE__ */ jsx(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props }), Arrows = (props) => /* @__PURE__ */ jsx(
  StyledMotionPath,
  {
    fill: "none",
    d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
    ...props
  }
), Checkmark = (props) => /* @__PURE__ */ jsx(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props }), rotateAnimation = keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`, RotateGroup = styled.g`
  transform-origin: center;

  &[data-rotate] {
    animation: ${rotateAnimation} 1s ease-in-out infinite;
  }
`, root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: { transition: { duration: 0 } }
}, circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
}, arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
}, checkmark = {
  syncing: {
    pathLength: 0,
    transition: { duration: 0 }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const { status } = props;
  return status ? /* @__PURE__ */ jsx(
    "svg",
    {
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.2",
      "data-sanity-icon": "animated-status-icon",
      children: /* @__PURE__ */ jsxs(motion.g, { variants: root, initial: status, animate: status, children: [
        /* @__PURE__ */ jsxs(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [
          /* @__PURE__ */ jsx(Arrows, { variants: arrows, initial: status, animate: status }),
          /* @__PURE__ */ jsx(Circle, { variants: circle, initial: status, animate: status })
        ] }),
        /* @__PURE__ */ jsx(Checkmark, { variants: checkmark, initial: status, animate: status })
      ] })
    }
  ) : null;
}
const STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
}, DocumentStatusPulse = (props) => {
  const { status } = props, { t } = useTranslation(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: currentStatus.tone, children: /* @__PURE__ */ jsx(AnimatedStatusIcon, { status }) }),
    /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t(currentStatus.i18nKey) })
  ] });
}, SYNCING_TIMEOUT = 1e3, SAVED_TIMEOUT = 3e3;
function DocumentStatusLine({ singleLine }) {
  const { documentId, documentType, editState, value } = useDocumentPane(), [status, setStatus] = useState(null), syncState = useSyncState(documentId, documentType), lastUpdated = value == null ? void 0 : value._updatedAt;
  return useEffect(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]), useLayoutEffect(() => {
    setStatus(null);
  }, [documentId]), useLayoutEffect(() => {
    syncState.isSyncing && setStatus("syncing");
  }, [syncState.isSyncing, lastUpdated]), status ? /* @__PURE__ */ jsx(DocumentStatusPulse, { status: status || void 0 }) : /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: /* @__PURE__ */ jsx(DocumentStatus, { absoluteDate: !0, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
      placement: "top",
      children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
        /* @__PURE__ */ jsx(
          DocumentStatus,
          {
            draft: editState == null ? void 0 : editState.draft,
            published: editState == null ? void 0 : editState.published,
            singleLine
          }
        )
      ] })
    }
  );
}
function useResizeObserver({
  element,
  onResize
}) {
  useLayoutEffect(() => (element && resizeObserver.observe(element, onResize), () => {
    element && resizeObserver.unobserve(element);
  }), [element, onResize]);
}
const CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props, { editState, timelineStore } = useDocumentPane(), showingRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), [collapsed, setCollapsed] = useState(null), [rootElement, setRootElement] = useState(null), handleResize = useCallback((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed == "boolean";
  return /* @__PURE__ */ jsx(Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && /* @__PURE__ */ jsxs(
    Flex,
    {
      align: "stretch",
      gap: 1,
      justify: "space-between",
      paddingY: 2,
      paddingLeft: 4,
      paddingRight: 3,
      children: [
        /* @__PURE__ */ jsxs(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
          /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
            /* @__PURE__ */ jsx(DocumentStatusLine, { singleLine: !collapsed }),
            /* @__PURE__ */ jsx(SpacerButton, { size: "large" })
          ] }),
          /* @__PURE__ */ jsx(DocumentBadges, {})
        ] }),
        /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "flex-start",
            justify: "flex-end",
            ref: actionsBoxRef,
            style: { flexShrink: 0, marginLeft: "auto" },
            children: [
              /* @__PURE__ */ jsx(SpacerButton, { size: "large" }),
              showingRevision ? /* @__PURE__ */ jsx(HistoryStatusBarActions, {}) : /* @__PURE__ */ jsx(DocumentStatusBarActions, {})
            ]
          }
        )
      ]
    }
  ) });
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, activeAction = states[activeIndex], handleKeyDown = useCallback(
    (event) => {
      const matchingStates = states.filter(
        (state2) => state2.shortcut && isHotkey(state2.shortcut, event)
      ), matchingState = matchingStates[0];
      if (matchingStates.length > 1 && console.warn(
        `Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`
      ), matchingState && !matchingState.disabled && matchingState.onHandle) {
        event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onActionStart, onKeyDown, states]
  );
  return createElement(
    as,
    {
      id,
      onKeyDown: handleKeyDown,
      tabIndex: -1,
      ...rest,
      ref: rootRef
    },
    [
      children,
      activeAction && activeAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })
    ]
  );
}
const DocumentActionShortcuts = React.memo(
  (props) => {
    const { actionsBoxElement, as = "div", children, ...rest } = props, { actions, editState } = useDocumentPane(), [activeIndex, setActiveIndex] = useState(-1), onActionStart = useCallback((idx) => {
      setActiveIndex(idx);
    }, []), actionProps = useMemo(
      () => editState && {
        ...editState,
        // @todo: what to call here?
        onComplete: () => {
        },
        // @todo: get revision string
        revision: void 0
      },
      [editState]
    );
    return !actionProps || !actions ? null : /* @__PURE__ */ jsx(RenderActionCollectionState, { actionProps, actions, children: ({ states }) => /* @__PURE__ */ jsx(
      KeyboardShortcutResponder,
      {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      }
    ) });
  }
);
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({ hasValue, t }) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t("document-inspector.menu-item.title"),
    icon: JsonIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem({ previewUrl, t }) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t("production-preview.menu-item.title"),
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
const isSanityDocument = (value) => isRecord(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = useState(void 0), [error, setError] = useState(null), { resolveProductionUrl } = useSource().document, value$ = useAsObservable(value);
  if (error)
    throw error;
  return useEffect(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap(
        (document2) => isSanityDocument(document2) ? from(resolveProductionUrl({ document: document2 })) : of(void 0)
      ),
      catchError$1((e) => {
        const message = isRecord(e) && typeof e.message == "string" ? e.message : "Unknown error";
        throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
      })
    ).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]), previewUrl;
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props, { t } = useTranslation();
  return /* @__PURE__ */ jsx(
    ErrorPane,
    {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-unknown-type.title",
          values: { documentType }
        }
      ),
      tone: "caution",
      children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
        documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
          Translate,
          {
            t,
            i18nKey: "panes.document-pane.document-unknown-type.text",
            values: { documentType }
          }
        ) }),
        !documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }),
        isDev && value && /* eslint-disable i18next/no-literal-string */
        /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(Text, { as: "p", children: "Here is the JSON representation of the document:" }),
          /* @__PURE__ */ jsx(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsx(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
        ] })
      ] })
    }
  );
}
const EMPTY_ARRAY$7 = [], DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
], StyledChangeConnectorRoot = styled(ChangeConnectorRoot)`
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
`;
function DocumentLayout() {
  const {
    changesOpen,
    documentId,
    documentType,
    fieldActions,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value
  } = useDocumentPane(), { features } = useStructureTool(), { t } = useTranslation$1(structureLocaleNamespace), { collapsed: layoutCollapsed } = usePaneLayout(), zOffsets = useZIndex(), previewUrl = usePreviewUrl(value), [rootElement, setRootElement] = useState(null), [footerElement, setFooterElement] = useState(null), [headerElement, setHeaderElement] = useState(null), [actionsBoxElement, setActionsBoxElement] = useState(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = useState(
    null
  ), [inspectorMenuItems, setInspectorMenuItems] = useState([]), [rootFieldActionNodes, setRootFieldActionNodes] = useState([]), footerRect = useElementRect(footerElement), headerRect = useElementRect(headerElement), footerHeight = footerRect == null ? void 0 : footerRect.height, headerHeight = headerRect == null ? void 0 : headerRect.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), currentInspector = useMemo(
    () => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)),
    [inspectors2, inspector == null ? void 0 : inspector.name]
  ), hasValue = !!value, menuItems = useMemo(
    () => getMenuItems({
      currentInspector,
      features,
      hasValue,
      inspectorMenuItems,
      inspectors: inspectors2,
      previewUrl,
      t
    }),
    [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]
  ), handleKeyUp = useCallback(
    (event) => {
      for (const item of menuItems)
        if (item.shortcut && isHotkey(item.shortcut, event)) {
          event.preventDefault(), event.stopPropagation(), onMenuAction(item);
          return;
        }
    },
    [onMenuAction, menuItems]
  ), onConnectorSetFocus = useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onPathOpen, onFocus]
  );
  return schemaType ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    inspectors2.length > 0 && /* @__PURE__ */ jsx(
      DocumentInspectorMenuItemsResolver,
      {
        documentId,
        documentType,
        inspectors: inspectors2,
        onMenuItems: setInspectorMenuItems
      }
    ),
    fieldActions.length > 0 && schemaType && /* @__PURE__ */ jsx(
      FieldActionsResolver,
      {
        actions: fieldActions,
        documentId,
        documentType,
        onActions: setRootFieldActionNodes,
        path: EMPTY_ARRAY$7,
        schemaType
      }
    ),
    /* @__PURE__ */ jsx(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$7, children: /* @__PURE__ */ jsxs(
      DocumentActionShortcuts,
      {
        actionsBoxElement,
        as: Pane,
        currentMinWidth,
        "data-testid": "document-pane",
        flex: 2.5,
        id: paneKey,
        minWidth,
        onKeyUp: handleKeyUp,
        rootRef: setRootElement,
        children: [
          /* @__PURE__ */ jsx(DocumentPanelHeader, { ref: setHeaderElement, menuItems }),
          /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: /* @__PURE__ */ jsx(
            StyledChangeConnectorRoot,
            {
              "data-testid": "change-connector-root",
              isReviewChangesOpen: changesOpen,
              onOpenReviewChanges: onHistoryOpen,
              onSetFocus: onConnectorSetFocus,
              children: /* @__PURE__ */ jsx(
                DocumentPanel,
                {
                  footerHeight: footerHeight || null,
                  headerHeight: headerHeight || null,
                  isInspectOpen: inspectOpen,
                  rootElement,
                  setDocumentPanelPortalElement
                }
              )
            }
          ) }) }),
          /* @__PURE__ */ jsx(
            PortalProvider,
            {
              __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement },
              children: /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: /* @__PURE__ */ jsx(PaneFooter, { ref: setFooterElement, children: /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) })
            }
          ),
          /* @__PURE__ */ jsx(DocumentOperationResults, {})
        ]
      }
    ) })
  ] }) : /* @__PURE__ */ jsx(
    DocumentLayoutError,
    {
      currentMinWidth,
      documentType,
      minWidth,
      paneKey,
      value
    }
  );
}
function pick(plugin) {
  var _a, _b;
  return (_b = (_a = plugin.document) == null ? void 0 : _a.components) == null ? void 0 : _b.unstable_layout;
}
function useDocumentLayoutComponent() {
  return useMiddlewareComponents({
    pick,
    defaultComponent: DocumentLayout
  });
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(
    `Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`
  );
  const template2 = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t) => t.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template2;
  return !template2 && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), { templateName, templateParams };
}
const DocumentPaneProvider = memo((props) => {
  const { children, index, pane, paneKey, onFocusPath } = props, schema2 = useSchema(), templates = useTemplates(), {
    __internal_tasks,
    document: {
      actions: documentActions2,
      badges: documentBadges2,
      unstable_fieldActions: fieldActionsResolver,
      unstable_languageFilter: languageFilterResolver,
      inspectors: inspectorsResolver
    }
  } = useSource(), presenceStore = usePresenceStore(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, { features } = useStructureTool(), { push: pushToast } = useToast(), {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane, paneOptions = useUnique(options), documentIdRaw = paneOptions.id, documentId = getPublishedId(documentIdRaw), documentType = options.type, params = useUnique(paneRouter.params) || EMPTY_PARAMS$2, panePayload = useUnique(paneRouter.payload), { templateName, templateParams } = useMemo(
    () => getInitialValueTemplateOpts(templates, {
      documentType,
      templateName: paneOptions.template,
      templateParams: paneOptions.templateParameters,
      panePayload,
      urlTemplate: params.template
    }),
    [documentType, paneOptions, params, panePayload, templates]
  ), initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  }), initialValue = useUnique(initialValueRaw), { patch } = useDocumentOperation(documentId, documentType), editState = useEditState(documentId, documentType), { validation: validationRaw } = useValidationStatus(documentId, documentType), connectionState = useConnectionState(documentId, documentType), schemaType = schema2.get(documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value, [isDeleting, setIsDeleting] = useState(!1), actions = useMemo(
    () => documentActions2({ schemaType: documentType, documentId }),
    [documentActions2, documentId, documentType]
  ), badges = useMemo(
    () => documentBadges2({ schemaType: documentType, documentId }),
    [documentBadges2, documentId, documentType]
  ), languageFilter = useMemo(
    () => languageFilterResolver({ schemaType: documentType, documentId }),
    [documentId, documentType, languageFilterResolver]
  ), validation = useUnique(validationRaw), views2 = useUnique(viewsProp), [focusPath, setFocusPath] = useState(
    () => params.path ? fromString(params.path) : EMPTY_ARRAY$k
  ), focusPathRef = useRef(focusPath), activeViewId = params.view || views2[0] && views2[0].id || null, [timelineMode, setTimelineMode] = useState("closed"), [timelineError, setTimelineError] = useState(null), timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes), timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed), timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady), isPristine = useTimelineSelector(timelineStore, (state2) => state2.isPristine), isDeleted = useMemo(() => timelineReady ? !(editState != null && editState.draft) && !(editState != null && editState.published) && !isPristine : !1, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]), previewUrl = usePreviewUrl(value), [presence, setPresence] = useState([]);
  useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = useMemo(
    () => inspectorsResolver({ documentId, documentType }),
    [documentId, documentType, inspectorsResolver]
  ), [inspectorName, setInspectorName] = useState(() => params.inspect || null), inspectParamRef = useRef(params.inspect);
  useEffect(() => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName), resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME), changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME, { t } = useTranslation(structureLocaleNamespace), inspectOpen = params.inspect === "on", compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null, fieldActions = useMemo(
    () => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [],
    [documentId, documentType, fieldActionsResolver, schemaType]
  ), ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError), displayed = useMemo(
    () => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value,
    [onOlderRevision, timelineDisplayed, value]
  ), setTimelineRange = useCallback(
    (newSince, newRev) => {
      setPaneParams({
        ...params,
        since: newSince,
        rev: newRev || void 0
      });
    },
    [params, setPaneParams]
  ), handleFocus = useCallback(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath), focusPathRef.current !== nextFocusPath && (focusPathRef.current = nextFocusPath, onFocusPath == null || onFocusPath(nextFocusPath)), presenceStore.setLocation([
        {
          type: "document",
          documentId,
          path: nextFocusPath,
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      ]);
    },
    [documentId, onFocusPath, presenceStore, setFocusPath]
  ), handleBlur = useCallback(
    (blurredPath) => {
      disableBlurRef.current || (setFocusPath(EMPTY_ARRAY$k), focusPathRef.current !== EMPTY_ARRAY$k && (focusPathRef.current = EMPTY_ARRAY$k, onFocusPath == null || onFocusPath(EMPTY_ARRAY$k)));
    },
    [onFocusPath, setFocusPath]
  ), patchRef = useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = useCallback((event) => patchRef.current(event), []), closeInspector = useCallback(
    (closeInspectorName) => {
      var _a, _b, _c, _d;
      const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
      if (closeInspectorName && !inspector) {
        console.warn(`No inspector named "${closeInspectorName}"`);
        return;
      }
      if (currentInspector) {
        if (inspector) {
          const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, { params })) != null ? _b : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
          return;
        }
        if (currentInspector) {
          const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, { params })) != null ? _d : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
        }
      }
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), openInspector = useCallback(
    (nextInspectorName, paneParams) => {
      var _a, _b, _c, _d;
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (!nextInspector) {
        console.warn(`No inspector named "${nextInspectorName}"`);
        return;
      }
      if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
        setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
        return;
      }
      let currentParams = params;
      currentInspector && (currentParams = ((_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, { params: currentParams })) != null ? _b : {
        params: currentParams
      }).params);
      const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, { params: currentParams })) != null ? _d : { params: currentParams };
      setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), handleHistoryClose = useCallback(() => {
    resolvedChangesInspector && closeInspector(resolvedChangesInspector.name);
  }, [closeInspector, resolvedChangesInspector]), handleHistoryOpen = useCallback(() => {
    features.reviewChanges && resolvedChangesInspector && openInspector(resolvedChangesInspector.name);
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]), handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]), handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]), toggleLegacyInspect = useCallback(
    (toggle = !inspectOpen) => {
      setPaneParams(toggle ? { ...params, inspect: "on" } : omit(params, "inspect"));
    },
    [inspectOpen, params, setPaneParams]
  ), handleMenuAction = useCallback(
    (item) => {
      if (item.action === "production-preview" && previewUrl)
        return window.open(previewUrl), !0;
      if (item.action === "inspect")
        return toggleLegacyInspect(!0), !0;
      if (item.action === "reviewChanges")
        return handleHistoryOpen(), !0;
      if (typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
        const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
        if (nextInspector)
          return nextInspector.name === inspectorName ? closeInspector(nextInspector.name) : openInspector(nextInspector.name), !0;
      }
      return !1;
    },
    [
      closeInspector,
      handleHistoryOpen,
      inspectorName,
      inspectors2,
      openInspector,
      previewUrl,
      toggleLegacyInspect
    ]
  ), handleLegacyInspectClose = useCallback(
    () => toggleLegacyInspect(!1),
    [toggleLegacyInspect]
  ), [openPath, onSetOpenPath] = useState([]), [fieldGroupState, onSetFieldGroupState] = useState(), [collapsedPaths, onSetCollapsedPath] = useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = useState(), handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), requiredPermission = value._createdAt ? "update" : "create", liveEdit = !!(schemaType != null && schemaType.liveEdit), docId = value._id ? value._id : "dummy-id", docPermissionsInput = useMemo(() => ({
    ...value,
    _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
  }), [liveEdit, value, docId]), [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  }), isNonExistent = !(value != null && value._id), readOnly = useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions != null && permissions.granted), updateActionDisabled = !isActionEnabled(schemaType, "update"), createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create"), reconnecting = connectionState === "reconnecting", isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [
    connectionState,
    editState.transactionSyncLock,
    isNonExistent,
    isDeleted,
    isDeleting,
    isPermissionsLoading,
    permissions == null ? void 0 : permissions.granted,
    ready,
    revTime,
    schemaType
  ]), formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  }), formStateRef = useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = useCallback(
    (path) => {
      getExpandOperations(formStateRef.current, path).forEach((op) => {
        op.type === "expandPath" && onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, !1)), op.type === "expandFieldSet" && onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, !1)), op.type === "setSelectedGroup" && onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }), onSetOpenPath(path);
    },
    [formStateRef]
  ), documentPane = useMemo(
    () => ({
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      inspector: currentInspector || null,
      inspectors: inspectors2,
      __internal_tasks,
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus,
      onPathOpen: setOpenPath,
      onHistoryClose: handleHistoryClose,
      onHistoryOpen: handleHistoryOpen,
      onInspectClose: handleLegacyInspectClose,
      onMenuAction: handleMenuAction,
      onPaneClose: handlePaneClose,
      onPaneSplit: handlePaneSplit,
      onSetActiveFieldGroup: handleSetActiveFieldGroup,
      onSetCollapsedPath: handleOnSetCollapsedPath,
      onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
      openInspector,
      index,
      inspectOpen,
      validation,
      menuItemGroups: menuItemGroups || [],
      paneKey,
      previewUrl,
      ready,
      schemaType,
      isPermissionsLoading,
      permissions,
      setTimelineMode,
      setTimelineRange,
      setIsDeleting,
      isDeleting,
      isDeleted,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      value,
      views: views2,
      formState,
      unstable_languageFilter: languageFilter
    }),
    [
      __internal_tasks,
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      currentInspector,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      formState,
      handleBlur,
      handleChange,
      handleFocus,
      handleHistoryClose,
      handleHistoryOpen,
      handleLegacyInspectClose,
      handleMenuAction,
      handleOnSetCollapsedFieldSet,
      handleOnSetCollapsedPath,
      handlePaneClose,
      handlePaneSplit,
      handleSetActiveFieldGroup,
      index,
      inspectOpen,
      inspectors2,
      isDeleted,
      isDeleting,
      isPermissionsLoading,
      languageFilter,
      menuItemGroups,
      openInspector,
      paneKey,
      permissions,
      previewUrl,
      ready,
      schemaType,
      setOpenPath,
      setTimelineRange,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      validation,
      value,
      views2
    ]
  );
  useEffect(() => {
    connectionState === "reconnecting" && pushToast({
      id: "sanity/structure/reconnecting",
      status: "warning",
      title: t("panes.document-pane-provider.reconnecting.title")
    });
  }, [connectionState, pushToast, t]);
  const disableBlurRef = useRef(!1);
  return useEffect(() => {
    var _a;
    if (ready && params.path) {
      const { path, ...restParams } = params, pathFromUrl = resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, fromString(path));
      disableBlurRef.current = !0, setFocusPath(pathFromUrl), setOpenPath(pathFromUrl), focusPathRef.current !== pathFromUrl && (focusPathRef.current = pathFromUrl, onFocusPath == null || onFocusPath(pathFromUrl));
      const timeout = setTimeout(() => {
        disableBlurRef.current = !1;
      }, 0);
      return paneRouter.setParams(restParams), () => clearTimeout(timeout);
    }
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]), /* @__PURE__ */ jsx(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
const DocumentPane = memo(function(props) {
  const { name: parentSourceName } = useSource();
  return /* @__PURE__ */ jsx(SourceProvider, { name: props.pane.source || parentSourceName, children: /* @__PURE__ */ jsx(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a;
  const { pane, paneKey } = props, { resolveNewDocumentOptions } = useSource().document, paneRouter = usePaneRouter(), options = usePaneOptions(pane.options, paneRouter.params), { documentType, isLoaded: isDocumentLoaded } = useDocumentType(options.id, options.type), DocumentLayout2 = useDocumentLayoutComponent(), templateItems = useMemo(() => resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), [options.id, options.type, resolveNewDocumentOptions]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading, providerProps = useMemo(() => isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, [props, documentType, isLoaded, options]), { ReferenceChildLink: ReferenceChildLink2, handleEditReference, groupIndex, routerPanesState } = paneRouter, childParams = ((_a = routerPanesState[groupIndex + 1]) == null ? void 0 : _a[0].params) || {}, routerPanesStateLength = routerPanesState.length, { parentRefPath } = childParams, activePath = useMemo(() => parentRefPath ? {
    path: fromString(parentRefPath),
    state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    )
  } : { path: [], state: "none" }, [parentRefPath, groupIndex, routerPanesStateLength]), { t } = useTranslation(structureLocaleNamespace);
  return options.type === "*" && !isLoaded ? /* @__PURE__ */ jsx(
    LoadingPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.loading")
    }
  ) : documentType ? /* @__PURE__ */ jsx(
    DocumentPaneProvider,
    {
      ...providerProps,
      children: /* @__PURE__ */ jsx(
        ReferenceInputOptionsProvider,
        {
          EditReferenceLinkComponent: ReferenceChildLink2,
          onEditReference: handleEditReference,
          initialValueTemplateItems: templatePermissions,
          activePath,
          children: /* @__PURE__ */ jsx(DocumentLayout2, { documentId: options.id, documentType: options.type })
        }
      )
    },
    `${documentType}-${options.id}`
  ) : /* @__PURE__ */ jsx(
    ErrorPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.title"),
      children: /* @__PURE__ */ jsx(Stack, { space: 4, children: /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-not-found.text",
          values: { id: options.id }
        }
      ) }) })
    }
  );
}
function usePaneOptions(options, params = {}) {
  const templates = useTemplates();
  return useMemo(() => {
    if (options.type && options.type !== "*")
      return options;
    const templateName = options.template || params.template, template2 = templateName ? templates.find((t) => t.id === templateName) : void 0, documentType = template2 == null ? void 0 : template2.schemaType;
    return documentType ? { ...options, type: documentType } : options;
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: { ...options, type: documentType }
    }
  };
}
const PARTIAL_PAGE_LIMIT = 100, FULL_LIST_LIMIT = 2e3, DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] }, EMPTY_RECORD = {}, RootBox = styled(Box)`
  position: relative;
`, CommandListBox = styled(Box)`
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
`, SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return /* @__PURE__ */ jsx(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => /* @__PURE__ */ jsx(SanityDefaultPreview, { isPlaceholder: !0, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const {
    childItemId,
    error,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    isLoading,
    items,
    layout,
    loadingVariant,
    onListChange,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons
  } = props, schema2 = useSchema(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed, index } = usePane(), [shouldRender, setShouldRender] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleEndReached = useCallback(() => {
    isLoading || isLazyLoading || !shouldRender || onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  useEffect(() => {
    if (collapsed)
      return;
    const timer2 = setTimeout(() => {
      setShouldRender(!0);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, [collapsed, items]);
  const renderItem2 = useCallback(
    (item, { activeIndex }) => {
      const publishedId = getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          PaneItem,
          {
            icon: showIcons === !1 ? !1 : void 0,
            id: publishedId,
            layout,
            marginBottom: 1,
            pressed,
            schemaType: schema2.get(item._type),
            selected,
            value: item
          }
        ),
        showSpinner && /* @__PURE__ */ jsx(LoadingBlock, {}),
        showMaxItemsMessage && /* @__PURE__ */ jsx(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })
      ] });
    },
    [childItemId, isActive, items.length, layout, schema2, showIcons, hasMaxItems, isLazyLoading, t]
  ), noDocumentsContent = useMemo(() => hasSearchQuery ? /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t("panes.document-list-pane.no-documents.text") }) }) }) }) : /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text") }) }) }) }), [filterIsSimpleTypeConstraint, hasSearchQuery, t]), mainContent = useMemo(() => {
    if (!shouldRender)
      return null;
    if (error)
      return /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsxs(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        /* @__PURE__ */ jsx(Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }),
        /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
          Translate,
          {
            t,
            i18nKey: "panes.document-list-pane.error.text",
            values: { error: error.message },
            components: { Code: ({ children }) => /* @__PURE__ */ jsx("code", { children }) }
          }
        ) }),
        onRetry && /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
          Button,
          {
            icon: SyncIcon,
            onClick: onRetry,
            text: t("panes.document-list-pane.error.retry-button.text"),
            tone: "primary"
          }
        ) })
      ] }) }) });
    if (!isLoading && items.length === 0)
      return noDocumentsContent;
    if (loadingVariant === "initial" && isLoading)
      return /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsx(LoadingView, { layout }) });
    if (loadingVariant === "spinner" && isLoading)
      return null;
    const key = `${index}-${collapsed}`;
    return /* @__PURE__ */ jsx(RootBox, { overflow: "hidden", height: "fill", children: /* @__PURE__ */ jsx(CommandListBox, { children: /* @__PURE__ */ jsx(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: paneTitle,
        canReceiveFocus: !0,
        inputElement: searchInputElement,
        itemHeight: 51,
        items,
        onEndReached: handleEndReached,
        onlyShowSelectionWhenActive: !0,
        overscan: 10,
        paddingBottom: 1,
        paddingX: 3,
        renderItem: renderItem2,
        wrapAround: !1
      },
      key
    ) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem2,
    searchInputElement,
    shouldRender
  ]);
  return /* @__PURE__ */ jsx(PaneContent, { overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto", children: mainContent });
}
const DocumentListPaneHeader = memo(
  ({
    contentAfter,
    index,
    initialValueTemplates = [],
    menuItemGroups = [],
    menuItems = [],
    setLayout,
    setSortOrder,
    title
  }) => {
    const { features } = useStructureTool(), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, actionHandlers = useMemo(() => ({
      setLayout: ({ layout: value }) => {
        setLayout(value);
      },
      setSortOrder: (sort) => {
        setSortOrder(sort);
      }
    }), [setLayout, setSortOrder]);
    return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(
      PaneHeader,
      {
        actions: /* @__PURE__ */ jsx(
          PaneHeaderActions,
          {
            initialValueTemplateItems: initialValueTemplates,
            actionHandlers,
            menuItemGroups,
            menuItems
          }
        ),
        backButton: features.backButton && index > 0 && /* @__PURE__ */ jsx(
          Button,
          {
            as: BackLink,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: "Back" }
          }
        ),
        contentAfter,
        tabIndex,
        title
      }
    ) });
  }
);
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => ({
    ...entry.draft || entry.published,
    hasPublished: !!entry.published,
    hasDraft: !!entry.draft
  }));
}
const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter2, params = {}) {
  const matches = filter2.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches)
    return null;
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1), v = params[k];
    return typeof v == "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter2) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter2.trim());
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy2 = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? { ...by, mapWith: "dateTime" } : fieldType.jsonType === "string" ? { ...by, mapWith: "lower" } : by : by;
  });
  return orderBy2.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy2 };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils.fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(isKeySegment(segment) || isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return !0;
    current = current.type;
  }
  return !1;
}
const IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path, strict = !1) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType))
    return "";
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = `The current ordering config targeted the nonexistent field "${head}" on schema type "${schemaType.name}". It should be one of ${schemaType.fields.map((field) => field.name).join(", ")}`;
      if (strict)
        throw new Error(errorMessage);
      console.warn(errorMessage);
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return `${head}->{${refTypes.map((refType) => joinReferences(refType, tail)).join(",")}}`;
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail), tailWrapper = tailFields ? `{${tailFields}}` : "";
  return tail.length > 0 ? `${head}${tailWrapper}` : head;
}
function getExtendedProjection(schemaType, orderBy2, strict = !1) {
  return orderBy2.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
function listenSearchQuery(options) {
  const {
    client,
    schema: schema2,
    sort,
    limit,
    params,
    filter: filter2,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    unstable_enableNewSearch
  } = options, sortBy = sort.by, extendedProjection = sort == null ? void 0 : sort.extendedProjection, events$ = defer(() => client.listen(`*[${filter2}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: !1,
    visibility: "query"
  })).pipe(
    mergeMap((ev, i) => i === 0 && ev.type !== "welcome" ? throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : of(ev)),
    share()
  ), [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome");
  return merge(
    welcome$.pipe(take(1)),
    mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, { leading: !0, trailing: !0 }))
  ).pipe(
    exhaustMapWithTrailing((event) => (staticTypeNames ? of(staticTypeNames) : client.observable.fetch(`array::unique(*[${filter2}][]._type)`, params)).pipe(
      mergeMap((typeNames) => {
        const types = getSearchableTypes(schema2).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, !0), !0) : !1), search = createSearch(types, client, {
          filter: filter2,
          params,
          unstable_enableNewSearch,
          maxDepth: maxFieldDepth
        }), doFetch = () => search({
          filter: filter2,
          query: searchQuery || "",
          types
        }, {
          __unstable_extendedProjection: extendedProjection,
          comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
          limit,
          skipSortByScore: !0,
          sort: sortBy
        }).pipe(
          map$1(
            (result) => (
              // eslint-disable-next-line max-nested-callbacks
              result.hits.map(({ hit }) => hit)
            )
          )
        );
        return event.type === "mutation" && event.visibility !== "query" ? timer(1200).pipe(mergeMap(doFetch)) : doFetch();
      })
    ))
  );
}
const EMPTY_ARRAY$6 = [], INITIAL_STATE$1 = {
  error: null,
  onRetry: void 0,
  result: null
}, INITIAL_QUERY_RESULTS = {
  result: null,
  error: null
};
function useDocumentList(opts) {
  const { filter: filter2, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts, client = useClient({
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), { unstable_enableNewSearch = !1 } = useWorkspace().search, schema2 = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), [resultState, setResult] = useState(INITIAL_STATE$1), { onRetry, error, result } = resultState, documents = result == null ? void 0 : result.documents, items = useMemo(
    () => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY$6,
    [documents]
  ), [isLazyLoading, setIsLazyLoading] = useState(!1), [hasFullList, setHasFullList] = useState(!1), [shouldFetchFullList, setShouldFetchFullList] = useState(!1), typeNameFromFilter = useMemo(
    () => getTypeNameFromSingleTypeFilter(filter2, paramsProp),
    [filter2, paramsProp]
  ), isLoading = result === null && !error, hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT, onListChange = useCallback(() => {
    isLoading || hasFullList || shouldFetchFullList || setShouldFetchFullList(!0);
  }, [isLoading, hasFullList, shouldFetchFullList]), handleSetResult = useCallback(
    (res) => {
      var _a, _b;
      if (res.error) {
        setResult(res);
        return;
      }
      const documentsLength = ((_b = (_a = res.result) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) || 0;
      if (!res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList) {
        setIsLazyLoading(!0);
        return;
      }
      if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList && setHasFullList(!0), (res == null ? void 0 : res.result) === null) {
        setResult((prev) => ({ ...prev.error ? res : prev }));
        return;
      }
      setIsLazyLoading(!1), setResult(res);
    },
    [shouldFetchFullList]
  ), queryResults$ = useMemo(() => {
    const onRetry$ = new Subject(), _onRetry = () => onRetry$.next();
    return listenSearchQuery({
      client,
      filter: filter2,
      limit: shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema: schema2,
      searchQuery: searchQuery || "",
      sort: sortOrder || DEFAULT_ORDERING,
      staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : void 0,
      maxFieldDepth,
      unstable_enableNewSearch
    }).pipe(
      map((results) => ({
        result: { documents: results },
        error: null
      })),
      startWith(INITIAL_QUERY_RESULTS),
      catchError$1((err) => err instanceof ProgressEvent ? throwError(() => new Error("Request error")) : throwError(() => err)),
      catchError$1((err, caught$) => concat(
        of({ result: null, error: err }),
        merge(fromEvent(window, "online"), onRetry$).pipe(
          take$1(1),
          mergeMap$1(() => caught$)
        )
      )),
      scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry }))
    );
  }, [
    shouldFetchFullList,
    sortOrder,
    client,
    filter2,
    paramsProp,
    schema2,
    searchQuery,
    typeNameFromFilter,
    maxFieldDepth,
    unstable_enableNewSearch
  ]);
  useEffect(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = useCallback(() => {
    setHasFullList(!1), setIsLazyLoading(!1), setResult(INITIAL_STATE$1), setShouldFetchFullList(!1);
  }, []);
  return useEffect(() => {
    reset();
  }, [reset, filter2, paramsProp, sortOrder, searchQuery]), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady: !error,
    items,
    onListChange,
    onRetry
  };
}
const EMPTY_ARRAY$5 = [], rotate = keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function useShallowUnique(value) {
  const valueRef = useRef(value);
  return shallowEquals(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
const addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a, _b, _c, _d;
    return (_a = item.params) != null && _a.layout ? {
      ...item,
      selected: layout === ((_b = item.params) == null ? void 0 : _b.layout)
    } : (_c = item == null ? void 0 : item.params) != null && _c.by ? {
      ...item,
      selected: isEqual(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d = item == null ? void 0 : item.params) == null ? void 0 : _d.by) || EMPTY_ARRAY$5)
    } : { ...item, selected: !1 };
  });
}, DocumentListPane = memo(function(props) {
  const { childItemId, index, isActive, isSelected, pane, paneKey } = props, schema2 = useSchema(), { name: parentSourceName } = useSource(), {
    defaultLayout = "default",
    displayOptions,
    initialValueTemplates = EMPTY_ARRAY$5,
    menuItemGroups,
    menuItems,
    options
  } = pane, { apiVersion, defaultOrdering = EMPTY_ARRAY$5, filter: filter2 } = options, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane.source, typeName = useMemo(() => getTypeNameFromSingleTypeFilter(filter2, params), [filter2, params]), showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== !1, [layout, setLayout] = useStructureToolSetting(
    "layout",
    typeName,
    defaultLayout
  ), { t } = useTranslation(structureLocaleNamespace), { title } = useI18nText(pane), [searchQuery, setSearchQuery] = useState(""), [searchInputValue, setSearchInputValue] = useState(""), [searchInputElement, setSearchInputElement] = useState(null), showSearchLoadingRef = useRef(!1), defaultSortOrder = useMemo(() => (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING, [defaultOrdering]), [sortOrderRaw, setSortOrder] = useStructureToolSetting(
    "sort-order",
    typeName,
    defaultSortOrder
  ), sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema2.get(typeName)) : sortOrderRaw, sortOrder = useUnique(sortWithOrderingFn), filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter2), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady,
    items,
    onListChange,
    onRetry
  } = useDocumentList({
    apiVersion,
    filter: filter2,
    params,
    searchQuery: searchQuery == null ? void 0 : searchQuery.trim(),
    sortOrder
  }), menuItemsWithSelectedState = useMemo(
    () => addSelectedStateToMenuItems({
      menuItems,
      sortOrderRaw,
      layout
    }),
    [layout, menuItems, sortOrderRaw]
  ), handleQueryChange = useObservableCallback(
    (event$) => event$.pipe(
      map$1((event) => event.target.value),
      tap$1(setSearchInputValue),
      debounce$1((value) => value === "" ? of("") : timer(300)),
      tap$1(setSearchQuery)
    ),
    []
  ), handleClearSearch = useCallback(() => {
    setSearchQuery(""), setSearchInputValue("");
  }, []), handleSearchKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && handleClearSearch();
    },
    [handleClearSearch]
  );
  useEffect(() => (showSearchLoadingRef.current === !1 && !isLoading && (showSearchLoadingRef.current = !0), () => {
    showSearchLoadingRef.current = !1;
  }), [isLoading]), useEffect(() => {
    handleClearSearch(), showSearchLoadingRef.current = !1;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = useMemo(() => isLoading && items.length === 0 && showSearchLoadingRef.current ? "spinner" : "initial", [isLoading, items.length]), searchInput = /* @__PURE__ */ jsx(Box, { paddingX: 3, paddingBottom: 3, children: /* @__PURE__ */ jsx(
    TextInput,
    {
      "aria-label": t("panes.document-list-pane.search-input.aria-label"),
      autoComplete: "off",
      border: !1,
      clearButton: !!searchQuery,
      disabled: !isSearchReady,
      fontSize: [2, 2, 1],
      icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : SearchIcon,
      onChange: handleQueryChange,
      onClear: handleClearSearch,
      onKeyDown: handleSearchKeyDown,
      padding: 2,
      placeholder: t("panes.document-list-pane.search-input.placeholder"),
      radius: 2,
      ref: setSearchInputElement,
      spellCheck: !1,
      value: searchInputValue
    }
  ) });
  return /* @__PURE__ */ jsx(SourceProvider, { name: sourceName || parentSourceName, children: /* @__PURE__ */ jsxs(
    Pane,
    {
      currentMaxWidth: 350,
      "data-ui": "DocumentListPane",
      id: paneKey,
      maxWidth: 640,
      minWidth: 320,
      selected: isSelected,
      children: [
        _DEBUG,
        /* @__PURE__ */ jsx(
          DocumentListPaneHeader,
          {
            contentAfter: searchInput,
            index,
            initialValueTemplates,
            menuItemGroups,
            menuItems: menuItemsWithSelectedState,
            setLayout,
            setSortOrder,
            title
          }
        ),
        /* @__PURE__ */ jsx(
          DocumentListPaneContent,
          {
            childItemId,
            error,
            filterIsSimpleTypeConstraint,
            hasMaxItems,
            hasSearchQuery: !!searchQuery,
            isActive,
            isLazyLoading,
            isLoading,
            items,
            layout,
            loadingVariant,
            onListChange,
            onRetry,
            paneTitle: title,
            searchInputElement,
            showIcons
          },
          paneKey
        )
      ]
    }
  ) });
});
class SerializeError extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    const segment = typeof pathSegment > "u" ? "<unknown>" : `${pathSegment}`;
    this.path = (parentPath || []).concat(hint ? `${segment} (${hint})` : segment);
  }
  withHelpUrl(id) {
    return this.helpId = id, this;
  }
}
var HELP_URL = /* @__PURE__ */ ((HELP_URL2) => (HELP_URL2.ID_REQUIRED = "structure-node-id-required", HELP_URL2.TITLE_REQUIRED = "structure-title-required", HELP_URL2.FILTER_REQUIRED = "structure-filter-required", HELP_URL2.INVALID_LIST_ITEM = "structure-invalid-list-item", HELP_URL2.COMPONENT_REQUIRED = "structure-view-component-required", HELP_URL2.DOCUMENT_ID_REQUIRED = "structure-document-id-required", HELP_URL2.DOCUMENT_TYPE_REQUIRED = "structure-document-type-required", HELP_URL2.SCHEMA_TYPE_REQUIRED = "structure-schema-type-required", HELP_URL2.SCHEMA_TYPE_NOT_FOUND = "structure-schema-type-not-found", HELP_URL2.LIST_ITEMS_MUST_BE_ARRAY = "structure-list-items-must-be-array", HELP_URL2.QUERY_PROVIDED_FOR_FILTER = "structure-query-provided-for-filter", HELP_URL2.ACTION_OR_INTENT_REQUIRED = "structure-action-or-intent-required", HELP_URL2.LIST_ITEM_IDS_MUST_BE_UNIQUE = "structure-list-item-ids-must-be-unique", HELP_URL2.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE = "structure-action-and-intent-mutually-exclusive", HELP_URL2.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER = "structure-api-version-required-for-custom-filter", HELP_URL2))(HELP_URL || {});
const ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  i18n: {
    title: {
      key: "menu-items.sort-by.last-edited",
      ns: structureLocaleNamespace
    }
  },
  name: "lastEditedDesc",
  by: [{ field: "_updatedAt", direction: "desc" }]
}, ORDER_BY_CREATED_AT = {
  title: "Created",
  i18n: {
    title: {
      key: "menu-items.sort-by.created",
      ns: structureLocaleNamespace
    }
  },
  name: "lastCreatedDesc",
  by: [{ field: "_createdAt", direction: "desc" }]
}, DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT, DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({ action });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({ group });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({ params });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction = !0) {
    return this.clone({ showAsAction: !!showAsAction });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options = { path: [] }) {
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action == "string" ? `action: "${action}"` : void 0;
      throw new SerializeError(
        "`title` is required for menu item",
        options.path,
        options.index,
        hint
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent)
      throw new SerializeError(
        `\`action\` or \`intent\` required for menu item with title ${this.spec.title}`,
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    if (intent && action)
      throw new SerializeError(
        "cannot set both `action` AND `intent`",
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    return { ...this.spec, title };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new MenuItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function getOrderingMenuItem(context, { by, title, i18n }, extendedProjection) {
  let builder = new MenuItemBuilder(context).group("sorting").title(
    context.i18n.t("default-menu-item.fallback-title", {
      // note this lives in the `studio` bundle because that one is loaded by default
      ns: "studio",
      replace: { title }
      // replaces the `{{title}}` option
    })
  ).icon(SortIcon).action("setSortOrder").params({ by, extendedProjection });
  return i18n && (builder = builder.i18n(i18n)), builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema: schema2 } = context, type = typeof typeName == "string" ? schema2.get(typeName) : typeName;
  return !type || !("orderings" in type) ? [] : (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(
    (ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by))
  );
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context, this._id = spec ? spec.id : "", this._title = spec ? spec.title : "", this._i18n = spec ? spec.i18n : void 0;
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n) {
    return new MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this._i18n;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options = { path: [] }) {
    const { _id, _title, _i18n } = this;
    if (!_id)
      throw new SerializeError(
        "`id` is required for a menu item group",
        options.path,
        options.index,
        _title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!_title)
      throw new SerializeError(
        "`title` is required for a menu item group",
        options.path,
        _id
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: _id,
      title: _title,
      i18n: _i18n
    };
  }
}
const disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id != "string")
    throw new SerializeError(
      `Structure node id must be of type string, got ${typeof id}`,
      parentPath,
      pathSegment
    );
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar)
    throw new SerializeError(
      `Structure node id cannot contain character "${disallowedChar}"`,
      parentPath,
      pathSegment
    );
  if (id.startsWith("__edit__"))
    throw new SerializeError(
      "Structure node id cannot start with __edit__",
      parentPath,
      pathSegment
    );
  return id;
}
function getStructureNodeId(title, id) {
  if (id)
    return id;
  const camelCased = camelCase(title);
  return disallowedPattern.test(camelCased) ? camelCase(speakingurl(title)) : camelCased;
}
class ComponentBuilder {
  constructor(spec) {
    this.spec = { options: {}, ...spec || {} };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options = { path: [] }) {
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!component2)
      throw new SerializeError(
        "`component` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, options.path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, options.path)
      )
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new ComponentBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = getPublishedId(id), draftId = getDraftId(id);
  return (await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(
    query,
    { documentId, draftId },
    { tag: "structure.resolve-type" }
  ))[0];
}
class GenericViewBuilder {
  constructor() {
    this.spec = {};
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({ title, id: this.spec.id || kebabCase(title) });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options = { path: [] }) {
    const { id, title, icon } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!title)
      throw new SerializeError(
        "`title` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
}
function isSerializable(view) {
  return typeof view.serialize == "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
const isComponentSpec = (spec) => isRecord(spec) && spec.type === "component";
class ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super(), this.spec = spec;
    const userComponent = typeof componentOrSpec == "function" ? componentOrSpec : this.spec.component;
    userComponent && (this.spec = this.component(userComponent).spec);
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options = { path: [] }) {
    const base = super.serialize(options), component2 = this.spec.component;
    if (typeof component2 != "function")
      throw new SerializeError(
        "`component` is required and must be a function for `component()` view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new ComponentViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
class FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super(), this.spec = { id: "editor", title: "Editor", ...spec || {} };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options = { path: [] }) {
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new FormViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
const form = (spec) => new FormViewBuilder(spec), component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
});
const createDocumentChildResolver = ({ resolveDocumentNode, getClient }) => async (itemId, { params, path }) => {
  let type = params.type;
  const parentPath = path.slice(0, path.length - 1), currentSegment = path[path.length - 1];
  if (type || (type = await resolveTypeForDocument(getClient, itemId)), !type)
    throw new SerializeError(
      "Failed to resolve document, and no type provided in parameters.",
      parentPath,
      currentSegment
    );
  return resolveDocumentNode({ documentId: itemId, schemaType: type });
};
class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options || {},
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        type: typeof documentType == "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const urlId = path[index || path.length - 1], id = this.spec.id || urlId && `${urlId}` || "", options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for document nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options || !options.id)
      throw new SerializeError(
        "document id (`id`) is required for document nodes",
        path,
        id,
        hint
      ).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    if (!options || !options.type)
      throw new SerializeError(
        "document type (`schemaType`) is required for document nodes",
        path,
        id,
        hint
      );
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map(
      (item, i) => maybeSerializeView(item, i, path)
    ), viewIds = views2.map((view) => view.id), dupes = uniq(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0)
      throw new SerializeError(
        `document node has views with duplicate IDs: ${dupes.join(",  ")}`,
        path,
        id,
        hint
      );
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec = {}) {
    const builder = new DocumentBuilder(this._context), options = { ...this.spec.options || {}, ...withSpec.options || {} };
    return builder.spec = { ...this.spec, ...withSpec, options }, builder;
  }
}
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  return spec.template && (opts.template = spec.template), spec.templateParameters && (opts.templateParameters = spec.templateParameters), opts;
}
function documentFromEditor(context, spec) {
  let doc = spec != null && spec.type ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const { id, type, template: template2, templateParameters } = spec.options;
  return doc = doc.id(spec.id).documentId(id), type && (doc = doc.schemaType(type)), template2 && (doc = doc.initialValueTemplate(template2, templateParameters)), spec.child && (doc = doc.child(spec.child)), doc;
}
function documentFromEditorWithInitialValue({ resolveDocumentNode, templates }, templateId, parameters) {
  const template2 = templates.find((t) => t.id === templateId);
  if (!template2)
    throw new Error(`Template with ID "${templateId}" not defined`);
  return resolveDocumentNode({ schemaType: template2.schemaType }).initialValueTemplate(
    templateId,
    parameters
  );
}
class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const { spec, _context } = this, { templates } = _context;
    if (typeof spec.id != "string" || !spec.id)
      throw new SerializeError(
        "`id` is required for initial value template item nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!spec.templateId)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const template2 = templates.find((t) => t.id === spec.templateId);
    if (!template2)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template2.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template2.description,
      title: spec.title || template2.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template2.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec = {}) {
    const builder = new InitialValueTemplateItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec }, builder;
  }
}
function defaultInitialValueTemplateItems(context) {
  const { schema: schema2, getStructureBuilder, templates } = context, typeNames = schema2.getTypeNames();
  return templates.filter((tpl) => {
    var _a;
    return !((_a = tpl.parameters) != null && _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)).map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema: schema2, templates } = context;
  return templateItems.map((item) => {
    const template2 = templates.find((t) => t.id === item.templateId), title = item.title || (template2 == null ? void 0 : template2.title) || "Create", params = {};
    template2 && template2.schemaType && (params.type = template2.schemaType), item.templateId && (params.template = item.templateId);
    const intentParams = item.parameters ? [params, item.parameters] : params, schemaType = template2 && schema2.get(template2.schemaType), i18n = item.i18n || (template2 == null ? void 0 : template2.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template2 && template2.icon || (schemaType == null ? void 0 : schemaType.icon) || AddIcon).intent({ type: "create", params: intentParams });
    return i18n && (builder = builder.i18n(i18n)), builder.serialize();
  });
}
const DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent"), defaultIntentChecker = (intentName, params, { pane }) => {
  var _a, _b;
  const isEdit = intentName === "edit", isCreate = intentName === "create", typedSpec = pane, paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "", paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {}, typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams), initialValueTemplates = typedSpec.initialValueTemplates || [];
  return isCreate && params.template ? initialValueTemplates.some((tpl) => tpl.templateId === params.template) : isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
const layoutOptions = ["default", "card", "media", "detail", "block"];
function noChildResolver() {
}
const shallowIntentChecker = (intentName, params, { pane, index }) => index <= 1 && defaultIntentChecker(intentName, params, { pane, index });
class GenericListBuilder {
  constructor() {
    this.initialValueTemplatesSpecified = !1, this.spec = {};
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    return this.initialValueTemplatesSpecified = !0, this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id || "", path = options.path, defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout))
      throw new SerializeError(
        `\`layout\` must be one of ${layoutOptions.map((item) => `"${item}"`).join(", ")}`,
        path,
        id || options.index,
        this.spec.title
      );
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map(
      (item, i) => maybeSerializeInitialValueTemplateItem(item, i, path)
    );
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      i18n: this.spec.i18n,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, path)
      )
    };
  }
}
const validateFilter = (spec, options) => {
  var _a;
  const filter2 = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter2[0]))
    throw new SerializeError(
      `\`filter\` cannot start with \`${filter2[0]}\` - looks like you are providing a query, not a filter`,
      options.path,
      spec.id,
      spec.title
    ).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  return filter2;
}, createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a;
  const parentItem = options.parent, template2 = (_a = options.params) != null && _a.template ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0, type = template2 ? template2.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(
    (schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType("")
  );
};
class DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec != null && spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter2) {
    return this.clone({ options: { ...this.spec.options || {}, filter: filter2 } });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type == "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, params }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering))
      throw new Error("`defaultOrdering` must be an array of order clauses");
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options = { path: [] }) {
    var _a;
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError(
        "`id` is required for document lists",
        options.path,
        options.index,
        this.spec.title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.options || !this.spec.options.filter)
      throw new SerializeError(
        "`filter` is required for document lists",
        options.path,
        this.spec.id,
        this.spec.title
      ).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    return ((_a = this.spec.options) == null ? void 0 : _a.filter) !== "_type == $type" && this.spec.options.filter && !this.spec.options.apiVersion && console.warn(
      `No apiVersion specified for document type list with custom filter: \`${this.spec.options.filter}\`. This will be required in the future. See %s for more info.`,
      generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER)
    ), {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, this.initialValueTemplatesSpecified || (builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec)), builder.spec.schemaTypeName || (builder.spec.schemaTypeName = inferTypeName(builder.spec)), builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
}
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context, { schemaTypeName, options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter2, params)));
  if (typeNames.length !== 0)
    return typeNames.flatMap(
      (schemaType) => document2.resolveNewDocumentOptions({
        type: "structure",
        schemaType
      })
    ).map((option) => ({ ...option, icon: AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = getTypeNamesFromFilter(filter2, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter2, params = {}) {
  let typeNames = getTypeNamesFromEqualityFilter(filter2, params);
  return typeNames.length === 0 && (typeNames = getTypeNamesFromInTypesFilter(filter2, params)), typeNames;
}
function getTypeNamesFromEqualityFilter(filter2, params = {}) {
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g, matches = [];
  let match;
  for (; (match = pattern.exec(filter2)) !== null; )
    matches.push(match[1] || match[2]);
  return matches.map((candidate) => ((candidate[0] === "$" ? params[candidate.slice(1)] : candidate) || "").trim().replace(/^["']|["']$/g, "")).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter2, params = {}) {
  const pattern = /\b_type\s+in\s+\[(.*?)\]/, matches = filter2.match(pattern);
  return matches ? matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean) : [];
}
const getArgType = (thing) => thing instanceof ListBuilder ? "ListBuilder" : isPromise(thing) ? "Promise" : Array.isArray(thing) ? "array" : typeof thing, isListItem = (item) => item.type === "listItem", defaultCanHandleIntent = (intentName, params, context) => (context.pane.items || []).filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context), resolveChildForItem = (itemId, options) => {
  const target = (options.parent.items.filter(isListItem).find((item) => item.id === itemId) || { child: void 0 }).child;
  return !target || typeof target != "function" ? target : typeof target == "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder)
    return item.serialize({ path, index });
  const listItem = item;
  if (listItem && listItem.type === "divider")
    return item;
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem), helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError(
      `List items must be of type "listItem", got "${gotWhat}"${helpText}`,
      path,
      index
    ).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord(thing) && typeof thing.then == "function";
}
class ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for lists",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const items = typeof this.spec.items > "u" ? [] : this.spec.items;
    if (!Array.isArray(items))
      throw new SerializeError(
        "`items` must be an array of items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    const path = (options.path || []).concat(id), serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path)), dupes = serializedItems.filter((val, i) => find(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5), dupeDesc = dupes.length > 5 ? `${dupeIds.join(", ")}...` : dupeIds.join(", ");
      throw new SerializeError(
        `List items with same ID found (${dupeDesc})`,
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    return typeof schemaType == "string" ? this._context.schema.get(schemaType) : this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options = { path: [] }) {
    const { id, title, child } = this.spec;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options.titleIsOptional && (typeof title != "string" || !title))
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(
        HELP_URL.TITLE_REQUIRED
      );
    let schemaType = this.spec.schemaType;
    if (typeof schemaType == "string") {
      const type = this._context.schema.get(schemaType);
      if (!type)
        throw new SerializeError(
          `Could not find type "${schemaType}" in schema`,
          options.path,
          id
        ).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild == "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => originalChild(itemId, { ...childOptions, serializeOptions });
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
const createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType == "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec), this._context = _context, this.spec = spec || {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options = { path: [] }) {
    const spec = super.serialize({ ...options, titleIsOptional: !0 });
    if (!spec.schemaType)
      throw new SerializeError(
        "`schemaType` is required for document list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function isDocumentListItem(item) {
  return isRecord(item) && typeof item.schemaType < "u" && typeof item._id == "string";
}
class DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context), this._context = _context, this.spec = spec || {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context);
    return builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} }, builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context), canHandleIntent = this.spec.canHandleIntent, override = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER ? { canHandleIntent: void 0 } : {};
    return builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec || {},
      ...override
    }, builder;
  }
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes({ schema: schema2 }) {
  return schema2.getTypeNames().filter((n) => {
    const schemaType = schema2.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  return getDocumentTypes(context).map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema: schema2 } = context, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent, parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    return parentItem && parentItem.title && (list = list.title(parentItem.title)), list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema: schema2, resolveDocumentNode } = context, schemaType = typeof typeNameOrSpec == "string" ? typeNameOrSpec : typeNameOrSpec.schemaType, typeName = typeof schemaType == "string" ? schemaType : schemaType.name, spec = typeof typeNameOrSpec == "string" ? { schemaType } : typeNameOrSpec, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(
    spec.menuItemGroups || [
      {
        id: "sorting",
        title: "Sort",
        i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } }
      },
      {
        id: "layout",
        title: "Layout",
        i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } }
      },
      {
        id: "actions",
        title: "Actions",
        i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } }
      }
    ]
  ).child(
    spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))
  ).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(
    spec.menuItems || [
      // Create new (from action button) will be added in serialization step of GenericList
      // Sort by <Y>
      ...getOrderingMenuItemsForSchemaType(context, type),
      // Display as <Z>
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({ layout: "default" }),
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(StackIcon).action("setLayout").params({ layout: "detail" })
      // Create new (from menu) will be added in serialization step of GenericList
    ]
  );
}
function hasIcon(schemaType) {
  return !schemaType || typeof schemaType == "string" ? !1 : !!schemaType.icon;
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder({
  defaultDocumentNode,
  source
}) {
  const configContext = getConfigContextFromSource(source), context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
      return builder.getId() || (builder = builder.id("documentEditor")), options.documentId && (builder = builder.documentId(getPublishedId(options.documentId))), builder.schemaType(options.schemaType);
    }
  }, structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: (...args) => getDocumentTypeList(context, ...args),
    documentTypeListItem: (...args) => getDocumentTypeListItem(context, ...args),
    documentTypeListItems: (...args) => getDocumentTypeListItems(context, ...args),
    document: (...args) => new DocumentBuilder(context, ...args),
    documentWithInitialValueTemplate: (...args) => documentFromEditorWithInitialValue(context, ...args),
    defaultDocument: context.resolveDocumentNode,
    list: (...args) => new ListBuilder(context, ...args),
    listItem: (...args) => new ListItemBuilder(context, ...args),
    menuItem: (...args) => new MenuItemBuilder(context, ...args),
    menuItemGroup: (...args) => new MenuItemGroupBuilder(context, ...args),
    menuItemsFromInitialValueTemplateItems: (...args) => menuItemsFromInitialValueTemplateItems(context, ...args),
    documentList: (...args) => new DocumentListBuilder(context, ...args),
    documentListItem: (...args) => new DocumentListItemBuilder(context, ...args),
    orderingMenuItem: (...args) => getOrderingMenuItem(context, ...args),
    orderingMenuItemsForType: (...args) => getOrderingMenuItemsForSchemaType(context, ...args),
    editor: (...args) => documentFromEditor(context, ...args),
    defaultInitialValueTemplateItems: (...args) => defaultInitialValueTemplateItems(context, ...args),
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => isValidElementType(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec),
    divider: () => ({ id: uniqueId("__divider__"), type: "divider" }),
    view: views,
    context
  };
  return structureBuilder;
}
const tasksLocaleNamespace = "tasks", tasksUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: tasksLocaleNamespace,
  resources: () => import("./resources3.js")
});
function getTargetValue({
  documentId,
  documentType,
  dataset,
  projectId
}) {
  return {
    documentType,
    document: {
      _ref: getPublishedId(documentId),
      _type: "crossDatasetReference",
      _dataset: dataset,
      _projectId: projectId,
      _weak: !0
    }
  };
}
function getMentionedUsers(description) {
  if (!description)
    return [];
  const subscribers = [];
  return description == null || description.forEach((block) => {
    isPortableTextTextBlock(block) && block.children.forEach((child) => {
      child._type === "mention" && typeof child.userId == "string" && !subscribers.includes(child.userId) && subscribers.push(child.userId);
    });
  }), subscribers;
}
const TASK_STATUS = [
  { value: "open", title: "To Do", icon: /* @__PURE__ */ jsx(CircleIcon, {}) },
  { value: "closed", title: "Done", icon: /* @__PURE__ */ jsx(CheckmarkCircleIcon, {}) }
];
function useDocumentPreviewValues(options) {
  var _a;
  const { documentId, documentType } = options || {}, schemaType = useSchema().get(documentType), documentPreviewStore = useDocumentPreviewStore(), previewState = useMemoObservable(() => !documentId || !schemaType ? of(null) : getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), isLoading = (_a = previewState == null ? void 0 : previewState.isLoading) != null ? _a : !0, { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title), subtitle = (draft == null ? void 0 : draft.subtitle) || (published == null ? void 0 : published.subtitle), description = (draft == null ? void 0 : draft.description) || (published == null ? void 0 : published.description), media = (draft == null ? void 0 : draft.media) || (published == null ? void 0 : published.media);
  return {
    isLoading,
    value: {
      title: documentTitle,
      subtitle,
      media,
      description
    }
  };
}
const DATE_FORMAT_OPTIONS = {
  month: "long",
  day: "2-digit",
  minute: "2-digit",
  hour: "2-digit",
  second: "2-digit"
}, RELATIVE_TIME_OPTIONS = {
  minimal: !0,
  useTemporalPhrase: !0
}, Strong = styled.strong`
  font-weight: 600;
`;
function UpdatedTimeAgo(timestamp) {
  const date = new Date(timestamp), formattedDate = useDateTimeFormat(DATE_FORMAT_OPTIONS).format(date);
  return { timeAgo: useRelativeTime(date || "", RELATIVE_TIME_OPTIONS), formattedDate };
}
function UserName({ userId }) {
  const [user, isLoading] = useUser(userId);
  return isLoading ? /* @__PURE__ */ jsx(TextSkeleton, { style: { width: "15ch" } }) : /* @__PURE__ */ jsx(Strong, { children: user == null ? void 0 : user.displayName });
}
const DUE_BY_DATE_OPTIONS = {
  month: "short",
  day: "numeric"
};
function DueByChange({ date }) {
  const dueBy = new Date(date), formattedDate = useDateTimeFormat(DUE_BY_DATE_OPTIONS).format(dueBy);
  return /* @__PURE__ */ jsx(Strong, { children: formattedDate });
}
const LinkWrapper = styled.span`
  > a {
    color: var(--card-fg-muted-color);
    text-decoration: underline;
    text-underline-offset: 1px;
    font-weight: 600;
  }
`;
function TargetContentChange({ target }) {
  const schema2 = useSchema(), documentId = target.document._ref, documentType = target.documentType, documentSchema = schema2.get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  });
  return isLoading ? /* @__PURE__ */ jsx(TextSkeleton, { style: { width: "15ch" } }) : documentSchema ? /* @__PURE__ */ jsx(LinkWrapper, { children: /* @__PURE__ */ jsx(IntentLink, { intent: "edit", params: { id: documentId, type: documentType }, children: value == null ? void 0 : value.title }) }) : null;
}
function getChangeDetails(activity) {
  var _a, _b;
  switch (activity.field) {
    case "status": {
      const statusTitle = (_a = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _a.title;
      return {
        text: "changed status to",
        icon: ((_b = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _b.icon) || /* @__PURE__ */ jsx(CircleIcon, {}),
        changeTo: /* @__PURE__ */ jsx(Strong, { children: statusTitle })
      };
    }
    case "target":
      return activity.to ? {
        text: "set target content to",
        icon: /* @__PURE__ */ jsx(LinkIcon, {}),
        changeTo: /* @__PURE__ */ jsx(TargetContentChange, { target: activity.to })
      } : {
        text: "removed target content",
        icon: /* @__PURE__ */ jsx(LinkIcon, {}),
        changeTo: void 0
      };
    case "dueBy":
      return activity.from ? activity.to ? {
        text: "changed the due date to",
        icon: /* @__PURE__ */ jsx(CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsx(DueByChange, { date: activity.to })
      } : {
        text: "removed the due date",
        icon: /* @__PURE__ */ jsx(CalendarIcon, {}),
        changeTo: void 0
      } : {
        text: "set the due date to",
        icon: /* @__PURE__ */ jsx(CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsx(DueByChange, { date: activity.to })
      };
    case "assignedTo":
      return activity.to ? {
        text: "assigned to",
        icon: /* @__PURE__ */ jsx(UserIcon, {}),
        changeTo: /* @__PURE__ */ jsx(UserName, { userId: activity.to })
      } : {
        text: "unassigned this task",
        icon: /* @__PURE__ */ jsx(UserIcon, {}),
        changeTo: void 0
      };
    case "description":
      return {
        text: "updated the task description",
        icon: /* @__PURE__ */ jsx(EditIcon, {}),
        changeTo: void 0
      };
    case "title":
      return {
        text: "updated the task title",
        icon: /* @__PURE__ */ jsx(EditIcon, {}),
        changeTo: void 0
      };
    default:
      return {
        text: "",
        icon: /* @__PURE__ */ jsx(CircleIcon, {})
      };
  }
}
const EditedAt = memo(
  function(props) {
    const { activity } = props, { formattedDate, timeAgo } = UpdatedTimeAgo(activity.timestamp), { icon, text, changeTo } = getChangeDetails(activity);
    return /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
      /* @__PURE__ */ jsx(Box, { marginTop: 1, marginLeft: 1, marginRight: 3, children: /* @__PURE__ */ jsx(Box, { marginRight: 1, children: /* @__PURE__ */ jsx(Text, { children: icon }) }) }),
      /* @__PURE__ */ jsxs(Text, { muted: !0, size: 1, children: [
        /* @__PURE__ */ jsx(UserName, { userId: activity.author }),
        " ",
        text,
        " ",
        changeTo,
        " \u2022",
        " ",
        /* @__PURE__ */ jsx(Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsx("time", { dateTime: formattedDate, children: timeAgo }) })
      ] })
    ] });
  },
  (prevProps, nextProps) => prevProps.activity.timestamp === nextProps.activity.timestamp
), AvatarRoot = styled.div(
  (props) => {
    var _a, _b;
    const theme = getTheme_v2(props.theme);
    return css`
      min-height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
      min-width: ${(_b = theme.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      ${props.$border ? "box-shadow: inset 0 0 0 1px var(--card-border-color);" : ""};
      ${props.$removeBg ? "--card-avatar-gray-bg-color: transparent;" : ""}
    `;
  }
), AvatarSkeleton = styled(Skeleton)((props) => {
  var _a, _b;
  const theme = getTheme_v2(props.theme);
  return css`
    height: ${(_a = theme.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
    width: ${(_b = theme.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
    border-radius: 50%;
  `;
});
function TasksUserAvatar(props) {
  const { user, size = 0, border = !0 } = props, [loadedUser, loading] = useUser((user == null ? void 0 : user.id) || "");
  return loading ? /* @__PURE__ */ jsx(AvatarSkeleton, { $size: size, animated: !0 }) : !user || !loadedUser ? /* @__PURE__ */ jsx(AvatarRoot, { $size: size, $border: border, children: /* @__PURE__ */ jsx(Text, { size, children: /* @__PURE__ */ jsx(UserIcon, {}) }) }) : /* @__PURE__ */ jsx(AvatarRoot, { $size: size, $removeBg: !!(loadedUser != null && loadedUser.imageUrl), children: /* @__PURE__ */ jsx(
    UserAvatar,
    {
      user: loadedUser,
      size,
      ...loadedUser != null && loadedUser.imageUrl ? { color: void 0 } : {}
    }
  ) });
}
const ActivityItemChildrenContainer = styled.div`
  width: 100%;
`;
function ActivityItem({ userId, children }) {
  return /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    /* @__PURE__ */ jsx(Box, { marginRight: 3, paddingTop: 1, children: /* @__PURE__ */ jsx(TasksUserAvatar, { user: { id: userId }, size: 0 }) }),
    /* @__PURE__ */ jsx(ActivityItemChildrenContainer, { children })
  ] });
}
function TasksActivityCommentInput(props) {
  const { mentionOptions, currentUser, onSubmit } = props, [value, setValue] = useState(null), editorRef = useRef(null), hasValue = useMemo(() => hasCommentMessageValue(value), [value]), handleChange = useCallback((nextValue) => {
    setValue(nextValue);
  }, []), handleSubmit = useCallback(() => {
    hasValue && (onSubmit(value), setValue(null));
  }, [hasValue, onSubmit, value]), handleDiscardCancel = useCallback(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = useCallback(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close(), setValue(null);
  }, []), handleKeyDown = useCallback(
    (e) => {
      var _a, _b;
      e.key === "Escape" && (e.preventDefault(), e.stopPropagation(), hasValue ? (_a = editorRef.current) == null || _a.discardDialogController.open() : ((_b = editorRef.current) == null || _b.discardDialogController.close(), setValue(null)));
    },
    [hasValue]
  ), { t } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsx(ActivityItem, { userId: currentUser.id, children: /* @__PURE__ */ jsx(Card, { tone: "transparent", radius: 3, padding: 2, children: /* @__PURE__ */ jsx(
    CommentInput,
    {
      withAvatar: !1,
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onChange: handleChange,
      onDiscardConfirm: handleDiscardConfirm,
      onDiscardCancel: handleDiscardCancel,
      onKeyDown: handleKeyDown,
      onSubmit: handleSubmit,
      placeholder: t("panel.comment.placeholder"),
      ref: editorRef,
      value
    }
  ) }) });
}
const COMMENTS_LIST_ITEM_AVATAR_CONFIG = {
  parentCommentAvatar: !1,
  threadCommentsAvatar: !0,
  replyAvatar: !0,
  avatarSize: 0
};
function TasksActivityCommentItem(props) {
  const { parentComment } = props;
  return /* @__PURE__ */ jsx(ActivityItem, { userId: parentComment.authorId, children: /* @__PURE__ */ jsx(
    CommentsListItem,
    {
      ...props,
      avatarConfig: COMMENTS_LIST_ITEM_AVATAR_CONFIG,
      canReply: !0,
      innerPadding: 1,
      isSelected: !1,
      mode: "default"
    }
  ) });
}
const UserSkeleton = styled(TextSkeleton)`
  max-width: 15ch;
  width: '100%';
`, TasksActivityCreatedAt = memo(
  function(props) {
    var _a;
    const { createdAt, authorId } = props, [user, loading] = useUser(authorId), { timeAgo, formattedDate } = UpdatedTimeAgo(createdAt), { t } = useTranslation(tasksLocaleNamespace);
    return /* @__PURE__ */ jsx(ActivityItem, { userId: authorId, children: /* @__PURE__ */ jsx(Flex, { align: "center", paddingTop: 1, children: /* @__PURE__ */ jsxs(Text, { size: 1, muted: !0, children: [
      /* @__PURE__ */ jsxs("strong", { style: { fontWeight: 600 }, children: [
        loading ? /* @__PURE__ */ jsx(UserSkeleton, {}) : (_a = user == null ? void 0 : user.displayName) != null ? _a : t("panel.activity.unknown-user"),
        " "
      ] }),
      t("panel.activity.created-fragment"),
      " \u2022",
      " ",
      /* @__PURE__ */ jsx(Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsx("time", { dateTime: createdAt, children: timeAgo }) })
    ] }) }) });
  },
  (prevProps, nextProps) => prevProps.createdAt === nextProps.createdAt
);
function TasksSubscribers(props) {
  var _a, _b;
  const { value, onChange, path, currentUserId } = props, buttonText = (_a = value.subscribers) != null && _a.includes(currentUserId) ? "Unsubscribe" : "Subscribe", handleToggleSubscribe = useCallback(() => {
    const subscribers = value.subscribers || [];
    subscribers.includes(currentUserId) || onChange(set(subscribers.concat(currentUserId), path)), subscribers.includes(currentUserId) && onChange(
      set(
        subscribers.filter((subscriberId) => subscriberId !== currentUserId),
        path
      )
    );
  }, [value.subscribers, currentUserId, onChange, path]);
  return /* @__PURE__ */ jsxs(Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsx(Button, { mode: "bleed", text: buttonText, onClick: handleToggleSubscribe }),
    value.subscribers && ((_b = value.subscribers) == null ? void 0 : _b.length) > 0 && /* @__PURE__ */ jsx(TasksSubscriberAvatars, { subscriberIds: value.subscribers })
  ] });
}
const EMPTY_ARRAY$4 = [];
function TasksSubscriberAvatars(props) {
  const { subscriberIds: subscriberIdsProp } = props, subscriberIds = useMemo(() => (subscriberIdsProp == null ? void 0 : subscriberIdsProp.filter(Boolean)) || EMPTY_ARRAY$4, [subscriberIdsProp]);
  return /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, children: /* @__PURE__ */ jsx(AvatarStack, { maxLength: 3, size: 0, children: subscriberIds.map((subscriberId) => /* @__PURE__ */ jsx(
    motion.div,
    {
      exit: { opacity: 0, translateX: "2px", scale: 0.9 },
      animate: {
        opacity: 1,
        translateX: 0,
        scale: 1,
        transition: { type: "just", duration: 0.2 }
      },
      initial: { opacity: 0, translateX: "2px", scale: 0.9 },
      children: /* @__PURE__ */ jsx(TasksUserAvatar, { user: { id: subscriberId }, size: 0 })
    },
    subscriberId
  )) }) });
}
const EMPTY_ARRAY$3 = [], VARIANTS$2 = {
  hidden: { opacity: 0, x: 0 },
  visible: { opacity: 1, x: 0 }
}, MotionStack = styled(motion(Stack))``;
function TasksActivityLog(props) {
  const { value, onChange, path, activityData = [] } = props, currentUser = useCurrentUser(), { title: workspaceTitle, basePath } = useWorkspace(), { comments: comments2, mentionOptions, operation, getComment } = useComments(), [commentToDeleteId, setCommentToDeleteId] = useState(null), [commentDeleteError, setCommentDeleteError] = useState(null), [commentDeleteLoading, setCommentDeleteLoading] = useState(!1), loading = comments2.loading, taskComments = comments2.data.open, handleGetNotificationValue = useCallback(
    (message, commentId) => {
      const studioUrl = new URL(`${window.location.origin}${basePath ? `${basePath}/` : ""}`);
      studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", value == null ? void 0 : value._id), studioUrl.searchParams.set("viewMode", "edit"), studioUrl.searchParams.set("commentId", commentId);
      const mentionedUsers = getMentionedUsers(message), subscribers = Array.from(/* @__PURE__ */ new Set([...value.subscribers || [], ...mentionedUsers]));
      return {
        documentTitle: value.title || "Sanity task",
        url: studioUrl.toString(),
        workspaceTitle,
        subscribers
      };
    },
    [basePath, value == null ? void 0 : value._id, value.title, workspaceTitle, value.subscribers]
  ), handleCommentCreate = useCallback(
    (message) => {
      const commentId = uuid(), notification = handleGetNotificationValue(message, commentId), nextComment = {
        id: commentId,
        type: "task",
        message,
        parentCommentId: void 0,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: uuid(),
        context: {
          notification
        }
      };
      onChange(set(notification.subscribers, ["subscribers"])), operation.create(nextComment);
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentReply = useCallback(
    (nextComment) => {
      const commentId = uuid(), notification = handleGetNotificationValue(nextComment.message, commentId);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        id: commentId,
        type: "task",
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: nextComment.threadId,
        context: {
          notification
        }
      });
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentCreateRetry = useCallback(
    (id) => {
      const comment = getComment(id);
      if (!comment)
        return;
      const notification = handleGetNotificationValue(comment.message, comment._id);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        type: "task",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || EMPTY_ARRAY$3,
        status: comment.status,
        threadId: comment.threadId,
        context: {
          notification
        }
      });
    },
    [getComment, operation, handleGetNotificationValue, onChange]
  ), handleCommentReact = useCallback(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeleteCommentStart = useCallback((id) => setCommentToDeleteId(id), []), handleDeleteCommentCancel = useCallback(() => setCommentToDeleteId(null), []), handleDeleteCommentConfirm = useCallback(
    async (id) => {
      try {
        setCommentDeleteLoading(!0), setCommentDeleteError(null), await operation.remove(id), setCommentToDeleteId(null);
      } catch (err) {
        setCommentDeleteError(err);
      } finally {
        setCommentDeleteLoading(!1);
      }
    },
    [operation]
  ), handleCommentEdit = useCallback(
    (id, next) => {
      operation.update(id, next);
    },
    [operation]
  ), activity = useMemo(() => {
    const taskActivity = activityData.map((item) => ({
      _type: "activity",
      payload: item,
      timestamp: item.timestamp
    })), commentsActivity = taskComments.map((comment) => ({
      _type: "comment",
      payload: comment,
      timestamp: comment.parentComment._createdAt
    }));
    return taskActivity.concat(commentsActivity).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  }, [activityData, taskComments]), { t } = useTranslation(tasksLocaleNamespace), commentToDeleteIsParent = useMemo(() => {
    var _a;
    const parent = taskComments.find((c) => {
      var _a2;
      return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === commentToDeleteId;
    });
    return !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
  }, [commentToDeleteId, taskComments]);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    commentToDeleteId && /* @__PURE__ */ jsx(
      CommentDeleteDialog,
      {
        commentId: commentToDeleteId,
        error: commentDeleteError,
        isParent: commentToDeleteIsParent,
        loading: commentDeleteLoading,
        onClose: handleDeleteCommentCancel,
        onConfirm: handleDeleteCommentConfirm
      }
    ),
    /* @__PURE__ */ jsxs(Stack, { space: 5, children: [
      /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
        /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { size: 2, weight: "semibold", children: t("panel.activity.title") }) }),
        (currentUser == null ? void 0 : currentUser.id) && /* @__PURE__ */ jsx(
          TasksSubscribers,
          {
            currentUserId: currentUser.id,
            value,
            onChange,
            path
          }
        )
      ] }),
      loading && /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: "Loading activity" }),
      /* @__PURE__ */ jsx(AnimatePresence, { children: !loading && /* @__PURE__ */ jsxs(MotionStack, { animate: "visible", initial: "hidden", space: 4, variants: VARIANTS$2, children: [
        value.createdByUser && /* @__PURE__ */ jsx(Stack, { paddingBottom: 1, children: /* @__PURE__ */ jsx(
          TasksActivityCreatedAt,
          {
            createdAt: value.createdByUser,
            authorId: value.authorId
          }
        ) }),
        currentUser && /* @__PURE__ */ jsxs(Stack, { space: 4, marginTop: 1, children: [
          activity.map((item) => item._type === "activity" ? /* @__PURE__ */ jsx(EditedAt, { activity: item.payload }, item.timestamp) : /* @__PURE__ */ jsx(
            TasksActivityCommentItem,
            {
              currentUser,
              mentionOptions,
              onCreateRetry: handleCommentCreateRetry,
              onDelete: handleDeleteCommentStart,
              onEdit: handleCommentEdit,
              onReactionSelect: handleCommentReact,
              onReply: handleCommentReply,
              parentComment: item.payload.parentComment,
              replies: item.payload.replies
            },
            item.payload.parentComment._id
          )),
          /* @__PURE__ */ jsx(
            TasksActivityCommentInput,
            {
              currentUser,
              mentionOptions,
              onSubmit: handleCommentCreate
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
const TasksEnabledContext = createContext(null);
function TasksEnabledProvider({ children }) {
  var _a;
  const { enabled, isLoading } = useFeatureEnabled("sanityTasks"), { enabled: stagingIsEnabled, isLoading: stagingIsLoading } = useFeatureEnabled("studioTasks"), isWorkspaceEnabled = (_a = useWorkspace().tasks) == null ? void 0 : _a.enabled, value = useMemo(() => !isWorkspaceEnabled || isLoading || stagingIsLoading ? {
    enabled: !1,
    mode: null
  } : stagingIsEnabled || enabled ? {
    enabled: !0,
    mode: "default"
  } : {
    enabled: !1,
    mode: null
  }, [enabled, isLoading, isWorkspaceEnabled, stagingIsEnabled, stagingIsLoading]);
  return /* @__PURE__ */ jsx(TasksEnabledContext.Provider, { value, children });
}
function useTasksEnabled() {
  const context = useContext(TasksEnabledContext);
  if (!context)
    throw new Error("useTasks must be used within a TasksEnabledProvider");
  return context;
}
const MentionUserContext = createContext(null);
function MentionUserProvider(props) {
  const [selectedDocument, setSelectedDocument] = useState(null), mentionOptions = useUserListWithPermissions({
    documentValue: selectedDocument,
    permission: "read"
  }), value = useMemo(
    () => ({
      mentionOptions,
      selectedDocument,
      setSelectedDocument
    }),
    [mentionOptions, selectedDocument, setSelectedDocument]
  );
  return /* @__PURE__ */ jsx(MentionUserContext.Provider, { value, children: props.children });
}
function useMentionUser() {
  const context = useContext(MentionUserContext);
  if (!context)
    throw new Error("useMentionUser must be used within a MentionUserProvider");
  return context;
}
const TasksNavigationContext = createContext(null), initialState = {
  viewMode: "list",
  selectedTask: null,
  activeTabId: "assigned",
  duplicateTaskValues: null,
  isOpen: !1
};
function reducer(state2, action) {
  switch (action.type) {
    case "TOGGLE_TASKS_VIEW":
      return action.payload === !1 ? {
        ...initialState,
        isOpen: action.payload
      } : {
        ...state2,
        isOpen: action.payload
      };
    case "CREATE_TASK":
      return {
        ...state2,
        viewMode: "create",
        selectedTask: uuid()
      };
    case "EDIT_TASK":
      return {
        ...state2,
        viewMode: "edit",
        selectedTask: action.payload.id
      };
    case "EDIT_DRAFT":
      return {
        ...state2,
        viewMode: "draft",
        selectedTask: action.payload.id
      };
    case "DUPLICATE_TASK":
      return {
        ...state2,
        viewMode: "duplicate",
        selectedTask: uuid(),
        duplicateTaskValues: action.payload.duplicateTaskValues
      };
    case "SET_ACTIVE_TAB":
      return {
        ...state2,
        viewMode: "list",
        activeTabId: action.payload
      };
    case "NAVIGATE_TO_LIST":
      return {
        ...state2,
        viewMode: "list"
      };
    default:
      return state2;
  }
}
const TasksNavigationProvider = ({ children }) => {
  const [state2, dispatch] = useReducer(reducer, initialState), router2 = useRouter(), toast = useToast(), setViewMode = useCallback((viewMode) => {
    switch (viewMode.type) {
      case "list":
        dispatch({ type: "NAVIGATE_TO_LIST" });
        break;
      case "create":
        dispatch({ type: "CREATE_TASK" });
        break;
      case "edit":
        dispatch({ type: "EDIT_TASK", payload: { id: viewMode.id } });
        break;
      case "duplicate":
        dispatch({
          type: "DUPLICATE_TASK",
          payload: { duplicateTaskValues: viewMode.duplicateTaskValues }
        });
        break;
      case "draft":
        dispatch({ type: "EDIT_DRAFT", payload: { id: viewMode.id } });
        break;
    }
  }, []), setActiveTab = useCallback((tabId) => {
    dispatch({ type: "SET_ACTIVE_TAB", payload: tabId });
  }, []), handleCloseTasks = useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !1 });
  }, []), handleOpenTasks = useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
  }, []), handleCopyLinkToTask = useCallback(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("sidebar", "tasks"), url.searchParams.set("viewMode", state2.viewMode), state2.selectedTask && url.searchParams.set("selectedTask", state2.selectedTask), navigator.clipboard.writeText(url.toString()).then(() => {
      toast.push({
        closable: !0,
        status: "info",
        title: "Copied link to clipboard"
      });
    }).catch(() => {
      toast.push({
        closable: !0,
        status: "error",
        title: "Failed to copy link to clipboard"
      });
    });
  }, [state2.selectedTask, state2.viewMode, toast]), searchParamsAsString = new URLSearchParams(router2.state._searchParams).toString();
  return useEffect(() => {
    if (searchParamsAsString) {
      const searchParams = new URLSearchParams(searchParamsAsString);
      if (searchParams.get("sidebar") !== "tasks")
        return;
      dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
      const viewMode = searchParams.get("viewMode"), selectedTask = searchParams.get("selectedTask");
      viewMode === "edit" && selectedTask && dispatch({ type: "EDIT_TASK", payload: { id: selectedTask } });
    }
  }, [searchParamsAsString]), /* @__PURE__ */ jsx(
    TasksNavigationContext.Provider,
    {
      value: {
        state: state2,
        setViewMode,
        setActiveTab,
        handleCloseTasks,
        handleOpenTasks,
        handleCopyLinkToTask
      },
      children
    }
  );
};
function useTasksNavigation() {
  return useContext(TasksNavigationContext) || {
    state: {
      activeTabId: "assigned",
      viewMode: "list",
      selectedTask: null,
      isOpen: !1,
      duplicateTaskValues: null
    },
    setActiveTab: () => null,
    setViewMode: () => null,
    handleCloseTasks: () => null,
    handleCopyLinkToTask: () => null,
    handleOpenTasks: () => null
  };
}
const TasksContext = createContext(null);
function createTasksSet(tasks2) {
  return tasks2.reduce((acc, task) => ({ ...acc, [task._id]: task }), {});
}
function tasksReducer(state2, action) {
  switch (action.type) {
    case "TASKS_SET": {
      const tasksById = createTasksSet(action.tasks);
      return {
        ...state2,
        tasks: tasksById
      };
    }
    case "TASK_ADDED": {
      const nextTaskResult = action.payload, nextTaskValue = nextTaskResult, nextTask = {
        [nextTaskResult._id]: {
          ...state2.tasks[nextTaskResult._id],
          ...nextTaskValue,
          _state: nextTaskResult._state || void 0,
          // If the task is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the tasks correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the task.
          // Once the task is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextTaskResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          ...nextTask
        }
      };
    }
    case "TASK_RECEIVED": {
      const nextTaskResult = action.payload;
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [nextTaskResult._id]: nextTaskResult
        }
      };
    }
    case "TASK_DELETED": {
      const { [action.id]: _, ...restTasks } = state2.tasks;
      return {
        ...state2,
        tasks: restTasks
      };
    }
    case "TASK_UPDATED": {
      const updatedTask = action.payload, id = updatedTask._id, nextTask = {
        // Add existing task data
        ...state2.tasks[id],
        // Add incoming task data
        ...updatedTask
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [id]: nextTask
        }
      };
    }
    default:
      return state2;
  }
}
const INITIAL_STATE = {
  tasks: {}
}, LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD = "_createdAt", SORT_ORDER = "desc", QUERY_FILTERS = ['_type == "tasks.task"'], QUERY_PROJECTION = `{
  ...,
}`, QUERY_SORT_ORDER = `order(${SORT_FIELD} ${SORT_ORDER})`, QUERY = `*[${QUERY_FILTERS.join(" && ")}] ${QUERY_PROJECTION} | ${QUERY_SORT_ORDER}`;
function useTasksStore(opts) {
  const { client } = useAddonDataset(), { documentId } = opts, [state2, dispatch] = useReducer(tasksReducer, INITIAL_STATE), [isLoading, setIsLoading] = useState(client !== null), [error, setError] = useState(null), params = useMemo(
    () => ({ documentId: documentId ? getPublishedId(documentId) : null }),
    [documentId]
  ), initialFetch = useCallback(async () => {
    if (!client) {
      setIsLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "TASKS_SET", tasks: res }), setIsLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = useCallback(
    async (event) => {
      if (event.type === "welcome" && (setIsLoading(!0), await initialFetch(), setIsLoading(!1)), event.type === "reconnect" && setIsLoading(!0), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextTask = event.result;
          nextTask && dispatch({
            type: "TASK_RECEIVED",
            payload: nextTask
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "TASK_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedTask = event.result;
          updatedTask && dispatch({
            type: "TASK_UPDATED",
            payload: updatedTask
          });
        }
      }
    },
    [initialFetch]
  ), listener$ = useMemo(() => client ? client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(
    catchError((err) => (setError(err), of(err)))
  ) : of(), [client, params]);
  return useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: useMemo(() => Object.values(state2.tasks), [state2.tasks]),
    dispatch,
    error,
    isLoading
  };
}
const EMPTY_ARRAY$2 = [];
function TasksProvider(props) {
  const { children } = props, [activeDocument, setActiveDocument] = useState(null), { data = EMPTY_ARRAY$2, isLoading } = useTasksStore({}), value = useMemo(
    () => ({
      activeDocument,
      setActiveDocument,
      isLoading,
      data: data != null ? data : []
    }),
    [activeDocument, data, isLoading]
  );
  return /* @__PURE__ */ jsx(TasksContext.Provider, { value, children });
}
function useTasks() {
  return useContext(TasksContext) || {
    activeDocument: null,
    setActiveDocument: () => null,
    data: [],
    isLoading: !1
  };
}
const API_VERSION = "2024-03-05";
function MentionUserMenuItem(props) {
  const { user, onSelect, pressed } = props, { t } = useTranslation(tasksLocaleNamespace), handleSelect = useCallback(() => onSelect(user.id), [user, onSelect]);
  return /* @__PURE__ */ jsx(MenuItem$1, { onClick: handleSelect, padding: 1, disabled: !user.granted, pressed, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, flex: 1, children: [
      /* @__PURE__ */ jsx(TasksUserAvatar, { user: user.id ? user : void 0, size: 1 }),
      /* @__PURE__ */ jsx(Text, { size: 1, textOverflow: "ellipsis", title: user.displayName, children: user.displayName })
    ] }),
    !user.granted && /* @__PURE__ */ jsx(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
  ] }) });
}
const StyledMenu$1 = styled(Menu)`
  width: 308px;
  border-radius: 3px;
`, IGNORED_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
], NO_ASSIGNEE_OPTION = {
  id: "",
  displayName: "No assignee",
  granted: !0
};
function MentionsMenu({ onSelect, value = "" }) {
  const [searchTerm, setSearchTerm] = useState(""), { mentionOptions } = useMentionUser(), inputRef = useRef(null), options = [NO_ASSIGNEE_OPTION].concat(mentionOptions.data || []), handleSearchChange = useCallback((event) => {
    setSearchTerm(event.currentTarget.value);
  }, []), filteredOptions = useMemo(() => {
    var _a;
    if (!searchTerm)
      return options || [];
    const deburredSearchTerm = deburr(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      searchName: deburr(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => option == null ? void 0 : option.searchName.includes(deburredSearchTerm))) == null ? void 0 : _a.sort((a, b) => {
      const matchA = a.searchName.startsWith(deburredSearchTerm), matchB = b.searchName.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || [];
  }, [options, searchTerm]), renderItem2 = useCallback(
    (user) => /* @__PURE__ */ jsx(
      MentionUserMenuItem,
      {
        user,
        onSelect,
        pressed: user.id === value
      },
      user.id
    ),
    [onSelect, value]
  ), handleKeyDown = useCallback((event) => {
    var _a;
    event.target !== inputRef.current && (IGNORED_KEYS.includes(event.key) || (_a = inputRef.current) == null || _a.focus());
  }, []), { t } = useTranslation(tasksLocaleNamespace);
  return mentionOptions.loading ? /* @__PURE__ */ jsx(Container, { width: 0, children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) }) : /* @__PURE__ */ jsxs("div", { onKeyDown: handleKeyDown, children: [
    /* @__PURE__ */ jsx(
      TextInput,
      {
        placeholder: t("form.input.assignee.search.placeholder"),
        autoFocus: !0,
        border: !1,
        onChange: handleSearchChange,
        value: searchTerm,
        fontSize: 1,
        icon: UserIcon,
        ref: inputRef
      }
    ),
    /* @__PURE__ */ jsx("div", { style: { maxHeight: "320px", overflowY: "scroll", paddingTop: "8px" }, children: filteredOptions.length === 0 ? /* @__PURE__ */ jsx(Box, { padding: 3, children: /* @__PURE__ */ jsx(Text, { align: "center", size: 1, muted: !0, children: t("form.input.assignee.search.no-users.text") }) }) : filteredOptions.map(renderItem2) })
  ] });
}
function AssigneeSelectionMenu(props) {
  const { onSelect, menuButton, value } = props;
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: menuButton,
      id: "assign-user-menu",
      menu: /* @__PURE__ */ jsx(StyledMenu$1, { children: /* @__PURE__ */ jsx(MentionsMenu, { onSelect, value }) }),
      popover: {
        placement: "bottom",
        portal: !0
      }
    }
  );
}
const FocusableCard = styled(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    &[data-as='button'] {
      border: 1px solid var(--card-border-color);
      &:focus-within {
        border: 1px solid var(--card-focus-ring-color);
      }
      --card-muted-fg-color: ${theme.color.input.default.enabled.placeholder};
    }
  `;
});
function AssigneeCreateFormField(props) {
  const { value, onChange } = props, { mentionOptions } = useMentionUser(), mentionedUser = useMemo(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), onSelect = useCallback((userId) => onChange(set(userId)), [onChange]), { t } = useTranslation(tasksLocaleNamespace), displayText = useMemo(() => {
    if (value) {
      if (mentionOptions.loading)
        return /* @__PURE__ */ jsx(TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.search.placeholder");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return /* @__PURE__ */ jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsx(FocusableCard, { "data-as": "button", padding: 1, radius: 2, tabIndex: 0, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, flex: 1, children: [
          /* @__PURE__ */ jsx(TasksUserAvatar, { user: mentionedUser, size: 1, border: !1 }),
          /* @__PURE__ */ jsx(Text, { size: 1, textOverflow: "ellipsis", muted: !mentionedUser, children: displayText })
        ] }),
        value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsx(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
const StyledButton = styled(Button$1)`
  padding: 3px 6px;
`;
function AssigneeEditFormField(props) {
  const { value, onChange, path } = props, subscribers = useFormValue(["subscribers"]), { mentionOptions } = useMentionUser(), mentionedUser = useMemo(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), { t } = useTranslation(tasksLocaleNamespace), onSelect = useCallback(
    (userId) => {
      onChange(set(userId, path)), subscribers && !subscribers.includes(userId) && userId && onChange(set([...subscribers, userId], ["subscribers"]));
    },
    [onChange, path, subscribers]
  ), displayText = useMemo(() => {
    if (value) {
      if (mentionOptions.loading)
        return /* @__PURE__ */ jsx(TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.no-user-assigned.text");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return /* @__PURE__ */ jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsx(StyledButton, { mode: "ghost", padding: 0, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, flex: 1, children: [
          /* @__PURE__ */ jsx(TasksUserAvatar, { user: mentionedUser, size: 0 }),
          /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, textOverflow: "ellipsis", children: displayText }) })
        ] }),
        value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsx(Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
const serialize = (date) => format(date, DEFAULT_DATE_FORMAT), deserialize = (value) => parse(value, DEFAULT_DATE_FORMAT);
function DateEditFormField(props) {
  var _a;
  const { value, onChange, path } = props, { t: coreT } = useTranslation(), { t } = useTranslation(tasksLocaleNamespace), [pickerOpen, setPickerOpen] = useState(!1), [popoverRef, setPopoverRef] = useState(null), buttonRef = useRef(null), dateFormatter = useDateTimeFormat({ dateStyle: "long" }), dueByeDisplayValue = useMemo(() => {
    if (!value)
      return { short: "----", full: "----" };
    const dueFormated = dateFormatter.format(new Date(value)), [monthAndDay] = dueFormated.split(",");
    return { short: monthAndDay, full: dueFormated };
  }, [dateFormatter, value]);
  useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleKeyUp = useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = useCallback(() => setPickerOpen((p) => !p), []), calendarLabels = useMemo(() => getCalendarLabels(coreT), [coreT]), handleChange = useCallback(
    (nextDate) => {
      onChange(nextDate ? set(serialize(nextDate), path) : unset(path)), setPickerOpen(!1);
    },
    [onChange, path]
  ), deserializedValue = deserialize(value), handleDeactivation = useCallback(() => {
    var _a2;
    (_a2 = buttonRef.current) == null || _a2.focus();
  }, [buttonRef]), dueDateIsThisYear = ((_a = deserializedValue == null ? void 0 : deserializedValue.date) == null ? void 0 : _a.getFullYear()) === (/* @__PURE__ */ new Date()).getFullYear();
  return /* @__PURE__ */ jsx(
    Popover,
    {
      constrainSize: !0,
      "data-testid": "date-input-dialog",
      portal: !0,
      ref: setPopoverRef,
      content: /* @__PURE__ */ jsx(Box, { overflow: "auto", children: /* @__PURE__ */ jsxs(FocusLock, { onDeactivation: handleDeactivation, children: [
        /* @__PURE__ */ jsx(
          DatePicker,
          {
            calendarLabels,
            selectTime: !1,
            timeStep: 1,
            onKeyUp: handleKeyUp,
            value: deserializedValue.date,
            onChange: handleChange
          }
        ),
        value && /* @__PURE__ */ jsx(Flex, { justify: "flex-start", padding: 3, paddingTop: 0, children: /* @__PURE__ */ jsx(
          Button,
          {
            mode: "bleed",
            text: t("form.input.date.buttons.remove.text"),
            onClick: () => handleChange(null),
            tone: "critical"
          }
        ) })
      ] }) }),
      open: pickerOpen,
      placement: "bottom",
      fallbackPlacements: ["bottom-start", "bottom-end"],
      children: /* @__PURE__ */ jsx(
        Button,
        {
          icon: CalendarIcon,
          mode: "ghost",
          text: dueDateIsThisYear ? dueByeDisplayValue.short : dueByeDisplayValue.full,
          onClick: handleClick,
          ref: buttonRef
        }
      )
    }
  );
}
const NormalText = styled(Text)`
  word-break: break-word;
`;
function DescriptionInputBlock(props) {
  const { children } = props;
  return /* @__PURE__ */ jsx(Box, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsx(NormalText, { size: 1, children }) });
}
const renderBlock = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsx(DescriptionInputBlock, { children });
}, DescriptionInputRoot = styled.div((props) => {
  const theme = getTheme_v2(props.theme), verticalPadding = props.$mode === "edit" ? theme.space[1] : theme.space[3];
  return css`
    /* select editable-wrap and change the padding */
    [data-ui='editable-wrap'] {
      overflow: hidden;
      padding: ${props.$mode === "edit" ? `${verticalPadding}px 0px` : `${verticalPadding}px ${theme.space[2]}px`};
      min-height: ${Math.max(props.$minHeight + verticalPadding, 200)}px !important;
    }
    #comment-input-root {
      box-shadow: ${props.$mode === "edit" ? "none" : ""};
    }
    [data-ui='CommentInputActions'] {
      display: none !important;
    }
  `;
});
function DescriptionInput(props) {
  const {
    value: _propValue,
    mode,
    inputProps: { onChange }
  } = props, value = _propValue, currentUser = useCurrentUser(), { mentionOptions } = useMentionUser(), handleChange = useCallback((next) => onChange(set(next)), [onChange]), [rootRef, setRootRef] = useState(null), [textBoxScrollHeight, setTextBoxScrollHeight] = useState(200), setTextboxHeight = useCallback((ref) => {
    const textBox = ref.querySelector('[role="textbox"]');
    if (!textBox)
      return;
    const height = textBox.scrollHeight;
    setTextBoxScrollHeight(height);
  }, []), handleSetRootRef = useCallback((ref) => {
    ref && startTransition(() => {
      setRootRef(ref);
    });
  }, []), { t } = useTranslation(tasksLocaleNamespace);
  return useEffect(() => {
    rootRef && setTextboxHeight(rootRef);
  }, [value, setTextboxHeight, rootRef]), currentUser ? /* @__PURE__ */ jsx(
    DescriptionInputRoot,
    {
      $mode: mode,
      ref: handleSetRootRef,
      $minHeight: textBoxScrollHeight || 200,
      children: /* @__PURE__ */ jsx(
        CommentInput,
        {
          expandOnFocus: !1,
          currentUser,
          mentionOptions,
          onChange: handleChange,
          value: value != null ? value : [],
          withAvatar: !1,
          placeholder: t("form.input.description.placeholder"),
          onDiscardConfirm: () => null,
          renderBlock
        }
      )
    }
  ) : null;
}
const FieldWrapperRoot = styled.div((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    // Reset the padding of the field header content box
    [data-ui='fieldHeaderContentBox'] {
      padding: 0;
      label {
        font-weight: ${theme.font.text.weights.regular};
      }
    }
  `;
});
function FieldWrapper(props) {
  return /* @__PURE__ */ jsx(FieldWrapperRoot, { children: props.renderDefault(props) });
}
const StatusMenuButton = forwardRef(function(props, ref) {
  var _a;
  const { value, options, ...rest } = props, selectedOption = options.find((option) => option.value === value), icon = (_a = TASK_STATUS.find((status) => status.value === value)) == null ? void 0 : _a.icon;
  return /* @__PURE__ */ jsx(
    Button,
    {
      ...rest,
      ref,
      tooltipProps: null,
      icon,
      text: (selectedOption == null ? void 0 : selectedOption.title) || value,
      tone: "default",
      mode: "ghost"
    }
  );
});
function StatusSelector(props) {
  const { value, onChange, options, path } = props;
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(StatusMenuButton, { value, options }),
      id: "reference-menuButton",
      menu: /* @__PURE__ */ jsx(Menu, { children: options.map((option) => {
        var _a;
        const isSelected = value === option.value, icon = (_a = TASK_STATUS.find((status) => status.value === option.value)) == null ? void 0 : _a.icon;
        return /* @__PURE__ */ jsx(
          MenuItem,
          {
            icon: isString$1(option.value) ? icon || CircleIcon : CircleIcon,
            text: option.title || option.value,
            pressed: isSelected,
            iconRight: isSelected && /* @__PURE__ */ jsx(CheckmarkIcon, {}),
            onClick: () => onChange(set(option.value, path))
          },
          option.title
        );
      }) })
    }
  );
}
function ConfigErrorsScreen() {
  return /* @__PURE__ */ jsx("div", { children: "Config errors" });
}
function CurrentWorkspaceProvider({ children }) {
  return /* @__PURE__ */ jsx(WorkspaceLoader, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children });
}
const EmptyReferenceRoot = styled(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    &:focus {
      border: 1px solid var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      border: 1px solid var(--card-focus-ring-color);
    }
    &:hover {
      border-color: ${theme.color.input.default.hovered.border};
    }
  `;
}), Placeholder = styled(Text)((props) => `
      color: ${getTheme_v2(props.theme).color.input.default.enabled.placeholder};
      margin-left: 3px;
  `), TargetRoot = styled(Card)`
  position: relative;
  [data-ui='show-on-hover'] {
    opacity: 0;
    position: absolute;
    right: 6px;
    top: 4px;
    display: flex;
  }
  &:focus-within,
  &:hover {
    padding-right: 36px;
    /* Hides the preview status dot, the button will take it's position. */
    [data-testid='compact-preview__status'] {
      opacity: 0;
    }
    [data-ui='show-on-hover'] {
      transition: opacity 200ms;
      opacity: 1;
    }
  }
`, StyledIntentLink$1 = styled(IntentLink)(() => css`
    text-decoration: none;
    width: 100%;
    overflow: hidden;
    cursor: pointer;
    &:focus {
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
  `);
function Preview(props) {
  const { value, handleRemove } = props, documentId = value.document._ref, documentType = value.documentType, schemaType = useSchema().get(value.documentType), documentPresence = useDocumentPresence(documentId), { t } = useTranslation(tasksLocaleNamespace), CardLink = useMemo(
    () => forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsx(
        StyledIntentLink$1,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return schemaType ? /* @__PURE__ */ jsx(TargetRoot, { border: !0, radius: 2, children: /* @__PURE__ */ jsxs(Flex, { gap: 1, align: "center", justify: "space-between", children: [
    /* @__PURE__ */ jsx(Card, { as: CardLink, radius: 2, "data-as": "button", children: /* @__PURE__ */ jsx(
      SearchResultItemPreview,
      {
        documentId: value.document._ref,
        layout: "compact",
        presence: documentPresence,
        schemaType,
        showBadge: !1
      }
    ) }),
    /* @__PURE__ */ jsx("div", { "data-ui": "show-on-hover", children: /* @__PURE__ */ jsx(
      Button,
      {
        icon: CloseIcon,
        mode: "bleed",
        onClick: handleRemove,
        tooltipProps: { content: t("form.input.target.buttons.remove.text") }
      }
    ) })
  ] }) }) : /* @__PURE__ */ jsx(Text, { children: t("form.input.target.error.schema-not-found") });
}
function TargetField(props) {
  const [open, setOpen] = useState(!1), { dataset, projectId } = useWorkspace(), {
    mode,
    inputProps: { onChange },
    value: _propValue
  } = props, value = _propValue, handleItemSelect = useCallback(
    (item) => {
      onChange(
        set(
          getTargetValue({
            documentId: item._id,
            documentType: item._type,
            dataset,
            projectId
          })
        )
      );
    },
    [dataset, projectId, onChange]
  ), handleRemove = useCallback(() => {
    onChange(unset());
  }, [onChange]), handleOpenSearch = useCallback(() => {
    setOpen(!0);
  }, [setOpen]), handleCloseSearch = useCallback(() => {
    setOpen(!1);
  }, [setOpen]), handleKeyDown = useCallback((event) => {
    (event.key === "Enter" || event.key === " ") && setOpen(!0);
  }, []), { t } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsx(Card, { borderBottom: mode === "edit", paddingBottom: mode === "edit" ? 4 : 0, children: /* @__PURE__ */ jsx(FieldWrapperRoot, { children: /* @__PURE__ */ jsx(LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsxs(CurrentWorkspaceProvider, { children: [
    /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
      mode === "create" && /* @__PURE__ */ jsx(Box, { "data-ui": "fieldHeaderContentBox", children: /* @__PURE__ */ jsx(
        FormFieldHeaderText,
        {
          description: props.description,
          inputId: props.inputId,
          title: props.title,
          validation: props.validation,
          deprecated: void 0
        }
      ) }),
      value ? /* @__PURE__ */ jsx(Preview, { value, handleRemove }) : /* @__PURE__ */ jsx(
        EmptyReferenceRoot,
        {
          border: !0,
          radius: 2,
          paddingX: 2,
          paddingY: 3,
          onClick: handleOpenSearch,
          onKeyDown: handleKeyDown,
          tabIndex: 0,
          children: /* @__PURE__ */ jsxs(Flex, { gap: 1, justify: "flex-start", align: "center", children: [
            /* @__PURE__ */ jsx(Box, { paddingX: 1, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DocumentIcon, {}) }) }),
            /* @__PURE__ */ jsx(Placeholder, { size: 1, children: t("form.input.target.search.placeholder") })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsx(SearchProvider, { children: /* @__PURE__ */ jsx(
      SearchPopover,
      {
        open,
        onClose: handleCloseSearch,
        onOpen: handleOpenSearch,
        onItemSelect: handleItemSelect,
        disableIntentLink: !0
      }
    ) })
  ] }) }) }) });
}
const Root$1 = styled.div((props) => `
      display: grid;
      grid-template-columns: 1fr;
      padding-top: ${getTheme_v2(props.theme).space[3]}px;
    `), TitleInput = styled.textarea((props) => {
  const { color, font } = getTheme_v2(props.theme);
  return css`
    resize: none;
    overflow: hidden;
    appearance: none;
    background: none;
    border: 0;
    padding: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${font.text.weights.semibold};
    font-size: ${font.text.sizes[3].fontSize}px;
    line-height: ${font.text.sizes[3].lineHeight}px;
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;
    transition: height 500ms;
    /* NOTE: This is a hack to disable Chrome’s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    color: ${color.input.default.enabled.fg};

    &::placeholder {
      color: ${color.input.default.enabled.placeholder};
    }
  `;
});
function Title(props) {
  const { value, onChange, placeholder, path } = props, ref = useRef(null);
  useEffect(() => {
    ref.current && (ref.current.style.height = "auto", ref.current.style.height = `${ref.current.scrollHeight}px`);
  }, [value]);
  const handleChange = useCallback(
    (event) => {
      const inputValue = event.currentTarget.value;
      return inputValue || onChange(unset(path)), onChange(set(inputValue.replace(/\n/g, ""), path));
    },
    [onChange, path]
  );
  return /* @__PURE__ */ jsx(Root$1, { children: /* @__PURE__ */ jsx(
    TitleInput,
    {
      ref,
      autoFocus: !value,
      value,
      placeholder,
      onChange: handleChange,
      rows: 1
    }
  ) });
}
function TitleField(props) {
  const { value, inputProps } = props, { onChange, schemaType } = inputProps;
  return /* @__PURE__ */ jsx(Title, { value, onChange, placeholder: schemaType.placeholder });
}
function useTaskOperations() {
  const { client, createAddonDataset } = useAddonDataset(), currentUser = useCurrentUser(), handleCreate = useCallback(
    async (payload) => {
      if (!currentUser)
        throw new Error("No current user found. Unable to create task.");
      const task = {
        ...payload,
        authorId: currentUser.id,
        _type: "tasks.task"
      };
      if (!client)
        try {
          const newCreatedClient = await createAddonDataset();
          if (!newCreatedClient)
            throw new Error("No addon client found. Unable to create task.");
          return await newCreatedClient.create(task);
        } catch (err) {
          throw err;
        }
      try {
        return await client.create(task);
      } catch (err) {
        throw err;
      }
    },
    [client, createAddonDataset, currentUser]
  ), handleEdit = useCallback(
    async (id, set2) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        return await client.patch(id).set(set2).commit();
      } catch (e) {
        throw e;
      }
    },
    [client]
  ), handleRemove = useCallback(
    async (id) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        await client.delete(id);
      } catch (e) {
        throw e;
      }
    },
    [client]
  );
  return useMemo(
    () => ({
      create: handleCreate,
      edit: handleEdit,
      remove: handleRemove
    }),
    [handleCreate, handleEdit, handleRemove]
  );
}
function useRemoveTask({ id, onError, onRemoved }) {
  const [removeStatus, setRemoveStatus] = useState("idle"), [showDialog, setShowDialog] = useState(!1), [error, setError] = useState(null), operations = useTaskOperations(), handleRemove = useCallback(async () => {
    try {
      setRemoveStatus("loading"), await operations.remove(id), onRemoved == null || onRemoved(), setRemoveStatus("idle"), await new Promise((resolve) => setTimeout(resolve, 300)), setShowDialog(!1);
    } catch (e) {
      onError == null || onError(e.message), setError(e.message), setRemoveStatus("error");
    } finally {
      setRemoveStatus("idle");
    }
  }, [id, operations, onError, onRemoved]), handleOpenDialog = useCallback(() => {
    setShowDialog(!0);
  }, [setShowDialog]), handleCloseDialog = useCallback(() => {
    setShowDialog(!1);
  }, [setShowDialog]);
  return {
    removeStatus,
    showDialog,
    error,
    handleRemove,
    handleOpenDialog,
    handleCloseDialog
  };
}
const getTaskSubscribers = (task) => {
  const subscribers = task.subscribers || [];
  return getMentionedUsers(task.description).forEach((user) => {
    subscribers.includes(user) || subscribers.push(user);
  }), task.assignedTo && (subscribers.includes(task.assignedTo) || subscribers.push(task.assignedTo)), subscribers;
};
function FormCreate(props) {
  const [createMore, setCreateMore] = useState(!1), {
    setViewMode,
    setActiveTab,
    state: { viewMode }
  } = useTasksNavigation(), toast = useToast(), handleCreateMore = useCallback(() => setCreateMore((p) => !p), []), { onChange } = props, value = props.value, onRemove = useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { handleRemove, removeStatus } = useRemoveTask({ id: value._id, onRemoved: onRemove }), { t } = useTranslation(tasksLocaleNamespace), handleCreate = useCallback(() => {
    if (!(value != null && value.title)) {
      toast.push({
        closable: !0,
        status: "error",
        title: t("form.status.error.title-required")
      });
      return;
    }
    onChange([
      set(getTaskSubscribers(value), ["subscribers"]),
      set((/* @__PURE__ */ new Date()).toISOString(), ["createdByUser"])
    ]), createMore ? setViewMode({ type: "create" }) : setActiveTab("subscribed"), toast.push({
      closable: !0,
      status: "success",
      title: t("form.status.success")
    });
  }, [setViewMode, setActiveTab, onChange, createMore, toast, value, t]);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    props.renderDefault(props),
    /* @__PURE__ */ jsx(Box, { paddingY: 5, children: /* @__PURE__ */ jsxs(Flex, { justify: "flex-end", paddingTop: 1, gap: 3, children: [
      /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, style: { flexGrow: viewMode === "draft" ? 1 : 0 }, children: [
        /* @__PURE__ */ jsx(Switch, { onChange: handleCreateMore, checked: createMore }),
        /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("form.input.create-more.text") })
      ] }),
      viewMode === "draft" && /* @__PURE__ */ jsx(
        Button,
        {
          text: t("buttons.discard.text"),
          onClick: handleRemove,
          mode: "bleed",
          disabled: removeStatus === "loading",
          loading: removeStatus === "loading"
        }
      ),
      /* @__PURE__ */ jsx(Button, { text: t("buttons.create.text"), onClick: handleCreate })
    ] }) })
  ] });
}
const FIELDS_TO_GROUP = [
  "title",
  "status",
  "assignedTo",
  "dueBy",
  "target",
  "description"
], GROUP_TIME = 2 * 60 * 1e3;
function groupChanges(changes) {
  const groupedChanges = [];
  for (const change of changes) {
    const lastChangeProcessed = groupedChanges[groupedChanges.length - 1];
    if (!lastChangeProcessed) {
      groupedChanges.push(change);
      continue;
    }
    if (!FIELDS_TO_GROUP.includes(change.field)) {
      groupedChanges.push(change);
      continue;
    }
    if (lastChangeProcessed.author === change.author && lastChangeProcessed.field === change.field) {
      const lastChangeDate = new Date(lastChangeProcessed.timestamp), changeDate = new Date(change.timestamp);
      if (Math.abs(lastChangeDate.getTime() - changeDate.getTime()) <= GROUP_TIME) {
        lastChangeProcessed.to = change.to, lastChangeProcessed.timestamp = change.timestamp;
        continue;
      }
    }
    groupedChanges.push(change);
  }
  return groupedChanges;
}
function omitRev(document2) {
  const { _rev, ...doc } = document2;
  return doc;
}
function trackFieldChanges(newestDocument, transactions, fieldsToTrack) {
  let currentDocument = omitRev(newestDocument);
  const changes = [];
  let previousDocument = currentDocument;
  for (const transaction of transactions) {
    const { timestamp, effects } = transaction, documentId = transaction.documentIDs[0], effect = effects[documentId];
    !effect || !effect.revert || (previousDocument = applyPatch(currentDocument, effect.revert), fieldsToTrack.forEach((field) => {
      (previousDocument == null ? void 0 : previousDocument[field]) !== (currentDocument == null ? void 0 : currentDocument[field]) && changes.push({
        field,
        from: previousDocument == null ? void 0 : previousDocument[field],
        to: currentDocument == null ? void 0 : currentDocument[field],
        timestamp,
        author: transaction.author
      });
    }), currentDocument = previousDocument);
  }
  const changesSortedByTimestamp = changes.sort((a, b) => a.timestamp.localeCompare(b.timestamp)), createdByUserIndex = changesSortedByTimestamp.findIndex(
    (change) => change.field === "createdByUser"
  );
  return groupChanges(changesSortedByTimestamp.slice(createdByUserIndex + 1));
}
function useActivityLog(task) {
  var _a;
  const [changes, setChanges] = useState([]), client = useClient({ apiVersion: API_VERSION }), { dataset, token } = client.config(), queryParams = "tag=sanity.studio.tasks.history&effectFormat=mendoza&excludeContent=true&includeIdentifiedDocumentsOnly=true&reverse=true", publishedId = getPublishedId((_a = task == null ? void 0 : task._id) != null ? _a : ""), transactionsUrl = client.getUrl(
    `/data/history/${dataset}/transactions/${publishedId}?${queryParams}`
  ), fetchAndParse = useCallback(
    async (newestTaskDocument) => {
      try {
        if (!publishedId)
          return;
        const transactions = [], reader = (await getJsonStream(transactionsUrl, token)).getReader();
        let result;
        for (; result = await reader.read(), !result.done; ) {
          if ("error" in result.value)
            throw new Error(result.value.error.description || result.value.error.type);
          transactions.push(result.value);
        }
        const fieldsToTrack = [
          "createdByUser",
          "title",
          "description",
          "dueBy",
          "assignedTo",
          "status",
          "target"
        ], parsedChanges = await trackFieldChanges(
          newestTaskDocument,
          [...transactions],
          fieldsToTrack
        );
        setChanges(parsedChanges);
      } catch (error) {
        console.error("Failed to fetch and parse activity log", error);
      }
    },
    [transactionsUrl, token, publishedId]
  );
  return useEffect(() => {
    fetchAndParse(task);
  }, [fetchAndParse, task._rev]), { changes };
}
function RemoveTaskDialog(props) {
  const { handleCloseDialog, handleRemove, removeStatus, showDialog } = props, { t } = useTranslation(tasksLocaleNamespace);
  return showDialog ? /* @__PURE__ */ jsx(
    Dialog,
    {
      id: "remove-task",
      header: t("dialog.remove-task.title"),
      onClose: handleCloseDialog,
      footer: {
        cancelButton: {
          text: t("dialog.remove-task.buttons.cancel.text"),
          onClick: handleCloseDialog
        },
        confirmButton: {
          text: t("dialog.remove-task.buttons.confirm.text"),
          tone: "critical",
          onClick: handleRemove,
          loading: removeStatus === "loading"
        }
      },
      children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
        /* @__PURE__ */ jsx(Text, { as: "p", children: t("dialog.remove-task.body") }),
        /* @__PURE__ */ jsx(Text, { as: "p", children: t("dialog.remove-task.body2") })
      ] })
    }
  ) : null;
}
const FirstRow = styled(Flex)((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    column-gap: ${theme.space[2]}px;
    row-gap: ${theme.space[3]}px;
  `;
});
function FormActionsMenu({ id, value }) {
  const { setViewMode, handleCopyLinkToTask } = useTasksNavigation(), onTaskRemoved = useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), removeTask = useRemoveTask({ id, onRemoved: onTaskRemoved }), duplicateTask = useCallback(() => {
    setViewMode({ type: "duplicate", duplicateTaskValues: value });
  }, [setViewMode, value]), { t } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Box, { paddingTop: 3, children: /* @__PURE__ */ jsx(
      MenuButton,
      {
        id: "edit-task-menu",
        button: /* @__PURE__ */ jsx(ContextMenuButton, {}),
        popover: {
          placement: "bottom",
          fallbackPlacements: ["bottom-end", "bottom-start"]
        },
        menu: /* @__PURE__ */ jsxs(Menu, { children: [
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              text: t("menuitem.duplicate.text"),
              icon: CopyIcon,
              onClick: duplicateTask
            }
          ),
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              text: t("menuitem.copylink.text"),
              icon: LinkIcon,
              onClick: handleCopyLinkToTask
            }
          ),
          /* @__PURE__ */ jsx(MenuDivider, {}),
          /* @__PURE__ */ jsx(
            MenuItem,
            {
              text: t("menuitem.delete.text"),
              icon: TrashIcon,
              onClick: removeTask.handleOpenDialog,
              tone: "critical"
            }
          )
        ] })
      }
    ) }),
    /* @__PURE__ */ jsx(RemoveTaskDialog, { ...removeTask })
  ] });
}
function FormEditInner(props) {
  var _a, _b, _c, _d, _e, _f;
  const statusField = props.schemaType.fields.find((f) => f.name === "status"), value = props.value, currentUser = useCurrentUser(), { t } = useTranslation(tasksLocaleNamespace), activityData = useActivityLog(value).changes, handleChangeAndSubscribe = useCallback(
    (patch) => {
      const subscribers = value.subscribers || [];
      props.onChange(patch), currentUser && (subscribers.includes(currentUser.id) || props.onChange(set([...subscribers, currentUser.id], ["subscribers"])));
    },
    [currentUser, props, value.subscribers]
  );
  if (!statusField)
    throw new Error("Status field not found");
  return (_a = props.value) != null && _a._id ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
      /* @__PURE__ */ jsx(Stack, { flex: 1, children: /* @__PURE__ */ jsx(
        Title,
        {
          onChange: handleChangeAndSubscribe,
          value: (_b = props.value) == null ? void 0 : _b.title,
          path: ["title"],
          placeholder: t("form.input.title.placeholder")
        }
      ) }),
      /* @__PURE__ */ jsx(FormActionsMenu, { id: (_c = props.value) == null ? void 0 : _c._id, value })
    ] }),
    /* @__PURE__ */ jsx(Card, { borderTop: !0, marginTop: 3, children: /* @__PURE__ */ jsxs(
      FirstRow,
      {
        paddingBottom: 3,
        paddingTop: 4,
        align: "flex-start",
        justify: "flex-start",
        wrap: "wrap",
        children: [
          /* @__PURE__ */ jsx(
            StatusSelector,
            {
              value: (_d = props.value) == null ? void 0 : _d.status,
              path: ["status"],
              onChange: handleChangeAndSubscribe,
              options: statusField.type.options.list
            }
          ),
          /* @__PURE__ */ jsx(
            AssigneeEditFormField,
            {
              value: (_e = props.value) == null ? void 0 : _e.assignedTo,
              onChange: handleChangeAndSubscribe,
              path: ["assignedTo"]
            }
          ),
          /* @__PURE__ */ jsx(
            DateEditFormField,
            {
              value: (_f = props.value) == null ? void 0 : _f.dueBy,
              onChange: handleChangeAndSubscribe,
              path: ["dueBy"]
            }
          )
        ]
      }
    ) }),
    props.renderDefault(props),
    /* @__PURE__ */ jsx(
      CommentsProvider,
      {
        documentId: value._id,
        documentType: "tasks.task",
        sortOrder: "asc",
        type: "task",
        children: /* @__PURE__ */ jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsx(Card, { borderTop: !0, paddingTop: 4, marginTop: 4, paddingBottom: 6, children: /* @__PURE__ */ jsx(
          TasksActivityLog,
          {
            value,
            onChange: props.onChange,
            path: ["subscribers"],
            activityData
          }
        ) }) })
      }
    )
  ] }) : /* @__PURE__ */ jsx(LoadingBlock, {});
}
function FormEdit(props) {
  const value = props.value, currentUser = useCurrentUser(), transformPatches = useCallback(
    (patches) => {
      if (!currentUser || patches.some((patch) => patch.path[0] === "subscribers"))
        return patches;
      const subscribers = value.subscribers || [], newSubscribers = [...subscribers], changeAssigneePatch = patches.find((patch) => patch.path[0] === "assignedTo");
      changeAssigneePatch && changeAssigneePatch.type === "set" && typeof changeAssigneePatch.value == "string" && !newSubscribers.includes(changeAssigneePatch.value) && newSubscribers.push(changeAssigneePatch.value), newSubscribers.includes(currentUser.id) || newSubscribers.push(currentUser.id);
      const changedDescriptionPatch = patches.find(
        (patch) => patch.path[0] === "description" && patch.type === "set"
      );
      if (changedDescriptionPatch) {
        const prevMentionedUser = getMentionedUsers(value.description), newDescription = changedDescriptionPatch.type === "set" ? changedDescriptionPatch.value : void 0;
        getMentionedUsers(newDescription).filter((user) => !prevMentionedUser.includes(user)).forEach((user) => {
          newSubscribers.includes(user) || newSubscribers.push(user);
        });
      }
      return newSubscribers.length !== subscribers.length && patches.push(set(newSubscribers, ["subscribers"])), patches;
    },
    [currentUser, value.subscribers, value.description]
  );
  return /* @__PURE__ */ jsx(TransformPatches, { transform: transformPatches, children: /* @__PURE__ */ jsx(FormEditInner, { ...props }) });
}
function TasksNotificationTargetInner(props) {
  var _a, _b, _c;
  const { inputProps } = props, { onChange } = inputProps, { target, _id, context } = useFormValue([]), { title: workspaceTitle, basePath } = useWorkspace(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = useMemo(() => imageUrlBuilder(client), [client]), documentId = (_b = (_a = target == null ? void 0 : target.document) == null ? void 0 : _a._ref) != null ? _b : "", documentType = (_c = target == null ? void 0 : target.documentType) != null ? _c : "", { isLoading: previewValuesLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), targetContentTitle = (value == null ? void 0 : value.title) || null, imageUrl = isImageSource(value == null ? void 0 : value.media) ? imageBuilder.image(value.media).width(96).height(96).url() : null;
  return useEffect(() => {
    if (documentId && documentType && previewValuesLoading)
      return;
    const studioUrl = new URL(`${window.location.origin}${basePath}/`);
    studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", _id), studioUrl.searchParams.set("viewMode", "edit");
    const notificationTarget = {
      url: studioUrl.toString(),
      workspaceTitle,
      targetContentImageUrl: imageUrl,
      targetContentTitle
    };
    deepCompare(notificationTarget, context == null ? void 0 : context.notification) || onChange(set(notificationTarget, ["notification"]));
  }, [
    _id,
    basePath,
    workspaceTitle,
    documentId,
    documentType,
    previewValuesLoading,
    targetContentTitle,
    imageUrl,
    onChange,
    context
  ]), null;
}
function TasksNotificationTarget(props) {
  return /* @__PURE__ */ jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsx(TasksNotificationTargetInner, { ...props }) });
}
const targetContentField = (mode) => defineField$1({
  type: "object",
  name: "target",
  title: "Target",
  components: {
    field: (props) => /* @__PURE__ */ jsx(TargetField, { ...props, mode })
  },
  fields: [
    {
      name: "document",
      type: "crossDatasetReference",
      dataset: "playground",
      weak: !0,
      studioUrl: ({ id, type }) => `intent/edit/id=${id};type=${type}/`,
      to: [
        {
          type: "any_document",
          preview: {
            select: { title: "title" }
          }
        }
      ]
    },
    {
      name: "documentType",
      type: "string",
      title: "Document type"
    }
  ]
}), descriptionInputField = (mode) => defineField$1({
  type: "array",
  name: "description",
  title: "Description",
  components: {
    field: (props) => /* @__PURE__ */ jsx(DescriptionInput, { ...props, mode })
  },
  of: [
    {
      type: "block",
      name: "block",
      of: [
        {
          name: "mention",
          type: "object",
          fields: [
            {
              name: "userId",
              type: "string"
            }
          ]
        }
      ],
      marks: {
        annotations: []
      },
      styles: [{ title: "Normal", value: "normal" }],
      lists: []
    }
  ]
}), taskSchema = (mode) => defineType({
  type: "document",
  name: "tasks.task",
  liveEdit: !0,
  components: {
    input: mode === "edit" ? FormEdit : FormCreate
  },
  fields: [
    {
      type: "string",
      title: "Title",
      name: "title",
      placeholder: "Task title",
      components: {
        field: TitleField
      },
      hidden: mode === "edit"
    },
    ...mode === "edit" ? [targetContentField(mode), descriptionInputField(mode)] : [descriptionInputField(mode), targetContentField(mode)],
    {
      type: "string",
      name: "assignedTo",
      title: "Assign to",
      placeholder: "Select username",
      components: {
        field: FieldWrapper,
        input: AssigneeCreateFormField
      },
      hidden: mode === "edit"
    },
    {
      type: "date",
      name: "dueBy",
      title: "Deadline",
      placeholder: "Select date",
      components: {
        field: FieldWrapper
      },
      hidden: mode === "edit"
    },
    {
      type: "string",
      name: "authorId",
      hidden: !0
    },
    {
      type: "string",
      name: "createdByUser",
      hidden: !0
    },
    {
      type: "array",
      of: [{ type: "string" }],
      name: "subscribers",
      hidden: !0
    },
    {
      type: "string",
      name: "status",
      title: "Status",
      options: {
        list: TASK_STATUS.map((s) => ({ value: s.value, title: s.title }))
      },
      hidden: !0
    },
    {
      type: "object",
      name: "context",
      components: {
        field: TasksNotificationTarget
      },
      fields: [
        {
          type: "object",
          name: "notification",
          fields: [
            {
              type: "string",
              name: "url"
            },
            {
              type: "string",
              name: "workspaceTitle"
            },
            {
              type: "string",
              name: "targetContentImageUrl"
            },
            {
              type: "string",
              name: "targetContentTitle"
            }
          ]
        }
      ]
    }
  ]
});
function TasksAddonWorkspaceProviderInner({
  children,
  mode,
  addonDataset
}) {
  const apiHost = useClient({ apiVersion: API_VERSION }).config().apiHost, basePath = "", source = useSource(), addonDatasetConfig = useMemo(
    () => ({
      basePath,
      dataset: addonDataset,
      name: `addon-dataset-${addonDataset}`,
      projectId: source.projectId,
      apiHost,
      schema: {
        types: [taskSchema(mode)]
      }
    }),
    [source.projectId, mode, apiHost, addonDataset, basePath]
  ), { workspaces } = useMemo(
    () => prepareConfig(addonDatasetConfig, { basePath }),
    [addonDatasetConfig, basePath]
  ), addonWorkspace = useWorkspaceLoader(workspaces[0]);
  return addonWorkspace ? /* @__PURE__ */ jsx(WorkspaceProvider, { workspace: addonWorkspace, children: /* @__PURE__ */ jsx(SourceProvider, { source: addonWorkspace.unstable_sources[0], children: /* @__PURE__ */ jsx(ResourceCacheProvider, { children }) }) }) : null;
}
function TasksAddonWorkspaceProvider(props) {
  const { client: addonDatasetClient, ready, createAddonDataset } = useAddonDataset(), addonDataset = addonDatasetClient == null ? void 0 : addonDatasetClient.config().dataset;
  return useEffect(() => {
    !addonDataset && ready && createAddonDataset();
  }, [addonDataset, ready, createAddonDataset]), addonDataset ? /* @__PURE__ */ jsx(TasksAddonWorkspaceProviderInner, { ...props, addonDataset }) : /* @__PURE__ */ jsx(LoadingBlock, {});
}
function useTasksFormBuilder(options) {
  const { documentType = "tasks.task", documentId, initialValue = {} } = options, tasksSchemaType = useSchema().get(documentType);
  if (!tasksSchemaType)
    throw new Error(`Schema type for '${documentType}' not found`);
  const { validation: validationRaw } = useValidationStatus(documentId, documentType), validation = useUnique(validationRaw), [focusPath, setFocusPath] = useState([]), [openPath, setOpenPath] = useState([]), [collapsedPaths, onSetCollapsedPath] = useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = useState(), [fieldGroupState, onSetFieldGroupState] = useState(), [presence] = useState([]), handleFocus = useCallback(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath);
    },
    [setFocusPath]
  ), handleBlur = useCallback(() => {
    setFocusPath([]);
  }, []), handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), { patch } = useDocumentOperation(documentId, documentType), patchRef = useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue);
  };
  const handleChange = useCallback((event) => patchRef.current(event), []), connectionState = useConnectionState(documentId, documentType), editState = useEditState(documentId, documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue, formState = useFormState(tasksSchemaType, {
    value,
    comparisonValue: value,
    readOnly: !1,
    changesOpen: !1,
    presence,
    focusPath,
    openPath,
    collapsedPaths,
    collapsedFieldSets,
    fieldGroupState,
    validation
  }), ready = editState.ready && connectionState === "connected", patchChannel = useMemo(() => createPatchChannel(), []);
  return formState === null || !ready ? { loading: !0 } : {
    id: "root",
    onChange: handleChange,
    // eslint-disable-next-line camelcase
    __internal_patchChannel: patchChannel,
    // eslint-disable-next-line camelcase
    __internal_fieldActions: void 0,
    onPathFocus: handleFocus,
    onPathOpen: setOpenPath,
    onPathBlur: handleBlur,
    onFieldGroupSelect: handleSetActiveFieldGroup,
    onSetFieldSetCollapsed: handleOnSetCollapsedFieldSet,
    onSetPathCollapsed: handleOnSetCollapsedPath,
    collapsedPaths,
    collapsedFieldSets,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    validation: formState.validation,
    members: formState.members,
    presence: formState.presence,
    schemaType: tasksSchemaType,
    value: formState.value
  };
}
const VARIANTS$1 = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.2, delay: 0.2 }
  }
}, FormBuilderRoot = styled(motion.div)((props) => {
  const theme = getTheme_v2(props.theme);
  return `
    // Update spacing for the form builder
    & > [data-ui='Stack'] {
      grid-gap: ${rem(theme.space[4])};
    }
`;
}), TasksFormBuilderInner = ({
  documentId,
  initialValue
}) => {
  var _a, _b;
  const formBuilderProps = useTasksFormBuilder({
    documentType: "tasks.task",
    documentId,
    initialValue
  }), { setSelectedDocument } = useMentionUser(), target = formBuilderProps.loading || (_a = formBuilderProps.value) == null ? void 0 : _a.target, targetId = (_b = target == null ? void 0 : target.document) == null ? void 0 : _b._ref, targetType = target == null ? void 0 : target.documentType;
  return useEffect(() => {
    setSelectedDocument(targetId && targetType ? { _id: targetId, _type: targetType } : null);
  }, [targetId, targetType, setSelectedDocument]), /* @__PURE__ */ jsx(CommentsEnabledProvider, { documentId: "", documentType: "", children: /* @__PURE__ */ jsx(Box, { children: formBuilderProps.loading ? /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsx(FormBuilderRoot, { id: "wrapper", initial: "hidden", animate: "visible", variants: VARIANTS$1, children: /* @__PURE__ */ jsx(FormBuilder, { ...formBuilderProps }) }) }) });
};
function TasksFormBuilder() {
  const currentUser = useCurrentUser(), { activeDocument } = useTasks(), { dataset, projectId } = useWorkspace(), {
    state: { selectedTask, viewMode, duplicateTaskValues }
  } = useTasksNavigation(), initialValue = useMemo(() => {
    if (currentUser && selectedTask) {
      if (viewMode === "duplicate")
        return {
          ...duplicateTaskValues,
          title: `${duplicateTaskValues == null ? void 0 : duplicateTaskValues.title} (copy)`,
          // Set the new task title
          createdByUser: void 0,
          // Remove the createdByUser field
          _id: selectedTask,
          // Set the new task ID
          _type: "tasks.task",
          authorId: currentUser.id,
          // Set the author ID
          status: "open"
        };
      if (viewMode === "create")
        return {
          _id: selectedTask,
          _type: "tasks.task",
          authorId: currentUser.id,
          status: "open",
          subscribers: [currentUser.id],
          target: activeDocument ? getTargetValue({
            documentId: activeDocument.documentId,
            documentType: activeDocument.documentType,
            dataset,
            projectId
          }) : void 0
        };
    }
  }, [activeDocument, currentUser, dataset, duplicateTaskValues, projectId, selectedTask, viewMode]);
  return currentUser ? selectedTask ? (
    // This provider needs to be mounted before the TasksAddonWorkspaceProvider.
    /* @__PURE__ */ jsx(MentionUserProvider, { children: /* @__PURE__ */ jsx(TasksAddonWorkspaceProvider, { mode: viewMode === "edit" ? "edit" : "create", children: /* @__PURE__ */ jsx(
      TasksFormBuilderInner,
      {
        documentId: selectedTask,
        currentUser,
        initialValue
      }
    ) }) })
  ) : null : /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: "Loading current user" });
}
const HEADING_BY_STATUS = {
  open: {
    assigned: {
      heading: "empty-state.status.list.open.assigned.heading",
      text: "empty-state.status.list.open.assigned.text"
    },
    document: { heading: "empty-state.status.list.open.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.open.subscribed.heading",
      text: "empty-state.status.list.open.subscribed.text"
    }
  },
  closed: {
    assigned: {
      heading: "empty-state.status.list.closed.assigned.heading",
      text: "empty-state.status.list.closed.assigned.text"
    },
    document: { heading: "empty-state.status.list.closed.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.closed.subscribed.heading",
      text: "empty-state.status.list.closed.subscribed.text"
    }
  }
};
function EmptyStatusListState({ status }) {
  const {
    state: { activeTabId }
  } = useTasksNavigation(), { t } = useTranslation$1(tasksLocaleNamespace), { heading, text } = HEADING_BY_STATUS[status][activeTabId];
  return /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: t(heading) }),
    /* @__PURE__ */ jsx(Text, { size: 1, children: t(text) })
  ] });
}
const EMPTY_TASK_LIST = {
  assigned: {
    heading: "empty-state.list.assigned.heading",
    text: "empty-state.list.assigned.text"
  },
  subscribed: {
    heading: "empty-state.list.subscribed.heading",
    text: "empty-state.list.subscribed.text"
  },
  document: {
    heading: "empty-state.list.document.heading",
    text: "empty-state.list.document.text"
  }
}, Root = styled.div`
  max-width: 268px;
  margin: 0 auto;
  height: 100%;
  margin-top: 40%;
`;
function EmptyTasksListState() {
  const {
    state: { activeTabId },
    setViewMode
  } = useTasksNavigation(), { heading, text } = EMPTY_TASK_LIST[activeTabId], { t } = useTranslation$1(tasksLocaleNamespace), handleTaskCreate = useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]);
  return /* @__PURE__ */ jsx(Root, { children: /* @__PURE__ */ jsxs(Flex, { direction: "column", gap: 3, align: "center", flex: 1, justify: "center", children: [
    /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: t(heading) }),
    /* @__PURE__ */ jsx(Box, { paddingBottom: 6, paddingTop: 1, children: /* @__PURE__ */ jsx(Text, { size: 1, align: "center", children: t(text) }) }),
    /* @__PURE__ */ jsx(Button, { icon: AddIcon, text: t("empty-state.list.create-new"), onClick: handleTaskCreate })
  ] }) });
}
const StyledIntentLink = styled(IntentLink)((props) => `
  text-decoration: underline;
  text-decoration-color: ${getTheme_v2(props.theme).color.input.default.enabled.border};
  text-underline-offset: 2px;
`);
function DocumentPreview({
  documentId,
  documentType
}) {
  const documentSchema = useSchema().get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), Link2 = useMemo(
    () => forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsx(
        StyledIntentLink,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return documentSchema ? /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DocumentIcon, {}) }),
    isLoading ? /* @__PURE__ */ jsx(TextSkeleton, { size: 1, muted: !0 }) : /* @__PURE__ */ jsx(Text, { size: 1, as: Link2, weight: "medium", style: { maxWidth: "20ch" }, textOverflow: "ellipsis", children: (value == null ? void 0 : value.title) || "Untitled" })
  ] }) : null;
}
function TasksStatus(props) {
  const operations = useTaskOperations(), { documentId, status } = props, [checkboxValue, setCheckboxValue] = useState(status === "closed"), [isLoading, setIsLoading] = useState(!1), handleCheckboxChange = useCallback(
    async (event) => {
      const isChecked = event.target.checked;
      setCheckboxValue(isChecked), setIsLoading(!0);
      try {
        isChecked ? await operations.edit(documentId, { status: "closed" }) : isChecked || await operations.edit(documentId, { status: "open" });
      } catch (error) {
        console.error("An error occurred while updating the task status", error);
      } finally {
        setIsLoading(!1);
      }
    },
    [documentId, operations]
  );
  return /* @__PURE__ */ jsx(Flex, { children: isLoading ? /* @__PURE__ */ jsx("div", { style: { height: "17px", width: "17px" }, children: /* @__PURE__ */ jsx(Spinner, { style: { marginLeft: "3.5px", marginRight: "3.5px", marginTop: "3.5px" } }) }) : /* @__PURE__ */ jsx(Checkbox, { onChange: handleCheckboxChange, checked: checkboxValue, disabled: isLoading }) });
}
const TitleButton = styled(Button$1)`
  width: 100%;
  max-width: 100%;
`, TaskDetailsRoot = styled(Flex)`
  /* Checkbox width is 17px and first row gap is 12px. */
  margin-left: 29px;
`;
function getTargetDocumentMeta(target) {
  var _a;
  if ((_a = target == null ? void 0 : target.document) != null && _a._ref)
    return {
      _ref: target == null ? void 0 : target.document._ref,
      _type: target == null ? void 0 : target.documentType
    };
}
function TaskDueDate({ dueBy }) {
  const fullDateFormatter = useDateTimeFormat({ dateStyle: "medium" }), monthAndDayFormatter = useDateTimeFormat({ month: "short", day: "numeric" }), dayFormatter = useDateTimeFormat({ weekday: "long" }), dateOptions = useMemo(() => {
    const date = new Date(dueBy);
    return {
      fullDate: fullDateFormatter.format(date),
      monthAndDay: monthAndDayFormatter.format(date),
      day: dayFormatter.format(date),
      isDueByToday: isToday(date),
      isDueThisWeek: isThisISOWeek(date)
    };
  }, [dayFormatter, dueBy, fullDateFormatter, monthAndDayFormatter]), { fullDate, monthAndDay, day, isDueByToday, isDueThisWeek } = dateOptions;
  return /* @__PURE__ */ jsx(Tooltip, { content: fullDate, children: /* @__PURE__ */ jsx(Card, { tone: isDueByToday ? "critical" : "transparent", padding: 1, radius: 2, children: /* @__PURE__ */ jsx(Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsx(Text, {
    as: "time",
    size: 1,
    dateTime: dueBy,
    muted: !0,
    // eslint-disable-next-line no-nested-ternary
    children: isDueByToday ? "Today" : isDueThisWeek ? day : monthAndDay
  }) }) }) });
}
function TasksListItem(props) {
  const { assignedTo, title, dueBy, target, onSelect, documentId, status } = props, targetDocument = useMemo(() => getTargetDocumentMeta(target), [target]);
  return /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(TasksStatus, { documentId, status }) }),
      /* @__PURE__ */ jsx(Flex, { flex: 1, children: /* @__PURE__ */ jsx(TitleButton, { onClick: onSelect, mode: "bleed", padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title || "Untitled" }) }) }),
      /* @__PURE__ */ jsx(TasksUserAvatar, { user: assignedTo ? { id: assignedTo } : void 0 })
    ] }),
    (dueBy || targetDocument) && /* @__PURE__ */ jsxs(TaskDetailsRoot, { align: "center", gap: 2, paddingX: 0, children: [
      dueBy && /* @__PURE__ */ jsx(TaskDueDate, { dueBy }),
      targetDocument && /* @__PURE__ */ jsx(Box, { marginLeft: 1, children: /* @__PURE__ */ jsx(
        DocumentPreview,
        {
          documentId: targetDocument._ref,
          documentType: targetDocument._type
        }
      ) })
    ] })
  ] });
}
const EMPTY_ARRAY$1 = [], getLabelForStatus = (status) => {
  const statusConfig = TASK_STATUS.find((item) => item.value === status);
  return statusConfig == null ? void 0 : statusConfig.title;
}, DetailsFlex = styled(Flex)`
  [data-ui='summary-icon'] {
    transition: transform 0.2s;
    transform: rotate(-90deg);
  }
  &[open] [data-ui='summary-icon'] {
    transform: rotate(0);
  }
  > summary::-webkit-details-marker {
    display: none;
  }
`, SummaryBox = styled(Box)`
  list-style: none;
`;
function TaskList(props) {
  const { status, tasks: tasks2, onTaskSelect } = props;
  return /* @__PURE__ */ jsxs(DetailsFlex, { forwardedAs: "details", direction: "column", open: status === "open", children: [
    /* @__PURE__ */ jsx(SummaryBox, { forwardedAs: "summary", children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, paddingY: 1, children: [
      /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", muted: !0, children: getLabelForStatus(status) }),
      /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronDownIcon, { "data-ui": "summary-icon" }) })
    ] }) }),
    /* @__PURE__ */ jsx(Stack, { space: 4, marginTop: 4, paddingBottom: 5, children: (tasks2 == null ? void 0 : tasks2.length) > 0 ? tasks2.map((task, index) => {
      const showDivider = index < tasks2.length - 1;
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          TasksListItem,
          {
            documentId: task._id,
            title: task.title,
            dueBy: task.dueBy,
            assignedTo: task.assignedTo,
            target: task.target,
            onSelect: () => onTaskSelect(task._id),
            status: task.status
          }
        ),
        showDivider && /* @__PURE__ */ jsx(MenuDivider, {})
      ] }, task._id);
    }) : /* @__PURE__ */ jsx(EmptyStatusListState, { status }) })
  ] });
}
function TasksList(props) {
  var _a, _b;
  const { items = EMPTY_ARRAY$1, onTaskSelect } = props, tasksByStatus = useMemo(
    () => items.reduce((acc, task) => (acc[task.status] || (acc[task.status] = []), acc[task.status].push(task), acc), {}),
    [items]
  ), hasOpenTasks = ((_a = tasksByStatus.open) == null ? void 0 : _a.length) > 0, hasClosedTasks = ((_b = tasksByStatus.closed) == null ? void 0 : _b.length) > 0;
  return /* @__PURE__ */ jsx(Stack, { space: 4, flex: 1, children: !hasOpenTasks && !hasClosedTasks ? /* @__PURE__ */ jsx(EmptyTasksListState, {}) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(TaskList, { status: "open", tasks: tasksByStatus.open, onTaskSelect }),
    /* @__PURE__ */ jsx(TaskList, { status: "closed", tasks: tasksByStatus.closed, onTaskSelect })
  ] }) });
}
const LIST_STYLES = {
  marginLeft: "-0.5em",
  justifyContent: "space-between",
  display: "flex"
};
function TasksListTabs({ activeTabId, onChange }) {
  const { activeDocument } = useTasks(), activeDocumentId = activeDocument == null ? void 0 : activeDocument.documentId, [documentTabIsDisabled, setDocumentTabIsDisabled] = useState(!activeDocumentId);
  useEffect(() => {
    let timeoutId = null;
    return !activeDocumentId && !documentTabIsDisabled && (timeoutId = setTimeout(() => {
      setDocumentTabIsDisabled(!0), onChange("assigned");
    }, 1e3)), documentTabIsDisabled && activeDocumentId && setDocumentTabIsDisabled(!1), () => {
      timeoutId && clearTimeout(timeoutId);
    };
  }, [activeDocumentId, documentTabIsDisabled, onChange]);
  const { t } = useTranslation(tasksLocaleNamespace), tabs = useMemo(
    () => [
      {
        id: "assigned",
        label: t("tab.assigned.label")
      },
      {
        id: "subscribed",
        label: t("tab.subscribed.label")
      },
      {
        id: "document",
        label: t("tab.document.label"),
        isDisabled: documentTabIsDisabled
      }
    ],
    [documentTabIsDisabled, t]
  ), handleTabChange = useCallback(
    (tab) => {
      tab.isDisabled || onChange(tab.id);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsx(TabList, { space: 2, style: LIST_STYLES, children: tabs.map((tab) => /* @__PURE__ */ jsx(
    Tab,
    {
      "aria-controls": `${tab.id}-panel`,
      id: `${tab.id}-tab`,
      onClick: () => handleTabChange(tab),
      disabled: tab == null ? void 0 : tab.isDisabled,
      selected: tab.id === activeTabId,
      children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: tab.label })
    },
    `${tab.id}-tab`
  )) });
}
const Divider = styled.div((props) => `
    height: 25px;
    width: 1px;
    background-color: ${getTheme_v2(props.theme).color.input.default.enabled.border};
  `);
function TasksActiveTabNavigation(props) {
  const { items: allItems } = props, { state: state2, setViewMode } = useTasksNavigation(), { selectedTask } = state2, items = allItems.filter((t2) => t2.status === "open"), currentItemIndex = items.findIndex((item) => item._id === selectedTask), goToPreviousTask = useCallback(() => {
    const prevTaskId = currentItemIndex > 0 ? items[currentItemIndex - 1]._id : items[items.length - 1]._id;
    setViewMode({ type: "edit", id: prevTaskId });
  }, [currentItemIndex, items, setViewMode]), goToNextTask = useCallback(() => {
    const nextTaskId = currentItemIndex < items.length - 1 ? items[currentItemIndex + 1]._id : items[0]._id;
    setViewMode({ type: "edit", id: nextTaskId });
  }, [currentItemIndex, items, setViewMode]), { t } = useTranslation(tasksLocaleNamespace);
  return items.length ? /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        tooltipProps: { content: t("buttons.previous.tooltip") },
        mode: "bleed",
        icon: ChevronLeftIcon,
        onClick: goToPreviousTask
      }
    ),
    /* @__PURE__ */ jsx(Tooltip, { content: t("panel.navigation.tooltip"), children: /* @__PURE__ */ jsx(Box, { paddingY: 2, children: /* @__PURE__ */ jsxs(Text, { size: 1, children: [
      currentItemIndex + 1,
      " / ",
      items.length
    ] }) }) }),
    /* @__PURE__ */ jsx(
      Button,
      {
        tooltipProps: { content: t("buttons.next.tooltip") },
        mode: "bleed",
        icon: ChevronRightIcon,
        onClick: goToNextTask
      }
    ),
    /* @__PURE__ */ jsx(Divider, {})
  ] }) }) : null;
}
const MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: !0,
  fallbackPlacements: ["bottom-end"],
  placement: "bottom-end",
  portal: !0
}, StyledMenu = styled(Menu)`
  width: 220px;
`;
function TasksDraftsMenuItem(props) {
  const { isSelected, item, onSelect } = props, handleClick = useCallback(() => {
    onSelect(item._id);
  }, [item._id, onSelect]), iconRight = isSelected ? CheckmarkIcon : void 0, text = item.title || "Untitled";
  return /* @__PURE__ */ jsx(
    MenuItem,
    {
      iconRight,
      onClick: handleClick,
      pressed: isSelected,
      selected: isSelected,
      text
    }
  );
}
function TasksHeaderDraftsMenu() {
  const { data } = useTasks(), { state: state2, setViewMode } = useTasksNavigation(), { viewMode, selectedTask } = state2, currentUser = useCurrentUser(), draftTasks = useMemo(() => currentUser != null && currentUser.id ? data.filter((task) => {
    const isAuthoredByUser = task.authorId === currentUser.id, isDraft = !task.createdByUser, hasEdits = task._updatedAt !== task._createdAt, isNotTheTaskBeingCreated = viewMode === "create" ? task._id !== selectedTask : !0;
    return isAuthoredByUser && isDraft && isNotTheTaskBeingCreated && hasEdits;
  }) : [], [data, selectedTask, currentUser == null ? void 0 : currentUser.id, viewMode]), handleSelectTask = useCallback(
    (id) => {
      setViewMode({ type: "draft", id });
    },
    [setViewMode]
  ), { t } = useTranslation(tasksLocaleNamespace);
  return draftTasks.length ? /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(Button, { text: t("buttons.draft.text"), mode: "ghost", iconRight: ChevronDownIcon }),
      id: "edit-task-menu",
      menu: /* @__PURE__ */ jsxs(StyledMenu, { children: [
        /* @__PURE__ */ jsx(Box, { padding: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: t("panel.drafts.title") }) }),
        /* @__PURE__ */ jsx(MenuDivider, {}),
        draftTasks == null ? void 0 : draftTasks.map((task) => /* @__PURE__ */ jsx(
          TasksDraftsMenuItem,
          {
            isSelected: selectedTask === task._id,
            item: task,
            onSelect: handleSelectTask
          },
          task._id
        ))
      ] }),
      popover: MENU_BUTTON_POPOVER_PROPS
    }
  ) : null;
}
function TasksSidebarHeader(props) {
  const { items: allItems } = props, { state: state2, setViewMode, handleCloseTasks } = useTasksNavigation(), { viewMode, activeTabId } = state2, handleTaskCreate = useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]), handleGoBack = useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { t } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxs(Flex, { justify: "space-between", align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxs(Flex, { align: "center", flex: 1, children: [
      viewMode === "list" ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 2, weight: "semibold", children: t("panel.title") }) }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(Button$1, { mode: "bleed", space: 2, padding: 2, onClick: handleGoBack, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("panel.title") }) }),
        /* @__PURE__ */ jsx(ChevronRightIcon, {}),
        /* @__PURE__ */ jsx(Box, { paddingX: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", style: { textTransform: "capitalize" }, children: viewMode === "create" || viewMode === "draft" ? t("panel.create.title") : activeTabId }) })
      ] }),
      /* @__PURE__ */ jsx(BetaBadge, { marginLeft: 2 })
    ] }),
    (viewMode === "create" || viewMode === "draft") && /* @__PURE__ */ jsx(TasksHeaderDraftsMenu, {}),
    viewMode === "edit" && /* @__PURE__ */ jsx(TasksActiveTabNavigation, { items: allItems }),
    /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
      viewMode === "list" && /* @__PURE__ */ jsx(
        Button,
        {
          icon: AddIcon,
          onClick: handleTaskCreate,
          mode: "bleed",
          text: t("buttons.new.text")
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          tooltipProps: {
            content: t("panel.close.tooltip")
          },
          iconRight: CloseIcon,
          mode: "bleed",
          onClick: handleCloseTasks
        }
      )
    ] })
  ] });
}
const RootCard = styled(Card)`
  flex: 1;
  flex-direction: column;
`, HeaderStack = styled(Stack)`
  border-bottom: 1px solid var(--card-border-color);
`, ContentFlex = styled(Flex)`
  overflow-y: scroll;
  overflow-x: hidden;
`;
function TasksStudioSidebarInner() {
  const { activeDocument, data, isLoading } = useTasks(), { state: state2, setActiveTab, setViewMode } = useTasksNavigation(), { activeTabId, viewMode, selectedTask } = state2, currentUser = useCurrentUser(), onTaskSelect = useCallback((id) => setViewMode({ type: "edit", id }), [setViewMode]), filteredList = useMemo(() => data.filter((item) => {
    var _a, _b;
    return item.createdByUser ? activeTabId === "assigned" ? item.assignedTo === (currentUser == null ? void 0 : currentUser.id) : activeTabId === "subscribed" ? (currentUser == null ? void 0 : currentUser.id) && ((_a = item.subscribers) == null ? void 0 : _a.includes(currentUser.id)) : activeTabId === "document" ? (activeDocument == null ? void 0 : activeDocument.documentId) && ((_b = item.target) == null ? void 0 : _b.document._ref) === activeDocument.documentId : !1 : !1;
  }), [activeDocument == null ? void 0 : activeDocument.documentId, activeTabId, data, currentUser]), content = useMemo(() => viewMode !== "list" ? /* @__PURE__ */ jsx(TasksFormBuilder, {}, selectedTask) : isLoading ? /* @__PURE__ */ jsx(Flex, { align: "center", justify: "center", children: /* @__PURE__ */ jsx(Spinner, {}) }) : /* @__PURE__ */ jsx(TasksList, { items: filteredList, onTaskSelect }), [filteredList, isLoading, onTaskSelect, selectedTask, viewMode]);
  return /* @__PURE__ */ jsxs(RootCard, { display: "flex", height: "fill", flex: 1, overflow: "hidden", children: [
    /* @__PURE__ */ jsxs(HeaderStack, { space: 3, padding: 3, sizing: "border", children: [
      /* @__PURE__ */ jsx(TasksSidebarHeader, { items: filteredList }),
      viewMode === "list" && !isLoading && /* @__PURE__ */ jsx(TasksListTabs, { activeTabId, onChange: setActiveTab })
    ] }),
    /* @__PURE__ */ jsx(
      ContentFlex,
      {
        direction: "column",
        flex: 1,
        overflow: "auto",
        padding: 3,
        paddingTop: 4,
        paddingX: 4,
        sizing: "border",
        children: content
      }
    )
  ] });
}
function TasksStudioSidebar() {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsx(TasksStudioSidebarInner, {}) : null;
}
function TaskCreateAction() {
  const { handleOpenTasks, setViewMode } = useTasksNavigation(), { enabled } = useTasksEnabled(), handleCreateTaskFromDocument = useCallback(() => {
    handleOpenTasks(), setViewMode({ type: "create" });
  }, [handleOpenTasks, setViewMode]), { t } = useTranslation(tasksLocaleNamespace);
  return enabled ? {
    icon: TaskIcon,
    label: t("actions.create.text"),
    title: t("actions.create.text"),
    group: ["paneActions"],
    onHandle: handleCreateTaskFromDocument
  } : null;
}
function SetActiveDocumentInner(document2) {
  const { documentId, documentType } = document2, { isLast } = usePane(), { setActiveDocument } = useTasks();
  return useEffect(() => (documentId && isLast && documentType && (setActiveDocument == null || setActiveDocument({
    documentId: getPublishedId(documentId),
    documentType
  })), () => {
    isLast && (setActiveDocument == null || setActiveDocument(null));
  }), [documentId, documentType, isLast, setActiveDocument]), null;
}
function SetActiveDocument(document2) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsx(SetActiveDocumentInner, { ...document2 }) : null;
}
function TasksDocumentInputLayout(props) {
  var _a, _b;
  const documentId = (_a = props.value) == null ? void 0 : _a._id, documentType = (_b = props.value) == null ? void 0 : _b._type;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SetActiveDocument, { documentId, documentType }),
    props.renderDefault(props)
  ] });
}
const ButtonContainer = styled.div`
  position: relative;
  [data-ui='Badge'] {
    position: absolute;
    top: -2px;
    right: -2px;
  }
`;
function TasksFooterOpenTasks() {
  const { data, activeDocument } = useTasks(), { handleOpenTasks, setActiveTab } = useTasksNavigation(), { enabled } = useTasksEnabled(), mediaIndex = useMediaIndex(), pendingTasks = useMemo(
    () => data.filter((item) => {
      var _a;
      return ((_a = item.target) == null ? void 0 : _a.document._ref) === (activeDocument == null ? void 0 : activeDocument.documentId) && item.status === "open" && item.createdByUser;
    }),
    [activeDocument, data]
  ), handleOnClick = useCallback(() => {
    handleOpenTasks(), setActiveTab("document");
  }, [handleOpenTasks, setActiveTab]), { t } = useTranslation(tasksLocaleNamespace);
  return pendingTasks.length === 0 || !enabled ? null : mediaIndex < 3 ? /* @__PURE__ */ jsxs(ButtonContainer, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        mode: "bleed",
        icon: TaskIcon,
        size: "large",
        onClick: handleOnClick,
        tooltipProps: {
          content: t("document.footer.open-tasks.placeholder", {
            count: pendingTasks.length
          })
        }
      }
    ),
    /* @__PURE__ */ jsx(Badge, { tone: "primary", fontSize: 0, children: pendingTasks.length })
  ] }) : /* @__PURE__ */ jsx(
    Button,
    {
      mode: "bleed",
      tooltipProps: {
        content: t("document.footer.open-tasks.placeholder", {
          count: pendingTasks.length
        })
      },
      text: t("document.footer.open-tasks.text", { count: pendingTasks.length }),
      onClick: handleOnClick
    }
  );
}
const VARIANTS = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
}, TRANSITION = { duration: 0.2 }, FULLSCREEN_MEDIA_INDEX = 1, POSITION_ABSOLUTE_MEDIA_INDEX = 2, RootFlex = styled(Flex)(({ theme }) => {
  const media = theme.sanity.media;
  return css`
    min-height: 100%;

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      position: relative;
    }
  `;
}), SidebarMotionLayer = styled(motion(Layer))(({ theme }) => {
  const media = theme.sanity.media;
  return css`
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 360px;
    border-left: 1px solid var(--card-border-color);
    box-sizing: border-box;
    overflow: hidden;

    box-shadow:
      0px 6px 8px -4px var(--card-shadow-umbra-color),
      0px 12px 17px -1px var(--card-shadow-penumbra-color);

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      bottom: 0;
      position: absolute;
      right: 0;
      top: 0;
    }

    @media (max-width: ${media[FULLSCREEN_MEDIA_INDEX]}px) {
      border-left: 0;
      min-width: 100%;
      left: 0;
    }
  `;
});
function TasksStudioActiveToolLayoutInner(props) {
  const mediaIndex = useMediaIndex(), {
    state: { isOpen }
  } = useTasksNavigation(), scrollLock = mediaIndex <= FULLSCREEN_MEDIA_INDEX && isOpen;
  return /* @__PURE__ */ jsxs(RootFlex, { sizing: "border", height: "fill", children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, height: "fill", overflow: scrollLock ? "hidden" : "auto", children: props.renderDefault(props) }),
    /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, children: isOpen && /* @__PURE__ */ jsx(
      SidebarMotionLayer,
      {
        animate: "visible",
        height: "fill",
        initial: "hidden",
        transition: TRANSITION,
        variants: VARIANTS,
        children: /* @__PURE__ */ jsx(TasksStudioSidebar, {})
      }
    ) })
  ] });
}
function TasksStudioActiveToolLayout(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsx(TasksStudioActiveToolLayoutInner, { ...props }) : props.renderDefault(props);
}
const TasksStudioLayoutInner = (props) => {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsx(AddonDatasetProvider, { children: /* @__PURE__ */ jsx(TasksProvider, { children: /* @__PURE__ */ jsx(TasksNavigationProvider, { children: props.renderDefault(props) }) }) }) : props.renderDefault(props);
};
function TasksStudioLayout(props) {
  return /* @__PURE__ */ jsx(TasksEnabledProvider, { children: /* @__PURE__ */ jsx(TasksStudioLayoutInner, { ...props }) });
}
const EMPTY_ARRAY = [];
function TasksStudioNavbarInner(props) {
  const {
    handleOpenTasks,
    state: { isOpen }
  } = useTasksNavigation(), { t } = useTranslation(tasksLocaleNamespace), actions = useMemo(() => [
    ...(props == null ? void 0 : props.__internal_actions) || EMPTY_ARRAY,
    {
      icon: PanelRightIcon,
      location: "topbar",
      name: "tasks-topbar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    },
    {
      icon: TaskIcon,
      location: "sidebar",
      name: "tasks-sidebar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    }
  ], [handleOpenTasks, isOpen, props == null ? void 0 : props.__internal_actions, t]);
  return props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_actions: actions
  });
}
function TasksStudioNavbar(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsx(TasksStudioNavbarInner, { ...props }) : props.renderDefault(props);
}
const tasks = definePlugin({
  name: "sanity/tasks",
  // eslint-disable-next-line camelcase
  __internal_tasks: {
    footerAction: /* @__PURE__ */ jsx(TasksFooterOpenTasks, {})
  },
  document: {
    actions: (prev) => [...prev, TaskCreateAction].filter(Boolean)
  },
  studio: {
    components: {
      layout: TasksStudioLayout,
      navbar: TasksStudioNavbar,
      activeToolLayout: TasksStudioActiveToolLayout
    }
  },
  form: {
    components: {
      input: (props) => {
        var _a;
        return props.id === "root" && ((_a = props.schemaType.type) == null ? void 0 : _a.name) === "document" ? /* @__PURE__ */ jsx(TasksDocumentInputLayout, { ...props }) : props.renderDefault(props);
      }
    }
  },
  i18n: {
    bundles: [tasksUsEnglishLocaleBundle]
  }
}), LiveEditBadge = (props) => {
  const { liveEdit } = props;
  return liveEdit ? {
    label: "Live",
    color: "danger"
  } : null;
}, state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [], activePanes = state.activePanes || [], editDocumentId = params.id || uuid(), isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane == "object" && ((_a = pane.canHandleIntent) != null && _a.call(pane, intent, params, {
      pane,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type")) {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$1;
      return {
        panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]])
      };
    }
  }
  return { intent, params, payload };
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */ new Map();
  return visitDiff(diff, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation)
      return !0;
    const { author, timestamp } = child.annotation, previous = authorMap.get(author);
    return (!previous || previous.timestamp < timestamp) && authorMap.set(author, child.annotation), !0;
  }), Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
const Scroller = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function ChangesInspector(props) {
  const { onClose } = props, { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane(), scrollRef = useRef(null), diff = useTimelineSelector(timelineStore, (state2) => state2.diff), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, { t } = useTranslation("studio"), documentContext = useMemo(
    () => ({
      documentId,
      schemaType,
      FieldWrapper: ChangeFieldWrapper,
      rootDiff: diff,
      isComparingCurrent,
      value
    }),
    [documentId, diff, isComparingCurrent, schemaType, value]
  ), changeAnnotations = useMemo(
    () => diff ? collectLatestAuthorAnnotations(diff) : [],
    [diff]
  );
  return /* @__PURE__ */ jsxs(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("changes.action.close-label"),
        flex: "none",
        onClose,
        title: t("changes.title"),
        children: /* @__PURE__ */ jsxs(Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [
          /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }),
          /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(
            DiffTooltip,
            {
              annotations: changeAnnotations,
              description: t("changes.changes-by-author"),
              portal: !0,
              children: /* @__PURE__ */ jsx(AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map(({ author }) => /* @__PURE__ */ jsx(UserAvatar, { user: author }, author)) })
            }
          ) })
        ] })
      }
    ),
    /* @__PURE__ */ jsx(Card, { flex: 1, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef.current, children: /* @__PURE__ */ jsx(Scroller, { "data-ui": "Scroller", ref: scrollRef, children: /* @__PURE__ */ jsx(Box, { flex: 1, padding: 4, children: /* @__PURE__ */ jsx(
      Content,
      {
        diff,
        documentContext,
        error: timelineError,
        loading,
        schemaType
      }
    ) }) }) }) })
  ] });
}
function Content({
  error,
  diff,
  documentContext,
  loading,
  schemaType
}) {
  return error ? /* @__PURE__ */ jsx(NoChanges, {}) : loading ? /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) : diff ? /* @__PURE__ */ jsx(DocumentChangeContext.Provider, { value: documentContext, children: /* @__PURE__ */ jsx(ChangeList, { diff, schemaType }) }) : /* @__PURE__ */ jsx(NoChanges, {});
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const { features } = useStructureTool(), { t } = useTranslation();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: t("changes.title")
    };
  },
  component: ChangesInspector,
  onClose: ({ params }) => ({ params: { ...params, since: void 0 } }),
  onOpen: ({ params }) => ({ params: { ...params, since: "@lastPublished" } })
};
function getPathTitles(options) {
  const { path, schemaType, value } = options, result = [];
  let s = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!isRecord(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s.jsonType !== "object")
        throw new Error(
          `Parent type is not an object schema type, cannot get path segment: .${segment}`
        );
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({ name: segment }), result;
      s = field.type, result.push(s);
      continue;
    }
    if (typeof segment == "number") {
      if (!isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: [${segment}]`
        );
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : isRecord(v) ? ofType.name === (v == null ? void 0 : v._type) : !1);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s = itemType, result.push(s);
      continue;
    }
    if (isRecord(segment) && segment._key) {
      if (!isArray(v))
        throw new Error(
          `Parent value is not an array, cannot get path segment: [_key == ${segment}]`
        );
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: .${segment}`
        );
      if (v = (v != null ? v : []).find((i) => isRecord(i) && i._key === segment._key), !isRecord(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      const ofType = s.of.find((i) => isRecord(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType)
        throw new Error(`Array item type not found: .${v == null ? void 0 : v._type}`);
      s = ofType, result.push(s);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
const MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
}, MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const { onClose } = props, { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane(), { t } = useTranslation("validation"), handleOpen = useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onFocus, onPathOpen]
  );
  return /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("panel.close-button-aria-label"),
        flex: "none",
        onClose,
        title: t("panel.title")
      }
    ),
    /* @__PURE__ */ jsxs(Card, { flex: 1, overflow: "auto", padding: 3, children: [
      validation.length === 0 && /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("panel.no-errors-message") }) }),
      validation.length > 0 && /* @__PURE__ */ jsx(Stack, { space: 2, children: validation.map((marker, i) => /* @__PURE__ */ jsx(
        ValidationCard,
        {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        },
        i
      )) })
    ] })
  ] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props, handleOpen = useCallback(() => onOpen(marker.path), [marker, onOpen]), [errorInfo, setErrorInfo] = useState(null);
  return /* @__PURE__ */ jsxs(ErrorBoundary, { onCatch: setErrorInfo, children: [
    errorInfo && /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsx(Text, { size: 1, children: errorInfo.error.message }) }),
    !errorInfo && /* @__PURE__ */ jsx(
      Card,
      {
        __unstable_focusRing: !0,
        as: "button",
        onClick: handleOpen,
        padding: 3,
        radius: 2,
        tone: MARKER_TONE[marker.level],
        children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
          /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: createElement(MARKER_ICON[marker.level]) }) }),
          /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
            /* @__PURE__ */ jsx(
              DocumentNodePathBreadcrumbs,
              {
                path: marker.path,
                schemaType,
                value
              }
            ),
            /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: marker.message })
          ] })
        ] })
      }
    )
  ] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props, pathTitles = useMemo(
    () => getPathTitles({ path, schemaType, value }),
    [path, schemaType, value]
  );
  return pathTitles.length ? /* @__PURE__ */ jsx(Text, { size: 1, children: pathTitles.map((t, i) => /* @__PURE__ */ jsxs(Fragment, { children: [
    i > 0 && /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }),
    /* @__PURE__ */ jsx("span", { style: { fontWeight: 500 }, children: t.title || t.name })
  ] }, i)) }) : null;
}
function useMenuItem(props) {
  const { documentId, documentType } = props, { t } = useTranslation("validation"), { validation: validationMarkers } = useValidationStatus(documentId, documentType), validation = useMemo(
    () => validationMarkers.map((item) => ({
      level: item.level,
      message: item.message,
      path: item.path
    })),
    [validationMarkers]
  ), hasErrors = validation.some(isValidationError), hasWarnings = validation.some(isValidationWarning), icon = useMemo(() => hasErrors ? ErrorOutlineIcon : hasWarnings ? WarningOutlineIcon : CheckmarkCircleIcon, [hasErrors, hasWarnings]), tone = useMemo(() => hasErrors ? "critical" : hasWarnings ? "caution" : "positive", [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: t("panel.title"),
    tone,
    showAsAction: !0
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
}, EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [
    route.create({
      path: "/:params",
      transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } }
    })
  ]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: { toState, toPath }
    }
  })
]), panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i, isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str), isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str), exclusiveParams = ["view", "since", "rev", "inspect", "comment"], isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS, payload: void 0 };
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else
      isPayloadLike(chunk) ? pane.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane;
  }, sibling);
}
function encodeChunks(pane, index, group) {
  const { payload, params = {}, id } = pane, [firstSibling] = group, paneIsFirstSibling = pane === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    var _a;
    const [key, value] = entry;
    if (!value)
      return !1;
    if (paneIsFirstSibling)
      return !0;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [
      firstSibling,
      ...restOfSiblings.map((sibling) => ({
        ...firstSibling,
        ...sibling,
        id: sibling.id || firstSibling.id,
        params: { ...omit(firstSibling.params, exclusiveParams), ...sibling.params },
        payload: sibling.payload || firstSibling.payload
      }))
    ];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
const documentActions = [
  PublishAction,
  UnpublishAction,
  DiscardChangesAction,
  DuplicateAction,
  DeleteAction,
  HistoryRestoreAction
], documentBadges = [LiveEditBadge], inspectors = [validationInspector, changesInspector], structureTool = definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions) => Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])),
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    plugins: [comments(), tasks()],
    tools: [
      {
        name: (options == null ? void 0 : options.name) || "structure",
        title: (options == null ? void 0 : options.title) || "Structure",
        icon,
        component: lazy(() => import("./index3.js")),
        canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1,
        getIntentState,
        // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
        controlsDocumentTitle: !0,
        options,
        router
      }
    ],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  return "type" in params ? "template" in params ? { template: !0 } : !0 : !1;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? { mode: params.mode === "structure" } : !0 : !1;
}
function StructureToolProvider({
  defaultDocumentNode,
  structure: resolveStructure,
  children
}) {
  const [layoutCollapsed, setLayoutCollapsed] = useState(!1), source = useSource(), configContext = useConfigContextFromSource(source), documentStore = useDocumentStore(), S = useMemo(() => createStructureBuilder({
    defaultDocumentNode,
    source
  }), [defaultDocumentNode, source]), rootPaneNode = useMemo(() => resolveStructure ? resolveStructure(S, {
    ...configContext,
    documentStore
  }) : S.defaults(), [S, resolveStructure, configContext, documentStore]), features = useMemo(
    () => ({
      backButton: layoutCollapsed,
      resizablePanes: !layoutCollapsed,
      reviewChanges: !layoutCollapsed,
      splitPanes: !layoutCollapsed,
      splitViews: !layoutCollapsed
    }),
    [layoutCollapsed]
  ), structureTool2 = useMemo(() => ({
    features,
    layoutCollapsed,
    setLayoutCollapsed,
    rootPaneNode,
    structureContext: S.context
  }), [features, layoutCollapsed, rootPaneNode, S.context]);
  return /* @__PURE__ */ jsx(StructureToolContext.Provider, { value: structureTool2, children });
}
export {
  Pane as $,
  maybeSerializeMenuItem as A,
  getOrderingMenuItem as B,
  CommentsIntentProvider as C,
  DocumentInspectorHeader as D,
  getOrderingMenuItemsForSchemaType as E,
  maybeSerializeMenuItemGroup as F,
  GenericListBuilder as G,
  MenuItemGroupBuilder as H,
  InitialValueTemplateItemBuilder as I,
  HELP_URL as J,
  form as K,
  ListBuilder as L,
  MenuItemBuilder as M,
  component as N,
  ComponentViewBuilder as O,
  PaneLayout as P,
  FormViewBuilder as Q,
  GenericViewBuilder as R,
  SerializeError as S,
  maybeSerializeView as T,
  structureTool as U,
  StructureToolProvider as V,
  useStructureTool as W,
  usePane as X,
  PaneHeader as Y,
  PaneHeaderActions as Z,
  BackLink as _,
  ConfirmDeleteDialogContainer as a,
  usePaneLayout as a0,
  PaneItem as a1,
  PaneContent as a2,
  _DEBUG as a3,
  ChildLink as a4,
  ReferenceChildLink as a5,
  ParameterizedLink as a6,
  LOADING_PANE as a7,
  LoadingPane as a8,
  setActivePanes as a9,
  PaneRouterContext as b,
  DocumentPane as c,
  DocumentPaneProvider as d,
  useDocumentTitle as e,
  useDocumentPane as f,
  DocumentListPane as g,
  ComponentBuilder as h,
  createStructureBuilder as i,
  DocumentBuilder as j,
  documentFromEditor as k,
  documentFromEditorWithInitialValue as l,
  DocumentListBuilder as m,
  getTypeNamesFromFilter as n,
  DocumentListItemBuilder as o,
  isDocumentListItem as p,
  DocumentTypeListBuilder as q,
  shallowIntentChecker as r,
  structureLocaleNamespace as s,
  defaultInitialValueTemplateItems as t,
  usePaneRouter as u,
  maybeSerializeInitialValueTemplateItem as v,
  menuItemsFromInitialValueTemplateItems as w,
  DEFAULT_INTENT_HANDLER as x,
  defaultIntentChecker as y,
  ListItemBuilder as z
};
//# sourceMappingURL=StructureToolProvider.js.map
