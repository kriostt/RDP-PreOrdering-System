import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import * as PathUtils from "@sanity/util/paths";
import { pathFor, isEqual as isEqual$1, toString, trimChildPath as trimChildPath$1, startsWith } from "@sanity/util/paths";
import { useRef, useContext, useState, useCallback, useMemo, useEffect, createElement, StrictMode, useLayoutEffect } from "react";
import deepCompare from "react-fast-compare";
import { C as ConnectorContext, a as useReporter, S as ScrollContext, r as resizeObserver, b as useReportedValues, d as SvgWrapper, e as Connector, D as DEBUG_LAYER_BOUNDS, i as isNonNullable$1, T as Tracker, f as ScrollContainer, h as useUserColorManager, j as useTranslation, k as getAnnotationColor, l as DiffTooltip, m as Checkbox, F as FromToArrow, P as Preview, n as DiffFromTo, o as SlugPreview, p as StringPreview, q as DatetimeFieldDiff, s as pathToString, H as HoveredFieldContext, t as FormFieldPresenceContext, A as ArrayOfObjectsItem, M as MemberItemError, R as ReviewChangesContext, v as defaultResolveAnnotationComponent, w as defaultResolveBlockComponent, x as defaultResolveInlineBlockComponent, y as defaultResolveFieldComponent, z as defaultResolveInputComponent, B as defaultResolveItemComponent, E as ArrayOfObjectsFunctions, G as DefaultMarkers, I as FormBuilderContext, J as FormCallbacksProvider, K as DocumentIdProvider, L as PresenceProvider, V as ValidationProvider, N as EMPTY_ARRAY$2, O as useSource, Q as useInputComponent, U as useFieldComponent, W as usePreviewComponent, X as useItemComponent, Y as useBlockComponent, Z as useInlineBlockComponent, _ as useAnnotationComponent, $ as PreviewLoader, a0 as PatchEvent, a1 as GetFormValueProvider, a2 as FormValueProvider, a3 as DocumentFieldActionsProvider, a4 as memoize, a5 as memoizeKeyGen, a6 as memoizedPair, a7 as validateTemplates, a8 as isBuilder, a9 as useDocumentStore, aa as getPublishedId, ab as useHistoryStore, ac as useClient, ad as DEFAULT_STUDIO_CLIENT_OPTIONS, ae as useProjectStore, af as prepareConfig, ag as useWorkspace, ah as AddonDatasetContext, ai as StudioProvider, aj as GlobalStyle, ak as StudioLayout, al as useListFormat, am as intlCache, an as useRelativeTime, ao as useUserStore, ap as grantsPermissionOn, aq as HookStateContainer, ar as useReferringDocuments, as as ZIndexContext, at as defaults, au as getFieldLevel, av as isRecord, aw as useCurrentUser, ax as immutableReconcile, ay as isMemberArrayOfObjects, az as isMemberObject, aA as SANITY_PATCH_TYPE } from "./_chunks-es/TransformPatches.js";
import { et, eu, ch, cd, ci, cj, cb, ck, cy, b6, cc, aR, aS, cm, dJ, bo, aC, aD, bp, bq, br, aV, b5, b7, eB, eA, ez, ey, ex, aE, aN, b9, ba, aF, dM, cR, fd, fm, cn, co, aO, aP, bs, bF, bt, bu, bw, bv, bG, dm, aG, aH, fy, cp, f2, bx, c5, c6, c7, by, dr, dn, dp, dq, cT, cN, b_, b$, c0, c1, c2, c3, bz, bA, cU, b1, aT, aI, b2, aW, aJ, df, dg, aQ, cz, cA, cB, bB, eW, bC, cq, cr, cC, cD, cE, ds, aK, cc as cc2, dt, aM, cS, cQ, ep, bD, fM, em, dy, bf, eQ, eL, eR, eJ, eM, eK, cs, ct, eV, a_, cu, eX, eS, eT, cv, aU, cw, a$, ei, ej, eU, b0, d2, dl, cl, f0, eZ, e$, e_, eY, cx, b3, fk, bE, ce, cg, f4, f1, fb, fc, en, dE, eD, fJ, dU, fw, dF, dS, dL, dz, d_, ft, ec, eh, fl, dD, dT, eo, fv, dB, fB, aX, aY, fj, er, cL, dk, fh, db, dc, dd, eH, eI, eP, cJ, bc, fn, dV, dW, fD, fC, bP, bd, bj, bk, e6, e9, fs, fq, e1, bW, bX, f6, d$, du, dv, dw, dG, dC, ed, bO, bZ, f5, fz, cK, bb, cG, bK, c$, c_, d0, dH, cZ, dI, bg, fo, fp, bY, bI, bJ, cY, cW, cV, bh, fr, bL, fA, cX, bM, fE, e2, ev, fu, bH, bS, bU, bT, bR, dK, dX, eO, bV, cM, dx, fx, eg, de, bN, fe, ff, fg, be, cH, cF, fG, dY, bQ, fF, fH, cI, dA, dj, ew, bm, eF, eG, eC, eE, dP, d3, d4, ca, bn, bi, d5, e8, e7, ek, dO, eb, ea, e0, d6, c8, d1, cO, c4, dh, el, dN, c9, di, e3, e4, dR, fI, b8, dQ, aL, d7, cP, e5, eq, aZ, d8, eN, ef, ee, d9, fL, da, es, fi, cf, f3, f7, b4, fK, fa, aB, f9, f8, dZ, bl } from "./_chunks-es/TransformPatches.js";
import sortBy from "lodash/sortBy.js";
import { useMemoObservable } from "react-rx";
import { of, merge, BehaviorSubject, tap, map, distinctUntilChanged, catchError, combineLatest, firstValueFrom, timer, share, take, skip, debounce, switchMap as switchMap$1, forkJoin, mergeMap, concat } from "rxjs";
import { switchMap, map as map$1, mapTo, startWith, distinctUntilChanged as distinctUntilChanged$1 } from "rxjs/operators";
import isEqual$2 from "lodash/isEqual.js";
import throttle from "lodash/throttle.js";
import { isKeyedObject, isKeySegment, isObjectSchemaType, isArraySchemaType, isArrayOfObjectsSchemaType } from "@sanity/types";
export * from "@sanity/types";
import { Badge, Flex, Box, Text, studioTheme, Hotkeys as Hotkeys$1, TextInput } from "@sanity/ui";
import { IntentLink } from "sanity/router";
import { u as useCurrentLocale, B as Button } from "./_chunks-es/getJsonStream.js";
import { a } from "./_chunks-es/getJsonStream.js";
import isString from "lodash/isString.js";
import "dataloader";
import "history";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/with-selector";
import "lodash/escapeRegExp.js";
import "lodash/isEqual";
import "lodash/startCase";
import "react-dom/server";
import "@sanity/schema/_internal";
import "lodash/compact.js";
import "lodash/intersection.js";
import "lodash/keyBy.js";
import "lodash/partition.js";
import "lodash/toLower.js";
import "lodash/union.js";
import "lodash/uniq.js";
import "lodash/words.js";
import "lodash/isFinite.js";
import "lodash/intersection";
import "lodash/isEmpty";
import "date-fns";
import "react-i18next";
import "@sanity/portable-text-editor";
import "@sanity/icons";
import "lodash/omit.js";
import "@sanity/diff-match-patch";
import flatten from "lodash/flatten.js";
import "lodash/orderBy.js";
import "lodash/xor.js";
import "sanity-diff-patch";
import "lodash/startCase.js";
import "lodash/debounce.js";
import "nano-pubsub";
import "shallow-equals";
import "scroll-into-view-if-needed";
import "lodash/get.js";
import "get-random-values-esm";
import { resolveTypeName as resolveTypeName$1 } from "@sanity/util/content";
import "lodash/isPlainObject.js";
import "@tanstack/react-virtual";
import "@sanity/util/legacyDateFormat";
import "speakingurl";
import "@sanity/telemetry/react";
import "lodash/find.js";
import castArray from "lodash/castArray.js";
import pick from "lodash/pick.js";
import { arrayToJSONMatchPath } from "@sanity/mutator";
import "@sanity/schema";
import "@sanity/asset-utils";
import "@sanity/image-url";
import "@sanity/uuid";
import "exif-component";
import "react-is";
import "lodash/difference.js";
import "lodash/memoize.js";
import "lodash/identity.js";
import "lodash/values.js";
import "lodash/assignWith.js";
import "lodash/capitalize.js";
import { createRoot } from "react-dom/client";
import "lodash/groupBy.js";
import "json-reduce";
import "rxjs-exhaustmap-with-trailing";
import "groq-js";
import "rxjs-etc/operators";
import "mendoza";
import "@sanity/diff";
import "raf";
import "@sanity/bifur-client";
import "@sanity/client";
import "i18next";
import { hues, black, white, blue, gray, red, green, yellow } from "@sanity/color";
import { parseColor, rgbToHex, multiply, screen, createColorTheme, rgba } from "@sanity/ui/theme";
import { getLuminance, mix, parseToRgb, rgb } from "polished";
function noop() {
}
function NoopTracker({ children }) {
  return /* @__PURE__ */ jsx(Fragment, { children });
}
function createNoopTrackerScope() {
  return {
    useReportedValues: noop,
    Tracker: NoopTracker,
    useReporter: noop
  };
}
const ChangeFieldWrapper = (props) => {
  const ref = useRef(null), { onSetFocus } = useContext(ConnectorContext), [isHover, setHover] = useState(!1), onMouseEnter = useCallback(() => {
    setHover(!0);
  }, []), onMouseLeave = useCallback(() => {
    setHover(!1);
  }, []);
  useReporter(
    `change-${PathUtils.toString(props.path)}`,
    () => ({
      element: ref.current,
      path: props.path,
      isChanged: !0,
      hasFocus: !1,
      hasHover: isHover,
      hasRevertHover: props.hasHover
    }),
    // note: deepCompare should be ok here since we're not comparing deep values
    deepCompare
  );
  const handleClick = useCallback(
    (event) => {
      setFocusWithStopPropagation(event, onSetFocus, props.path);
    },
    [onSetFocus, props.path]
  );
  return /* @__PURE__ */ jsx("div", { ref, onClick: handleClick, onMouseLeave, onMouseEnter, children: props.children });
};
function setFocusWithStopPropagation(event, onSetFocus, path) {
  event.stopPropagation(), onSetFocus(path);
}
function isArray(value) {
  return Array.isArray(value);
}
function isTruthy(value) {
  return !!value;
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
const FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif", FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace", uncaughtErrorHandler = () => (
  // prettier-ignore
  [
    "window.onerror = function(m,u,l,c,e) {",
    "var p=window.location.port;",
    "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');",
    "var r=document.getElementById('sanity');",
    "while(r.firstChild){r.removeChild(r.firstChild);}",
    "var s=document.createElement('style');",
    "s.appendChild(document.createTextNode('",
    "html,body,#sanityBody,#sanity,#sanityError{height:100%;}",
    "body{-webkit-font-smoothing:antialiased;margin:0;}",
    `#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:${FONT_SANS_SERIF};font-size:16px;line-height:21px;min-height:100%;}`,
    "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}",
    "@media(min-width:512px){",
    "#sanityError>div{",
    "padding:47px 84px;",
    "}",
    "}",
    "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}",
    "#sanityError button:hover{background-color:#1E63D0;}",
    "#sanityError button:active{background-color:#1B50A5;}",
    "'));",
    "document.head.appendChild(s);",
    "var f=document.createElement('div');",
    "f.id='sanityError';",
    "f.innerHTML='",
    "<div>",
    '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>',
    '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>',
    '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>',
    '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">',
    `<code style="font-family:${FONT_MONOSPACE};">`,
    "'+e.stack.replaceAll(h,'')+'",
    "</code>",
    "</pre>",
    "</div>",
    "';",
    "var b=f.querySelector('.sanity-error-handler__reload-btn');",
    "if(b){",
    "b.onclick=function() {",
    "window.location.reload();",
    "}",
    "};",
    "r.appendChild(f);",
    "};"
  ].join("")
);
function useThrottledCallback(callback, wait, options) {
  return useMemo(
    () => throttle(callback, wait, options),
    [callback, options, wait]
  );
}
function useOnScroll(callback) {
  const parentContext = useContext(ScrollContext);
  useEffect(() => parentContext == null ? void 0 : parentContext.subscribe(callback), [callback, parentContext]);
}
function ScrollMonitor({ onScroll, children }) {
  return useOnScroll(onScroll), /* @__PURE__ */ jsx(Fragment, { children });
}
function findMostSpecificTarget(targetType, id, values) {
  const pathString = id.slice(id.indexOf("-") + 1) || "[]", path = PathUtils.fromString(pathString), exactId = `${targetType}-${PathUtils.toString(path)}`;
  if (values.has(exactId))
    return values.get(exactId);
  let mostSpecific;
  for (const [targetId, target] of values) {
    if (!("path" in target) || !targetId.startsWith(targetType))
      continue;
    const numEqual = PathUtils.numEqualSegments(path, target.path), lastPathSegment = target.path[target.path.length - 1], pathOnlyDiffersByKey = numEqual === target.path.length - 1 && isKeyedObject(lastPathSegment);
    if (numEqual !== 0 && !(numEqual !== target.path.length && !pathOnlyDiffersByKey) && (mostSpecific = target, numEqual === path.length))
      break;
  }
  return mostSpecific;
}
function hasOverflowScroll(el2) {
  const overflow = getComputedStyle(el2).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el2) {
  return (el2.scrollHeight !== el2.offsetHeight || el2.scrollWidth !== el2.offsetWidth) && hasOverflowScroll(el2);
}
const getOffsetsTo = (source, target) => {
  const bounds = {
    top: 0,
    left: 0,
    height: target.offsetHeight,
    width: target.offsetWidth
  }, rect = {
    top: 0,
    left: 0,
    height: source.offsetHeight,
    width: source.offsetWidth
  };
  let foundScrollContainer = !1, el2 = source;
  for (; el2 && el2 !== target && target.contains(el2); )
    foundScrollContainer && (bounds.top += el2.offsetTop, bounds.left += el2.offsetLeft), hasOverflowScroll(el2) && (bounds.top = el2.offsetTop, bounds.height = el2.offsetHeight, bounds.left = el2.offsetLeft, bounds.width = el2.offsetWidth, foundScrollContainer = !0), rect.top += el2.offsetTop - el2.scrollTop, rect.left += el2.offsetLeft - el2.scrollLeft, el2 = el2.offsetParent;
  return { rect, bounds };
};
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
const SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  let parentElementWithScroll = field.element;
  for (; !isScrollable(parentElementWithScroll); )
    if (parentElementWithScroll = parentElementWithScroll.parentElement, !parentElementWithScroll)
      return;
  parentElementWithScroll.scroll({
    top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING,
    left: 0,
    behavior: "smooth"
  });
}
function useResizeObserver(element, onResize) {
  useEffect(() => resizeObserver.observe(element, onResize), [element, onResize]);
}
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [], changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged)
      continue;
    const [id, reportedChangeBar] = value;
    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  return { connectors: (isHoverConnector ? changeBarsWithHover : changeBarsWithFocus).map(([id]) => {
    const field = findMostSpecificTarget("field", id, byId), change = findMostSpecificTarget("change", id, byId);
    return !field || !change ? null : { field: { id, ...field }, change: { id, ...change } };
  }).filter(isNonNullable$1).map(({ field, change }) => ({
    hasHover: field.hasHover || change.hasHover,
    hasFocus: field.hasFocus,
    hasRevertHover: change.hasRevertHover,
    field: { ...field, ...getOffsetsTo(field.element, rootElement) },
    change: { ...change, ...getOffsetsTo(change.element, rootElement) }
  })), isHoverConnector };
}
function ConnectorsOverlay(props) {
  const { rootElement, onSetFocus } = props, [hovered, setHovered] = useState(null), allReportedValues = useReportedValues(), byId = useMemo(
    () => new Map(allReportedValues),
    [allReportedValues]
  ), [{ connectors }, setState] = useState(
    () => getState(allReportedValues, hovered, byId, rootElement)
  ), visibleConnectors = useMemo(
    () => sortBy(connectors, (c) => 0 - c.field.path.length).slice(0, 1),
    [connectors]
  ), handleScrollOrResize = useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  return useResizeObserver(rootElement, handleScrollOrResize), /* @__PURE__ */ jsx(ScrollMonitor, { onScroll: handleScrollOrResize, children: /* @__PURE__ */ jsx(SvgWrapper, { style: { zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex }, children: visibleConnectors.map(({ field, change }) => change ? /* @__PURE__ */ jsx(
    ConnectorGroup,
    {
      field,
      change,
      onSetFocus,
      setHovered
    },
    field.id
  ) : null) }) });
}
function ConnectorGroup(props) {
  const { change, field, onSetFocus, setHovered } = props, onConnectorClick = useCallback(() => {
    scrollIntoView(field), scrollIntoView(change), onSetFocus(field.path);
  }, [field, change, onSetFocus]), handleMouseEnter = useCallback(() => setHovered(field.id), [field, setHovered]), handleMouseLeave = useCallback(() => setHovered(null), [setHovered]), from = useMemo(
    () => ({
      rect: {
        ...field.rect,
        left: field.rect.left + 3
      },
      bounds: field.bounds
    }),
    [field.bounds, field.rect]
  ), to = useMemo(
    () => ({
      rect: {
        ...change.rect,
        left: change.rect.left + 1
      },
      bounds: change.bounds
    }),
    [change.bounds, change.rect]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("g", { onClick: onConnectorClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: /* @__PURE__ */ jsx(Connector, { from, to }) }),
    DEBUG_LAYER_BOUNDS
  ] });
}
function EnabledChangeConnectorRoot({
  children,
  className,
  isReviewChangesOpen,
  onOpenReviewChanges,
  onSetFocus,
  ...restProps
}) {
  const [rootElement, setRootElement] = useState(), contextValue = useMemo(
    () => ({
      isReviewChangesOpen,
      onOpenReviewChanges,
      onSetFocus
    }),
    [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]
  );
  return /* @__PURE__ */ jsx(ConnectorContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(Tracker, { children: /* @__PURE__ */ jsxs(ScrollContainer, { ...restProps, ref: setRootElement, className, children: [
    children,
    rootElement && /* @__PURE__ */ jsx(ConnectorsOverlay, { rootElement, onSetFocus })
  ] }) }) });
}
function DisabledChangeConnectorRoot({
  children,
  className
}) {
  return /* @__PURE__ */ jsx(ScrollContainer, { className, children });
}
const ChangeConnectorRoot = EnabledChangeConnectorRoot;
function BetaBadge(props) {
  const { fontSize = 1, children = "Beta", ...rest } = props;
  return /* @__PURE__ */ jsx(Badge, { ...rest, fontSize, radius: 2, tone: "primary", children });
}
function Favicons({ basePath }) {
  const base = `${basePath.replace(/\/+$/, "")}/static`;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("link", { rel: "icon", href: `${base}/favicon.ico`, sizes: "any" }),
    /* @__PURE__ */ jsx("link", { rel: "icon", href: `${base}/favicon.svg`, type: "image/svg+xml" }),
    /* @__PURE__ */ jsx("link", { rel: "apple-touch-icon", href: `${base}/apple-touch-icon.png` }),
    /* @__PURE__ */ jsx("link", { rel: "manifest", href: `${base}/manifest.webmanifest` })
  ] });
}
const errorHandlerScript = `
;(function () {
  var _caughtErrors = []

  var errorChannel = (function () {
    var subscribers = []

    function publish(msg) {
      for (var i = 0; i < subscribers.length; i += 1) {
        subscribers[i](msg)
      }
    }

    function subscribe(subscriber) {
      subscribers.push(subscriber)

      return function () {
        var idx = subscribers.indexOf(subscriber)

        if (idx > -1) {
          subscribers.splice(idx, 1)
        }
      }
    }

    return {publish, subscribe, subscribers}
  })()

  // NOTE: Store the error channel instance in the global scope so that the Studio application can
  // access it and subscribe to errors.
  window.__sanityErrorChannel = {
    subscribe: errorChannel.subscribe,
  }

  function _nextTick(callback) {
    setTimeout(callback, 0)
  }

  function _handleError(error, params) {
    _nextTick(function () {
      // - If there are error channel subscribers, then we notify them (no console error).
      // - If there are no subscribers, then we log the error to the console and render the error overlay.
      if (errorChannel.subscribers.length) {
        errorChannel.publish({error, params})
      } else {
        console.error(error)

        _renderErrorOverlay(error, params)
      }
    })
  }

  var ERROR_BOX_STYLE = [
    'background: #fff',
    'border-radius: 6px',
    'box-sizing: border-box',
    'color: #121923',
    'flex: 1',
    "font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif",
    'font-size: 16px',
    'line-height: 21px',
    'margin: 0 auto',
    'max-width: 960px',
    'overflow: auto',
    'padding: 20px',
    'width: 100%',
  ].join(';')

  var ERROR_CODE_STYLE = [
    'color: #972E2A',
    "font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace",
    'font-size: 13px',
    'line-height: 17px',
    'margin: 0',
  ].join(';')

  function _renderErrorOverlay(error, params) {
    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')
    var colno = params.event.colno
    var lineno = params.event.lineno
    var filename = params.event.filename

    errorElement.id = '__sanityError'
    errorElement.innerHTML = [
      '<div style="' + ERROR_BOX_STYLE + '">',
      '<div style="font-weight: 700;">Uncaught error: ' + error.message + '</div>',
      '<div style="color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;">' +
        filename +
        ':' +
        lineno +
        ':' +
        colno +
        '</div>',
      '<pre style="' + ERROR_CODE_STYLE + '">' + error.stack + '</pre>',
      '</div>',
    ].join('')

    errorElement.style.position = 'fixed'
    errorElement.style.zIndex = 1000000
    errorElement.style.top = 0
    errorElement.style.left = 0
    errorElement.style.right = 0
    errorElement.style.bottom = 0
    errorElement.style.padding = '20px'
    errorElement.style.background = 'rgba(16,17,18,0.66)'
    errorElement.style.display = 'flex'
    errorElement.style.alignItems = 'center'
    errorElement.style.justifyContent = 'center'

    document.body.appendChild(errorElement)
  }

  // NOTE:
  // Yes \u2013 we're attaching 2 error listeners below \u{1F440}
  // This is because React makes the same error throw twice (in development mode).
  // See: https://github.com/facebook/react/issues/10384

  // Error listener #1
  window.onerror = function (event, source, lineno, colno, error) {
    _nextTick(function () {
      if (_caughtErrors.indexOf(error) !== -1) return

      _caughtErrors.push(error)

      _handleError(error, {
        event,
        lineno,
        colno,
        source,
      })

      _nextTick(function () {
        var idx = _caughtErrors.indexOf(error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    // IMPORTANT: this callback must return \`true\` to prevent the error from being rendered in
    // the browser\u2019s console.
    return true
  }

  // Error listener #2
  window.addEventListener('error', function (event) {
    if (_caughtErrors.indexOf(event.error) !== -1) return true

    _caughtErrors.push(event.error)

    _handleError(event.error, {
      event,
      lineno: event.lineno,
      colno: event.colno,
    })

    _nextTick(function () {
      _nextTick(function () {
        var idx = _caughtErrors.indexOf(event.error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    return true
  })
})()
`;
function GlobalErrorHandler() {
  return /* @__PURE__ */ jsx("script", { dangerouslySetInnerHTML: { __html: errorHandlerScript } });
}
const NoJsStyles = `
.sanity-app-no-js__root {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  background: #fff;
}

.sanity-app-no-js__content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  font-family: helvetica, arial, sans-serif;
}
`;
function NoJavascript() {
  return /* @__PURE__ */ jsx("noscript", { children: /* @__PURE__ */ jsx("div", { className: "sanity-app-no-js__root", children: /* @__PURE__ */ jsxs("div", { className: "sanity-app-no-js__content", children: [
    /* @__PURE__ */ jsx("style", { type: "text/css", children: NoJsStyles }),
    /* @__PURE__ */ jsx("h1", { children: "JavaScript disabled" }),
    /* @__PURE__ */ jsxs("p", { children: [
      "Please ",
      /* @__PURE__ */ jsx("a", { href: "https://www.enable-javascript.com/", children: "enable JavaScript" }),
      " in your browser and reload the page to proceed."
    ] })
  ] }) }) });
}
const globalStyles = `
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");
  }
  html {
    background-color: #f1f3f6;
  }
  html,
  body,
  #sanity {
    height: 100%;
  }
  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
  }
`, EMPTY_ARRAY$1 = [];
function DefaultDocument(props) {
  const { entryPath, css = EMPTY_ARRAY$1, basePath = "/" } = props;
  return /* @__PURE__ */ jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx(
        "meta",
        {
          name: "viewport",
          content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
        }
      ),
      /* @__PURE__ */ jsx("meta", { name: "robots", content: "noindex" }),
      /* @__PURE__ */ jsx("meta", { name: "referrer", content: "same-origin" }),
      /* @__PURE__ */ jsx(Favicons, { basePath }),
      /* @__PURE__ */ jsx("title", { children: "Sanity Studio" }),
      /* @__PURE__ */ jsx(GlobalErrorHandler, {}),
      css.map((href) => /* @__PURE__ */ jsx("link", { rel: "stylesheet", href }, href)),
      /* @__PURE__ */ jsx("style", { dangerouslySetInnerHTML: { __html: globalStyles } })
    ] }),
    /* @__PURE__ */ jsxs("body", { children: [
      /* @__PURE__ */ jsx("div", { id: "sanity" }),
      /* @__PURE__ */ jsx("script", { type: "module", src: entryPath }),
      /* @__PURE__ */ jsx(NoJavascript, {})
    ] })
  ] });
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return config;
}
function validatePlugin(pluginResult) {
  const messages = [
    "projectId" in pluginResult && "`projectId` not allowed in plugin configuration",
    "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"
  ].filter(isString);
  if (messages.length)
    throw new Error(
      `Invalid plugin configuration:
${messages.map((message) => `	${message}`).join(`
`)}`
    );
}
function definePlugin(arg) {
  if (typeof arg == "function") {
    const pluginFactory = arg;
    return (options) => {
      const result = pluginFactory(options);
      return validatePlugin(result), result;
    };
  }
  return validatePlugin(arg), () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
function defineDocumentInspector(inspector) {
  return inspector;
}
function createMockAuthStore({ client, currentUser = null }) {
  return {
    state: of({ authenticated: !0, client, currentUser })
  };
}
function isEqual(item, otherItem) {
  if (item === otherItem)
    return !0;
  if (typeof item != typeof otherItem)
    return !1;
  if (typeof item != "object" && !Array.isArray(item))
    return item === otherItem;
  if (isKeyedObject(item) && isKeyedObject(otherItem) && item._key === otherItem._key)
    return !0;
  if (Array.isArray(item) && Array.isArray(otherItem))
    return item.length !== otherItem.length ? !1 : item.every((child, i) => isEqual(child, otherItem[i]));
  if (item === null || otherItem === null)
    return item === otherItem;
  const obj = item, otherObj = otherItem, keys = Object.keys(obj), otherKeys = Object.keys(otherObj);
  return keys.length !== otherKeys.length ? !1 : keys.every((keyName) => isEqual(obj[keyName], otherObj[keyName]));
}
const ArrayOfOptionsFieldDiff = ({ diff, schemaType }) => {
  var _a;
  const options = (_a = schemaType.options) == null ? void 0 : _a.list, colorManager = useUserColorManager(), { t } = useTranslation();
  return Array.isArray(options) ? /* @__PURE__ */ jsx("div", { children: diff.items.map((item) => normalizeItems(item, diff, schemaType)).filter((item) => item !== null).sort(sortItems).map((item, index) => {
    const { annotation, isPresent, value, memberType, title } = item, color = getAnnotationColor(colorManager, annotation), action = t(isPresent ? "changes.added-label" : "changes.removed-label");
    return /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
      /* @__PURE__ */ jsx(DiffTooltip, { annotations: annotation ? [annotation] : [], description: action, children: /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
        /* @__PURE__ */ jsx(Checkbox, { checked: !isPresent, color }),
        /* @__PURE__ */ jsx(Box, { margin: 2, children: /* @__PURE__ */ jsx(FromToArrow, {}) }),
        /* @__PURE__ */ jsx(Checkbox, { checked: isPresent, color })
      ] }) }),
      /* @__PURE__ */ jsx(Flex, { align: "center", children: /* @__PURE__ */ jsx(ItemPreview, { value: title || value, memberType }) })
    ] }, getItemKey(diff, index));
  }) }) : null;
};
function normalizeItems(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged")
    return null;
  const { fromValue, toValue } = parentDiff, value = getValue(item.diff), wasPresent = isInArray(value, fromValue), isPresent = isInArray(value, toValue);
  return wasPresent === isPresent ? null : {
    title: getItemTitle(value, schemaType),
    memberType: resolveMemberType(getValue(item.diff), schemaType),
    itemIndex: getOptionIndex(value, schemaType),
    annotation: item.annotation,
    isPresent,
    value
  };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview({ value, memberType }) {
  return /* @__PURE__ */ jsx(Box, { marginX: 2, marginY: 1, children: typeof value == "string" || typeof value == "number" ? value : /* @__PURE__ */ jsx(Preview, { schemaType: memberType, value, layout: "default" }) });
}
function isInArray(value, parent) {
  const array = parent || [];
  return typeof value == "object" && value !== null ? array.some((item) => isEqual(item, value)) : array.includes(value);
}
function getItemKey(diff, index) {
  const value = diff.toValue || diff.fromValue;
  return isKeyedObject(value) ? value._key : index;
}
function getValue(diff) {
  return typeof diff.toValue > "u" ? diff.fromValue : diff.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object")
    return jsType;
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType(val) {
  return val === null ? "null" : Array.isArray(val) ? "array" : typeof val;
}
function isNamedOption(item) {
  return typeof item == "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a;
  return (((_a = schemaType.options) == null ? void 0 : _a.list) || []).findIndex((opt) => isEqual(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [], index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
const SlugFieldDiff = ({ diff, schemaType }) => /* @__PURE__ */ jsx(
  DiffFromTo,
  {
    layout: "inline",
    diff,
    schemaType,
    previewComponent: SlugPreview
  }
), UrlFieldDiff = ({ diff, schemaType }) => /* @__PURE__ */ jsx(DiffFromTo, { diff, schemaType, previewComponent: StringPreview }), diffResolver = ({ schemaType }) => {
  var _a;
  if (["datetime", "date"].includes(schemaType.name))
    return DatetimeFieldDiff;
  if (schemaType.name === "url")
    return UrlFieldDiff;
  if (schemaType.name === "slug")
    return SlugFieldDiff;
  if (schemaType.jsonType === "array" && Array.isArray((_a = schemaType.options) == null ? void 0 : _a.list))
    return ArrayOfOptionsFieldDiff;
};
function HoveredFieldProvider(props) {
  const { children } = props, [hoveredStack, setHoveredStack] = useState([]), handleMouseEnter = useCallback((path) => {
    const pathString = pathToString(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev : [pathString, ...prev]);
  }, []), handleMouseLeave = useCallback((path) => {
    const pathString = pathToString(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev.filter((item) => item !== pathString) : prev);
  }, []), context = useMemo(
    () => ({
      hoveredStack,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }),
    [handleMouseEnter, handleMouseLeave, hoveredStack]
  );
  return /* @__PURE__ */ jsx(HoveredFieldContext.Provider, { value: context, children });
}
const EMPTY_ARRAY = [];
function trimChildPath(path, childPath) {
  return PathUtils.startsWith(path, childPath) ? PathUtils.trimLeft(path, childPath) : EMPTY_ARRAY;
}
function PresenceScope(props) {
  const { readOnly, path, children } = props, contextPresence = useContext(FormFieldPresenceContext), childPresence = useMemo(() => readOnly ? EMPTY_ARRAY : (contextPresence || EMPTY_ARRAY).filter((presence) => PathUtils.startsWith(path, presence.path)).map((presence) => ({
    ...presence,
    path: trimChildPath(path, presence.path)
  })), [contextPresence, path, readOnly]);
  return /* @__PURE__ */ jsx(FormFieldPresenceContext.Provider, { value: childPresence, children });
}
function createPatchChannel() {
  const _subscribers = [];
  return {
    publish(msg) {
      for (const subscriber of _subscribers)
        subscriber(msg);
    },
    subscribe(subscriber) {
      return _subscribers.push(subscriber), () => {
        const idx = _subscribers.indexOf(subscriber);
        idx > -1 && _subscribers.splice(idx, 1);
      };
    }
  };
}
function ArrayOfObjectsInputMember(props) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props;
  return member.kind === "item" ? /* @__PURE__ */ jsx(
    ArrayOfObjectsItem,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    },
    member.key
  ) : member.kind === "error" ? /* @__PURE__ */ jsx(MemberItemError, { member }, member.key) : (console.warn(new Error(`Unhandled member kind ${member.kind}`)), null);
}
function ArrayOfObjectsInputMembers(props) {
  const { members, ...rest } = props;
  return /* @__PURE__ */ jsx(Fragment, { children: members.map((member) => /* @__PURE__ */ jsx(ArrayOfObjectsInputMember, { member, ...rest }, member.key)) });
}
function useReviewChanges() {
  const reviewChanges = useContext(ReviewChangesContext);
  if (!reviewChanges)
    throw new Error("Review changes: missing context value");
  return reviewChanges;
}
const defaultRenderAnnotation = (props) => createElement(defaultResolveAnnotationComponent(props.schemaType), props), defaultRenderBlock = (props) => createElement(defaultResolveBlockComponent(props.schemaType), props), defaultRenderInlineBlock = (props) => createElement(defaultResolveInlineBlockComponent(props.schemaType), props), defaultRenderField = (props) => createElement(defaultResolveFieldComponent(props.schemaType), props), defaultRenderInput = (props) => createElement(defaultResolveInputComponent(props.schemaType), props), defaultRenderItem = (props) => createElement(defaultResolveItemComponent(props.schemaType), props), defaultRenderPreview = (props) => createElement(Preview, props);
function DefaultCustomMarkers() {
  return /* @__PURE__ */ jsxs(Text, { size: 1, children: [
    "This is a example custom marker, please implement ",
    /* @__PURE__ */ jsx("code", { children: "renderCustomMarkers" }),
    " function."
  ] });
}
const missingPatchChannel = {
  publish: () => {
  },
  subscribe: () => (console.warn(
    "No patch channel provided to form-builder. If you need input based patch updates, please provide one"
  ), () => {
  })
};
function FormBuilderProvider(props) {
  const {
    __internal_fieldActions: fieldActions = EMPTY_ARRAY$2,
    __internal_patchChannel: patchChannel = missingPatchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    file,
    filterField,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onFieldGroupSelect,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    unstable,
    validation
  } = props, __internal = useMemo(
    () => ({
      patchChannel,
      // eslint-disable-line camelcase
      components: {
        ArrayFunctions: ArrayOfObjectsFunctions,
        CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers,
        Markers: (unstable == null ? void 0 : unstable.Markers) || DefaultMarkers
      },
      field: {
        actions: fieldActions
      },
      file: {
        assetSources: file.assetSources,
        directUploads: (file == null ? void 0 : file.directUploads) !== !1
      },
      filterField: filterField || (() => !0),
      image: {
        assetSources: image.assetSources,
        directUploads: (image == null ? void 0 : image.directUploads) !== !1
      },
      onChange
    }),
    [
      fieldActions,
      file.assetSources,
      file == null ? void 0 : file.directUploads,
      filterField,
      image.assetSources,
      image == null ? void 0 : image.directUploads,
      onChange,
      patchChannel,
      unstable == null ? void 0 : unstable.CustomMarkers,
      unstable == null ? void 0 : unstable.Markers
    ]
  ), formBuilder = useMemo(
    () => ({
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType
    }),
    [
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType
    ]
  );
  return /* @__PURE__ */ jsx(FormBuilderContext.Provider, { value: formBuilder, children: /* @__PURE__ */ jsx(
    FormCallbacksProvider,
    {
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      children: /* @__PURE__ */ jsx(DocumentIdProvider, { id, children: /* @__PURE__ */ jsx(PresenceProvider, { presence, children: /* @__PURE__ */ jsx(ValidationProvider, { validation, children: /* @__PURE__ */ jsx(HoveredFieldProvider, { children }) }) }) })
    }
  ) });
}
function FormProvider(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    schemaType,
    validation
  } = props, { file, image } = useSource().form, Input = useInputComponent(), Field = useFieldComponent(), Preview2 = usePreviewComponent(), Item = useItemComponent(), Block = useBlockComponent(), InlineBlock = useInlineBlockComponent(), Annotation = useAnnotationComponent(), renderInput = useCallback(
    (inputProps) => /* @__PURE__ */ jsx(Input, { ...inputProps }),
    [Input]
  ), renderField = useCallback(
    (fieldProps) => /* @__PURE__ */ jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem = useCallback(
    (itemProps) => /* @__PURE__ */ jsx(Item, { ...itemProps }),
    [Item]
  ), renderPreview = useCallback(
    (previewProps) => /* @__PURE__ */ jsx(PreviewLoader, { component: Preview2, ...previewProps }),
    [Preview2]
  ), renderBlock = useCallback(
    (blockProps) => /* @__PURE__ */ jsx(Block, { ...blockProps }),
    [Block]
  ), renderInlineBlock = useCallback(
    (blockProps) => /* @__PURE__ */ jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = useCallback(
    (annotationProps) => /* @__PURE__ */ jsx(Annotation, { ...annotationProps }),
    [Annotation]
  );
  return /* @__PURE__ */ jsx(
    FormBuilderProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      file,
      focusPath,
      focused,
      groups,
      id,
      image,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      validation,
      children
    }
  );
}
function FormBuilder(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    members,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    schemaType,
    validation,
    value
  } = props, handleCollapseField = useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !0),
    [onSetPathCollapsed]
  ), handleExpandField = useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !1),
    [onSetPathCollapsed]
  ), handleBlur = useCallback(() => onPathBlur(EMPTY_ARRAY$2), [onPathBlur]), handleFocus = useCallback(() => onPathFocus(EMPTY_ARRAY$2), [onPathFocus]), handleChange = useCallback(
    (patch) => onChange(PatchEvent.from(patch)),
    [onChange]
  ), focusRef = useRef(null), handleSelectFieldGroup = useCallback(
    (groupName) => onFieldGroupSelect(EMPTY_ARRAY$2, groupName),
    [onFieldGroupSelect]
  ), handleOpenField = useCallback((fieldName) => onPathOpen([fieldName]), [onPathOpen]), handleCloseField = useCallback(() => onPathOpen([]), [onPathOpen]), handleCollapseFieldSet = useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !0),
    [onSetFieldSetCollapsed]
  ), handleExpandFieldSet = useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !1),
    [onSetFieldSetCollapsed]
  ), Input = useInputComponent(), Field = useFieldComponent(), Preview2 = usePreviewComponent(), Item = useItemComponent(), Block = useBlockComponent(), InlineBlock = useInlineBlockComponent(), Annotation = useAnnotationComponent(), renderInput = useCallback(
    (inputProps) => /* @__PURE__ */ jsx(Input, { ...inputProps }),
    [Input]
  ), renderField = useCallback(
    (fieldProps) => /* @__PURE__ */ jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem = useCallback(
    (itemProps) => /* @__PURE__ */ jsx(Item, { ...itemProps }),
    [Item]
  ), renderPreview = useCallback(
    (previewProps) => /* @__PURE__ */ jsx(PreviewLoader, { component: Preview2, ...previewProps }),
    [Preview2]
  ), renderBlock = useCallback(
    (blockProps) => /* @__PURE__ */ jsx(Block, { ...blockProps }),
    [Block]
  ), renderInlineBlock = useCallback(
    (blockProps) => /* @__PURE__ */ jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = useCallback(
    (annotationProps) => /* @__PURE__ */ jsx(Annotation, { ...annotationProps }),
    [Annotation]
  ), rootInputProps = {
    focusPath,
    elementProps: {
      ref: focusRef,
      id,
      onBlur: handleBlur,
      onFocus: handleFocus,
      "aria-describedby": void 0
      // Root input should not have any aria-describedby
    },
    changed: members.some((m) => m.kind === "field" && m.field.changed),
    focused,
    groups,
    id,
    level: 0,
    members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onPathFocus,
    onFieldOpen: handleOpenField,
    onFieldGroupSelect: handleSelectFieldGroup,
    path: EMPTY_ARRAY$2,
    presence: EMPTY_ARRAY$2,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation: EMPTY_ARRAY$2,
    value
  };
  return /* @__PURE__ */ jsx(
    FormProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      validation,
      readOnly,
      schemaType,
      children: /* @__PURE__ */ jsx(GetFormValueProvider, { value, children: /* @__PURE__ */ jsx(FormValueProvider, { value, children: /* @__PURE__ */ jsx(DocumentFieldActionsProvider, { actions: fieldActions, children: renderInput(rootInputProps) }) }) })
    }
  );
}
const remoteSnapshots = memoize(
  (client, idPair, typeName) => memoizedPair(client, idPair, typeName).pipe(
    switchMap(({ published, draft }) => merge(published.remoteSnapshot$, draft.remoteSnapshot$))
  ),
  memoizeKeyGen
);
function maybeSerialize(template) {
  return isBuilder(template) ? template.serialize() : template;
}
function isNonNullable(t) {
  return !!t;
}
function prepareTemplates(schema, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return validateTemplates(schema, serialized);
}
function defaultTemplateForType(schemaType) {
  return {
    id: schemaType.name,
    schemaType: schemaType.name,
    title: schemaType.title || schemaType.name,
    icon: schemaType.icon,
    value: schemaType.initialValue || { _type: schemaType.name }
  };
}
function defaultTemplatesForSchema(schema) {
  const schemaTypes = schema.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema.get(typeName)).filter(isNonNullable).filter((schemaType) => {
    var _a;
    return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
  });
  return prepareTemplates(
    schema,
    schemaTypes.map((schemaType) => defaultTemplateForType(schemaType))
  );
}
const LOADING_STATE = {
  isLoaded: !1,
  documentType: void 0
};
function useDocumentType(documentId, specifiedType = "*") {
  const documentStore = useDocumentStore(), publishedId = getPublishedId(documentId), isResolved = !!(specifiedType && specifiedType !== "*"), SYNC_RESOLVED_STATE = useMemo(
    () => ({ documentType: specifiedType, isLoaded: !0 }),
    [specifiedType]
  ), [resolvedState, setDocumentType] = useState(
    isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE
  );
  return useEffect(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]), useEffect(() => {
    if (isResolved)
      return;
    const sub = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe((documentType) => setDocumentType({ documentType, isLoaded: !0 }));
    return () => sub.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]), isResolved ? (
    // `isResolved` is only true when we're _synchronously_ resolved
    SYNC_RESOLVED_STATE
  ) : (
    // Using the document type resolved from the API
    resolvedState
  );
}
function useTimelineSelector(timelineStore, selector) {
  return useSyncExternalStoreWithSelector(
    timelineStore.subscribe,
    timelineStore.getSnapshot,
    null,
    selector
  );
}
const INITIAL_TIMELINE_STATE = {
  chunks: [],
  diff: null,
  hasMoreChunks: null,
  isLoading: !1,
  isPristine: null,
  lastNonDeletedRevId: null,
  onOlderRevision: !1,
  realRevChunk: null,
  revTime: null,
  selectionState: "inactive",
  sinceAttributes: null,
  sinceTime: null,
  timelineDisplayed: null,
  timelineReady: !1
};
function useTimelineStore({
  documentId,
  documentType,
  onError,
  rev,
  since
}) {
  const historyStore = useHistoryStore(), snapshotsSubscriptionRef = useRef(null), timelineStateRef = useRef(INITIAL_TIMELINE_STATE), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), controller = useMemo(
    () => historyStore.getTimelineController({
      client,
      documentId,
      documentType
    }),
    [client, documentId, documentType, historyStore]
  ), timelineController$ = useMemo(
    () => new BehaviorSubject(controller),
    [controller]
  );
  return useEffect(() => (controller.setRange(since || null, rev || null), timelineController$.next(controller), controller.handler = (err, innerController) => {
    err ? timelineController$.error(err) : setTimeout(() => {
      innerController.setRange(since || null, rev || null), timelineController$.next(innerController);
    }, 0);
  }, controller.resume(), () => controller.suspend()), [rev, since, controller, timelineController$]), useEffect(() => (snapshotsSubscriptionRef.current || (snapshotsSubscriptionRef.current = remoteSnapshots(
    client,
    { draftId: `drafts.${documentId}`, publishedId: documentId },
    documentType
  ).subscribe((ev2) => {
    controller.handleRemoteMutation(ev2);
  })), () => {
    snapshotsSubscriptionRef.current && (snapshotsSubscriptionRef.current.unsubscribe(), snapshotsSubscriptionRef.current = null);
  }), [client, controller, documentId, documentType]), useMemo(() => ({
    findRangeForRev: (chunk) => controller.findRangeForNewRev(chunk),
    findRangeForSince: (chunk) => controller.findRangeForNewSince(chunk),
    loadMore: () => {
      controller.setLoadMore(!0), timelineStateRef.current.isLoading = !0;
    },
    getSnapshot: () => timelineStateRef.current,
    subscribe: (callback) => {
      const subscription = timelineController$.pipe(
        // Manually stop loading transactions in TimelineController, otherwise transaction history
        // will continue to be fetched – even if unwanted.
        tap((innerController) => innerController.setLoadMore(!1)),
        map((innerController) => {
          var _a;
          const chunks = innerController.timeline.mapChunks((c) => c), lastNonDeletedChunk = chunks.filter(
            (chunk) => !["delete", "initial"].includes(chunk.type)
          ), hasMoreChunks = !innerController.timeline.reachedEarliestEntry, timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return {
            chunks,
            diff: innerController.sinceTime ? innerController.currentObjectDiff() : null,
            isLoading: !1,
            isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === !1 : null,
            hasMoreChunks: !innerController.timeline.reachedEarliestEntry,
            lastNonDeletedRevId: (_a = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a.id,
            onOlderRevision: innerController.onOlderRevision(),
            realRevChunk: innerController.realRevChunk,
            revTime: innerController.revTime,
            selectionState: innerController.selectionState,
            sinceAttributes: innerController.sinceAttributes(),
            sinceTime: innerController.sinceTime,
            timelineDisplayed: innerController.displayed(),
            timelineReady
          };
        }),
        // Only emit (and in turn, re-render) when values have changed
        distinctUntilChanged(deepCompare),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        catchError((err) => (onError == null || onError(err), of(INITIAL_TIMELINE_STATE))),
        tap((timelineState) => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        tap(callback)
      ).subscribe();
      return () => subscription.unsubscribe();
    }
  }), [controller, onError, timelineController$]);
}
function useProject() {
  const projectStore = useProjectStore(), [value, setValue] = useState(null);
  return useEffect(() => {
    const sub = projectStore.get().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function useProjectDatasets() {
  const projectStore = useProjectStore(), [value, setValue] = useState(null);
  return useEffect(() => {
    const sub = projectStore.getDatasets().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function resolveConfig(config) {
  const { workspaces } = prepareConfig(config);
  return combineLatest(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workspaces.flatMap(
      (workspaceSummary) => combineLatest(workspaceSummary.__internal.sources.map(({ source }) => source)).pipe(
        map$1(
          (sources) => ({
            ...workspaceSummary,
            ...sources[0],
            unstable_sources: sources,
            type: "workspace"
          })
        )
      )
    )
  );
}
async function createWorkspaceFromConfig(options) {
  const client = "getClient" in options ? options.getClient({ apiVersion: "2023-11-13" }) : void 0, [workspace] = await firstValueFrom(
    resolveConfig({
      ...options,
      ...client && "currentUser" in options && {
        auth: createMockAuthStore({ ...options, client })
      }
    })
  );
  return workspace;
}
async function createSourceFromConfig(options) {
  return (await createWorkspaceFromConfig(options)).unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const { projectId, dataset, schema, currentUser, getClient, i18n } = source;
  return useMemo(() => ({ projectId, dataset, schema, currentUser, getClient, i18n }), [projectId, dataset, schema, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const { projectId, dataset, schema, currentUser, getClient, i18n } = source;
  return { projectId, dataset, schema, currentUser, getClient, i18n };
}
const API_VERSION = "v2023-11-13";
function AddonDatasetProvider(props) {
  const { children } = props, { dataset, projectId } = useWorkspace(), originalClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [addonDatasetClient, setAddonDatasetClient] = useState(null), [isCreatingDataset, setIsCreatingDataset] = useState(!1), [ready, setReady] = useState(!1), getAddonDatasetName = useCallback(async () => {
    var _a;
    const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
      uri: `/projects/${projectId}/datasets?datasetProfile=comments&addonFor=${dataset}`,
      tag: "sanity.studio"
    });
    return (_a = res == null ? void 0 : res[0]) == null ? void 0 : _a.name;
  }, [dataset, originalClient, projectId]), handleCreateClient = useCallback(
    (addonDatasetName) => originalClient.withConfig({
      apiVersion: API_VERSION,
      dataset: addonDatasetName,
      projectId,
      requestTagPrefix: "sanity.studio",
      useCdn: !1,
      withCredentials: !0
    }),
    [originalClient, projectId]
  ), handleCreateAddonDataset = useCallback(async () => {
    setIsCreatingDataset(!0);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client = handleCreateClient(addonDatasetName);
        return setAddonDatasetClient(client), setIsCreatingDataset(!1), client;
      }
    } catch {
    }
    try {
      const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
        uri: `/comments/${dataset}/setup`,
        method: "POST"
      }), datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName)
        return setIsCreatingDataset(!1), null;
      const client = handleCreateClient(datasetName);
      return setAddonDatasetClient(client), client;
    } catch (err) {
      throw err;
    } finally {
      setIsCreatingDataset(!1);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  useEffect(() => {
    getAddonDatasetName().then((addonDatasetName) => {
      if (!addonDatasetName)
        return;
      const client = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client);
    }).finally(() => {
      setReady(!0);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = useMemo(
    () => ({
      client: addonDatasetClient,
      createAddonDataset: handleCreateAddonDataset,
      isCreatingDataset,
      ready
    }),
    [addonDatasetClient, handleCreateAddonDataset, isCreatingDataset, ready]
  );
  return /* @__PURE__ */ jsx(AddonDatasetContext.Provider, { value: ctxValue, children });
}
function useAddonDataset() {
  const ctx = useContext(AddonDatasetContext);
  if (!ctx)
    throw new Error("useAddonDataset: missing context value");
  return ctx;
}
function StudioLogo(props) {
  const { title } = props;
  return /* @__PURE__ */ jsx(Box, { padding: 3, "data-testid": "studio-logo", children: /* @__PURE__ */ jsx(Text, { weight: "medium", children: title }) });
}
function _buildTints(bg2, mid, fg2) {
  return {
    50: mix(0.1, mid, bg2),
    100: mix(0.2, mid, bg2),
    200: mix(0.4, mid, bg2),
    300: mix(0.6, mid, bg2),
    400: mix(0.8, mid, bg2),
    500: mid,
    600: mix(0.8, mid, fg2),
    700: mix(0.6, mid, fg2),
    800: mix(0.4, mid, fg2),
    900: mix(0.2, mid, fg2),
    950: mix(0.1, mid, fg2)
  };
}
function _toHex(color) {
  const { red: red2, green: green2, blue: blue2 } = parseToRgb(color);
  return rgb(red2, green2, blue2);
}
function _isDark(bg2, fg2) {
  return getLuminance(bg2) < getLuminance(fg2);
}
function _multiply(bg2, fg2) {
  const b = parseColor(bg2), s = parseColor(fg2);
  return rgbToHex(multiply(b, s));
}
function _screen(bg2, fg2) {
  const b = parseColor(bg2), s = parseColor(fg2);
  return rgbToHex(screen(b, s));
}
const NEUTRAL_TONES = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return createColorTheme({
    base: ({ dark: navbar, name }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, dark = stateTones.dark, blend = navbar ? _screen : _multiply, tints = stateTones[name] || stateTones.default;
      if (name === "default") {
        const skeletonFrom2 = stateTones.default[100];
        return {
          fg: stateTones.fg,
          bg: stateTones.bg,
          border: stateTones.default[200],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: rgba(stateTones.default[500], 0.4),
            umbra: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.2),
            penumbra: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.14),
            ambient: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (name === "transparent") {
        const bg22 = tints[50], skeletonFrom2 = blend(bg22, tints[100]);
        return {
          fg: tints[900],
          bg: bg22,
          border: tints[300],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: rgba(tints[500], dark ? 0.2 : 0.4),
            umbra: rgba(dark ? legacyPalette.black : tints[500], 0.2),
            penumbra: rgba(dark ? legacyPalette.black : tints[500], 0.14),
            ambient: rgba(dark ? legacyPalette.black : tints[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg2 = tints[50], skeletonFrom = blend(bg2, tints[100]);
      return {
        fg: tints[900],
        bg: bg2,
        border: tints[200],
        focusRing: tints[500],
        shadow: {
          outline: rgba(tints[500], dark ? 0.2 : 0.4),
          umbra: rgba(dark ? legacyPalette.black : tints[500], 0.2),
          penumbra: rgba(dark ? legacyPalette.black : tints[500], 0.14),
          ambient: rgba(dark ? legacyPalette.black : tints[500], 0.12)
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    solid: ({ base, dark: navbar, name, state, tone }) => {
      const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default, dark = buttonTones.dark, blend = dark ? _screen : _multiply, blendInvert = dark ? _multiply : _screen, defaultTints = buttonTones[name] || buttonTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg22 = blend(base.bg, tints[200]), skeletonFrom2 = blendInvert(bg22, tints[800]);
        return {
          bg: bg22,
          border: blend(base.bg, tints[200]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[50])
          },
          accent: {
            fg: blend(base.bg, tints[50])
          },
          link: {
            fg: blend(base.bg, tints[50])
          },
          code: {
            bg: bg22,
            fg: blend(base.bg, tints[50])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg22 = blend(base.bg, tints[600]), skeletonFrom2 = blendInvert(bg22, tints[800]);
        return {
          bg: bg22,
          border: blend(base.bg, tints[600]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg22, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg22, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        const bg22 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg22, tints[800]);
        return {
          bg: bg22,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg22, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg22, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = buttonTones.primary);
        const bg22 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg22, tints[800]);
        return {
          bg: bg22,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg22, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg22, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg2 = blend(base.bg, tints[500]), skeletonFrom = blendInvert(bg2, tints[800]);
      return {
        bg: bg2,
        border: blend(base.bg, tints[500]),
        fg: blend(base.bg, buttonTones.bg),
        icon: blend(base.bg, buttonTones.bg),
        muted: {
          fg: blend(base.bg, tints[100])
        },
        accent: {
          fg: blendInvert(bg2, buttonTones.critical[200])
        },
        link: {
          fg: blendInvert(bg2, buttonTones.primary[100])
        },
        code: {
          bg: blend(bg2, tints[50]),
          fg: blend(base.bg, tints[100])
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    muted: ({ base, dark: navbar, name, state, tone }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, defaultTints = stateTones[name] || stateTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg22 = base.bg, skeletonFrom2 = blend(bg22, tints[100]);
        return {
          bg: bg22,
          border: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[200]),
          icon: blend(base.bg, tints[200]),
          muted: {
            fg: blend(bg22, tints[100])
          },
          accent: {
            fg: blend(bg22, tints[100])
          },
          link: {
            fg: blend(bg22, tints[100])
          },
          code: {
            bg: bg22,
            fg: blend(bg22, tints[100])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg22 = blend(base.bg, tints[50]), skeletonFrom2 = blend(bg22, tints[100]);
        return {
          bg: bg22,
          border: blend(bg22, tints[100]),
          fg: blend(base.bg, tints[900]),
          icon: blend(base.bg, tints[900]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(base.bg, stateTones.critical[500])
          },
          link: {
            fg: blend(base.bg, stateTones.primary[600])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(base.bg, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        isNeutral && (tints = stateTones.primary);
        const bg22 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg22, tints[100]);
        return {
          bg: bg22,
          border: blend(bg22, tints[100]),
          fg: blend(base.bg, tints[800]),
          icon: blend(base.bg, tints[800]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(bg22, stateTones.critical[500])
          },
          link: {
            fg: blend(bg22, stateTones.primary[600])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(bg22, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = stateTones.primary);
        const bg22 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg22, tints[100]);
        return {
          bg: bg22,
          border: blend(bg22, tints[100]),
          fg: blend(bg22, tints[800]),
          icon: blend(bg22, tints[800]),
          muted: {
            fg: blend(bg22, tints[600])
          },
          accent: {
            fg: blend(bg22, stateTones.critical[500])
          },
          link: {
            fg: blend(bg22, stateTones.primary[600])
          },
          code: {
            bg: blend(bg22, tints[50]),
            fg: blend(bg22, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg2 = base.bg, skeletonFrom = blend(base.bg, tints[100]);
      return {
        bg: bg2,
        border: blend(bg2, tints[100]),
        fg: blend(bg2, tints[700]),
        icon: blend(bg2, tints[700]),
        muted: {
          fg: blend(bg2, tints[600])
        },
        accent: {
          fg: blend(bg2, stateTones.critical[500])
        },
        link: {
          fg: blend(bg2, stateTones.primary[600])
        },
        code: {
          bg: blend(bg2, tints[50]),
          fg: blend(bg2, tints[600])
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    button: ({ base, mode, muted, solid }) => mode === "bleed" ? {
      enabled: {
        ...muted.enabled,
        border: muted.enabled.bg
      },
      hovered: {
        ...muted.hovered,
        border: muted.hovered.bg
      },
      pressed: {
        ...muted.pressed,
        border: muted.pressed.bg
      },
      selected: {
        ...muted.selected,
        border: muted.selected.bg
      },
      disabled: {
        ...muted.disabled,
        border: muted.disabled.bg
      }
    } : mode === "ghost" ? {
      ...solid,
      enabled: {
        ...muted.enabled,
        border: base.border
      },
      disabled: muted.disabled
    } : solid,
    card: ({ base, dark: navbar, muted, name, solid, state }) => {
      if (state === "hovered")
        return muted[name].hovered;
      if (state === "disabled")
        return muted[name].disabled;
      const isNeutral = NEUTRAL_TONES.includes(name), stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, tints = stateTones[name] || stateTones.default, dark = stateTones.dark, blend = dark ? _screen : _multiply;
      if (state === "pressed")
        return isNeutral ? muted.primary.pressed : muted[name].pressed;
      if (state === "selected")
        return isNeutral ? solid.primary.enabled : solid[name].enabled;
      const bg2 = base.bg, skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
      return {
        bg: bg2,
        fg: base.fg,
        icon: base.fg,
        border: base.border,
        muted: {
          fg: blend(base.bg, tints[dark ? 400 : 600])
        },
        accent: {
          fg: blend(base.bg, stateTones.critical[dark ? 400 : 500])
        },
        link: {
          fg: blend(base.bg, stateTones.primary[dark ? 400 : 600])
        },
        code: {
          bg: blend(base.bg, tints[dark ? 950 : 50]),
          fg: tints[dark ? 400 : 600]
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    input: ({ base, dark: navbar, mode, state }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply;
      if (mode === "invalid") {
        const tints = stateTones.critical;
        return {
          bg: blend(base.bg, tints[50]),
          bg2: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[700]),
          border: blend(base.bg, tints[200]),
          placeholder: blend(base.bg, tints[400])
        };
      }
      return state === "hovered" ? {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: blend(base.bg, hues.gray[300].hex),
        placeholder: blend(base.bg, hues.gray[400].hex)
      } : state === "disabled" ? {
        bg: blend(base.bg, hues.gray[50].hex),
        bg2: blend(base.bg, hues.gray[50].hex),
        fg: blend(base.bg, hues.gray[200].hex),
        border: blend(base.bg, hues.gray[100].hex),
        placeholder: blend(base.bg, hues.gray[100].hex)
      } : state === "readOnly" ? {
        bg: blend(base.bg, hues.gray[50].hex),
        bg2: blend(base.bg, hues.gray[50].hex),
        fg: blend(base.bg, hues.gray[800].hex),
        border: blend(base.bg, hues.gray[200].hex),
        placeholder: blend(base.bg, hues.gray[400].hex)
      } : {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: base.border,
        placeholder: blend(base.bg, hues.gray[700].hex)
      };
    },
    selectable: ({ base, muted, tone, solid, state }) => state === "enabled" ? {
      ...muted[tone].enabled,
      bg: base.bg
    } : state === "pressed" ? tone === "default" ? muted.primary.pressed : muted[tone].pressed : state === "selected" ? tone === "default" ? solid.primary.enabled : solid[tone].enabled : state === "disabled" ? {
      ...muted[tone].disabled,
      bg: base.bg
    } : muted[tone][state],
    spot: ({ base, key }) => {
      const dark = _isDark(base.bg, base.fg);
      return (dark ? _screen : _multiply)(base.bg, hues[key][dark ? 400 : 500].hex);
    },
    syntax: ({ base, dark: navbar }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, mainShade = 600, secondaryShade = 400;
      return {
        atrule: blend(base.bg, hues.purple[mainShade].hex),
        attrName: blend(base.bg, stateTones.positive[mainShade]),
        attrValue: blend(base.bg, stateTones.caution[mainShade]),
        attribute: blend(base.bg, stateTones.caution[mainShade]),
        boolean: blend(base.bg, hues.purple[mainShade].hex),
        builtin: blend(base.bg, hues.purple[mainShade].hex),
        cdata: blend(base.bg, stateTones.caution[mainShade]),
        char: blend(base.bg, stateTones.caution[mainShade]),
        class: blend(base.bg, hues.orange[mainShade].hex),
        className: blend(base.bg, hues.cyan[mainShade].hex),
        comment: blend(base.bg, stateTones.default[secondaryShade]),
        constant: blend(base.bg, hues.purple[mainShade].hex),
        deleted: blend(base.bg, stateTones.critical[mainShade]),
        doctype: blend(base.bg, stateTones.default[secondaryShade]),
        entity: blend(base.bg, stateTones.critical[mainShade]),
        function: blend(base.bg, stateTones.positive[mainShade]),
        hexcode: blend(base.bg, stateTones.primary[mainShade]),
        id: blend(base.bg, hues.purple[mainShade].hex),
        important: blend(base.bg, hues.purple[mainShade].hex),
        inserted: blend(base.bg, stateTones.caution[mainShade]),
        keyword: blend(base.bg, hues.magenta[mainShade].hex),
        number: blend(base.bg, hues.purple[mainShade].hex),
        operator: blend(base.bg, hues.magenta[mainShade].hex),
        prolog: blend(base.bg, stateTones.default[secondaryShade]),
        property: blend(base.bg, stateTones.primary[mainShade]),
        pseudoClass: blend(base.bg, stateTones.caution[mainShade]),
        pseudoElement: blend(base.bg, stateTones.caution[mainShade]),
        punctuation: blend(base.bg, stateTones.default[mainShade]),
        regex: blend(base.bg, stateTones.primary[mainShade]),
        selector: blend(base.bg, stateTones.critical[mainShade]),
        string: blend(base.bg, stateTones.caution[mainShade]),
        symbol: blend(base.bg, hues.purple[mainShade].hex),
        tag: blend(base.bg, stateTones.critical[mainShade]),
        unit: blend(base.bg, hues.orange[mainShade].hex),
        url: blend(base.bg, stateTones.critical[mainShade]),
        variable: blend(base.bg, stateTones.critical[mainShade])
      };
    }
  });
}
function buildFonts(cssCustomProperties) {
  return {
    ...studioTheme.fonts,
    code: {
      ...studioTheme.fonts.code,
      family: cssCustomProperties["--font-family-monospace"] || studioTheme.fonts.code.family
    },
    heading: {
      ...studioTheme.fonts.heading,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    },
    label: {
      ...studioTheme.fonts.label,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    },
    text: {
      ...studioTheme.fonts.text,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    }
  };
}
function buildLegacyPalette(cssCustomProperties) {
  return {
    black: _toHex(cssCustomProperties["--black"]),
    component: {
      bg: _toHex(cssCustomProperties["--component-bg"]),
      fg: _toHex(cssCustomProperties["--component-text-color"])
    },
    defaultButton: {
      default: {
        base: _toHex(cssCustomProperties["--default-button-color"])
      },
      primary: {
        base: _toHex(cssCustomProperties["--default-button-primary-color"])
      },
      success: {
        base: _toHex(cssCustomProperties["--default-button-success-color"])
      },
      warning: {
        base: _toHex(cssCustomProperties["--default-button-warning-color"])
      },
      danger: {
        base: _toHex(cssCustomProperties["--default-button-danger-color"])
      }
    },
    focus: {
      base: _toHex(cssCustomProperties["--focus-color"])
    },
    gray: {
      base: _toHex(cssCustomProperties["--gray-base"])
    },
    mainNavigation: {
      bg: _toHex(cssCustomProperties["--main-navigation-color"]),
      fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"])
    },
    state: {
      info: {
        fg: _toHex(cssCustomProperties["--state-info-color"])
      },
      success: {
        fg: _toHex(cssCustomProperties["--state-success-color"])
      },
      warning: {
        fg: _toHex(cssCustomProperties["--state-warning-color"])
      },
      danger: {
        fg: _toHex(cssCustomProperties["--state-danger-color"])
      }
    }
  };
}
function buildLegacyTones(legacyPalette) {
  return {
    state: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.info.fg,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.success.fg,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.info.fg,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.success.fg,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.mainNavigation.fg
        )
      }
    },
    button: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.mainNavigation.fg
        )
      }
    }
  };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme), legacyPalette = buildLegacyPalette(legacyTheme), legacyTones = buildLegacyTones(legacyPalette), color = buildColor(legacyPalette, legacyTones), fonts = buildFonts(legacyTheme);
  return {
    __dark: _isDark(color.light.default.base.bg, color.light.default.base.fg),
    __legacy: !0,
    color,
    fonts
  };
}
const defaultCustomProperties = {
  "--font-family-monospace": studioTheme.fonts.code.family,
  "--font-family-base": studioTheme.fonts.text.family,
  "--black": black.hex,
  "--white": white.hex,
  // Brand
  "--brand-primary": blue[500].hex,
  // Component
  "--component-bg": white.hex,
  "--component-text-color": black.hex,
  // Gray
  "--gray": gray[500].hex,
  "--gray-base": gray[500].hex,
  // Default button
  "--default-button-color": gray[500].hex,
  "--default-button-danger-color": red[500].hex,
  "--default-button-primary-color": blue[500].hex,
  "--default-button-success-color": green[500].hex,
  "--default-button-warning-color": yellow[500].hex,
  // Focus
  "--focus-color": blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": blue[500].hex,
  "--state-success-color": green[500].hex,
  "--state-warning-color": yellow[500].hex,
  "--state-danger-color": red[500].hex,
  // Navbar
  "--main-navigation-color": black.hex,
  "--main-navigation-color--inverted": white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props = {
    ...defaultCustomProperties,
    ...legacyTheme
  };
  return props["--focus-color"] = legacyTheme["--focus-color"] || props["--brand-primary"], props["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props["--brand-primary"], props["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props["--black"], props["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props["--white"], props["--state-info-color"] = legacyTheme["--brand-primary"] || props["--brand-primary"], props;
}
function Studio(props) {
  const {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_globalStyles: globalStyles2,
    unstable_history,
    unstable_noAuthBoundary
  } = props;
  return /* @__PURE__ */ jsxs(
    StudioProvider,
    {
      basePath,
      config,
      onSchemeChange,
      scheme,
      unstable_history,
      unstable_noAuthBoundary,
      children: [
        globalStyles2 && /* @__PURE__ */ jsx(GlobalStyle, {}),
        /* @__PURE__ */ jsx(StudioLayout, {})
      ]
    }
  );
}
function renderStudio(rootElement, config, options = !1) {
  if (!rootElement)
    throw new Error("Missing root element to mount application into");
  const opts = typeof options == "boolean" ? { reactStrictMode: options } : options, { reactStrictMode = !1, basePath } = opts, root = createRoot(rootElement);
  return root.render(
    reactStrictMode ? /* @__PURE__ */ jsx(StrictMode, { children: /* @__PURE__ */ jsx(Studio, { config, basePath, unstable_globalStyles: !0 }) }) : /* @__PURE__ */ jsx(Studio, { config, basePath, unstable_globalStyles: !0 })
  ), () => root.unmount();
}
const INITIAL$1 = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(
    () => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(
      map$1((ev2) => ev2.type),
      map$1((eventType) => eventType !== "reconnect"),
      switchMap(
        (isConnected) => isConnected ? of("connected") : timer(200).pipe(mapTo("reconnecting"))
      ),
      startWith(INITIAL$1),
      distinctUntilChanged$1()
    ),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL$1
  );
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(
    () => documentStore.pair.operationEvents(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName]
  );
}
function useEditState(publishedDocId, docTypeName, priority = "default") {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => {
    if (priority === "low") {
      const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(share());
      return merge(
        base.pipe(take(1)),
        base.pipe(
          skip(1),
          debounce(() => timer(1e3))
        )
      );
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
const PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const { style = "short", resolution = "seconds" } = options || {}, unitDisplay = style, locale = useCurrentLocale().id, listFormat = useListFormat({ type: "unit", style }), isNegative = durationMs < 0, duration = parseMilliseconds(Math.abs(durationMs)), formatters = useMemo(
    () => ({
      days: intlCache.numberFormat(locale, { style: "unit", unit: "day", unitDisplay }),
      hours: intlCache.numberFormat(locale, { style: "unit", unit: "hour", unitDisplay }),
      minutes: intlCache.numberFormat(locale, { style: "unit", unit: "minute", unitDisplay }),
      seconds: intlCache.numberFormat(locale, { style: "unit", unit: "second", unitDisplay }),
      milliseconds: intlCache.numberFormat(locale, {
        style: "unit",
        unit: "millisecond",
        unitDisplay
      })
    }),
    [locale, unitDisplay]
  ), parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds")
      continue;
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push(`${prefix}${formatters[period].format(value)}`);
  }
  const formatted = parts.length === 0 ? (
    // If passing duration 0, we still want to show something
    formatters[resolution].format(0)
  ) : (
    // Usually, we want to join the parts with the locales list formatter
    listFormat.format(parts)
  ), iso8601 = durationToISO8601(duration, isNegative);
  return { formatted, iso8601 };
}
function parseMilliseconds(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5) % 24,
    minutes: Math.trunc(milliseconds / 6e4) % 60,
    seconds: Math.trunc(milliseconds / 1e3) % 60,
    milliseconds: Math.trunc(milliseconds) % 1e3
  };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? `${dur.days}D` : "";
  let time = "";
  if (dur.hours && (time += `${dur.hours}H`), dur.minutes && (time += `${dur.minutes}M`), dur.milliseconds ? time += `${((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3)}S` : dur.seconds && (time += `${dur.seconds}S`), !date && !time)
    return "PT0S";
  const duration = `P${(time ? [date, time] : [date]).join("T")}`;
  return isNegative ? `-${duration}` : duration;
}
function useNumberFormat(options = {}) {
  const currentLocale = useCurrentLocale().id;
  return intlCache.numberFormat(currentLocale, options);
}
const SYNCING = { isSyncing: !0 }, NOT_SYNCING = { isSyncing: !1 };
function useSyncState(publishedDocId, documentType) {
  const documentStore = useDocumentStore();
  return useMemoObservable(
    () => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(map$1((isConsistent) => isConsistent ? NOT_SYNCING : SYNCING)),
    [documentStore.pair, documentType, publishedDocId],
    NOT_SYNCING
  );
}
function useTimeAgo(time, options = {}) {
  return useRelativeTime(time, {
    minimal: options.minimal,
    useTemporalPhrase: options.agoSuffix
  });
}
function useTools() {
  return useSource().tools;
}
const INITIAL_STATE = {
  data: [],
  error: null,
  loading: !0
};
let cachedSystemGroups = null;
function useUserListWithPermissions(opts) {
  const { documentValue, permission } = opts, projectStore = useProjectStore(), userStore = useUserStore(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [state, setState] = useState(INITIAL_STATE), list$ = useMemo(() => {
    const users$ = projectStore.get().pipe(map((res) => {
      var _a;
      return (_a = res.members) == null ? void 0 : _a.filter((m) => !m.isRobot);
    })).pipe(
      switchMap$1(async (members) => {
        const ids = members.map(({ id }) => id);
        return await userStore.getUsers(ids);
      }),
      map(
        (res) => res.map((user) => ({
          displayName: user.displayName,
          id: user.id,
          granted: !1
        }))
      )
    ), cached = cachedSystemGroups, systemGroup$ = cached ? of(cached) : client.observable.fetch('*[_type == "system.group"]');
    return forkJoin([users$, systemGroup$]).pipe(
      mergeMap(async ([users, groups]) => {
        cached || (cachedSystemGroups = groups);
        const grantPromises = users == null ? void 0 : users.map(async (user) => {
          const flattenedGrants = [...groups.map((group) => group.members.includes(user.id) ? group.grants : [])].flat(), { granted } = await grantsPermissionOn(
            user.id,
            flattenedGrants,
            permission,
            documentValue
          );
          return {
            ...user,
            granted
          };
        });
        return await Promise.all(grantPromises || []);
      })
    ).pipe(
      map((res) => ({
        error: null,
        loading: !1,
        data: sortBy(res, "displayName")
      }))
    );
  }, [client.observable, documentValue, projectStore, userStore, permission]);
  return useEffect(() => {
    const initial$ = of(INITIAL_STATE), sub = concat(initial$, list$).subscribe({
      next: setState,
      error: (error) => {
        setState({ data: [], error, loading: !1 });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [list$]), state;
}
const INITIAL = { validation: [], isValidating: !1 };
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(
    () => documentStore.pair.validation(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL
  );
}
const actionIds = /* @__PURE__ */ new WeakMap();
let counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId)
    return cachedId;
  const id = `${actionHook.name || actionHook.displayName || "<anonymous>"}-${counter++}`;
  return actionIds.set(actionHook, id), id;
}
const requestIdleCallbackShim = (callback) => {
  const start = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: !1,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 1);
}, cancelIdleCallbackShim = (handle) => clearTimeout(handle), _requestIdleCallback = typeof requestIdleCallback > "u" ? requestIdleCallbackShim : requestIdleCallback, _cancelIdleCallback = typeof cancelIdleCallback > "u" ? cancelIdleCallbackShim : cancelIdleCallback, throttleOptions = { trailing: !0 };
function GetHookCollectionState(props) {
  const { hooks, args, children, group, onReset } = props, statesRef = useRef({}), [tickId, setTick] = useState(0), [keys, setKeys] = useState({}), ricHandle = useRef(null), handleRequestUpdate = useCallback(() => {
    ricHandle.current && _cancelIdleCallback(ricHandle.current), ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null, setTick((tick) => tick + 1);
    });
  }, []), handleRequestUpdateThrottled = useThrottledCallback(
    handleRequestUpdate,
    60,
    throttleOptions
  ), handleNext = useCallback(
    (id, hookState) => {
      const hookGroup = (hookState == null ? void 0 : hookState.group) || ["default"];
      if (hookState === null || group && !hookGroup.includes(group))
        delete statesRef.current[id];
      else {
        const current = statesRef.current[id];
        statesRef.current[id] = { ...current, value: hookState };
      }
    },
    [group]
  ), handleReset = useCallback(
    (id) => {
      setKeys((currentKeys) => ({ ...currentKeys, [id]: (currentKeys[id] || 0) + 1 })), onReset && onReset();
    },
    [onReset]
  ), hookIds = useMemo(() => hooks.map((hook) => getHookId(hook)), [hooks]), states = useMemo(
    () => hookIds.map((id) => {
      var _a;
      return (_a = statesRef.current[id]) == null ? void 0 : _a.value;
    }).filter(isNonNullable$1),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
    [hookIds, tickId]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    hooks.map((hook) => {
      const id = getHookId(hook), key = keys[id] || 0;
      return /* @__PURE__ */ jsx(
        HookStateContainer,
        {
          hook,
          id,
          args,
          onNext: handleNext,
          onRequestUpdate: handleRequestUpdateThrottled,
          onReset: handleReset
        },
        `${id}-${key}`
      );
    }),
    children({ states })
  ] });
}
function Hotkeys({ makePlatformAware = !0, keys: hotKeys = [], ...props }) {
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return /* @__PURE__ */ jsx(Hotkeys$1, { ...props, keys });
}
const IS_APPLE_DEVICE = typeof navigator > "u" || typeof navigator.platform != "string" ? !1 : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key) {
  const lowerKey = key.toLowerCase();
  return lowerKey === "alt" && IS_APPLE_DEVICE ? matchCase(key, "option") : lowerKey === "option" && !IS_APPLE_DEVICE ? matchCase(key, "alt") : key;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char);
}
function IntentButton(props) {
  return props.disabled ? /* @__PURE__ */ jsx(Button, { ...props, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsx(Button, { ...props, as: IntentLink });
}
function RelativeTime({ time, ...options }) {
  const timestamp = time instanceof Date ? time : new Date(time), timeAgo = useRelativeTime(timestamp, options);
  return /* @__PURE__ */ jsx("time", { dateTime: timestamp.toISOString(), title: timeAgo, children: timeAgo });
}
function WithReferringDocuments({
  children,
  id
}) {
  return children(useReferringDocuments(id));
}
function ZIndexProvider({ children }) {
  return /* @__PURE__ */ jsx(ZIndexContext.Provider, { value: defaults, children });
}
function TelephoneInput(props) {
  const { schemaType, validationError, value, elementProps } = props;
  return /* @__PURE__ */ jsx(
    TextInput,
    {
      type: "tel",
      inputMode: "tel",
      customValidity: validationError,
      value: value || "",
      placeholder: schemaType.placeholder,
      ...elementProps
    }
  );
}
function resolveConditionalProperty(property, context) {
  const { currentUser, document, parent, value } = context;
  return typeof property == "boolean" || property === void 0 ? !!property : property({
    document,
    parent,
    value,
    currentUser
  }) === !0;
}
function setAtPath(currentTree, path, value) {
  var _a;
  if (path.length === 0)
    return { ...currentTree || {}, value };
  const [head, ...tail] = path, key = isKeySegment(head) ? head._key : String(head), children = (_a = currentTree == null ? void 0 : currentTree.children) != null ? _a : {};
  return {
    value: currentTree == null ? void 0 : currentTree.value,
    children: { ...children, [key]: setAtPath(children[key] || {}, tail, value) }
  };
}
const MAX_FIELD_DEPTH = 20, AUTO_COLLAPSE_DEPTH = 3, ALL_FIELDS_GROUP = {
  name: "all-fields",
  title: "All fields",
  hidden: !1
};
function getCollapsedWithDefaults(options = {}, level) {
  if ((options == null ? void 0 : options.collapsible) === !1 || (options == null ? void 0 : options.collapsable) === !1)
    return { collapsible: !1, collapsed: !1 };
  const collapsed = (
    // eslint-disable-next-line no-nested-ternary
    typeof (options == null ? void 0 : options.collapsed) == "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? !0 : void 0
  );
  return {
    collapsible: (options == null ? void 0 : options.collapsible) === !0 || (options == null ? void 0 : options.collapsable) === !0 || collapsed === !0 ? !0 : void 0,
    collapsed
  };
}
function getItemType(arrayType, item) {
  const itemTypeName = resolveTypeName$1(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = resolveTypeName$1(item);
  return arrayType == null ? void 0 : arrayType.of.find(
    (memberType) => memberType.name === itemTypeName || memberType.jsonType === itemTypeName
  );
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  return selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : fieldGroup === void 0 ? !1 : groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : castArray(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value > "u" || isRecord(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every((item) => isRecord(item));
}
function findDuplicateKeyEntries(array) {
  const seenKeys = /* @__PURE__ */ new Set();
  return array.reduce((acc, item, index) => (seenKeys.has(item._key) && acc.push([index, item._key]), seenKeys.add(item._key), acc), []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array) {
  return array == null ? void 0 : array.every((item) => isRecord(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  return Array.isArray(value) && typeof comparisonValue > "u" || Array.isArray(comparisonValue) && typeof value > "u" ? !1 : value && !comparisonValue ? !0 : !isEqual$2(value, comparisonValue);
}
function prepareFieldMember(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const { parent, field, index } = props, fieldPath = pathFor([...parent.path, field.name]), fieldLevel = getFieldLevel(field.type, parent.level + 1), parentValue = parent.value, parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue))
    throw new Error("Unexpected non-object value");
  const normalizedFieldGroupNames = field.group ? castArray(field.group) : [], inSelectedGroup = isFieldEnabledByGroupFilter(
    parent.groups,
    field.group,
    parent.selectedGroup
  );
  if (isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue))
      return {
        kind: "error",
        key: field.name,
        fieldName: field.name,
        error: {
          type: "INCOMPATIBLE_TYPE",
          expectedSchemaType: field.type,
          resolvedValueType: resolveTypeName$1(fieldValue),
          value: fieldValue
        }
      };
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return {
        kind: "hidden",
        key: `field-${field.name}`,
        name: field.name,
        index
      };
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[field.name], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[field.name], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[field.name], inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly,
      changesOpen: parent.changesOpen
    });
    if (inputState === null)
      return null;
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel), collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      open: startsWith(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if (isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (isArrayOfObjectsSchemaType(field.type)) {
      const hasValue = typeof fieldValue < "u";
      if (hasValue && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = resolveTypeName$1(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemIsObject(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MIXED_ARRAY",
            schemaType: field.type,
            value: fieldValue
          }
        };
      if (hasValue && !everyItemHasKey(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MISSING_KEYS",
            value: fieldValue,
            schemaType: field.type
          }
        };
      const duplicateKeyEntries = hasValue ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0)
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "DUPLICATE_KEYS",
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      const fieldGroupState = (_h = (_g = parent.fieldGroupState) == null ? void 0 : _g.children) == null ? void 0 : _h[field.name], scopedCollapsedPaths = (_j = (_i = parent.collapsedPaths) == null ? void 0 : _i.children) == null ? void 0 : _j[field.name], scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        open: startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = resolveTypeName$1(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name], scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name], scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0, conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return null;
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldState = preparePrimitiveInputState({
      ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      open: startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: !1,
      collapsed: !1,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props, enableHiddenCheck = !0) {
  var _a;
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  }, readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), schemaTypeGroupConfig = props.schemaType.groups || [], defaultGroupName = (_a = schemaTypeGroupConfig.find((g) => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a.name, groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap((group) => {
    var _a2;
    const groupHidden = resolveConditionalProperty(group.hidden, conditionalPropertyContext), isSelected = group.name === (((_a2 = props.fieldGroupState) == null ? void 0 : _a2.value) || defaultGroupName), selected = props.changesOpen ? group.name === ALL_FIELDS_GROUP.name : isSelected, disabled = props.changesOpen ? !selected : !1;
    return groupHidden ? [] : [
      {
        disabled,
        icon: group == null ? void 0 : group.icon,
        name: group.name,
        selected,
        title: group.title
      }
    ];
  }), selectedGroup = groups.find((group) => group.selected), members = (props.schemaType.fieldsets ? props.schemaType.fieldsets : props.schemaType.fields.map((field) => ({ single: !0, field }))).flatMap(
    (fieldSet, index) => {
      var _a2, _b, _c, _d;
      if (fieldSet.single) {
        const field = fieldSet.field, fieldMember = prepareFieldMember({
          field,
          parent: { ...props, readOnly, groups, selectedGroup },
          index
        });
        return fieldMember ? [fieldMember] : [];
      }
      const fieldsetFieldNames = fieldSet.fields.map((f) => f.name), fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, {
        currentUser: props.currentUser,
        document: props.document,
        parent: props.value,
        value: pick(props.value, fieldsetFieldNames)
      }), fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, {
        currentUser: props.currentUser,
        document: props.document,
        parent: props.value,
        value: pick(props.value, fieldsetFieldNames)
      }), fieldsetMembers = fieldSet.fields.flatMap(
        (field) => {
          if (fieldsetHidden)
            return [
              {
                kind: "hidden",
                key: `field-${field.name}`,
                name: field.name,
                index
              }
            ];
          const fieldMember = prepareFieldMember({
            field,
            parent: { ...props, readOnly: readOnly || fieldsetReadOnly, groups, selectedGroup },
            index
          });
          return fieldMember ? [fieldMember] : [];
        }
      ), defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props.level), collapsed = (_c = (_b = (((_a2 = props.collapsedFieldSets) == null ? void 0 : _a2.children) || {})[fieldSet.name]) == null ? void 0 : _b.value) != null ? _c : defaultCollapsedState.collapsed;
      return [
        {
          kind: "fieldSet",
          key: `fieldset-${fieldSet.name}`,
          _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup),
          groups: fieldSet.group ? castArray(fieldSet.group) : [],
          fieldSet: {
            path: pathFor(props.path.concat(fieldSet.name)),
            name: fieldSet.name,
            title: fieldSet.title,
            description: fieldSet.description,
            hidden: !1,
            level: props.level + 1,
            members: fieldsetMembers.filter(
              (member) => member.kind !== "hidden"
            ),
            collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible,
            collapsed,
            columns: (_d = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d.columns
          }
        }
      ];
    }
  ), hasFieldGroups = schemaTypeGroupConfig.length > 0, filteredPresence = props.presence.filter((item) => isEqual$1(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2, validation = props.validation.filter((item) => isEqual$1(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), visibleMembers = members.filter(
    (member) => member.kind !== "hidden"
  );
  if (visibleMembers.length === 0 && enableHiddenCheck)
    return null;
  const visibleGroups = hasFieldGroups ? groups.flatMap((group) => group.name === ALL_FIELDS_GROUP.name || visibleMembers.some((member) => member.kind === "error" ? !1 : member.kind === "field" ? member.groups.includes(group.name) : member.groups.includes(group.name) || member.fieldSet.members.some(
    (fieldsetMember) => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group.name)
  )) ? group : []) : [], filtereredMembers = visibleMembers.flatMap(
    (member) => {
      if (member.kind === "error")
        return [member];
      if (member.kind === "field")
        return member.inSelectedGroup ? [member] : [];
      const filteredFieldsetMembers = member.fieldSet.members.filter(
        (fieldsetMember) => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup
      );
      return filteredFieldsetMembers.length > 0 ? [
        {
          ...member,
          fieldSet: { ...member.fieldSet, members: filteredFieldsetMembers }
        }
      ] : [];
    }
  ), node = {
    value: props.value,
    changed: isChangedValue(props.value, props.comparisonValue),
    schemaType: props.schemaType,
    readOnly,
    path: props.path,
    id: toString(props.path),
    level: props.level,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    presence,
    validation,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  return Object.defineProperty(node, "_allMembers", {
    value: members,
    enumerable: !1
  }), node;
}
function prepareArrayOfPrimitivesInputState(props) {
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    comparisonValue: props.comparisonValue,
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  if (resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props.value) ? props.value : [], filteredPresence = props.presence.filter((item) => isEqual$1(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2, validation = props.validation.filter((item) => isEqual$1(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfPrimitivesMember({ arrayItem: item, parent: props, index })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    path: props.path,
    id: toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props) {
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  if (resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props.value) ? props.value : [], filteredPresence = props.presence.filter((item) => isEqual$1(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2, validation = props.validation.filter((item) => isEqual$1(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfObjectsMember({
      arrayItem: item,
      parent: props,
      index
    })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    path: props.path,
    id: toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { arrayItem, parent, index } = props, itemType = getItemType(parent.schemaType, arrayItem), key = arrayItem._key;
  if (!itemType) {
    const itemTypeName = resolveTypeName$1(arrayItem);
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }
  const itemPath = pathFor([...parent.path, { _key: key }]), itemLevel = parent.level + 1, conditionalPropertyContext = {
    value: parent.value,
    parent: props.parent,
    document: parent.document,
    currentUser: parent.currentUser
  }, readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[key], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[key], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[key], comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find((i) => i._key === arrayItem._key) || void 0, itemState = prepareObjectInputState(
    {
      schemaType: itemType,
      level: itemLevel,
      document: parent.document,
      value: arrayItem,
      comparisonValue,
      changed: isChangedValue(arrayItem, comparisonValue),
      path: itemPath,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      currentUser: parent.currentUser,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      readOnly
    },
    !1
  ), defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel), collapsed = (_g = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g : defaultCollapsedState.collapsed;
  return {
    kind: "item",
    key,
    index,
    open: startsWith(itemPath, parent.openPath),
    collapsed,
    collapsible: !0,
    parentSchemaType: parent.schemaType,
    item: itemState
  };
}
function prepareArrayOfPrimitivesMember(props) {
  var _a, _b;
  const { arrayItem, parent, index } = props, itemType = getPrimitiveItemType(parent.schemaType, arrayItem), itemPath = pathFor([...parent.path, index]), itemValue = (_a = parent.value) == null ? void 0 : _a[index], itemComparisonValue = (_b = parent.comparisonValue) == null ? void 0 : _b[index], itemLevel = parent.level + 1, key = `${(itemType == null ? void 0 : itemType.name) || "invalid-type"}-${String(index)}`;
  if (!itemType)
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        validTypes: parent.schemaType.of,
        resolvedValueType: resolveTypeName$1(itemType),
        value: itemValue
      }
    };
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  }), item = preparePrimitiveInputState({
    ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: "item",
    key,
    index,
    parentSchemaType: parent.schemaType,
    open: isEqual$1(itemPath, parent.openPath),
    item
  };
}
function preparePrimitiveInputState(props) {
  const filteredPresence = props.presence.filter((item) => isEqual$1(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2, validation = props.validation.filter((item) => isEqual$1(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path }));
  return {
    schemaType: props.schemaType,
    changed: isChangedValue(props.value, props.comparisonValue),
    value: props.value,
    level: props.level,
    id: toString(props.path),
    readOnly: props.readOnly,
    focused: isEqual$1(props.path, props.focusPath),
    path: props.path,
    presence,
    validation
  };
}
function prepareFormState(props) {
  return prepareObjectInputState(props);
}
function useFormState(schemaType, {
  comparisonValue,
  value,
  fieldGroupState,
  collapsedFieldSets,
  collapsedPaths,
  focusPath,
  openPath,
  presence,
  validation,
  readOnly,
  changesOpen
}) {
  const currentUser = useCurrentUser(), prev = useRef(null);
  return useLayoutEffect(() => {
    prev.current = null;
  }, [schemaType]), useMemo(() => {
    const next = prepareFormState({
      schemaType,
      document: value,
      fieldGroupState,
      collapsedFieldSets,
      collapsedPaths,
      value,
      comparisonValue,
      focusPath,
      openPath,
      readOnly,
      path: pathFor([]),
      level: 0,
      currentUser,
      presence,
      validation,
      changesOpen
    }), reconciled = immutableReconcile(prev.current, next);
    return prev.current = reconciled, reconciled;
  }, [
    schemaType,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    comparisonValue,
    focusPath,
    openPath,
    readOnly,
    currentUser,
    presence,
    validation,
    changesOpen
  ]);
}
function isObjectFormNode(formNode) {
  return isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path) {
  return [
    // make sure to expand all intermediate paths
    ...path.map((p, i) => ({ type: "expandPath", path: path.slice(0, i + 1) })),
    // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
    ...getFieldsetAndFieldGroupOperations(node, path)
  ];
}
function getFieldsetAndFieldGroupOperations(node, path) {
  return path.length === 0 ? [] : isObjectFormNode(node) && hasAllMembers(node) ? getObjectFieldsetAndFieldGroupOperations(node, path) : isArrayOfObjectsFormNode(node) ? getArrayFieldsetAndFieldGroupOperations(node, path) : [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path) {
  var _a, _b;
  if (path.length === 0)
    return [];
  const [fieldName, ...tail] = path, fieldsetMember = node._allMembers.find(
    (member) => member.kind === "fieldSet" && member.fieldSet.members.some(
      (field) => field.kind === "field" && field.name === fieldName
    )
  ), fieldMember = (fieldsetMember ? fieldsetMember.fieldSet.members : (
    // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
    node._allMembers
  )).find(
    (member) => member !== null && member.kind === "field" && member.name === fieldName
  ), schemaField = node.schemaType.fields.find((field) => field.name === fieldName), selectedGroupName = (_a = node.groups.find((group) => group.selected)) == null ? void 0 : _a.name, defaultGroupName = (_b = (node.schemaType.groups || []).find((group) => group.default)) == null ? void 0 : _b.name, inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && castArray(schemaField.group).includes(selectedGroupName)), ops = [];
  return inSelectedGroup || ops.push({
    type: "setSelectedGroup",
    path: node.path,
    groupName: defaultGroupName || ALL_FIELDS_GROUP.name
  }), fieldsetMember && ops.push({ type: "expandFieldSet", path: fieldsetMember.fieldSet.path }), fieldMember && hasAllMembers(fieldMember.field) && (isMemberArrayOfObjects(fieldMember) ? ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail)) : isMemberObject(fieldMember) && ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail))), ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path) {
  if (path.length === 0)
    return [];
  const [segment, ...rest] = path;
  if (!isKeySegment(segment))
    throw new Error("Expected path segment to be an object with a _key property");
  const foundMember = state.members.find(
    (member) => member.key === segment._key
  );
  return foundMember ? getFieldsetAndFieldGroupOperations(foundMember.item, rest) : [];
}
const IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key] = segment.split("==");
  return { [attr]: unquote(key) };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map((seg) => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return flatten(patches.map((patch) => toFormBuilderPatches(origin, patch)));
}
const notIn = (values) => (value) => !values.includes(value);
function toFormBuilderPatches(origin, patch) {
  return flatten(
    Object.keys(patch).filter(notIn(["id", "ifRevisionID", "query"])).map((type) => {
      if (type === "unset")
        return patch.unset.map((path) => ({
          type: "unset",
          path: decodePath(path),
          origin
        }));
      if (type === "insert") {
        const position = "before" in patch.insert ? "before" : "after";
        return {
          type: "insert",
          position,
          path: decodePath(patch.insert[position]),
          items: patch.insert.items,
          origin
        };
      }
      return Object.keys(patch[type]).map((gradientPath) => type === "set" ? {
        type: "set",
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "inc" || type === "dec" ? {
        type,
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "setIfMissing" ? {
        type: "setIfMissing",
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "diffMatchPatch" ? {
        type,
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : (console.warn(new Error(`Unsupported patch type: ${type}`)), null)).filter(Boolean);
    })
  );
}
function toMutationPatch(patch) {
  if (patch.patchType !== SANITY_PATCH_TYPE && patch.type)
    throw new Error(
      `Patch is missing "patchType" - import and use "${patch.type}()" from "sanity/form"`
    );
  if (patch.patchType !== SANITY_PATCH_TYPE)
    throw new Error(
      'Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"'
    );
  const matchPath = arrayToJSONMatchPath(patch.path || []);
  if (patch.type === "insert") {
    const { position, items } = patch;
    return {
      insert: {
        [position]: matchPath,
        items
      }
    };
  }
  if (patch.type === "unset")
    return {
      unset: [matchPath]
    };
  if (!patch.type)
    throw new Error(`Missing patch type in patch ${JSON.stringify(patch)}`);
  return matchPath ? {
    [patch.type]: {
      [matchPath]: patch.value
    }
  } : {
    [patch.type]: patch.value
  };
}
export {
  et as ActiveWorkspaceMatcher,
  eu as ActiveWorkspaceMatcherContext,
  AddonDatasetContext,
  AddonDatasetProvider,
  ch as ArrayOfObjectOptionsInput,
  ArrayOfObjectsFunctions,
  cd as ArrayOfObjectsInput,
  ArrayOfObjectsInputMember,
  ArrayOfObjectsInputMembers,
  ArrayOfObjectsItem,
  ci as ArrayOfOptionsInput,
  cj as ArrayOfPrimitiveOptionsInput,
  cb as ArrayOfPrimitivesFunctions,
  ck as ArrayOfPrimitivesInput,
  cy as ArrayOfPrimitivesItem,
  b6 as AutoCollapseMenu,
  BetaBadge,
  cc as BlockEditor,
  aR as BlockImagePreview,
  aS as BlockPreview,
  cm as BooleanInput,
  dJ as CONNECTING,
  bo as ChangeBreadcrumb,
  ChangeConnectorRoot,
  ChangeFieldWrapper,
  aC as ChangeIndicator,
  aD as ChangeIndicatorContext,
  bp as ChangeList,
  bq as ChangeResolver,
  br as ChangeTitleSegment,
  aV as CircularProgress,
  b5 as CollapseMenu,
  b7 as CollapseMenuButton,
  eB as ColorSchemeCustomProvider,
  eA as ColorSchemeLocalStorageProvider,
  ez as ColorSchemeProvider,
  ey as ColorSchemeSetValueContext,
  ex as ColorSchemeValueContext,
  aE as CommandList,
  aN as CompactPreview,
  b9 as ConfigPropertyError,
  ba as ConfigResolutionError,
  ConnectorContext,
  aF as ContextMenuButton,
  dM as CorsOriginError,
  cR as CrossDatasetReferenceInput,
  fd as DEFAULT_MAX_RECURSION_DEPTH,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  fm as DRAFTS_FOLDER,
  cn as DateInput,
  co as DateTimeInput,
  DefaultDocument,
  aO as DefaultPreview,
  aP as DetailPreview,
  bs as DiffCard,
  bF as DiffContext,
  bt as DiffErrorBoundary,
  DiffFromTo,
  bu as DiffInspectWrapper,
  bw as DiffString,
  bv as DiffStringSegment,
  DiffTooltip,
  DisabledChangeConnectorRoot,
  bG as DocumentChangeContext,
  dm as DocumentPreviewPresence,
  aG as DocumentStatus,
  aH as DocumentStatusIndicator,
  EMPTY_ARRAY$2 as EMPTY_ARRAY,
  fy as EMPTY_OBJECT,
  cp as EmailInput,
  EnabledChangeConnectorRoot,
  f2 as ErrorMessage,
  bx as FallbackDiff,
  c5 as FieldActionMenu,
  c6 as FieldActionsProvider,
  c7 as FieldActionsResolver,
  by as FieldChange,
  dr as FieldPresence,
  dn as FieldPresenceInner,
  dp as FieldPresenceWithOverlay,
  dq as FieldPresenceWithoutOverlay,
  cT as FileInput,
  FormBuilder,
  FormBuilderContext,
  cN as FormCallbacksContext,
  FormCallbacksProvider,
  b_ as FormField,
  b$ as FormFieldHeaderText,
  FormFieldPresenceContext,
  c0 as FormFieldSet,
  c1 as FormFieldStatus,
  c2 as FormFieldValidationStatus,
  c3 as FormInput,
  FormProvider,
  FormValueProvider,
  bz as FromTo,
  FromToArrow,
  GetHookCollectionState,
  GlobalErrorHandler,
  bA as GroupChange,
  Hotkeys,
  HoveredFieldProvider,
  cU as ImageInput,
  b1 as ImperativeToast,
  aT as InlinePreview,
  aI as InsufficientPermissionsMessage,
  IntentButton,
  b2 as LegacyLayerProvider,
  aW as LinearProgress,
  aJ as LoadingBlock,
  df as LocaleProvider,
  dg as LocaleProviderBase,
  aQ as MediaPreview,
  cz as MemberField,
  cA as MemberFieldError,
  cB as MemberFieldSet,
  MemberItemError,
  bB as MetaInfo,
  eW as NavbarContext,
  bC as NoChanges,
  cq as NumberInput,
  cr as ObjectInput,
  cC as ObjectInputMember,
  cD as ObjectInputMembers,
  cE as ObjectMembers,
  ds as OverlayDisabled,
  PatchEvent,
  aK as PopoverDialog,
  cc2 as PortableTextInput,
  dt as PresenceOverlay,
  PresenceScope,
  Preview,
  aM as PreviewCard,
  PreviewLoader,
  cS as ReferenceInput,
  cQ as ReferenceInputOptionsProvider,
  RelativeTime,
  ep as ResourceCacheProvider,
  bD as RevertChangesButton,
  ReviewChangesContext,
  SANITY_PATCH_TYPE,
  fM as SANITY_VERSION,
  em as SESSION_ID,
  dy as SanityDefaultPreview,
  bf as SchemaError,
  ScrollContainer,
  ScrollMonitor,
  eQ as SearchButton,
  eL as SearchContext,
  eR as SearchDialog,
  eJ as SearchPopover,
  eM as SearchProvider,
  eK as SearchResultItemPreview,
  cs as SelectInput,
  ct as SlugInput,
  eV as SourceProvider,
  a_ as StatusButton,
  cu as StringInput,
  Studio,
  StudioLayout,
  eX as StudioLayoutComponent,
  StudioLogo,
  eS as StudioNavbar,
  StudioProvider,
  eT as StudioToolMenu,
  cv as TagsArrayInput,
  TelephoneInput,
  aU as TemplatePreview,
  cw as TextInput,
  a$ as TextWithTone,
  ei as Timeline,
  ej as TimelineController,
  eU as ToolLink,
  b0 as TooltipOfDisabled,
  Tracker,
  d2 as TransformPatches,
  dl as Translate,
  cl as UniversalArrayInput,
  f0 as UpsellDescriptionSerializer,
  eZ as UpsellDialogDismissed,
  e$ as UpsellDialogLearnMoreCtaClicked,
  e_ as UpsellDialogUpgradeCtaClicked,
  eY as UpsellDialogViewed,
  cx as UrlInput,
  b3 as UserAvatar,
  fk as UserColorManagerProvider,
  bE as ValueError,
  ce as VirtualizerScrollInstanceContext,
  cg as VirtualizerScrollInstanceProvider,
  WithReferringDocuments,
  f4 as WorkspaceLoader,
  f1 as WorkspaceProvider,
  fb as WorkspacesContext,
  fc as WorkspacesProvider,
  ZIndexProvider,
  en as __tmp_wrap_presenceStore,
  dE as _createAuthStore,
  _isCustomDocumentTypeDefinition,
  _isSanityDocumentTypeDefinition,
  eD as _useColorSchemeInternalValue,
  fJ as asLoadable,
  buildLegacyTheme,
  dU as checkoutPair,
  fw as collate,
  dF as createAuthStore,
  dS as createBufferedDocument,
  createConfig,
  dL as createConnectionStatusStore,
  dz as createDocumentPreviewStore,
  d_ as createDocumentStore,
  ft as createDraftFrom,
  ec as createGrantsStore,
  eh as createHistoryStore,
  fl as createHookFromObservableFactory,
  dD as createKeyValueStore,
  createMockAuthStore,
  createNoopTrackerScope,
  dT as createObservableBufferedDocument,
  createPatchChannel,
  createPlugin,
  eo as createProjectStore,
  fv as createPublishedFrom,
  dB as createSchema,
  fB as createSharedResizeObserver,
  createSourceFromConfig,
  aX as createTrackerScope,
  aY as createUseReporter,
  fj as createUserColorManager,
  er as createUserStore,
  createWorkspaceFromConfig,
  cL as dec,
  decodePath,
  dk as defaultLocale,
  defaultRenderAnnotation,
  defaultRenderBlock,
  defaultRenderField,
  defaultRenderInlineBlock,
  defaultRenderInput,
  defaultRenderItem,
  defaultRenderPreview,
  defaultTemplateForType,
  defaultTemplatesForSchema,
  fh as defaultTheme,
  defineConfig,
  defineDocumentFieldAction,
  defineDocumentInspector,
  db as defineLocale,
  dc as defineLocaleResourceBundle,
  dd as defineLocalesResources,
  definePlugin,
  eH as defineSearchFilter,
  eI as defineSearchFilterOperators,
  eP as defineSearchOperator,
  cJ as diffMatchPatch,
  diffResolver,
  bc as documentFieldActionsReducer,
  fn as documentIdEquals,
  dV as editState,
  dW as emitOperation,
  encodePath,
  fD as escapeField,
  fC as fieldNeedsEscape,
  bP as findIndex,
  bd as flattenConfig,
  fromMutationPatches,
  bj as getAnnotationAtPath,
  getAnnotationColor,
  getConfigContextFromSource,
  bk as getDiffAtPath,
  e6 as getDocumentPairPermissions,
  e9 as getDocumentValuePermissions,
  fs as getDraftId,
  getExpandOperations,
  fq as getIdPair,
  e1 as getInitialValueStream,
  bW as getItemKey,
  bX as getItemKeySegment,
  f6 as getNamelessWorkspaceIdentifier,
  d$ as getPairListener,
  du as getPreviewPaths,
  dv as getPreviewStateObservable,
  dw as getPreviewValueWithFallback,
  dG as getProviderTitle,
  getPublishedId,
  dC as getSchemaTypeTitle,
  ed as getTemplatePermissions,
  bO as getValueAtPath,
  bZ as getValueError,
  f5 as getWorkspaceIdentifier,
  fz as globalScope,
  grantsPermissionOn,
  cK as inc,
  bb as initialDocumentFieldActions,
  cG as insert,
  bK as isAddedItemDiff,
  isArray,
  c$ as isArrayOfBlocksInputProps,
  c_ as isArrayOfObjectsInputProps,
  d0 as isArrayOfPrimitivesInputProps,
  dH as isAuthStore,
  cZ as isBooleanInputProps,
  isBuilder,
  dI as isCookielessCompatibleLoginMethod,
  bg as isDev,
  fo as isDraft,
  fp as isDraftId,
  bY as isEmptyObject,
  bI as isFieldChange,
  bJ as isGroupChange,
  isNonNullable$1 as isNonNullable,
  cY as isNumberInputProps,
  cW as isObjectInputProps,
  cV as isObjectItemProps,
  bh as isProd,
  fr as isPublishedId,
  isRecord,
  bL as isRemovedItemDiff,
  fA as isString,
  cX as isStringInputProps,
  isTruthy,
  bM as isUnchangedDiff,
  fE as joinPath,
  e2 as listenQuery,
  ev as matchWorkspace,
  fu as newDraftFrom,
  bH as noop,
  bS as normalizeIndexSegment,
  bU as normalizeIndexTupleSegment,
  bT as normalizeKeySegment,
  bR as normalizePathSegment,
  dK as onRetry,
  dX as operationEvents,
  eO as operatorDefinitions,
  pathToString,
  bV as pathsAreEqual,
  cM as prefixPath,
  prepareConfig,
  dx as prepareForPreview,
  prepareTemplates,
  remoteSnapshots,
  fx as removeDupes,
  eg as removeMissingReferences,
  de as removeUndefinedLocaleResources,
  renderStudio,
  resizeObserver,
  resolveConditionalProperty,
  resolveConfig,
  bN as resolveDiffComponent,
  fe as resolveInitialObjectValue,
  ff as resolveInitialValue,
  fg as resolveInitialValueForType,
  be as resolveSchemaTypes,
  cH as set,
  setAtPath,
  cF as setIfMissing,
  fG as sliceString,
  dY as snapshotPair,
  bQ as stringToPath,
  fF as supportsTouch,
  toMutationPatches,
  fH as truncateString,
  uncaughtErrorHandler,
  cI as unset,
  dA as unstable_useValuePreview,
  dj as usEnglishLocale,
  ew as useActiveWorkspace,
  useAddonDataset,
  bm as useAnnotationColor,
  useClient,
  eF as useColorScheme,
  eG as useColorSchemeOptions,
  eC as useColorSchemeSetValue,
  eE as useColorSchemeValue,
  useConfigContextFromSource,
  useConnectionState,
  dP as useConnectionStatusStore,
  useCurrentLocale,
  useCurrentUser,
  d3 as useDataset,
  d4 as useDateTimeFormat,
  ca as useDidUpdate,
  bn as useDiffAnnotationColor,
  bi as useDocumentChange,
  d5 as useDocumentOperation,
  useDocumentOperationEvent,
  e8 as useDocumentPairPermissions,
  e7 as useDocumentPairPermissionsFromHookFactory,
  ek as useDocumentPresence,
  dO as useDocumentPreviewStore,
  useDocumentStore,
  useDocumentType,
  eb as useDocumentValuePermissions,
  ea as useDocumentValuePermissionsFromHookFactory,
  e0 as useDocumentValues,
  useEditState,
  d6 as useFeatureEnabled,
  c8 as useFieldActions,
  d1 as useFormBuilder,
  cO as useFormCallbacks,
  useFormState,
  c4 as useFormValue,
  useFormattedDuration,
  dh as useGetI18nText,
  el as useGlobalPresence,
  dN as useGrantsStore,
  useHistoryStore,
  c9 as useHoveredField,
  di as useI18nText,
  e3 as useInitialValue,
  e4 as useInitialValueResolverContext,
  dR as useKeyValueStore,
  useListFormat,
  fI as useLoadable,
  a as useLocale,
  b8 as useMiddlewareComponents,
  useNumberFormat,
  useOnScroll,
  dQ as usePresenceStore,
  aL as usePreviewCard,
  useProject,
  useProjectDatasets,
  d7 as useProjectId,
  useProjectStore,
  cP as useReferenceInputOptions,
  useRelativeTime,
  useReportedValues,
  useReporter,
  e5 as useResolveInitialValueForType,
  eq as useResourceCache,
  useReviewChanges,
  aZ as useRovingFocus,
  d8 as useSchema,
  eN as useSearchState,
  useSource,
  useSyncState,
  ef as useTemplatePermissions,
  ee as useTemplatePermissionsFromHookFactory,
  d9 as useTemplates,
  useThrottledCallback,
  useTimeAgo,
  useTimelineSelector,
  useTimelineStore,
  useTools,
  useTranslation,
  fL as useUnique,
  da as useUnitFormatter,
  es as useUser,
  fi as useUserColor,
  useUserColorManager,
  useUserListWithPermissions,
  useUserStore,
  useValidationStatus,
  cf as useVirtualizerScrollInstance,
  useWorkspace,
  f3 as useWorkspaceLoader,
  f7 as useWorkspaces,
  b4 as useZIndex,
  fK as userHasRole,
  fa as validateBasePaths,
  aB as validateDocument,
  f9 as validateNames,
  f8 as validateWorkspaces,
  dZ as validation,
  bl as visitDiff
};
//# sourceMappingURL=index.esm.js.map
