"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var jsxRuntime = require("react/jsx-runtime"), PathUtils = require("@sanity/util/paths"), React = require("react"), deepCompare = require("react-fast-compare"), TransformPatches = require("./_chunks-cjs/TransformPatches.js"), sortBy = require("lodash/sortBy.js"), reactRx = require("react-rx"), rxjs = require("rxjs"), operators = require("rxjs/operators"), isEqual$1 = require("lodash/isEqual.js"), throttle = require("lodash/throttle.js"), types = require("@sanity/types"), ui = require("@sanity/ui"), router = require("sanity/router"), getJsonStream = require("./_chunks-cjs/getJsonStream.js"), isString = require("lodash/isString.js");
require("dataloader");
require("history");
var withSelector = require("use-sync-external-store/with-selector");
require("lodash/escapeRegExp.js");
require("lodash/isEqual");
require("lodash/startCase");
require("react-dom/server");
require("@sanity/schema/_internal");
require("lodash/compact.js");
require("lodash/intersection.js");
require("lodash/keyBy.js");
require("lodash/partition.js");
require("lodash/toLower.js");
require("lodash/union.js");
require("lodash/uniq.js");
require("lodash/words.js");
require("lodash/isFinite.js");
require("lodash/intersection");
require("lodash/isEmpty");
require("date-fns");
require("react-i18next");
require("@sanity/portable-text-editor");
require("@sanity/icons");
require("lodash/omit.js");
require("@sanity/diff-match-patch");
var flatten = require("lodash/flatten.js");
require("lodash/orderBy.js");
require("lodash/xor.js");
require("sanity-diff-patch");
require("lodash/startCase.js");
require("lodash/debounce.js");
require("nano-pubsub");
require("shallow-equals");
require("scroll-into-view-if-needed");
require("lodash/get.js");
require("get-random-values-esm");
var content = require("@sanity/util/content");
require("lodash/isPlainObject.js");
require("@tanstack/react-virtual");
require("@sanity/util/legacyDateFormat");
require("speakingurl");
require("@sanity/telemetry/react");
require("lodash/find.js");
var castArray = require("lodash/castArray.js"), pick = require("lodash/pick.js"), mutator = require("@sanity/mutator");
require("@sanity/schema");
require("@sanity/asset-utils");
require("@sanity/image-url");
require("@sanity/uuid");
require("exif-component");
require("react-is");
require("lodash/difference.js");
require("lodash/memoize.js");
require("lodash/identity.js");
require("lodash/values.js");
require("lodash/assignWith.js");
require("lodash/capitalize.js");
var client = require("react-dom/client");
require("lodash/groupBy.js");
require("json-reduce");
require("rxjs-exhaustmap-with-trailing");
require("groq-js");
require("rxjs-etc/operators");
require("mendoza");
require("@sanity/diff");
require("raf");
require("@sanity/bifur-client");
require("@sanity/client");
require("i18next");
var color = require("@sanity/color"), theme = require("@sanity/ui/theme"), polished = require("polished");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e)
    return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
var PathUtils__namespace = /* @__PURE__ */ _interopNamespaceCompat(PathUtils), deepCompare__default = /* @__PURE__ */ _interopDefaultCompat(deepCompare), sortBy__default = /* @__PURE__ */ _interopDefaultCompat(sortBy), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual$1), throttle__default = /* @__PURE__ */ _interopDefaultCompat(throttle), isString__default = /* @__PURE__ */ _interopDefaultCompat(isString), flatten__default = /* @__PURE__ */ _interopDefaultCompat(flatten), castArray__default = /* @__PURE__ */ _interopDefaultCompat(castArray), pick__default = /* @__PURE__ */ _interopDefaultCompat(pick);
function noop() {
}
function NoopTracker({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
function createNoopTrackerScope() {
  return {
    useReportedValues: noop,
    Tracker: NoopTracker,
    useReporter: noop
  };
}
const ChangeFieldWrapper = (props) => {
  const ref = React.useRef(null), { onSetFocus } = React.useContext(TransformPatches.ConnectorContext), [isHover, setHover] = React.useState(!1), onMouseEnter = React.useCallback(() => {
    setHover(!0);
  }, []), onMouseLeave = React.useCallback(() => {
    setHover(!1);
  }, []);
  TransformPatches.useReporter(
    `change-${PathUtils__namespace.toString(props.path)}`,
    () => ({
      element: ref.current,
      path: props.path,
      isChanged: !0,
      hasFocus: !1,
      hasHover: isHover,
      hasRevertHover: props.hasHover
    }),
    // note: deepCompare should be ok here since we're not comparing deep values
    deepCompare__default.default
  );
  const handleClick = React.useCallback(
    (event) => {
      setFocusWithStopPropagation(event, onSetFocus, props.path);
    },
    [onSetFocus, props.path]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref, onClick: handleClick, onMouseLeave, onMouseEnter, children: props.children });
};
function setFocusWithStopPropagation(event, onSetFocus, path) {
  event.stopPropagation(), onSetFocus(path);
}
function isArray(value) {
  return Array.isArray(value);
}
function isTruthy(value) {
  return !!value;
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
const FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif", FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace", uncaughtErrorHandler = () => (
  // prettier-ignore
  [
    "window.onerror = function(m,u,l,c,e) {",
    "var p=window.location.port;",
    "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');",
    "var r=document.getElementById('sanity');",
    "while(r.firstChild){r.removeChild(r.firstChild);}",
    "var s=document.createElement('style');",
    "s.appendChild(document.createTextNode('",
    "html,body,#sanityBody,#sanity,#sanityError{height:100%;}",
    "body{-webkit-font-smoothing:antialiased;margin:0;}",
    `#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:${FONT_SANS_SERIF};font-size:16px;line-height:21px;min-height:100%;}`,
    "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}",
    "@media(min-width:512px){",
    "#sanityError>div{",
    "padding:47px 84px;",
    "}",
    "}",
    "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}",
    "#sanityError button:hover{background-color:#1E63D0;}",
    "#sanityError button:active{background-color:#1B50A5;}",
    "'));",
    "document.head.appendChild(s);",
    "var f=document.createElement('div');",
    "f.id='sanityError';",
    "f.innerHTML='",
    "<div>",
    '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>',
    '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>',
    '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>',
    '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">',
    `<code style="font-family:${FONT_MONOSPACE};">`,
    "'+e.stack.replaceAll(h,'')+'",
    "</code>",
    "</pre>",
    "</div>",
    "';",
    "var b=f.querySelector('.sanity-error-handler__reload-btn');",
    "if(b){",
    "b.onclick=function() {",
    "window.location.reload();",
    "}",
    "};",
    "r.appendChild(f);",
    "};"
  ].join("")
);
function useThrottledCallback(callback, wait, options) {
  return React.useMemo(
    () => throttle__default.default(callback, wait, options),
    [callback, options, wait]
  );
}
function useOnScroll(callback) {
  const parentContext = React.useContext(TransformPatches.ScrollContext);
  React.useEffect(() => parentContext == null ? void 0 : parentContext.subscribe(callback), [callback, parentContext]);
}
function ScrollMonitor({ onScroll, children }) {
  return useOnScroll(onScroll), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
function findMostSpecificTarget(targetType, id, values) {
  const pathString = id.slice(id.indexOf("-") + 1) || "[]", path = PathUtils__namespace.fromString(pathString), exactId = `${targetType}-${PathUtils__namespace.toString(path)}`;
  if (values.has(exactId))
    return values.get(exactId);
  let mostSpecific;
  for (const [targetId, target] of values) {
    if (!("path" in target) || !targetId.startsWith(targetType))
      continue;
    const numEqual = PathUtils__namespace.numEqualSegments(path, target.path), lastPathSegment = target.path[target.path.length - 1], pathOnlyDiffersByKey = numEqual === target.path.length - 1 && types.isKeyedObject(lastPathSegment);
    if (numEqual !== 0 && !(numEqual !== target.path.length && !pathOnlyDiffersByKey) && (mostSpecific = target, numEqual === path.length))
      break;
  }
  return mostSpecific;
}
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el) {
  return (el.scrollHeight !== el.offsetHeight || el.scrollWidth !== el.offsetWidth) && hasOverflowScroll(el);
}
const getOffsetsTo = (source, target) => {
  const bounds = {
    top: 0,
    left: 0,
    height: target.offsetHeight,
    width: target.offsetWidth
  }, rect = {
    top: 0,
    left: 0,
    height: source.offsetHeight,
    width: source.offsetWidth
  };
  let foundScrollContainer = !1, el = source;
  for (; el && el !== target && target.contains(el); )
    foundScrollContainer && (bounds.top += el.offsetTop, bounds.left += el.offsetLeft), hasOverflowScroll(el) && (bounds.top = el.offsetTop, bounds.height = el.offsetHeight, bounds.left = el.offsetLeft, bounds.width = el.offsetWidth, foundScrollContainer = !0), rect.top += el.offsetTop - el.scrollTop, rect.left += el.offsetLeft - el.scrollLeft, el = el.offsetParent;
  return { rect, bounds };
};
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
const SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  let parentElementWithScroll = field.element;
  for (; !isScrollable(parentElementWithScroll); )
    if (parentElementWithScroll = parentElementWithScroll.parentElement, !parentElementWithScroll)
      return;
  parentElementWithScroll.scroll({
    top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING,
    left: 0,
    behavior: "smooth"
  });
}
function useResizeObserver(element, onResize) {
  React.useEffect(() => TransformPatches.resizeObserver.observe(element, onResize), [element, onResize]);
}
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [], changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged)
      continue;
    const [id, reportedChangeBar] = value;
    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  return { connectors: (isHoverConnector ? changeBarsWithHover : changeBarsWithFocus).map(([id]) => {
    const field = findMostSpecificTarget("field", id, byId), change = findMostSpecificTarget("change", id, byId);
    return !field || !change ? null : { field: { id, ...field }, change: { id, ...change } };
  }).filter(TransformPatches.isNonNullable).map(({ field, change }) => ({
    hasHover: field.hasHover || change.hasHover,
    hasFocus: field.hasFocus,
    hasRevertHover: change.hasRevertHover,
    field: { ...field, ...getOffsetsTo(field.element, rootElement) },
    change: { ...change, ...getOffsetsTo(change.element, rootElement) }
  })), isHoverConnector };
}
function ConnectorsOverlay(props) {
  const { rootElement, onSetFocus } = props, [hovered, setHovered] = React.useState(null), allReportedValues = TransformPatches.useReportedValues(), byId = React.useMemo(
    () => new Map(allReportedValues),
    [allReportedValues]
  ), [{ connectors }, setState] = React.useState(
    () => getState(allReportedValues, hovered, byId, rootElement)
  ), visibleConnectors = React.useMemo(
    () => sortBy__default.default(connectors, (c) => 0 - c.field.path.length).slice(0, 1),
    [connectors]
  ), handleScrollOrResize = React.useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  return useResizeObserver(rootElement, handleScrollOrResize), /* @__PURE__ */ jsxRuntime.jsx(ScrollMonitor, { onScroll: handleScrollOrResize, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.SvgWrapper, { style: { zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex }, children: visibleConnectors.map(({ field, change }) => change ? /* @__PURE__ */ jsxRuntime.jsx(
    ConnectorGroup,
    {
      field,
      change,
      onSetFocus,
      setHovered
    },
    field.id
  ) : null) }) });
}
function ConnectorGroup(props) {
  const { change, field, onSetFocus, setHovered } = props, onConnectorClick = React.useCallback(() => {
    scrollIntoView(field), scrollIntoView(change), onSetFocus(field.path);
  }, [field, change, onSetFocus]), handleMouseEnter = React.useCallback(() => setHovered(field.id), [field, setHovered]), handleMouseLeave = React.useCallback(() => setHovered(null), [setHovered]), from = React.useMemo(
    () => ({
      rect: {
        ...field.rect,
        left: field.rect.left + 3
      },
      bounds: field.bounds
    }),
    [field.bounds, field.rect]
  ), to = React.useMemo(
    () => ({
      rect: {
        ...change.rect,
        left: change.rect.left + 1
      },
      bounds: change.bounds
    }),
    [change.bounds, change.rect]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("g", { onClick: onConnectorClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.Connector, { from, to }) }),
    TransformPatches.DEBUG_LAYER_BOUNDS
  ] });
}
function EnabledChangeConnectorRoot({
  children,
  className,
  isReviewChangesOpen,
  onOpenReviewChanges,
  onSetFocus,
  ...restProps
}) {
  const [rootElement, setRootElement] = React.useState(), contextValue = React.useMemo(
    () => ({
      isReviewChangesOpen,
      onOpenReviewChanges,
      onSetFocus
    }),
    [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.ConnectorContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.Tracker, { children: /* @__PURE__ */ jsxRuntime.jsxs(TransformPatches.ScrollContainer, { ...restProps, ref: setRootElement, className, children: [
    children,
    rootElement && /* @__PURE__ */ jsxRuntime.jsx(ConnectorsOverlay, { rootElement, onSetFocus })
  ] }) }) });
}
function DisabledChangeConnectorRoot({
  children,
  className
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.ScrollContainer, { className, children });
}
const ChangeConnectorRoot = EnabledChangeConnectorRoot;
function BetaBadge(props) {
  const { fontSize = 1, children = "Beta", ...rest } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { ...rest, fontSize, radius: 2, tone: "primary", children });
}
function Favicons({ basePath }) {
  const base = `${basePath.replace(/\/+$/, "")}/static`;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "icon", href: `${base}/favicon.ico`, sizes: "any" }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "icon", href: `${base}/favicon.svg`, type: "image/svg+xml" }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "apple-touch-icon", href: `${base}/apple-touch-icon.png` }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "manifest", href: `${base}/manifest.webmanifest` })
  ] });
}
const errorHandlerScript = `
;(function () {
  var _caughtErrors = []

  var errorChannel = (function () {
    var subscribers = []

    function publish(msg) {
      for (var i = 0; i < subscribers.length; i += 1) {
        subscribers[i](msg)
      }
    }

    function subscribe(subscriber) {
      subscribers.push(subscriber)

      return function () {
        var idx = subscribers.indexOf(subscriber)

        if (idx > -1) {
          subscribers.splice(idx, 1)
        }
      }
    }

    return {publish, subscribe, subscribers}
  })()

  // NOTE: Store the error channel instance in the global scope so that the Studio application can
  // access it and subscribe to errors.
  window.__sanityErrorChannel = {
    subscribe: errorChannel.subscribe,
  }

  function _nextTick(callback) {
    setTimeout(callback, 0)
  }

  function _handleError(error, params) {
    _nextTick(function () {
      // - If there are error channel subscribers, then we notify them (no console error).
      // - If there are no subscribers, then we log the error to the console and render the error overlay.
      if (errorChannel.subscribers.length) {
        errorChannel.publish({error, params})
      } else {
        console.error(error)

        _renderErrorOverlay(error, params)
      }
    })
  }

  var ERROR_BOX_STYLE = [
    'background: #fff',
    'border-radius: 6px',
    'box-sizing: border-box',
    'color: #121923',
    'flex: 1',
    "font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif",
    'font-size: 16px',
    'line-height: 21px',
    'margin: 0 auto',
    'max-width: 960px',
    'overflow: auto',
    'padding: 20px',
    'width: 100%',
  ].join(';')

  var ERROR_CODE_STYLE = [
    'color: #972E2A',
    "font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace",
    'font-size: 13px',
    'line-height: 17px',
    'margin: 0',
  ].join(';')

  function _renderErrorOverlay(error, params) {
    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')
    var colno = params.event.colno
    var lineno = params.event.lineno
    var filename = params.event.filename

    errorElement.id = '__sanityError'
    errorElement.innerHTML = [
      '<div style="' + ERROR_BOX_STYLE + '">',
      '<div style="font-weight: 700;">Uncaught error: ' + error.message + '</div>',
      '<div style="color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;">' +
        filename +
        ':' +
        lineno +
        ':' +
        colno +
        '</div>',
      '<pre style="' + ERROR_CODE_STYLE + '">' + error.stack + '</pre>',
      '</div>',
    ].join('')

    errorElement.style.position = 'fixed'
    errorElement.style.zIndex = 1000000
    errorElement.style.top = 0
    errorElement.style.left = 0
    errorElement.style.right = 0
    errorElement.style.bottom = 0
    errorElement.style.padding = '20px'
    errorElement.style.background = 'rgba(16,17,18,0.66)'
    errorElement.style.display = 'flex'
    errorElement.style.alignItems = 'center'
    errorElement.style.justifyContent = 'center'

    document.body.appendChild(errorElement)
  }

  // NOTE:
  // Yes \u2013 we're attaching 2 error listeners below \u{1F440}
  // This is because React makes the same error throw twice (in development mode).
  // See: https://github.com/facebook/react/issues/10384

  // Error listener #1
  window.onerror = function (event, source, lineno, colno, error) {
    _nextTick(function () {
      if (_caughtErrors.indexOf(error) !== -1) return

      _caughtErrors.push(error)

      _handleError(error, {
        event,
        lineno,
        colno,
        source,
      })

      _nextTick(function () {
        var idx = _caughtErrors.indexOf(error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    // IMPORTANT: this callback must return \`true\` to prevent the error from being rendered in
    // the browser\u2019s console.
    return true
  }

  // Error listener #2
  window.addEventListener('error', function (event) {
    if (_caughtErrors.indexOf(event.error) !== -1) return true

    _caughtErrors.push(event.error)

    _handleError(event.error, {
      event,
      lineno: event.lineno,
      colno: event.colno,
    })

    _nextTick(function () {
      _nextTick(function () {
        var idx = _caughtErrors.indexOf(event.error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    return true
  })
})()
`;
function GlobalErrorHandler() {
  return /* @__PURE__ */ jsxRuntime.jsx("script", { dangerouslySetInnerHTML: { __html: errorHandlerScript } });
}
const NoJsStyles = `
.sanity-app-no-js__root {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  background: #fff;
}

.sanity-app-no-js__content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  font-family: helvetica, arial, sans-serif;
}
`;
function NoJavascript() {
  return /* @__PURE__ */ jsxRuntime.jsx("noscript", { children: /* @__PURE__ */ jsxRuntime.jsx("div", { className: "sanity-app-no-js__root", children: /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "sanity-app-no-js__content", children: [
    /* @__PURE__ */ jsxRuntime.jsx("style", { type: "text/css", children: NoJsStyles }),
    /* @__PURE__ */ jsxRuntime.jsx("h1", { children: "JavaScript disabled" }),
    /* @__PURE__ */ jsxRuntime.jsxs("p", { children: [
      "Please ",
      /* @__PURE__ */ jsxRuntime.jsx("a", { href: "https://www.enable-javascript.com/", children: "enable JavaScript" }),
      " in your browser and reload the page to proceed."
    ] })
  ] }) }) });
}
const globalStyles = `
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");
  }
  html {
    background-color: #f1f3f6;
  }
  html,
  body,
  #sanity {
    height: 100%;
  }
  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
  }
`, EMPTY_ARRAY$1 = [];
function DefaultDocument(props) {
  const { entryPath, css = EMPTY_ARRAY$1, basePath = "/" } = props;
  return /* @__PURE__ */ jsxRuntime.jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxRuntime.jsxs("head", { children: [
      /* @__PURE__ */ jsxRuntime.jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "meta",
        {
          name: "viewport",
          content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx("meta", { name: "robots", content: "noindex" }),
      /* @__PURE__ */ jsxRuntime.jsx("meta", { name: "referrer", content: "same-origin" }),
      /* @__PURE__ */ jsxRuntime.jsx(Favicons, { basePath }),
      /* @__PURE__ */ jsxRuntime.jsx("title", { children: "Sanity Studio" }),
      /* @__PURE__ */ jsxRuntime.jsx(GlobalErrorHandler, {}),
      css.map((href) => /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "stylesheet", href }, href)),
      /* @__PURE__ */ jsxRuntime.jsx("style", { dangerouslySetInnerHTML: { __html: globalStyles } })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs("body", { children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { id: "sanity" }),
      /* @__PURE__ */ jsxRuntime.jsx("script", { type: "module", src: entryPath }),
      /* @__PURE__ */ jsxRuntime.jsx(NoJavascript, {})
    ] })
  ] });
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return config;
}
function validatePlugin(pluginResult) {
  const messages = [
    "projectId" in pluginResult && "`projectId` not allowed in plugin configuration",
    "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"
  ].filter(isString__default.default);
  if (messages.length)
    throw new Error(
      `Invalid plugin configuration:
${messages.map((message) => `	${message}`).join(`
`)}`
    );
}
function definePlugin(arg) {
  if (typeof arg == "function") {
    const pluginFactory = arg;
    return (options) => {
      const result = pluginFactory(options);
      return validatePlugin(result), result;
    };
  }
  return validatePlugin(arg), () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
function defineDocumentInspector(inspector) {
  return inspector;
}
function createMockAuthStore({ client: client2, currentUser = null }) {
  return {
    state: rxjs.of({ authenticated: !0, client: client2, currentUser })
  };
}
function isEqual(item, otherItem) {
  if (item === otherItem)
    return !0;
  if (typeof item != typeof otherItem)
    return !1;
  if (typeof item != "object" && !Array.isArray(item))
    return item === otherItem;
  if (types.isKeyedObject(item) && types.isKeyedObject(otherItem) && item._key === otherItem._key)
    return !0;
  if (Array.isArray(item) && Array.isArray(otherItem))
    return item.length !== otherItem.length ? !1 : item.every((child, i) => isEqual(child, otherItem[i]));
  if (item === null || otherItem === null)
    return item === otherItem;
  const obj = item, otherObj = otherItem, keys = Object.keys(obj), otherKeys = Object.keys(otherObj);
  return keys.length !== otherKeys.length ? !1 : keys.every((keyName) => isEqual(obj[keyName], otherObj[keyName]));
}
const ArrayOfOptionsFieldDiff = ({ diff, schemaType }) => {
  var _a;
  const options = (_a = schemaType.options) == null ? void 0 : _a.list, colorManager = TransformPatches.useUserColorManager(), { t } = TransformPatches.useTranslation();
  return Array.isArray(options) ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: diff.items.map((item) => normalizeItems(item, diff, schemaType)).filter((item) => item !== null).sort(sortItems).map((item, index) => {
    const { annotation, isPresent, value, memberType, title } = item, color2 = TransformPatches.getAnnotationColor(colorManager, annotation), action = t(isPresent ? "changes.added-label" : "changes.removed-label");
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.DiffTooltip, { annotations: annotation ? [annotation] : [], description: action, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.Checkbox, { checked: !isPresent, color: color2 }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.FromToArrow, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.Checkbox, { checked: isPresent, color: color2 })
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ItemPreview, { value: title || value, memberType }) })
    ] }, getItemKey(diff, index));
  }) }) : null;
};
function normalizeItems(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged")
    return null;
  const { fromValue, toValue } = parentDiff, value = getValue(item.diff), wasPresent = isInArray(value, fromValue), isPresent = isInArray(value, toValue);
  return wasPresent === isPresent ? null : {
    title: getItemTitle(value, schemaType),
    memberType: resolveMemberType(getValue(item.diff), schemaType),
    itemIndex: getOptionIndex(value, schemaType),
    annotation: item.annotation,
    isPresent,
    value
  };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview({ value, memberType }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginX: 2, marginY: 1, children: typeof value == "string" || typeof value == "number" ? value : /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.Preview, { schemaType: memberType, value, layout: "default" }) });
}
function isInArray(value, parent) {
  const array = parent || [];
  return typeof value == "object" && value !== null ? array.some((item) => isEqual(item, value)) : array.includes(value);
}
function getItemKey(diff, index) {
  const value = diff.toValue || diff.fromValue;
  return types.isKeyedObject(value) ? value._key : index;
}
function getValue(diff) {
  return typeof diff.toValue > "u" ? diff.fromValue : diff.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object")
    return jsType;
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType(val) {
  return val === null ? "null" : Array.isArray(val) ? "array" : typeof val;
}
function isNamedOption(item) {
  return typeof item == "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a;
  return (((_a = schemaType.options) == null ? void 0 : _a.list) || []).findIndex((opt) => isEqual(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [], index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
const SlugFieldDiff = ({ diff, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  TransformPatches.DiffFromTo,
  {
    layout: "inline",
    diff,
    schemaType,
    previewComponent: TransformPatches.SlugPreview
  }
), UrlFieldDiff = ({ diff, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.DiffFromTo, { diff, schemaType, previewComponent: TransformPatches.StringPreview }), diffResolver = ({ schemaType }) => {
  var _a;
  if (["datetime", "date"].includes(schemaType.name))
    return TransformPatches.DatetimeFieldDiff;
  if (schemaType.name === "url")
    return UrlFieldDiff;
  if (schemaType.name === "slug")
    return SlugFieldDiff;
  if (schemaType.jsonType === "array" && Array.isArray((_a = schemaType.options) == null ? void 0 : _a.list))
    return ArrayOfOptionsFieldDiff;
};
function HoveredFieldProvider(props) {
  const { children } = props, [hoveredStack, setHoveredStack] = React.useState([]), handleMouseEnter = React.useCallback((path) => {
    const pathString = TransformPatches.pathToString(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev : [pathString, ...prev]);
  }, []), handleMouseLeave = React.useCallback((path) => {
    const pathString = TransformPatches.pathToString(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev.filter((item) => item !== pathString) : prev);
  }, []), context = React.useMemo(
    () => ({
      hoveredStack,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }),
    [handleMouseEnter, handleMouseLeave, hoveredStack]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.HoveredFieldContext.Provider, { value: context, children });
}
const EMPTY_ARRAY = [];
function trimChildPath(path, childPath) {
  return PathUtils__namespace.startsWith(path, childPath) ? PathUtils__namespace.trimLeft(path, childPath) : EMPTY_ARRAY;
}
function PresenceScope(props) {
  const { readOnly, path, children } = props, contextPresence = React.useContext(TransformPatches.FormFieldPresenceContext), childPresence = React.useMemo(() => readOnly ? EMPTY_ARRAY : (contextPresence || EMPTY_ARRAY).filter((presence) => PathUtils__namespace.startsWith(path, presence.path)).map((presence) => ({
    ...presence,
    path: trimChildPath(path, presence.path)
  })), [contextPresence, path, readOnly]);
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.FormFieldPresenceContext.Provider, { value: childPresence, children });
}
function createPatchChannel() {
  const _subscribers = [];
  return {
    publish(msg) {
      for (const subscriber of _subscribers)
        subscriber(msg);
    },
    subscribe(subscriber) {
      return _subscribers.push(subscriber), () => {
        const idx = _subscribers.indexOf(subscriber);
        idx > -1 && _subscribers.splice(idx, 1);
      };
    }
  };
}
function ArrayOfObjectsInputMember(props) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props;
  return member.kind === "item" ? /* @__PURE__ */ jsxRuntime.jsx(
    TransformPatches.ArrayOfObjectsItem,
    {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    },
    member.key
  ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.MemberItemError, { member }, member.key) : (console.warn(new Error(`Unhandled member kind ${member.kind}`)), null);
}
function ArrayOfObjectsInputMembers(props) {
  const { members, ...rest } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: members.map((member) => /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectsInputMember, { member, ...rest }, member.key)) });
}
function useReviewChanges() {
  const reviewChanges = React.useContext(TransformPatches.ReviewChangesContext);
  if (!reviewChanges)
    throw new Error("Review changes: missing context value");
  return reviewChanges;
}
const defaultRenderAnnotation = (props) => React.createElement(TransformPatches.defaultResolveAnnotationComponent(props.schemaType), props), defaultRenderBlock = (props) => React.createElement(TransformPatches.defaultResolveBlockComponent(props.schemaType), props), defaultRenderInlineBlock = (props) => React.createElement(TransformPatches.defaultResolveInlineBlockComponent(props.schemaType), props), defaultRenderField = (props) => React.createElement(TransformPatches.defaultResolveFieldComponent(props.schemaType), props), defaultRenderInput = (props) => React.createElement(TransformPatches.defaultResolveInputComponent(props.schemaType), props), defaultRenderItem = (props) => React.createElement(TransformPatches.defaultResolveItemComponent(props.schemaType), props), defaultRenderPreview = (props) => React.createElement(TransformPatches.Preview, props);
function DefaultCustomMarkers() {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
    "This is a example custom marker, please implement ",
    /* @__PURE__ */ jsxRuntime.jsx("code", { children: "renderCustomMarkers" }),
    " function."
  ] });
}
const missingPatchChannel = {
  publish: () => {
  },
  subscribe: () => (console.warn(
    "No patch channel provided to form-builder. If you need input based patch updates, please provide one"
  ), () => {
  })
};
function FormBuilderProvider(props) {
  const {
    __internal_fieldActions: fieldActions = TransformPatches.EMPTY_ARRAY,
    __internal_patchChannel: patchChannel = missingPatchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    file,
    filterField,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onFieldGroupSelect,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    unstable,
    validation
  } = props, __internal = React.useMemo(
    () => ({
      patchChannel,
      // eslint-disable-line camelcase
      components: {
        ArrayFunctions: TransformPatches.ArrayOfObjectsFunctions,
        CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers,
        Markers: (unstable == null ? void 0 : unstable.Markers) || TransformPatches.DefaultMarkers
      },
      field: {
        actions: fieldActions
      },
      file: {
        assetSources: file.assetSources,
        directUploads: (file == null ? void 0 : file.directUploads) !== !1
      },
      filterField: filterField || (() => !0),
      image: {
        assetSources: image.assetSources,
        directUploads: (image == null ? void 0 : image.directUploads) !== !1
      },
      onChange
    }),
    [
      fieldActions,
      file.assetSources,
      file == null ? void 0 : file.directUploads,
      filterField,
      image.assetSources,
      image == null ? void 0 : image.directUploads,
      onChange,
      patchChannel,
      unstable == null ? void 0 : unstable.CustomMarkers,
      unstable == null ? void 0 : unstable.Markers
    ]
  ), formBuilder = React.useMemo(
    () => ({
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType
    }),
    [
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.FormBuilderContext.Provider, { value: formBuilder, children: /* @__PURE__ */ jsxRuntime.jsx(
    TransformPatches.FormCallbacksProvider,
    {
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.DocumentIdProvider, { id, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.PresenceProvider, { presence, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.ValidationProvider, { validation, children: /* @__PURE__ */ jsxRuntime.jsx(HoveredFieldProvider, { children }) }) }) })
    }
  ) });
}
function FormProvider(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    schemaType,
    validation
  } = props, { file, image } = TransformPatches.useSource().form, Input = TransformPatches.useInputComponent(), Field = TransformPatches.useFieldComponent(), Preview = TransformPatches.usePreviewComponent(), Item = TransformPatches.useItemComponent(), Block = TransformPatches.useBlockComponent(), InlineBlock = TransformPatches.useInlineBlockComponent(), Annotation = TransformPatches.useAnnotationComponent(), renderInput = React.useCallback(
    (inputProps) => /* @__PURE__ */ jsxRuntime.jsx(Input, { ...inputProps }),
    [Input]
  ), renderField = React.useCallback(
    (fieldProps) => /* @__PURE__ */ jsxRuntime.jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(Item, { ...itemProps }),
    [Item]
  ), renderPreview = React.useCallback(
    (previewProps) => /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.PreviewLoader, { component: Preview, ...previewProps }),
    [Preview]
  ), renderBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(Block, { ...blockProps }),
    [Block]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => /* @__PURE__ */ jsxRuntime.jsx(Annotation, { ...annotationProps }),
    [Annotation]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormBuilderProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      file,
      focusPath,
      focused,
      groups,
      id,
      image,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      readOnly,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview,
      schemaType,
      validation,
      children
    }
  );
}
function FormBuilder(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    members,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    schemaType,
    validation,
    value
  } = props, handleCollapseField = React.useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !0),
    [onSetPathCollapsed]
  ), handleExpandField = React.useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !1),
    [onSetPathCollapsed]
  ), handleBlur = React.useCallback(() => onPathBlur(TransformPatches.EMPTY_ARRAY), [onPathBlur]), handleFocus = React.useCallback(() => onPathFocus(TransformPatches.EMPTY_ARRAY), [onPathFocus]), handleChange = React.useCallback(
    (patch) => onChange(TransformPatches.PatchEvent.from(patch)),
    [onChange]
  ), focusRef = React.useRef(null), handleSelectFieldGroup = React.useCallback(
    (groupName) => onFieldGroupSelect(TransformPatches.EMPTY_ARRAY, groupName),
    [onFieldGroupSelect]
  ), handleOpenField = React.useCallback((fieldName) => onPathOpen([fieldName]), [onPathOpen]), handleCloseField = React.useCallback(() => onPathOpen([]), [onPathOpen]), handleCollapseFieldSet = React.useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !0),
    [onSetFieldSetCollapsed]
  ), handleExpandFieldSet = React.useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !1),
    [onSetFieldSetCollapsed]
  ), Input = TransformPatches.useInputComponent(), Field = TransformPatches.useFieldComponent(), Preview = TransformPatches.usePreviewComponent(), Item = TransformPatches.useItemComponent(), Block = TransformPatches.useBlockComponent(), InlineBlock = TransformPatches.useInlineBlockComponent(), Annotation = TransformPatches.useAnnotationComponent(), renderInput = React.useCallback(
    (inputProps) => /* @__PURE__ */ jsxRuntime.jsx(Input, { ...inputProps }),
    [Input]
  ), renderField = React.useCallback(
    (fieldProps) => /* @__PURE__ */ jsxRuntime.jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(Item, { ...itemProps }),
    [Item]
  ), renderPreview = React.useCallback(
    (previewProps) => /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.PreviewLoader, { component: Preview, ...previewProps }),
    [Preview]
  ), renderBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(Block, { ...blockProps }),
    [Block]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => /* @__PURE__ */ jsxRuntime.jsx(Annotation, { ...annotationProps }),
    [Annotation]
  ), rootInputProps = {
    focusPath,
    elementProps: {
      ref: focusRef,
      id,
      onBlur: handleBlur,
      onFocus: handleFocus,
      "aria-describedby": void 0
      // Root input should not have any aria-describedby
    },
    changed: members.some((m) => m.kind === "field" && m.field.changed),
    focused,
    groups,
    id,
    level: 0,
    members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onPathFocus,
    onFieldOpen: handleOpenField,
    onFieldGroupSelect: handleSelectFieldGroup,
    path: TransformPatches.EMPTY_ARRAY,
    presence: TransformPatches.EMPTY_ARRAY,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation: TransformPatches.EMPTY_ARRAY,
    value
  };
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      validation,
      readOnly,
      schemaType,
      children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.GetFormValueProvider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.FormValueProvider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.DocumentFieldActionsProvider, { actions: fieldActions, children: renderInput(rootInputProps) }) }) })
    }
  );
}
const remoteSnapshots = TransformPatches.memoize(
  (client2, idPair, typeName) => TransformPatches.memoizedPair(client2, idPair, typeName).pipe(
    operators.switchMap(({ published, draft }) => rxjs.merge(published.remoteSnapshot$, draft.remoteSnapshot$))
  ),
  TransformPatches.memoizeKeyGen
);
function maybeSerialize(template) {
  return TransformPatches.isBuilder(template) ? template.serialize() : template;
}
function isNonNullable(t) {
  return !!t;
}
function prepareTemplates(schema, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return TransformPatches.validateTemplates(schema, serialized);
}
function defaultTemplateForType(schemaType) {
  return {
    id: schemaType.name,
    schemaType: schemaType.name,
    title: schemaType.title || schemaType.name,
    icon: schemaType.icon,
    value: schemaType.initialValue || { _type: schemaType.name }
  };
}
function defaultTemplatesForSchema(schema) {
  const schemaTypes = schema.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema.get(typeName)).filter(isNonNullable).filter((schemaType) => {
    var _a;
    return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
  });
  return prepareTemplates(
    schema,
    schemaTypes.map((schemaType) => defaultTemplateForType(schemaType))
  );
}
const LOADING_STATE = {
  isLoaded: !1,
  documentType: void 0
};
function useDocumentType(documentId, specifiedType = "*") {
  const documentStore = TransformPatches.useDocumentStore(), publishedId = TransformPatches.getPublishedId(documentId), isResolved = !!(specifiedType && specifiedType !== "*"), SYNC_RESOLVED_STATE = React.useMemo(
    () => ({ documentType: specifiedType, isLoaded: !0 }),
    [specifiedType]
  ), [resolvedState, setDocumentType] = React.useState(
    isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE
  );
  return React.useEffect(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]), React.useEffect(() => {
    if (isResolved)
      return;
    const sub = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe((documentType) => setDocumentType({ documentType, isLoaded: !0 }));
    return () => sub.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]), isResolved ? (
    // `isResolved` is only true when we're _synchronously_ resolved
    SYNC_RESOLVED_STATE
  ) : (
    // Using the document type resolved from the API
    resolvedState
  );
}
function useTimelineSelector(timelineStore, selector) {
  return withSelector.useSyncExternalStoreWithSelector(
    timelineStore.subscribe,
    timelineStore.getSnapshot,
    null,
    selector
  );
}
const INITIAL_TIMELINE_STATE = {
  chunks: [],
  diff: null,
  hasMoreChunks: null,
  isLoading: !1,
  isPristine: null,
  lastNonDeletedRevId: null,
  onOlderRevision: !1,
  realRevChunk: null,
  revTime: null,
  selectionState: "inactive",
  sinceAttributes: null,
  sinceTime: null,
  timelineDisplayed: null,
  timelineReady: !1
};
function useTimelineStore({
  documentId,
  documentType,
  onError,
  rev,
  since
}) {
  const historyStore = TransformPatches.useHistoryStore(), snapshotsSubscriptionRef = React.useRef(null), timelineStateRef = React.useRef(INITIAL_TIMELINE_STATE), client2 = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS), controller = React.useMemo(
    () => historyStore.getTimelineController({
      client: client2,
      documentId,
      documentType
    }),
    [client2, documentId, documentType, historyStore]
  ), timelineController$ = React.useMemo(
    () => new rxjs.BehaviorSubject(controller),
    [controller]
  );
  return React.useEffect(() => (controller.setRange(since || null, rev || null), timelineController$.next(controller), controller.handler = (err, innerController) => {
    err ? timelineController$.error(err) : setTimeout(() => {
      innerController.setRange(since || null, rev || null), timelineController$.next(innerController);
    }, 0);
  }, controller.resume(), () => controller.suspend()), [rev, since, controller, timelineController$]), React.useEffect(() => (snapshotsSubscriptionRef.current || (snapshotsSubscriptionRef.current = remoteSnapshots(
    client2,
    { draftId: `drafts.${documentId}`, publishedId: documentId },
    documentType
  ).subscribe((ev) => {
    controller.handleRemoteMutation(ev);
  })), () => {
    snapshotsSubscriptionRef.current && (snapshotsSubscriptionRef.current.unsubscribe(), snapshotsSubscriptionRef.current = null);
  }), [client2, controller, documentId, documentType]), React.useMemo(() => ({
    findRangeForRev: (chunk) => controller.findRangeForNewRev(chunk),
    findRangeForSince: (chunk) => controller.findRangeForNewSince(chunk),
    loadMore: () => {
      controller.setLoadMore(!0), timelineStateRef.current.isLoading = !0;
    },
    getSnapshot: () => timelineStateRef.current,
    subscribe: (callback) => {
      const subscription = timelineController$.pipe(
        // Manually stop loading transactions in TimelineController, otherwise transaction history
        // will continue to be fetched – even if unwanted.
        rxjs.tap((innerController) => innerController.setLoadMore(!1)),
        rxjs.map((innerController) => {
          var _a;
          const chunks = innerController.timeline.mapChunks((c) => c), lastNonDeletedChunk = chunks.filter(
            (chunk) => !["delete", "initial"].includes(chunk.type)
          ), hasMoreChunks = !innerController.timeline.reachedEarliestEntry, timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return {
            chunks,
            diff: innerController.sinceTime ? innerController.currentObjectDiff() : null,
            isLoading: !1,
            isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === !1 : null,
            hasMoreChunks: !innerController.timeline.reachedEarliestEntry,
            lastNonDeletedRevId: (_a = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a.id,
            onOlderRevision: innerController.onOlderRevision(),
            realRevChunk: innerController.realRevChunk,
            revTime: innerController.revTime,
            selectionState: innerController.selectionState,
            sinceAttributes: innerController.sinceAttributes(),
            sinceTime: innerController.sinceTime,
            timelineDisplayed: innerController.displayed(),
            timelineReady
          };
        }),
        // Only emit (and in turn, re-render) when values have changed
        rxjs.distinctUntilChanged(deepCompare__default.default),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        rxjs.catchError((err) => (onError == null || onError(err), rxjs.of(INITIAL_TIMELINE_STATE))),
        rxjs.tap((timelineState) => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        rxjs.tap(callback)
      ).subscribe();
      return () => subscription.unsubscribe();
    }
  }), [controller, onError, timelineController$]);
}
function useProject() {
  const projectStore = TransformPatches.useProjectStore(), [value, setValue] = React.useState(null);
  return React.useEffect(() => {
    const sub = projectStore.get().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function useProjectDatasets() {
  const projectStore = TransformPatches.useProjectStore(), [value, setValue] = React.useState(null);
  return React.useEffect(() => {
    const sub = projectStore.getDatasets().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function resolveConfig(config) {
  const { workspaces } = TransformPatches.prepareConfig(config);
  return rxjs.combineLatest(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workspaces.flatMap(
      (workspaceSummary) => rxjs.combineLatest(workspaceSummary.__internal.sources.map(({ source }) => source)).pipe(
        operators.map(
          (sources) => ({
            ...workspaceSummary,
            ...sources[0],
            unstable_sources: sources,
            type: "workspace"
          })
        )
      )
    )
  );
}
async function createWorkspaceFromConfig(options) {
  const client2 = "getClient" in options ? options.getClient({ apiVersion: "2023-11-13" }) : void 0, [workspace] = await rxjs.firstValueFrom(
    resolveConfig({
      ...options,
      ...client2 && "currentUser" in options && {
        auth: createMockAuthStore({ ...options, client: client2 })
      }
    })
  );
  return workspace;
}
async function createSourceFromConfig(options) {
  return (await createWorkspaceFromConfig(options)).unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const { projectId, dataset, schema, currentUser, getClient, i18n } = source;
  return React.useMemo(() => ({ projectId, dataset, schema, currentUser, getClient, i18n }), [projectId, dataset, schema, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const { projectId, dataset, schema, currentUser, getClient, i18n } = source;
  return { projectId, dataset, schema, currentUser, getClient, i18n };
}
const API_VERSION = "v2023-11-13";
function AddonDatasetProvider(props) {
  const { children } = props, { dataset, projectId } = TransformPatches.useWorkspace(), originalClient = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS), [addonDatasetClient, setAddonDatasetClient] = React.useState(null), [isCreatingDataset, setIsCreatingDataset] = React.useState(!1), [ready, setReady] = React.useState(!1), getAddonDatasetName = React.useCallback(async () => {
    var _a;
    const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
      uri: `/projects/${projectId}/datasets?datasetProfile=comments&addonFor=${dataset}`,
      tag: "sanity.studio"
    });
    return (_a = res == null ? void 0 : res[0]) == null ? void 0 : _a.name;
  }, [dataset, originalClient, projectId]), handleCreateClient = React.useCallback(
    (addonDatasetName) => originalClient.withConfig({
      apiVersion: API_VERSION,
      dataset: addonDatasetName,
      projectId,
      requestTagPrefix: "sanity.studio",
      useCdn: !1,
      withCredentials: !0
    }),
    [originalClient, projectId]
  ), handleCreateAddonDataset = React.useCallback(async () => {
    setIsCreatingDataset(!0);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client2 = handleCreateClient(addonDatasetName);
        return setAddonDatasetClient(client2), setIsCreatingDataset(!1), client2;
      }
    } catch {
    }
    try {
      const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
        uri: `/comments/${dataset}/setup`,
        method: "POST"
      }), datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName)
        return setIsCreatingDataset(!1), null;
      const client2 = handleCreateClient(datasetName);
      return setAddonDatasetClient(client2), client2;
    } catch (err) {
      throw err;
    } finally {
      setIsCreatingDataset(!1);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  React.useEffect(() => {
    getAddonDatasetName().then((addonDatasetName) => {
      if (!addonDatasetName)
        return;
      const client2 = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client2);
    }).finally(() => {
      setReady(!0);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = React.useMemo(
    () => ({
      client: addonDatasetClient,
      createAddonDataset: handleCreateAddonDataset,
      isCreatingDataset,
      ready
    }),
    [addonDatasetClient, handleCreateAddonDataset, isCreatingDataset, ready]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.AddonDatasetContext.Provider, { value: ctxValue, children });
}
function useAddonDataset() {
  const ctx = React.useContext(TransformPatches.AddonDatasetContext);
  if (!ctx)
    throw new Error("useAddonDataset: missing context value");
  return ctx;
}
function StudioLogo(props) {
  const { title } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, "data-testid": "studio-logo", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: title }) });
}
function _buildTints(bg, mid, fg) {
  return {
    50: polished.mix(0.1, mid, bg),
    100: polished.mix(0.2, mid, bg),
    200: polished.mix(0.4, mid, bg),
    300: polished.mix(0.6, mid, bg),
    400: polished.mix(0.8, mid, bg),
    500: mid,
    600: polished.mix(0.8, mid, fg),
    700: polished.mix(0.6, mid, fg),
    800: polished.mix(0.4, mid, fg),
    900: polished.mix(0.2, mid, fg),
    950: polished.mix(0.1, mid, fg)
  };
}
function _toHex(color2) {
  const { red, green, blue } = polished.parseToRgb(color2);
  return polished.rgb(red, green, blue);
}
function _isDark(bg, fg) {
  return polished.getLuminance(bg) < polished.getLuminance(fg);
}
function _multiply(bg, fg) {
  const b = theme.parseColor(bg), s = theme.parseColor(fg);
  return theme.rgbToHex(theme.multiply(b, s));
}
function _screen(bg, fg) {
  const b = theme.parseColor(bg), s = theme.parseColor(fg);
  return theme.rgbToHex(theme.screen(b, s));
}
const NEUTRAL_TONES = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return theme.createColorTheme({
    base: ({ dark: navbar, name }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, dark = stateTones.dark, blend = navbar ? _screen : _multiply, tints = stateTones[name] || stateTones.default;
      if (name === "default") {
        const skeletonFrom2 = stateTones.default[100];
        return {
          fg: stateTones.fg,
          bg: stateTones.bg,
          border: stateTones.default[200],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(stateTones.default[500], 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (name === "transparent") {
        const bg2 = tints[50], skeletonFrom2 = blend(bg2, tints[100]);
        return {
          fg: tints[900],
          bg: bg2,
          border: tints[300],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = tints[50], skeletonFrom = blend(bg, tints[100]);
      return {
        fg: tints[900],
        bg,
        border: tints[200],
        focusRing: tints[500],
        shadow: {
          outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
          umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
          penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
          ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    solid: ({ base, dark: navbar, name, state, tone }) => {
      const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default, dark = buttonTones.dark, blend = dark ? _screen : _multiply, blendInvert = dark ? _multiply : _screen, defaultTints = buttonTones[name] || buttonTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = blend(base.bg, tints[200]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[200]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[50])
          },
          accent: {
            fg: blend(base.bg, tints[50])
          },
          link: {
            fg: blend(base.bg, tints[50])
          },
          code: {
            bg: bg2,
            fg: blend(base.bg, tints[50])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[600]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[600]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        const bg2 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = buttonTones.primary);
        const bg2 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = blend(base.bg, tints[500]), skeletonFrom = blendInvert(bg, tints[800]);
      return {
        bg,
        border: blend(base.bg, tints[500]),
        fg: blend(base.bg, buttonTones.bg),
        icon: blend(base.bg, buttonTones.bg),
        muted: {
          fg: blend(base.bg, tints[100])
        },
        accent: {
          fg: blendInvert(bg, buttonTones.critical[200])
        },
        link: {
          fg: blendInvert(bg, buttonTones.primary[100])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(base.bg, tints[100])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    muted: ({ base, dark: navbar, name, state, tone }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, defaultTints = stateTones[name] || stateTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = base.bg, skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[200]),
          icon: blend(base.bg, tints[200]),
          muted: {
            fg: blend(bg2, tints[100])
          },
          accent: {
            fg: blend(bg2, tints[100])
          },
          link: {
            fg: blend(bg2, tints[100])
          },
          code: {
            bg: bg2,
            fg: blend(bg2, tints[100])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[50]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[900]),
          icon: blend(base.bg, tints[900]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(base.bg, stateTones.critical[500])
          },
          link: {
            fg: blend(base.bg, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        isNeutral && (tints = stateTones.primary);
        const bg2 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[800]),
          icon: blend(base.bg, tints[800]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = stateTones.primary);
        const bg2 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(bg2, tints[800]),
          icon: blend(bg2, tints[800]),
          muted: {
            fg: blend(bg2, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = base.bg, skeletonFrom = blend(base.bg, tints[100]);
      return {
        bg,
        border: blend(bg, tints[100]),
        fg: blend(bg, tints[700]),
        icon: blend(bg, tints[700]),
        muted: {
          fg: blend(bg, tints[600])
        },
        accent: {
          fg: blend(bg, stateTones.critical[500])
        },
        link: {
          fg: blend(bg, stateTones.primary[600])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(bg, tints[600])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    button: ({ base, mode, muted, solid }) => mode === "bleed" ? {
      enabled: {
        ...muted.enabled,
        border: muted.enabled.bg
      },
      hovered: {
        ...muted.hovered,
        border: muted.hovered.bg
      },
      pressed: {
        ...muted.pressed,
        border: muted.pressed.bg
      },
      selected: {
        ...muted.selected,
        border: muted.selected.bg
      },
      disabled: {
        ...muted.disabled,
        border: muted.disabled.bg
      }
    } : mode === "ghost" ? {
      ...solid,
      enabled: {
        ...muted.enabled,
        border: base.border
      },
      disabled: muted.disabled
    } : solid,
    card: ({ base, dark: navbar, muted, name, solid, state }) => {
      if (state === "hovered")
        return muted[name].hovered;
      if (state === "disabled")
        return muted[name].disabled;
      const isNeutral = NEUTRAL_TONES.includes(name), stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, tints = stateTones[name] || stateTones.default, dark = stateTones.dark, blend = dark ? _screen : _multiply;
      if (state === "pressed")
        return isNeutral ? muted.primary.pressed : muted[name].pressed;
      if (state === "selected")
        return isNeutral ? solid.primary.enabled : solid[name].enabled;
      const bg = base.bg, skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
      return {
        bg,
        fg: base.fg,
        icon: base.fg,
        border: base.border,
        muted: {
          fg: blend(base.bg, tints[dark ? 400 : 600])
        },
        accent: {
          fg: blend(base.bg, stateTones.critical[dark ? 400 : 500])
        },
        link: {
          fg: blend(base.bg, stateTones.primary[dark ? 400 : 600])
        },
        code: {
          bg: blend(base.bg, tints[dark ? 950 : 50]),
          fg: tints[dark ? 400 : 600]
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    input: ({ base, dark: navbar, mode, state }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply;
      if (mode === "invalid") {
        const tints = stateTones.critical;
        return {
          bg: blend(base.bg, tints[50]),
          bg2: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[700]),
          border: blend(base.bg, tints[200]),
          placeholder: blend(base.bg, tints[400])
        };
      }
      return state === "hovered" ? {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: blend(base.bg, color.hues.gray[300].hex),
        placeholder: blend(base.bg, color.hues.gray[400].hex)
      } : state === "disabled" ? {
        bg: blend(base.bg, color.hues.gray[50].hex),
        bg2: blend(base.bg, color.hues.gray[50].hex),
        fg: blend(base.bg, color.hues.gray[200].hex),
        border: blend(base.bg, color.hues.gray[100].hex),
        placeholder: blend(base.bg, color.hues.gray[100].hex)
      } : state === "readOnly" ? {
        bg: blend(base.bg, color.hues.gray[50].hex),
        bg2: blend(base.bg, color.hues.gray[50].hex),
        fg: blend(base.bg, color.hues.gray[800].hex),
        border: blend(base.bg, color.hues.gray[200].hex),
        placeholder: blend(base.bg, color.hues.gray[400].hex)
      } : {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: base.border,
        placeholder: blend(base.bg, color.hues.gray[700].hex)
      };
    },
    selectable: ({ base, muted, tone, solid, state }) => state === "enabled" ? {
      ...muted[tone].enabled,
      bg: base.bg
    } : state === "pressed" ? tone === "default" ? muted.primary.pressed : muted[tone].pressed : state === "selected" ? tone === "default" ? solid.primary.enabled : solid[tone].enabled : state === "disabled" ? {
      ...muted[tone].disabled,
      bg: base.bg
    } : muted[tone][state],
    spot: ({ base, key }) => {
      const dark = _isDark(base.bg, base.fg);
      return (dark ? _screen : _multiply)(base.bg, color.hues[key][dark ? 400 : 500].hex);
    },
    syntax: ({ base, dark: navbar }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, mainShade = 600, secondaryShade = 400;
      return {
        atrule: blend(base.bg, color.hues.purple[mainShade].hex),
        attrName: blend(base.bg, stateTones.positive[mainShade]),
        attrValue: blend(base.bg, stateTones.caution[mainShade]),
        attribute: blend(base.bg, stateTones.caution[mainShade]),
        boolean: blend(base.bg, color.hues.purple[mainShade].hex),
        builtin: blend(base.bg, color.hues.purple[mainShade].hex),
        cdata: blend(base.bg, stateTones.caution[mainShade]),
        char: blend(base.bg, stateTones.caution[mainShade]),
        class: blend(base.bg, color.hues.orange[mainShade].hex),
        className: blend(base.bg, color.hues.cyan[mainShade].hex),
        comment: blend(base.bg, stateTones.default[secondaryShade]),
        constant: blend(base.bg, color.hues.purple[mainShade].hex),
        deleted: blend(base.bg, stateTones.critical[mainShade]),
        doctype: blend(base.bg, stateTones.default[secondaryShade]),
        entity: blend(base.bg, stateTones.critical[mainShade]),
        function: blend(base.bg, stateTones.positive[mainShade]),
        hexcode: blend(base.bg, stateTones.primary[mainShade]),
        id: blend(base.bg, color.hues.purple[mainShade].hex),
        important: blend(base.bg, color.hues.purple[mainShade].hex),
        inserted: blend(base.bg, stateTones.caution[mainShade]),
        keyword: blend(base.bg, color.hues.magenta[mainShade].hex),
        number: blend(base.bg, color.hues.purple[mainShade].hex),
        operator: blend(base.bg, color.hues.magenta[mainShade].hex),
        prolog: blend(base.bg, stateTones.default[secondaryShade]),
        property: blend(base.bg, stateTones.primary[mainShade]),
        pseudoClass: blend(base.bg, stateTones.caution[mainShade]),
        pseudoElement: blend(base.bg, stateTones.caution[mainShade]),
        punctuation: blend(base.bg, stateTones.default[mainShade]),
        regex: blend(base.bg, stateTones.primary[mainShade]),
        selector: blend(base.bg, stateTones.critical[mainShade]),
        string: blend(base.bg, stateTones.caution[mainShade]),
        symbol: blend(base.bg, color.hues.purple[mainShade].hex),
        tag: blend(base.bg, stateTones.critical[mainShade]),
        unit: blend(base.bg, color.hues.orange[mainShade].hex),
        url: blend(base.bg, stateTones.critical[mainShade]),
        variable: blend(base.bg, stateTones.critical[mainShade])
      };
    }
  });
}
function buildFonts(cssCustomProperties) {
  return {
    ...ui.studioTheme.fonts,
    code: {
      ...ui.studioTheme.fonts.code,
      family: cssCustomProperties["--font-family-monospace"] || ui.studioTheme.fonts.code.family
    },
    heading: {
      ...ui.studioTheme.fonts.heading,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    label: {
      ...ui.studioTheme.fonts.label,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    text: {
      ...ui.studioTheme.fonts.text,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    }
  };
}
function buildLegacyPalette(cssCustomProperties) {
  return {
    black: _toHex(cssCustomProperties["--black"]),
    component: {
      bg: _toHex(cssCustomProperties["--component-bg"]),
      fg: _toHex(cssCustomProperties["--component-text-color"])
    },
    defaultButton: {
      default: {
        base: _toHex(cssCustomProperties["--default-button-color"])
      },
      primary: {
        base: _toHex(cssCustomProperties["--default-button-primary-color"])
      },
      success: {
        base: _toHex(cssCustomProperties["--default-button-success-color"])
      },
      warning: {
        base: _toHex(cssCustomProperties["--default-button-warning-color"])
      },
      danger: {
        base: _toHex(cssCustomProperties["--default-button-danger-color"])
      }
    },
    focus: {
      base: _toHex(cssCustomProperties["--focus-color"])
    },
    gray: {
      base: _toHex(cssCustomProperties["--gray-base"])
    },
    mainNavigation: {
      bg: _toHex(cssCustomProperties["--main-navigation-color"]),
      fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"])
    },
    state: {
      info: {
        fg: _toHex(cssCustomProperties["--state-info-color"])
      },
      success: {
        fg: _toHex(cssCustomProperties["--state-success-color"])
      },
      warning: {
        fg: _toHex(cssCustomProperties["--state-warning-color"])
      },
      danger: {
        fg: _toHex(cssCustomProperties["--state-danger-color"])
      }
    }
  };
}
function buildLegacyTones(legacyPalette) {
  return {
    state: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.info.fg,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.success.fg,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.info.fg,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.success.fg,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.mainNavigation.fg
        )
      }
    },
    button: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.mainNavigation.fg
        )
      }
    }
  };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme), legacyPalette = buildLegacyPalette(legacyTheme), legacyTones = buildLegacyTones(legacyPalette), color2 = buildColor(legacyPalette, legacyTones), fonts = buildFonts(legacyTheme);
  return {
    __dark: _isDark(color2.light.default.base.bg, color2.light.default.base.fg),
    __legacy: !0,
    color: color2,
    fonts
  };
}
const defaultCustomProperties = {
  "--font-family-monospace": ui.studioTheme.fonts.code.family,
  "--font-family-base": ui.studioTheme.fonts.text.family,
  "--black": color.black.hex,
  "--white": color.white.hex,
  // Brand
  "--brand-primary": color.blue[500].hex,
  // Component
  "--component-bg": color.white.hex,
  "--component-text-color": color.black.hex,
  // Gray
  "--gray": color.gray[500].hex,
  "--gray-base": color.gray[500].hex,
  // Default button
  "--default-button-color": color.gray[500].hex,
  "--default-button-danger-color": color.red[500].hex,
  "--default-button-primary-color": color.blue[500].hex,
  "--default-button-success-color": color.green[500].hex,
  "--default-button-warning-color": color.yellow[500].hex,
  // Focus
  "--focus-color": color.blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": color.blue[500].hex,
  "--state-success-color": color.green[500].hex,
  "--state-warning-color": color.yellow[500].hex,
  "--state-danger-color": color.red[500].hex,
  // Navbar
  "--main-navigation-color": color.black.hex,
  "--main-navigation-color--inverted": color.white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props = {
    ...defaultCustomProperties,
    ...legacyTheme
  };
  return props["--focus-color"] = legacyTheme["--focus-color"] || props["--brand-primary"], props["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props["--brand-primary"], props["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props["--black"], props["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props["--white"], props["--state-info-color"] = legacyTheme["--brand-primary"] || props["--brand-primary"], props;
}
function Studio(props) {
  const {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_globalStyles: globalStyles2,
    unstable_history,
    unstable_noAuthBoundary
  } = props;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    TransformPatches.StudioProvider,
    {
      basePath,
      config,
      onSchemeChange,
      scheme,
      unstable_history,
      unstable_noAuthBoundary,
      children: [
        globalStyles2 && /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.GlobalStyle, {}),
        /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.StudioLayout, {})
      ]
    }
  );
}
function renderStudio(rootElement, config, options = !1) {
  if (!rootElement)
    throw new Error("Missing root element to mount application into");
  const opts = typeof options == "boolean" ? { reactStrictMode: options } : options, { reactStrictMode = !1, basePath } = opts, root = client.createRoot(rootElement);
  return root.render(
    reactStrictMode ? /* @__PURE__ */ jsxRuntime.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntime.jsx(Studio, { config, basePath, unstable_globalStyles: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsx(Studio, { config, basePath, unstable_globalStyles: !0 })
  ), () => root.unmount();
}
const INITIAL$1 = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(
      operators.map((ev) => ev.type),
      operators.map((eventType) => eventType !== "reconnect"),
      operators.switchMap(
        (isConnected) => isConnected ? rxjs.of("connected") : rxjs.timer(200).pipe(operators.mapTo("reconnecting"))
      ),
      operators.startWith(INITIAL$1),
      operators.distinctUntilChanged()
    ),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL$1
  );
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.operationEvents(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName]
  );
}
function useEditState(publishedDocId, docTypeName, priority = "default") {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => {
    if (priority === "low") {
      const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(rxjs.share());
      return rxjs.merge(
        base.pipe(rxjs.take(1)),
        base.pipe(
          rxjs.skip(1),
          rxjs.debounce(() => rxjs.timer(1e3))
        )
      );
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
const PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const { style = "short", resolution = "seconds" } = options || {}, unitDisplay = style, locale = getJsonStream.useCurrentLocale().id, listFormat = TransformPatches.useListFormat({ type: "unit", style }), isNegative = durationMs < 0, duration = parseMilliseconds(Math.abs(durationMs)), formatters = React.useMemo(
    () => ({
      days: TransformPatches.intlCache.numberFormat(locale, { style: "unit", unit: "day", unitDisplay }),
      hours: TransformPatches.intlCache.numberFormat(locale, { style: "unit", unit: "hour", unitDisplay }),
      minutes: TransformPatches.intlCache.numberFormat(locale, { style: "unit", unit: "minute", unitDisplay }),
      seconds: TransformPatches.intlCache.numberFormat(locale, { style: "unit", unit: "second", unitDisplay }),
      milliseconds: TransformPatches.intlCache.numberFormat(locale, {
        style: "unit",
        unit: "millisecond",
        unitDisplay
      })
    }),
    [locale, unitDisplay]
  ), parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds")
      continue;
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push(`${prefix}${formatters[period].format(value)}`);
  }
  const formatted = parts.length === 0 ? (
    // If passing duration 0, we still want to show something
    formatters[resolution].format(0)
  ) : (
    // Usually, we want to join the parts with the locales list formatter
    listFormat.format(parts)
  ), iso8601 = durationToISO8601(duration, isNegative);
  return { formatted, iso8601 };
}
function parseMilliseconds(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5) % 24,
    minutes: Math.trunc(milliseconds / 6e4) % 60,
    seconds: Math.trunc(milliseconds / 1e3) % 60,
    milliseconds: Math.trunc(milliseconds) % 1e3
  };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? `${dur.days}D` : "";
  let time = "";
  if (dur.hours && (time += `${dur.hours}H`), dur.minutes && (time += `${dur.minutes}M`), dur.milliseconds ? time += `${((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3)}S` : dur.seconds && (time += `${dur.seconds}S`), !date && !time)
    return "PT0S";
  const duration = `P${(time ? [date, time] : [date]).join("T")}`;
  return isNegative ? `-${duration}` : duration;
}
function useNumberFormat(options = {}) {
  const currentLocale = getJsonStream.useCurrentLocale().id;
  return TransformPatches.intlCache.numberFormat(currentLocale, options);
}
const SYNCING = { isSyncing: !0 }, NOT_SYNCING = { isSyncing: !1 };
function useSyncState(publishedDocId, documentType) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(operators.map((isConsistent) => isConsistent ? NOT_SYNCING : SYNCING)),
    [documentStore.pair, documentType, publishedDocId],
    NOT_SYNCING
  );
}
function useTimeAgo(time, options = {}) {
  return TransformPatches.useRelativeTime(time, {
    minimal: options.minimal,
    useTemporalPhrase: options.agoSuffix
  });
}
function useTools() {
  return TransformPatches.useSource().tools;
}
const INITIAL_STATE = {
  data: [],
  error: null,
  loading: !0
};
let cachedSystemGroups = null;
function useUserListWithPermissions(opts) {
  const { documentValue, permission } = opts, projectStore = TransformPatches.useProjectStore(), userStore = TransformPatches.useUserStore(), client2 = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS), [state, setState] = React.useState(INITIAL_STATE), list$ = React.useMemo(() => {
    const users$ = projectStore.get().pipe(rxjs.map((res) => {
      var _a;
      return (_a = res.members) == null ? void 0 : _a.filter((m) => !m.isRobot);
    })).pipe(
      rxjs.switchMap(async (members) => {
        const ids = members.map(({ id }) => id);
        return await userStore.getUsers(ids);
      }),
      rxjs.map(
        (res) => res.map((user) => ({
          displayName: user.displayName,
          id: user.id,
          granted: !1
        }))
      )
    ), cached = cachedSystemGroups, systemGroup$ = cached ? rxjs.of(cached) : client2.observable.fetch('*[_type == "system.group"]');
    return rxjs.forkJoin([users$, systemGroup$]).pipe(
      rxjs.mergeMap(async ([users, groups]) => {
        cached || (cachedSystemGroups = groups);
        const grantPromises = users == null ? void 0 : users.map(async (user) => {
          const flattenedGrants = [...groups.map((group) => group.members.includes(user.id) ? group.grants : [])].flat(), { granted } = await TransformPatches.grantsPermissionOn(
            user.id,
            flattenedGrants,
            permission,
            documentValue
          );
          return {
            ...user,
            granted
          };
        });
        return await Promise.all(grantPromises || []);
      })
    ).pipe(
      rxjs.map((res) => ({
        error: null,
        loading: !1,
        data: sortBy__default.default(res, "displayName")
      }))
    );
  }, [client2.observable, documentValue, projectStore, userStore, permission]);
  return React.useEffect(() => {
    const initial$ = rxjs.of(INITIAL_STATE), sub = rxjs.concat(initial$, list$).subscribe({
      next: setState,
      error: (error) => {
        setState({ data: [], error, loading: !1 });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [list$]), state;
}
const INITIAL = { validation: [], isValidating: !1 };
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.validation(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL
  );
}
const actionIds = /* @__PURE__ */ new WeakMap();
let counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId)
    return cachedId;
  const id = `${actionHook.name || actionHook.displayName || "<anonymous>"}-${counter++}`;
  return actionIds.set(actionHook, id), id;
}
const requestIdleCallbackShim = (callback) => {
  const start = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: !1,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 1);
}, cancelIdleCallbackShim = (handle) => clearTimeout(handle), _requestIdleCallback = typeof requestIdleCallback > "u" ? requestIdleCallbackShim : requestIdleCallback, _cancelIdleCallback = typeof cancelIdleCallback > "u" ? cancelIdleCallbackShim : cancelIdleCallback, throttleOptions = { trailing: !0 };
function GetHookCollectionState(props) {
  const { hooks, args, children, group, onReset } = props, statesRef = React.useRef({}), [tickId, setTick] = React.useState(0), [keys, setKeys] = React.useState({}), ricHandle = React.useRef(null), handleRequestUpdate = React.useCallback(() => {
    ricHandle.current && _cancelIdleCallback(ricHandle.current), ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null, setTick((tick) => tick + 1);
    });
  }, []), handleRequestUpdateThrottled = useThrottledCallback(
    handleRequestUpdate,
    60,
    throttleOptions
  ), handleNext = React.useCallback(
    (id, hookState) => {
      const hookGroup = (hookState == null ? void 0 : hookState.group) || ["default"];
      if (hookState === null || group && !hookGroup.includes(group))
        delete statesRef.current[id];
      else {
        const current = statesRef.current[id];
        statesRef.current[id] = { ...current, value: hookState };
      }
    },
    [group]
  ), handleReset = React.useCallback(
    (id) => {
      setKeys((currentKeys) => ({ ...currentKeys, [id]: (currentKeys[id] || 0) + 1 })), onReset && onReset();
    },
    [onReset]
  ), hookIds = React.useMemo(() => hooks.map((hook) => getHookId(hook)), [hooks]), states = React.useMemo(
    () => hookIds.map((id) => {
      var _a;
      return (_a = statesRef.current[id]) == null ? void 0 : _a.value;
    }).filter(TransformPatches.isNonNullable),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
    [hookIds, tickId]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    hooks.map((hook) => {
      const id = getHookId(hook), key = keys[id] || 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        TransformPatches.HookStateContainer,
        {
          hook,
          id,
          args,
          onNext: handleNext,
          onRequestUpdate: handleRequestUpdateThrottled,
          onReset: handleReset
        },
        `${id}-${key}`
      );
    }),
    children({ states })
  ] });
}
function Hotkeys({ makePlatformAware = !0, keys: hotKeys = [], ...props }) {
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Hotkeys, { ...props, keys });
}
const IS_APPLE_DEVICE = typeof navigator > "u" || typeof navigator.platform != "string" ? !1 : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key) {
  const lowerKey = key.toLowerCase();
  return lowerKey === "alt" && IS_APPLE_DEVICE ? matchCase(key, "option") : lowerKey === "option" && !IS_APPLE_DEVICE ? matchCase(key, "alt") : key;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char);
}
function IntentButton(props) {
  return props.disabled ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { ...props, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { ...props, as: router.IntentLink });
}
function RelativeTime({ time, ...options }) {
  const timestamp = time instanceof Date ? time : new Date(time), timeAgo = TransformPatches.useRelativeTime(timestamp, options);
  return /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: timestamp.toISOString(), title: timeAgo, children: timeAgo });
}
function WithReferringDocuments({
  children,
  id
}) {
  return children(TransformPatches.useReferringDocuments(id));
}
function ZIndexProvider({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches.ZIndexContext.Provider, { value: TransformPatches.defaults, children });
}
function TelephoneInput(props) {
  const { schemaType, validationError, value, elementProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      type: "tel",
      inputMode: "tel",
      customValidity: validationError,
      value: value || "",
      placeholder: schemaType.placeholder,
      ...elementProps
    }
  );
}
function resolveConditionalProperty(property, context) {
  const { currentUser, document, parent, value } = context;
  return typeof property == "boolean" || property === void 0 ? !!property : property({
    document,
    parent,
    value,
    currentUser
  }) === !0;
}
function setAtPath(currentTree, path, value) {
  var _a;
  if (path.length === 0)
    return { ...currentTree || {}, value };
  const [head, ...tail] = path, key = types.isKeySegment(head) ? head._key : String(head), children = (_a = currentTree == null ? void 0 : currentTree.children) != null ? _a : {};
  return {
    value: currentTree == null ? void 0 : currentTree.value,
    children: { ...children, [key]: setAtPath(children[key] || {}, tail, value) }
  };
}
const MAX_FIELD_DEPTH = 20, AUTO_COLLAPSE_DEPTH = 3, ALL_FIELDS_GROUP = {
  name: "all-fields",
  title: "All fields",
  hidden: !1
};
function getCollapsedWithDefaults(options = {}, level) {
  if ((options == null ? void 0 : options.collapsible) === !1 || (options == null ? void 0 : options.collapsable) === !1)
    return { collapsible: !1, collapsed: !1 };
  const collapsed = (
    // eslint-disable-next-line no-nested-ternary
    typeof (options == null ? void 0 : options.collapsed) == "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? !0 : void 0
  );
  return {
    collapsible: (options == null ? void 0 : options.collapsible) === !0 || (options == null ? void 0 : options.collapsable) === !0 || collapsed === !0 ? !0 : void 0,
    collapsed
  };
}
function getItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return arrayType == null ? void 0 : arrayType.of.find(
    (memberType) => memberType.name === itemTypeName || memberType.jsonType === itemTypeName
  );
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  return selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : fieldGroup === void 0 ? !1 : groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : castArray__default.default(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value > "u" || TransformPatches.isRecord(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every((item) => TransformPatches.isRecord(item));
}
function findDuplicateKeyEntries(array) {
  const seenKeys = /* @__PURE__ */ new Set();
  return array.reduce((acc, item, index) => (seenKeys.has(item._key) && acc.push([index, item._key]), seenKeys.add(item._key), acc), []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array) {
  return array == null ? void 0 : array.every((item) => TransformPatches.isRecord(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  return Array.isArray(value) && typeof comparisonValue > "u" || Array.isArray(comparisonValue) && typeof value > "u" ? !1 : value && !comparisonValue ? !0 : !isEqual__default.default(value, comparisonValue);
}
function prepareFieldMember(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const { parent, field, index } = props, fieldPath = PathUtils.pathFor([...parent.path, field.name]), fieldLevel = TransformPatches.getFieldLevel(field.type, parent.level + 1), parentValue = parent.value, parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue))
    throw new Error("Unexpected non-object value");
  const normalizedFieldGroupNames = field.group ? castArray__default.default(field.group) : [], inSelectedGroup = isFieldEnabledByGroupFilter(
    parent.groups,
    field.group,
    parent.selectedGroup
  );
  if (types.isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue))
      return {
        kind: "error",
        key: field.name,
        fieldName: field.name,
        error: {
          type: "INCOMPATIBLE_TYPE",
          expectedSchemaType: field.type,
          resolvedValueType: content.resolveTypeName(fieldValue),
          value: fieldValue
        }
      };
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return {
        kind: "hidden",
        key: `field-${field.name}`,
        name: field.name,
        index
      };
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[field.name], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[field.name], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[field.name], inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly,
      changesOpen: parent.changesOpen
    });
    if (inputState === null)
      return null;
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel), collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if (types.isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (types.isArrayOfObjectsSchemaType(field.type)) {
      const hasValue = typeof fieldValue < "u";
      if (hasValue && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemIsObject(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MIXED_ARRAY",
            schemaType: field.type,
            value: fieldValue
          }
        };
      if (hasValue && !everyItemHasKey(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MISSING_KEYS",
            value: fieldValue,
            schemaType: field.type
          }
        };
      const duplicateKeyEntries = hasValue ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0)
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "DUPLICATE_KEYS",
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      const fieldGroupState = (_h = (_g = parent.fieldGroupState) == null ? void 0 : _g.children) == null ? void 0 : _h[field.name], scopedCollapsedPaths = (_j = (_i = parent.collapsedPaths) == null ? void 0 : _i.children) == null ? void 0 : _j[field.name], scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name], scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name], scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0, conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return null;
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldState = preparePrimitiveInputState({
      ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: !1,
      collapsed: !1,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props, enableHiddenCheck = !0) {
  var _a;
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  }, readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), schemaTypeGroupConfig = props.schemaType.groups || [], defaultGroupName = (_a = schemaTypeGroupConfig.find((g) => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a.name, groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap((group) => {
    var _a2;
    const groupHidden = resolveConditionalProperty(group.hidden, conditionalPropertyContext), isSelected = group.name === (((_a2 = props.fieldGroupState) == null ? void 0 : _a2.value) || defaultGroupName), selected = props.changesOpen ? group.name === ALL_FIELDS_GROUP.name : isSelected, disabled = props.changesOpen ? !selected : !1;
    return groupHidden ? [] : [
      {
        disabled,
        icon: group == null ? void 0 : group.icon,
        name: group.name,
        selected,
        title: group.title
      }
    ];
  }), selectedGroup = groups.find((group) => group.selected), members = (props.schemaType.fieldsets ? props.schemaType.fieldsets : props.schemaType.fields.map((field) => ({ single: !0, field }))).flatMap(
    (fieldSet, index) => {
      var _a2, _b, _c, _d;
      if (fieldSet.single) {
        const field = fieldSet.field, fieldMember = prepareFieldMember({
          field,
          parent: { ...props, readOnly, groups, selectedGroup },
          index
        });
        return fieldMember ? [fieldMember] : [];
      }
      const fieldsetFieldNames = fieldSet.fields.map((f) => f.name), fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, {
        currentUser: props.currentUser,
        document: props.document,
        parent: props.value,
        value: pick__default.default(props.value, fieldsetFieldNames)
      }), fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, {
        currentUser: props.currentUser,
        document: props.document,
        parent: props.value,
        value: pick__default.default(props.value, fieldsetFieldNames)
      }), fieldsetMembers = fieldSet.fields.flatMap(
        (field) => {
          if (fieldsetHidden)
            return [
              {
                kind: "hidden",
                key: `field-${field.name}`,
                name: field.name,
                index
              }
            ];
          const fieldMember = prepareFieldMember({
            field,
            parent: { ...props, readOnly: readOnly || fieldsetReadOnly, groups, selectedGroup },
            index
          });
          return fieldMember ? [fieldMember] : [];
        }
      ), defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props.level), collapsed = (_c = (_b = (((_a2 = props.collapsedFieldSets) == null ? void 0 : _a2.children) || {})[fieldSet.name]) == null ? void 0 : _b.value) != null ? _c : defaultCollapsedState.collapsed;
      return [
        {
          kind: "fieldSet",
          key: `fieldset-${fieldSet.name}`,
          _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup),
          groups: fieldSet.group ? castArray__default.default(fieldSet.group) : [],
          fieldSet: {
            path: PathUtils.pathFor(props.path.concat(fieldSet.name)),
            name: fieldSet.name,
            title: fieldSet.title,
            description: fieldSet.description,
            hidden: !1,
            level: props.level + 1,
            members: fieldsetMembers.filter(
              (member) => member.kind !== "hidden"
            ),
            collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible,
            collapsed,
            columns: (_d = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d.columns
          }
        }
      ];
    }
  ), hasFieldGroups = schemaTypeGroupConfig.length > 0, filteredPresence = props.presence.filter((item) => PathUtils.isEqual(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY, validation = props.validation.filter((item) => PathUtils.isEqual(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), visibleMembers = members.filter(
    (member) => member.kind !== "hidden"
  );
  if (visibleMembers.length === 0 && enableHiddenCheck)
    return null;
  const visibleGroups = hasFieldGroups ? groups.flatMap((group) => group.name === ALL_FIELDS_GROUP.name || visibleMembers.some((member) => member.kind === "error" ? !1 : member.kind === "field" ? member.groups.includes(group.name) : member.groups.includes(group.name) || member.fieldSet.members.some(
    (fieldsetMember) => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group.name)
  )) ? group : []) : [], filtereredMembers = visibleMembers.flatMap(
    (member) => {
      if (member.kind === "error")
        return [member];
      if (member.kind === "field")
        return member.inSelectedGroup ? [member] : [];
      const filteredFieldsetMembers = member.fieldSet.members.filter(
        (fieldsetMember) => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup
      );
      return filteredFieldsetMembers.length > 0 ? [
        {
          ...member,
          fieldSet: { ...member.fieldSet, members: filteredFieldsetMembers }
        }
      ] : [];
    }
  ), node = {
    value: props.value,
    changed: isChangedValue(props.value, props.comparisonValue),
    schemaType: props.schemaType,
    readOnly,
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    presence,
    validation,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  return Object.defineProperty(node, "_allMembers", {
    value: members,
    enumerable: !1
  }), node;
}
function prepareArrayOfPrimitivesInputState(props) {
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    comparisonValue: props.comparisonValue,
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  if (resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props.value) ? props.value : [], filteredPresence = props.presence.filter((item) => PathUtils.isEqual(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY, validation = props.validation.filter((item) => PathUtils.isEqual(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfPrimitivesMember({ arrayItem: item, parent: props, index })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props) {
  if (props.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  if (resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props.value) ? props.value : [], filteredPresence = props.presence.filter((item) => PathUtils.isEqual(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY, validation = props.validation.filter((item) => PathUtils.isEqual(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfObjectsMember({
      arrayItem: item,
      parent: props,
      index
    })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { arrayItem, parent, index } = props, itemType = getItemType(parent.schemaType, arrayItem), key = arrayItem._key;
  if (!itemType) {
    const itemTypeName = content.resolveTypeName(arrayItem);
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }
  const itemPath = PathUtils.pathFor([...parent.path, { _key: key }]), itemLevel = parent.level + 1, conditionalPropertyContext = {
    value: parent.value,
    parent: props.parent,
    document: parent.document,
    currentUser: parent.currentUser
  }, readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[key], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[key], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[key], comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find((i) => i._key === arrayItem._key) || void 0, itemState = prepareObjectInputState(
    {
      schemaType: itemType,
      level: itemLevel,
      document: parent.document,
      value: arrayItem,
      comparisonValue,
      changed: isChangedValue(arrayItem, comparisonValue),
      path: itemPath,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      currentUser: parent.currentUser,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      readOnly
    },
    !1
  ), defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel), collapsed = (_g = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g : defaultCollapsedState.collapsed;
  return {
    kind: "item",
    key,
    index,
    open: PathUtils.startsWith(itemPath, parent.openPath),
    collapsed,
    collapsible: !0,
    parentSchemaType: parent.schemaType,
    item: itemState
  };
}
function prepareArrayOfPrimitivesMember(props) {
  var _a, _b;
  const { arrayItem, parent, index } = props, itemType = getPrimitiveItemType(parent.schemaType, arrayItem), itemPath = PathUtils.pathFor([...parent.path, index]), itemValue = (_a = parent.value) == null ? void 0 : _a[index], itemComparisonValue = (_b = parent.comparisonValue) == null ? void 0 : _b[index], itemLevel = parent.level + 1, key = `${(itemType == null ? void 0 : itemType.name) || "invalid-type"}-${String(index)}`;
  if (!itemType)
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        validTypes: parent.schemaType.of,
        resolvedValueType: content.resolveTypeName(itemType),
        value: itemValue
      }
    };
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  }), item = preparePrimitiveInputState({
    ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: "item",
    key,
    index,
    parentSchemaType: parent.schemaType,
    open: PathUtils.isEqual(itemPath, parent.openPath),
    item
  };
}
function preparePrimitiveInputState(props) {
  const filteredPresence = props.presence.filter((item) => PathUtils.isEqual(item.path, props.path)), presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY, validation = props.validation.filter((item) => PathUtils.isEqual(item.path, props.path)).map((v) => ({ level: v.level, message: v.message, path: v.path }));
  return {
    schemaType: props.schemaType,
    changed: isChangedValue(props.value, props.comparisonValue),
    value: props.value,
    level: props.level,
    id: PathUtils.toString(props.path),
    readOnly: props.readOnly,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    path: props.path,
    presence,
    validation
  };
}
function prepareFormState(props) {
  return prepareObjectInputState(props);
}
function useFormState(schemaType, {
  comparisonValue,
  value,
  fieldGroupState,
  collapsedFieldSets,
  collapsedPaths,
  focusPath,
  openPath,
  presence,
  validation,
  readOnly,
  changesOpen
}) {
  const currentUser = TransformPatches.useCurrentUser(), prev = React.useRef(null);
  return React.useLayoutEffect(() => {
    prev.current = null;
  }, [schemaType]), React.useMemo(() => {
    const next = prepareFormState({
      schemaType,
      document: value,
      fieldGroupState,
      collapsedFieldSets,
      collapsedPaths,
      value,
      comparisonValue,
      focusPath,
      openPath,
      readOnly,
      path: PathUtils.pathFor([]),
      level: 0,
      currentUser,
      presence,
      validation,
      changesOpen
    }), reconciled = TransformPatches.immutableReconcile(prev.current, next);
    return prev.current = reconciled, reconciled;
  }, [
    schemaType,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    comparisonValue,
    focusPath,
    openPath,
    readOnly,
    currentUser,
    presence,
    validation,
    changesOpen
  ]);
}
function isObjectFormNode(formNode) {
  return types.isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return types.isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path) {
  return [
    // make sure to expand all intermediate paths
    ...path.map((p, i) => ({ type: "expandPath", path: path.slice(0, i + 1) })),
    // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
    ...getFieldsetAndFieldGroupOperations(node, path)
  ];
}
function getFieldsetAndFieldGroupOperations(node, path) {
  return path.length === 0 ? [] : isObjectFormNode(node) && hasAllMembers(node) ? getObjectFieldsetAndFieldGroupOperations(node, path) : isArrayOfObjectsFormNode(node) ? getArrayFieldsetAndFieldGroupOperations(node, path) : [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path) {
  var _a, _b;
  if (path.length === 0)
    return [];
  const [fieldName, ...tail] = path, fieldsetMember = node._allMembers.find(
    (member) => member.kind === "fieldSet" && member.fieldSet.members.some(
      (field) => field.kind === "field" && field.name === fieldName
    )
  ), fieldMember = (fieldsetMember ? fieldsetMember.fieldSet.members : (
    // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
    node._allMembers
  )).find(
    (member) => member !== null && member.kind === "field" && member.name === fieldName
  ), schemaField = node.schemaType.fields.find((field) => field.name === fieldName), selectedGroupName = (_a = node.groups.find((group) => group.selected)) == null ? void 0 : _a.name, defaultGroupName = (_b = (node.schemaType.groups || []).find((group) => group.default)) == null ? void 0 : _b.name, inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && castArray__default.default(schemaField.group).includes(selectedGroupName)), ops = [];
  return inSelectedGroup || ops.push({
    type: "setSelectedGroup",
    path: node.path,
    groupName: defaultGroupName || ALL_FIELDS_GROUP.name
  }), fieldsetMember && ops.push({ type: "expandFieldSet", path: fieldsetMember.fieldSet.path }), fieldMember && hasAllMembers(fieldMember.field) && (TransformPatches.isMemberArrayOfObjects(fieldMember) ? ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail)) : TransformPatches.isMemberObject(fieldMember) && ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail))), ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path) {
  if (path.length === 0)
    return [];
  const [segment, ...rest] = path;
  if (!types.isKeySegment(segment))
    throw new Error("Expected path segment to be an object with a _key property");
  const foundMember = state.members.find(
    (member) => member.key === segment._key
  );
  return foundMember ? getFieldsetAndFieldGroupOperations(foundMember.item, rest) : [];
}
const IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key] = segment.split("==");
  return { [attr]: unquote(key) };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map((seg) => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return mutator.arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return flatten__default.default(patches.map((patch) => toFormBuilderPatches(origin, patch)));
}
const notIn = (values) => (value) => !values.includes(value);
function toFormBuilderPatches(origin, patch) {
  return flatten__default.default(
    Object.keys(patch).filter(notIn(["id", "ifRevisionID", "query"])).map((type) => {
      if (type === "unset")
        return patch.unset.map((path) => ({
          type: "unset",
          path: decodePath(path),
          origin
        }));
      if (type === "insert") {
        const position = "before" in patch.insert ? "before" : "after";
        return {
          type: "insert",
          position,
          path: decodePath(patch.insert[position]),
          items: patch.insert.items,
          origin
        };
      }
      return Object.keys(patch[type]).map((gradientPath) => type === "set" ? {
        type: "set",
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "inc" || type === "dec" ? {
        type,
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "setIfMissing" ? {
        type: "setIfMissing",
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : type === "diffMatchPatch" ? {
        type,
        path: decodePath(gradientPath),
        value: patch[type][gradientPath],
        origin
      } : (console.warn(new Error(`Unsupported patch type: ${type}`)), null)).filter(Boolean);
    })
  );
}
function toMutationPatch(patch) {
  if (patch.patchType !== TransformPatches.SANITY_PATCH_TYPE && patch.type)
    throw new Error(
      `Patch is missing "patchType" - import and use "${patch.type}()" from "sanity/form"`
    );
  if (patch.patchType !== TransformPatches.SANITY_PATCH_TYPE)
    throw new Error(
      'Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"'
    );
  const matchPath = mutator.arrayToJSONMatchPath(patch.path || []);
  if (patch.type === "insert") {
    const { position, items } = patch;
    return {
      insert: {
        [position]: matchPath,
        items
      }
    };
  }
  if (patch.type === "unset")
    return {
      unset: [matchPath]
    };
  if (!patch.type)
    throw new Error(`Missing patch type in patch ${JSON.stringify(patch)}`);
  return matchPath ? {
    [patch.type]: {
      [matchPath]: patch.value
    }
  } : {
    [patch.type]: patch.value
  };
}
exports.ActiveWorkspaceMatcher = TransformPatches.ActiveWorkspaceMatcher;
exports.ActiveWorkspaceMatcherContext = TransformPatches.ActiveWorkspaceMatcherContext;
exports.AddonDatasetContext = TransformPatches.AddonDatasetContext;
exports.ArrayOfObjectOptionsInput = TransformPatches.ArrayOfObjectOptionsInput;
exports.ArrayOfObjectsFunctions = TransformPatches.ArrayOfObjectsFunctions;
exports.ArrayOfObjectsInput = TransformPatches.ArrayOfObjectsInput;
exports.ArrayOfObjectsItem = TransformPatches.ArrayOfObjectsItem;
exports.ArrayOfOptionsInput = TransformPatches.ArrayOfOptionsInput;
exports.ArrayOfPrimitiveOptionsInput = TransformPatches.ArrayOfPrimitiveOptionsInput;
exports.ArrayOfPrimitivesFunctions = TransformPatches.ArrayOfPrimitivesFunctions;
exports.ArrayOfPrimitivesInput = TransformPatches.ArrayOfPrimitivesInput;
exports.ArrayOfPrimitivesItem = TransformPatches.ArrayOfPrimitivesItem;
exports.AutoCollapseMenu = TransformPatches.AutoCollapseMenu;
exports.BlockEditor = TransformPatches.PortableTextInput;
exports.BlockImagePreview = TransformPatches.BlockImagePreview;
exports.BlockPreview = TransformPatches.BlockPreview;
exports.BooleanInput = TransformPatches.BooleanInput;
exports.CONNECTING = TransformPatches.CONNECTING;
exports.ChangeBreadcrumb = TransformPatches.ChangeBreadcrumb;
exports.ChangeIndicator = TransformPatches.ChangeIndicator;
exports.ChangeIndicatorContext = TransformPatches.ChangeIndicatorContext;
exports.ChangeList = TransformPatches.ChangeList;
exports.ChangeResolver = TransformPatches.ChangeResolver;
exports.ChangeTitleSegment = TransformPatches.ChangeTitleSegment;
exports.CircularProgress = TransformPatches.CircularProgress;
exports.CollapseMenu = TransformPatches.CollapseMenu;
exports.CollapseMenuButton = TransformPatches.CollapseMenuButton;
exports.ColorSchemeCustomProvider = TransformPatches.ColorSchemeCustomProvider;
exports.ColorSchemeLocalStorageProvider = TransformPatches.ColorSchemeLocalStorageProvider;
exports.ColorSchemeProvider = TransformPatches.ColorSchemeProvider;
exports.ColorSchemeSetValueContext = TransformPatches.ColorSchemeSetValueContext;
exports.ColorSchemeValueContext = TransformPatches.ColorSchemeValueContext;
exports.CommandList = TransformPatches.CommandList;
exports.CompactPreview = TransformPatches.CompactPreview;
exports.ConfigPropertyError = TransformPatches.ConfigPropertyError;
exports.ConfigResolutionError = TransformPatches.ConfigResolutionError;
exports.ConnectorContext = TransformPatches.ConnectorContext;
exports.ContextMenuButton = TransformPatches.ContextMenuButton;
exports.CorsOriginError = TransformPatches.CorsOriginError;
exports.CrossDatasetReferenceInput = TransformPatches.StudioCrossDatasetReferenceInput;
exports.DEFAULT_MAX_RECURSION_DEPTH = TransformPatches.DEFAULT_MAX_RECURSION_DEPTH;
exports.DEFAULT_STUDIO_CLIENT_OPTIONS = TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS;
exports.DRAFTS_FOLDER = TransformPatches.DRAFTS_FOLDER;
exports.DateInput = TransformPatches.DateInput;
exports.DateTimeInput = TransformPatches.DateTimeInput;
exports.DefaultPreview = TransformPatches.DefaultPreview;
exports.DetailPreview = TransformPatches.DetailPreview;
exports.DiffCard = TransformPatches.DiffCard;
exports.DiffContext = TransformPatches.DiffContext;
exports.DiffErrorBoundary = TransformPatches.DiffErrorBoundary;
exports.DiffFromTo = TransformPatches.DiffFromTo;
exports.DiffInspectWrapper = TransformPatches.DiffInspectWrapper;
exports.DiffString = TransformPatches.DiffString;
exports.DiffStringSegment = TransformPatches.DiffStringSegment;
exports.DiffTooltip = TransformPatches.DiffTooltip;
exports.DocumentChangeContext = TransformPatches.DocumentChangeContext;
exports.DocumentPreviewPresence = TransformPatches.DocumentPreviewPresence;
exports.DocumentStatus = TransformPatches.DocumentStatus;
exports.DocumentStatusIndicator = TransformPatches.DocumentStatusIndicator;
exports.EMPTY_ARRAY = TransformPatches.EMPTY_ARRAY;
exports.EMPTY_OBJECT = TransformPatches.EMPTY_OBJECT;
exports.EmailInput = TransformPatches.EmailInput;
exports.ErrorMessage = TransformPatches.ErrorMessage;
exports.FallbackDiff = TransformPatches.FallbackDiff;
exports.FieldActionMenu = TransformPatches.FieldActionMenu;
exports.FieldActionsProvider = TransformPatches.FieldActionsProvider;
exports.FieldActionsResolver = TransformPatches.FieldActionsResolver;
exports.FieldChange = TransformPatches.FieldChange;
exports.FieldPresence = TransformPatches.FieldPresence;
exports.FieldPresenceInner = TransformPatches.FieldPresenceInner;
exports.FieldPresenceWithOverlay = TransformPatches.FieldPresenceWithOverlay;
exports.FieldPresenceWithoutOverlay = TransformPatches.FieldPresenceWithoutOverlay;
exports.FileInput = TransformPatches.StudioFileInput;
exports.FormBuilderContext = TransformPatches.FormBuilderContext;
exports.FormCallbacksContext = TransformPatches.FormCallbacksContext;
exports.FormCallbacksProvider = TransformPatches.FormCallbacksProvider;
exports.FormField = TransformPatches.FormField;
exports.FormFieldHeaderText = TransformPatches.FormFieldHeaderText;
exports.FormFieldPresenceContext = TransformPatches.FormFieldPresenceContext;
exports.FormFieldSet = TransformPatches.FormFieldSet;
exports.FormFieldStatus = TransformPatches.FormFieldStatus;
exports.FormFieldValidationStatus = TransformPatches.FormFieldValidationStatus;
exports.FormInput = TransformPatches.FormInput;
exports.FormValueProvider = TransformPatches.FormValueProvider;
exports.FromTo = TransformPatches.FromTo;
exports.FromToArrow = TransformPatches.FromToArrow;
exports.GroupChange = TransformPatches.GroupChange;
exports.ImageInput = TransformPatches.StudioImageInput;
exports.ImperativeToast = TransformPatches.ImperativeToast;
exports.InlinePreview = TransformPatches.InlinePreview;
exports.InsufficientPermissionsMessage = TransformPatches.InsufficientPermissionsMessage;
exports.LegacyLayerProvider = TransformPatches.LegacyLayerProvider;
exports.LinearProgress = TransformPatches.LinearProgress;
exports.LoadingBlock = TransformPatches.LoadingBlock;
exports.LocaleProvider = TransformPatches.LocaleProvider;
exports.LocaleProviderBase = TransformPatches.LocaleProviderBase;
exports.MediaPreview = TransformPatches.MediaPreview;
exports.MemberField = TransformPatches.MemberField;
exports.MemberFieldError = TransformPatches.MemberFieldError;
exports.MemberFieldSet = TransformPatches.MemberFieldSet;
exports.MemberItemError = TransformPatches.MemberItemError;
exports.MetaInfo = TransformPatches.MetaInfo;
exports.NavbarContext = TransformPatches.NavbarContext;
exports.NoChanges = TransformPatches.NoChanges;
exports.NumberInput = TransformPatches.NumberInput;
exports.ObjectInput = TransformPatches.ObjectInput;
exports.ObjectInputMember = TransformPatches.ObjectInputMember;
exports.ObjectInputMembers = TransformPatches.ObjectInputMembers;
exports.ObjectMembers = TransformPatches.ObjectMembers;
exports.OverlayDisabled = TransformPatches.OverlayDisabled;
exports.PatchEvent = TransformPatches.PatchEvent;
exports.PopoverDialog = TransformPatches.PopoverDialog;
exports.PortableTextInput = TransformPatches.PortableTextInput;
exports.PresenceOverlay = TransformPatches.PresenceOverlay;
exports.Preview = TransformPatches.Preview;
exports.PreviewCard = TransformPatches.PreviewCard;
exports.PreviewLoader = TransformPatches.PreviewLoader;
exports.ReferenceInput = TransformPatches.StudioReferenceInput;
exports.ReferenceInputOptionsProvider = TransformPatches.ReferenceInputOptionsProvider;
exports.ResourceCacheProvider = TransformPatches.ResourceCacheProvider;
exports.RevertChangesButton = TransformPatches.RevertChangesButton;
exports.ReviewChangesContext = TransformPatches.ReviewChangesContext;
exports.SANITY_PATCH_TYPE = TransformPatches.SANITY_PATCH_TYPE;
exports.SANITY_VERSION = TransformPatches.SANITY_VERSION;
exports.SESSION_ID = TransformPatches.SESSION_ID;
exports.SanityDefaultPreview = TransformPatches.SanityDefaultPreview;
exports.SchemaError = TransformPatches.SchemaError;
exports.ScrollContainer = TransformPatches.ScrollContainer;
exports.SearchButton = TransformPatches.SearchButton;
exports.SearchContext = TransformPatches.SearchContext;
exports.SearchDialog = TransformPatches.SearchDialog;
exports.SearchPopover = TransformPatches.SearchPopover;
exports.SearchProvider = TransformPatches.SearchProvider;
exports.SearchResultItemPreview = TransformPatches.SearchResultItemPreview;
exports.SelectInput = TransformPatches.SelectInput;
exports.SlugInput = TransformPatches.SlugInput;
exports.SourceProvider = TransformPatches.SourceProvider;
exports.StatusButton = TransformPatches.StatusButton;
exports.StringInput = TransformPatches.StringInput;
exports.StudioLayout = TransformPatches.StudioLayout;
exports.StudioLayoutComponent = TransformPatches.StudioLayoutComponent;
exports.StudioNavbar = TransformPatches.StudioNavbar;
exports.StudioProvider = TransformPatches.StudioProvider;
exports.StudioToolMenu = TransformPatches.StudioToolMenu;
exports.TagsArrayInput = TransformPatches.TagsArrayInput;
exports.TemplatePreview = TransformPatches.TemplatePreview;
exports.TextInput = TransformPatches.TextInput;
exports.TextWithTone = TransformPatches.TextWithTone;
exports.Timeline = TransformPatches.Timeline;
exports.TimelineController = TransformPatches.TimelineController;
exports.ToolLink = TransformPatches.ToolLink;
exports.TooltipOfDisabled = TransformPatches.TooltipOfDisabled;
exports.Tracker = TransformPatches.Tracker;
exports.TransformPatches = TransformPatches.TransformPatches;
exports.Translate = TransformPatches.Translate;
exports.UniversalArrayInput = TransformPatches.UniversalArrayInput;
exports.UpsellDescriptionSerializer = TransformPatches.UpsellDescriptionSerializer;
exports.UpsellDialogDismissed = TransformPatches.UpsellDialogDismissed;
exports.UpsellDialogLearnMoreCtaClicked = TransformPatches.UpsellDialogLearnMoreCtaClicked;
exports.UpsellDialogUpgradeCtaClicked = TransformPatches.UpsellDialogUpgradeCtaClicked;
exports.UpsellDialogViewed = TransformPatches.UpsellDialogViewed;
exports.UrlInput = TransformPatches.UrlInput;
exports.UserAvatar = TransformPatches.UserAvatar;
exports.UserColorManagerProvider = TransformPatches.UserColorManagerProvider;
exports.ValueError = TransformPatches.ValueError;
exports.VirtualizerScrollInstanceContext = TransformPatches.VirtualizerScrollInstanceContext;
exports.VirtualizerScrollInstanceProvider = TransformPatches.VirtualizerScrollInstanceProvider;
exports.WorkspaceLoader = TransformPatches.WorkspaceLoaderBoundary;
exports.WorkspaceProvider = TransformPatches.WorkspaceProvider;
exports.WorkspacesContext = TransformPatches.WorkspacesContext;
exports.WorkspacesProvider = TransformPatches.WorkspacesProvider;
exports.__tmp_wrap_presenceStore = TransformPatches.__tmp_wrap_presenceStore;
exports._createAuthStore = TransformPatches._createAuthStore;
exports._useColorSchemeInternalValue = TransformPatches._useColorSchemeInternalValue;
exports.asLoadable = TransformPatches.asLoadable;
exports.checkoutPair = TransformPatches.checkoutPair;
exports.collate = TransformPatches.collate;
exports.createAuthStore = TransformPatches.createAuthStore;
exports.createBufferedDocument = TransformPatches.createBufferedDocument;
exports.createConnectionStatusStore = TransformPatches.createConnectionStatusStore;
exports.createDocumentPreviewStore = TransformPatches.createDocumentPreviewStore;
exports.createDocumentStore = TransformPatches.createDocumentStore;
exports.createDraftFrom = TransformPatches.createDraftFrom;
exports.createGrantsStore = TransformPatches.createGrantsStore;
exports.createHistoryStore = TransformPatches.createHistoryStore;
exports.createHookFromObservableFactory = TransformPatches.createHookFromObservableFactory;
exports.createKeyValueStore = TransformPatches.createKeyValueStore;
exports.createObservableBufferedDocument = TransformPatches.createObservableBufferedDocument;
exports.createProjectStore = TransformPatches.createProjectStore;
exports.createPublishedFrom = TransformPatches.createPublishedFrom;
exports.createSchema = TransformPatches.createSchema;
exports.createSharedResizeObserver = TransformPatches.createSharedResizeObserver;
exports.createTrackerScope = TransformPatches.createTrackerScope;
exports.createUseReporter = TransformPatches.createUseReporter;
exports.createUserColorManager = TransformPatches.createUserColorManager;
exports.createUserStore = TransformPatches.createUserStore;
exports.dec = TransformPatches.dec;
exports.defaultLocale = TransformPatches.defaultLocale;
exports.defaultTheme = TransformPatches.defaultTheme;
exports.defineLocale = TransformPatches.defineLocale;
exports.defineLocaleResourceBundle = TransformPatches.defineLocaleResourceBundle;
exports.defineLocalesResources = TransformPatches.defineLocalesResources;
exports.defineSearchFilter = TransformPatches.defineSearchFilter;
exports.defineSearchFilterOperators = TransformPatches.defineSearchFilterOperators;
exports.defineSearchOperator = TransformPatches.defineSearchOperator;
exports.diffMatchPatch = TransformPatches.diffMatchPatch;
exports.documentFieldActionsReducer = TransformPatches.documentFieldActionsReducer;
exports.documentIdEquals = TransformPatches.documentIdEquals;
exports.editState = TransformPatches.editState;
exports.emitOperation = TransformPatches.emitOperation;
exports.escapeField = TransformPatches.escapeField;
exports.fieldNeedsEscape = TransformPatches.fieldNeedsEscape;
exports.findIndex = TransformPatches.findIndex;
exports.flattenConfig = TransformPatches.flattenConfig;
exports.getAnnotationAtPath = TransformPatches.getAnnotationAtPath;
exports.getAnnotationColor = TransformPatches.getAnnotationColor;
exports.getDiffAtPath = TransformPatches.getDiffAtPath;
exports.getDocumentPairPermissions = TransformPatches.getDocumentPairPermissions;
exports.getDocumentValuePermissions = TransformPatches.getDocumentValuePermissions;
exports.getDraftId = TransformPatches.getDraftId;
exports.getIdPair = TransformPatches.getIdPair;
exports.getInitialValueStream = TransformPatches.getInitialValueStream;
exports.getItemKey = TransformPatches.getItemKey;
exports.getItemKeySegment = TransformPatches.getItemKeySegment;
exports.getNamelessWorkspaceIdentifier = TransformPatches.getNamelessWorkspaceIdentifier;
exports.getPairListener = TransformPatches.getPairListener;
exports.getPreviewPaths = TransformPatches.getPreviewPaths;
exports.getPreviewStateObservable = TransformPatches.getPreviewStateObservable;
exports.getPreviewValueWithFallback = TransformPatches.getPreviewValueWithFallback;
exports.getProviderTitle = TransformPatches.getProviderTitle;
exports.getPublishedId = TransformPatches.getPublishedId;
exports.getSchemaTypeTitle = TransformPatches.getSchemaTypeTitle;
exports.getTemplatePermissions = TransformPatches.getTemplatePermissions;
exports.getValueAtPath = TransformPatches.getValueAtPath;
exports.getValueError = TransformPatches.getValueError;
exports.getWorkspaceIdentifier = TransformPatches.getWorkspaceIdentifier;
exports.globalScope = TransformPatches.globalScope;
exports.grantsPermissionOn = TransformPatches.grantsPermissionOn;
exports.inc = TransformPatches.inc;
exports.initialDocumentFieldActions = TransformPatches.initialDocumentFieldActions;
exports.insert = TransformPatches.insert;
exports.isAddedItemDiff = TransformPatches.isAddedItemDiff;
exports.isArrayOfBlocksInputProps = TransformPatches.isArrayOfBlocksInputProps;
exports.isArrayOfObjectsInputProps = TransformPatches.isArrayOfObjectsInputProps;
exports.isArrayOfPrimitivesInputProps = TransformPatches.isArrayOfPrimitivesInputProps;
exports.isAuthStore = TransformPatches.isAuthStore;
exports.isBooleanInputProps = TransformPatches.isBooleanInputProps;
exports.isBuilder = TransformPatches.isBuilder;
exports.isCookielessCompatibleLoginMethod = TransformPatches.isCookielessCompatibleLoginMethod;
exports.isDev = TransformPatches.isDev;
exports.isDraft = TransformPatches.isDraft;
exports.isDraftId = TransformPatches.isDraftId;
exports.isEmptyObject = TransformPatches.isEmptyObject;
exports.isFieldChange = TransformPatches.isFieldChange;
exports.isGroupChange = TransformPatches.isGroupChange;
exports.isNonNullable = TransformPatches.isNonNullable;
exports.isNumberInputProps = TransformPatches.isNumberInputProps;
exports.isObjectInputProps = TransformPatches.isObjectInputProps;
exports.isObjectItemProps = TransformPatches.isObjectItemProps;
exports.isProd = TransformPatches.isProd;
exports.isPublishedId = TransformPatches.isPublishedId;
exports.isRecord = TransformPatches.isRecord;
exports.isRemovedItemDiff = TransformPatches.isRemovedItemDiff;
exports.isString = TransformPatches.isString;
exports.isStringInputProps = TransformPatches.isStringInputProps;
exports.isUnchangedDiff = TransformPatches.isUnchangedDiff;
exports.joinPath = TransformPatches.joinPath;
exports.listenQuery = TransformPatches.listenQuery;
exports.matchWorkspace = TransformPatches.matchWorkspace;
exports.newDraftFrom = TransformPatches.newDraftFrom;
exports.noop = TransformPatches.noop;
exports.normalizeIndexSegment = TransformPatches.normalizeIndexSegment;
exports.normalizeIndexTupleSegment = TransformPatches.normalizeIndexTupleSegment;
exports.normalizeKeySegment = TransformPatches.normalizeKeySegment;
exports.normalizePathSegment = TransformPatches.normalizePathSegment;
exports.onRetry = TransformPatches.onRetry;
exports.operationEvents = TransformPatches.operationEvents;
exports.operatorDefinitions = TransformPatches.operatorDefinitions;
exports.pathToString = TransformPatches.pathToString;
exports.pathsAreEqual = TransformPatches.pathsAreEqual;
exports.prefixPath = TransformPatches.prefixPath;
exports.prepareConfig = TransformPatches.prepareConfig;
exports.prepareForPreview = TransformPatches.prepareForPreview;
exports.removeDupes = TransformPatches.removeDupes;
exports.removeMissingReferences = TransformPatches.removeMissingReferences;
exports.removeUndefinedLocaleResources = TransformPatches.removeUndefinedLocaleResources;
exports.resizeObserver = TransformPatches.resizeObserver;
exports.resolveDiffComponent = TransformPatches.resolveDiffComponent;
exports.resolveInitialObjectValue = TransformPatches.resolveInitialObjectValue;
exports.resolveInitialValue = TransformPatches.resolveInitialValue;
exports.resolveInitialValueForType = TransformPatches.resolveInitialValueForType;
exports.resolveSchemaTypes = TransformPatches.resolveSchemaTypes;
exports.set = TransformPatches.set;
exports.setIfMissing = TransformPatches.setIfMissing;
exports.sliceString = TransformPatches.sliceString;
exports.snapshotPair = TransformPatches.snapshotPair;
exports.stringToPath = TransformPatches.stringToPath;
exports.supportsTouch = TransformPatches.supportsTouch;
exports.truncateString = TransformPatches.truncateString;
exports.unset = TransformPatches.unset;
exports.unstable_useValuePreview = TransformPatches.useDocumentPreview;
exports.usEnglishLocale = TransformPatches.usEnglishLocale;
exports.useActiveWorkspace = TransformPatches.useActiveWorkspace;
exports.useAnnotationColor = TransformPatches.useAnnotationColor;
exports.useClient = TransformPatches.useClient;
exports.useColorScheme = TransformPatches.useColorScheme;
exports.useColorSchemeOptions = TransformPatches.useColorSchemeOptions;
exports.useColorSchemeSetValue = TransformPatches.useColorSchemeSetValue;
exports.useColorSchemeValue = TransformPatches.useColorSchemeValue;
exports.useConnectionStatusStore = TransformPatches.useConnectionStatusStore;
exports.useCurrentUser = TransformPatches.useCurrentUser;
exports.useDataset = TransformPatches.useDataset;
exports.useDateTimeFormat = TransformPatches.useDateTimeFormat;
exports.useDidUpdate = TransformPatches.useDidUpdate;
exports.useDiffAnnotationColor = TransformPatches.useDiffAnnotationColor;
exports.useDocumentChange = TransformPatches.useDocumentChange;
exports.useDocumentOperation = TransformPatches.useDocumentOperation;
exports.useDocumentPairPermissions = TransformPatches.useDocumentPairPermissions;
exports.useDocumentPairPermissionsFromHookFactory = TransformPatches.useDocumentPairPermissionsFromHookFactory;
exports.useDocumentPresence = TransformPatches.useDocumentPresence;
exports.useDocumentPreviewStore = TransformPatches.useDocumentPreviewStore;
exports.useDocumentStore = TransformPatches.useDocumentStore;
exports.useDocumentValuePermissions = TransformPatches.useDocumentValuePermissions;
exports.useDocumentValuePermissionsFromHookFactory = TransformPatches.useDocumentValuePermissionsFromHookFactory;
exports.useDocumentValues = TransformPatches.useDocumentValues;
exports.useFeatureEnabled = TransformPatches.useFeatureEnabled;
exports.useFieldActions = TransformPatches.useFieldActions;
exports.useFormBuilder = TransformPatches.useFormBuilder;
exports.useFormCallbacks = TransformPatches.useFormCallbacks;
exports.useFormValue = TransformPatches.useFormValue;
exports.useGetI18nText = TransformPatches.useGetI18nText;
exports.useGlobalPresence = TransformPatches.useGlobalPresence;
exports.useGrantsStore = TransformPatches.useGrantsStore;
exports.useHistoryStore = TransformPatches.useHistoryStore;
exports.useHoveredField = TransformPatches.useHoveredField;
exports.useI18nText = TransformPatches.useI18nText;
exports.useInitialValue = TransformPatches.useInitialValue;
exports.useInitialValueResolverContext = TransformPatches.useInitialValueResolverContext;
exports.useKeyValueStore = TransformPatches.useKeyValueStore;
exports.useListFormat = TransformPatches.useListFormat;
exports.useLoadable = TransformPatches.useLoadable;
exports.useMiddlewareComponents = TransformPatches.useMiddlewareComponents;
exports.usePresenceStore = TransformPatches.usePresenceStore;
exports.usePreviewCard = TransformPatches.usePreviewCard;
exports.useProjectId = TransformPatches.useProjectId;
exports.useProjectStore = TransformPatches.useProjectStore;
exports.useReferenceInputOptions = TransformPatches.useReferenceInputOptions;
exports.useRelativeTime = TransformPatches.useRelativeTime;
exports.useReportedValues = TransformPatches.useReportedValues;
exports.useReporter = TransformPatches.useReporter;
exports.useResolveInitialValueForType = TransformPatches.useResolveInitialValueForType;
exports.useResourceCache = TransformPatches.useResourceCache;
exports.useRovingFocus = TransformPatches.useRovingFocus;
exports.useSchema = TransformPatches.useSchema;
exports.useSearchState = TransformPatches.useSearchState;
exports.useSource = TransformPatches.useSource;
exports.useTemplatePermissions = TransformPatches.useTemplatePermissions;
exports.useTemplatePermissionsFromHookFactory = TransformPatches.useTemplatePermissionsFromHookFactory;
exports.useTemplates = TransformPatches.useTemplates;
exports.useTranslation = TransformPatches.useTranslation;
exports.useUnique = TransformPatches.useUnique;
exports.useUnitFormatter = TransformPatches.useUnitFormatter;
exports.useUser = TransformPatches.useUser;
exports.useUserColor = TransformPatches.useUserColor;
exports.useUserColorManager = TransformPatches.useUserColorManager;
exports.useUserStore = TransformPatches.useUserStore;
exports.useVirtualizerScrollInstance = TransformPatches.useVirtualizerScrollInstance;
exports.useWorkspace = TransformPatches.useWorkspace;
exports.useWorkspaceLoader = TransformPatches.useWorkspaceLoader;
exports.useWorkspaces = TransformPatches.useWorkspaces;
exports.useZIndex = TransformPatches.useZIndex;
exports.userHasRole = TransformPatches.userHasRole;
exports.validateBasePaths = TransformPatches.validateBasePaths;
exports.validateDocument = TransformPatches.validateDocument;
exports.validateNames = TransformPatches.validateNames;
exports.validateWorkspaces = TransformPatches.validateWorkspaces;
exports.validation = TransformPatches.validation;
exports.visitDiff = TransformPatches.visitDiff;
exports.useCurrentLocale = getJsonStream.useCurrentLocale;
exports.useLocale = getJsonStream.useLocale;
exports.AddonDatasetProvider = AddonDatasetProvider;
exports.ArrayOfObjectsInputMember = ArrayOfObjectsInputMember;
exports.ArrayOfObjectsInputMembers = ArrayOfObjectsInputMembers;
exports.BetaBadge = BetaBadge;
exports.ChangeConnectorRoot = ChangeConnectorRoot;
exports.ChangeFieldWrapper = ChangeFieldWrapper;
exports.DefaultDocument = DefaultDocument;
exports.DisabledChangeConnectorRoot = DisabledChangeConnectorRoot;
exports.EnabledChangeConnectorRoot = EnabledChangeConnectorRoot;
exports.FormBuilder = FormBuilder;
exports.FormProvider = FormProvider;
exports.GetHookCollectionState = GetHookCollectionState;
exports.GlobalErrorHandler = GlobalErrorHandler;
exports.Hotkeys = Hotkeys;
exports.HoveredFieldProvider = HoveredFieldProvider;
exports.IntentButton = IntentButton;
exports.PresenceScope = PresenceScope;
exports.RelativeTime = RelativeTime;
exports.ScrollMonitor = ScrollMonitor;
exports.Studio = Studio;
exports.StudioLogo = StudioLogo;
exports.TelephoneInput = TelephoneInput;
exports.WithReferringDocuments = WithReferringDocuments;
exports.ZIndexProvider = ZIndexProvider;
exports._isCustomDocumentTypeDefinition = _isCustomDocumentTypeDefinition;
exports._isSanityDocumentTypeDefinition = _isSanityDocumentTypeDefinition;
exports.buildLegacyTheme = buildLegacyTheme;
exports.createConfig = createConfig;
exports.createMockAuthStore = createMockAuthStore;
exports.createNoopTrackerScope = createNoopTrackerScope;
exports.createPatchChannel = createPatchChannel;
exports.createPlugin = createPlugin;
exports.createSourceFromConfig = createSourceFromConfig;
exports.createWorkspaceFromConfig = createWorkspaceFromConfig;
exports.decodePath = decodePath;
exports.defaultRenderAnnotation = defaultRenderAnnotation;
exports.defaultRenderBlock = defaultRenderBlock;
exports.defaultRenderField = defaultRenderField;
exports.defaultRenderInlineBlock = defaultRenderInlineBlock;
exports.defaultRenderInput = defaultRenderInput;
exports.defaultRenderItem = defaultRenderItem;
exports.defaultRenderPreview = defaultRenderPreview;
exports.defaultTemplateForType = defaultTemplateForType;
exports.defaultTemplatesForSchema = defaultTemplatesForSchema;
exports.defineConfig = defineConfig;
exports.defineDocumentFieldAction = defineDocumentFieldAction;
exports.defineDocumentInspector = defineDocumentInspector;
exports.definePlugin = definePlugin;
exports.diffResolver = diffResolver;
exports.encodePath = encodePath;
exports.fromMutationPatches = fromMutationPatches;
exports.getConfigContextFromSource = getConfigContextFromSource;
exports.getExpandOperations = getExpandOperations;
exports.isArray = isArray;
exports.isTruthy = isTruthy;
exports.prepareTemplates = prepareTemplates;
exports.remoteSnapshots = remoteSnapshots;
exports.renderStudio = renderStudio;
exports.resolveConditionalProperty = resolveConditionalProperty;
exports.resolveConfig = resolveConfig;
exports.setAtPath = setAtPath;
exports.toMutationPatches = toMutationPatches;
exports.uncaughtErrorHandler = uncaughtErrorHandler;
exports.useAddonDataset = useAddonDataset;
exports.useConfigContextFromSource = useConfigContextFromSource;
exports.useConnectionState = useConnectionState;
exports.useDocumentOperationEvent = useDocumentOperationEvent;
exports.useDocumentType = useDocumentType;
exports.useEditState = useEditState;
exports.useFormState = useFormState;
exports.useFormattedDuration = useFormattedDuration;
exports.useNumberFormat = useNumberFormat;
exports.useOnScroll = useOnScroll;
exports.useProject = useProject;
exports.useProjectDatasets = useProjectDatasets;
exports.useReviewChanges = useReviewChanges;
exports.useSyncState = useSyncState;
exports.useThrottledCallback = useThrottledCallback;
exports.useTimeAgo = useTimeAgo;
exports.useTimelineSelector = useTimelineSelector;
exports.useTimelineStore = useTimelineStore;
exports.useTools = useTools;
exports.useUserListWithPermissions = useUserListWithPermissions;
exports.useValidationStatus = useValidationStatus;
Object.keys(types).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return types[k];
    }
  });
});
//# sourceMappingURL=index.js.map
